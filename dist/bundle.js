/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@fms-cat/automaton/dist/automaton.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fms-cat/automaton/dist/automaton.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

/*!
  Automaton v2.0.1
  Animation engine with Timeline GUI for creative coding
 
  Copyright (c) 2017-2018 FMS_Cat
  Automaton is distributed under the MIT License
  https://opensource.org/licenses/MIT

  Repository: https://github.com/FMS-Cat/automaton
*/
(function (f) {
  if (( false ? undefined : _typeof2(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var g; }
})(function () {
  var define, module, exports;
  return function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return require(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }

          var p = n[i] = {
            exports: {}
          };
          e[i][0].call(p.exports, function (r) {
            var n = e[i][1][r];
            return o(n || r);
          }, p, p.exports, r, e, n, t);
        }

        return n[i].exports;
      }

      for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
        o(t[i]);
      }

      return o;
    }

    return r;
  }()({
    1: [function (require, module, exports) {
      module.exports = {
        "default": require("core-js/library/fn/array/from"),
        __esModule: true
      };
    }, {
      "core-js/library/fn/array/from": 5
    }],
    2: [function (require, module, exports) {
      module.exports = {
        "default": require("core-js/library/fn/math/log10"),
        __esModule: true
      };
    }, {
      "core-js/library/fn/math/log10": 6
    }],
    3: [function (require, module, exports) {
      module.exports = {
        "default": require("core-js/library/fn/math/sign"),
        __esModule: true
      };
    }, {
      "core-js/library/fn/math/sign": 7
    }],
    4: [function (require, module, exports) {
      "use strict";

      exports.__esModule = true;

      var _from = require("../core-js/array/from");

      var _from2 = _interopRequireDefault(_from);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      exports.default = function (arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } else {
          return (0, _from2.default)(arr);
        }
      };
    }, {
      "../core-js/array/from": 1
    }],
    5: [function (require, module, exports) {
      require('../../modules/es6.string.iterator');

      require('../../modules/es6.array.from');

      module.exports = require('../../modules/_core').Array.from;
    }, {
      "../../modules/_core": 13,
      "../../modules/es6.array.from": 58,
      "../../modules/es6.string.iterator": 61
    }],
    6: [function (require, module, exports) {
      require('../../modules/es6.math.log10');

      module.exports = require('../../modules/_core').Math.log10;
    }, {
      "../../modules/_core": 13,
      "../../modules/es6.math.log10": 59
    }],
    7: [function (require, module, exports) {
      require('../../modules/es6.math.sign');

      module.exports = require('../../modules/_core').Math.sign;
    }, {
      "../../modules/_core": 13,
      "../../modules/es6.math.sign": 60
    }],
    8: [function (require, module, exports) {
      module.exports = function (it) {
        if (typeof it != 'function') throw TypeError(it + ' is not a function!');
        return it;
      };
    }, {}],
    9: [function (require, module, exports) {
      var isObject = require('./_is-object');

      module.exports = function (it) {
        if (!isObject(it)) throw TypeError(it + ' is not an object!');
        return it;
      };
    }, {
      "./_is-object": 29
    }],
    10: [function (require, module, exports) {
      // false -> Array#indexOf
      // true  -> Array#includes
      var toIObject = require('./_to-iobject');

      var toLength = require('./_to-length');

      var toAbsoluteIndex = require('./_to-absolute-index');

      module.exports = function (IS_INCLUDES) {
        return function ($this, el, fromIndex) {
          var O = toIObject($this);
          var length = toLength(O.length);
          var index = toAbsoluteIndex(fromIndex, length);
          var value; // Array#includes uses SameValueZero equality algorithm
          // eslint-disable-next-line no-self-compare

          if (IS_INCLUDES && el != el) while (length > index) {
            value = O[index++]; // eslint-disable-next-line no-self-compare

            if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
          } else for (; length > index; index++) {
            if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0;
            }
          }
          return !IS_INCLUDES && -1;
        };
      };
    }, {
      "./_to-absolute-index": 49,
      "./_to-iobject": 51,
      "./_to-length": 52
    }],
    11: [function (require, module, exports) {
      // getting tag from 19.1.3.6 Object.prototype.toString()
      var cof = require('./_cof');

      var TAG = require('./_wks')('toStringTag'); // ES3 wrong here


      var ARG = cof(function () {
        return arguments;
      }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

      var tryGet = function tryGet(it, key) {
        try {
          return it[key];
        } catch (e) {
          /* empty */
        }
      };

      module.exports = function (it) {
        var O, T, B;
        return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
        : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
        : ARG ? cof(O) // ES3 arguments fallback
        : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
      };
    }, {
      "./_cof": 12,
      "./_wks": 56
    }],
    12: [function (require, module, exports) {
      var toString = {}.toString;

      module.exports = function (it) {
        return toString.call(it).slice(8, -1);
      };
    }, {}],
    13: [function (require, module, exports) {
      var core = module.exports = {
        version: '2.5.7'
      };
      if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
    }, {}],
    14: [function (require, module, exports) {
      'use strict';

      var $defineProperty = require('./_object-dp');

      var createDesc = require('./_property-desc');

      module.exports = function (object, index, value) {
        if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
      };
    }, {
      "./_object-dp": 38,
      "./_property-desc": 43
    }],
    15: [function (require, module, exports) {
      // optional / simple context binding
      var aFunction = require('./_a-function');

      module.exports = function (fn, that, length) {
        aFunction(fn);
        if (that === undefined) return fn;

        switch (length) {
          case 1:
            return function (a) {
              return fn.call(that, a);
            };

          case 2:
            return function (a, b) {
              return fn.call(that, a, b);
            };

          case 3:
            return function (a, b, c) {
              return fn.call(that, a, b, c);
            };
        }

        return function ()
        /* ...args */
        {
          return fn.apply(that, arguments);
        };
      };
    }, {
      "./_a-function": 8
    }],
    16: [function (require, module, exports) {
      // 7.2.1 RequireObjectCoercible(argument)
      module.exports = function (it) {
        if (it == undefined) throw TypeError("Can't call method on  " + it);
        return it;
      };
    }, {}],
    17: [function (require, module, exports) {
      // Thank's IE8 for his funny defineProperty
      module.exports = !require('./_fails')(function () {
        return Object.defineProperty({}, 'a', {
          get: function get() {
            return 7;
          }
        }).a != 7;
      });
    }, {
      "./_fails": 21
    }],
    18: [function (require, module, exports) {
      var isObject = require('./_is-object');

      var document = require('./_global').document; // typeof document.createElement is 'object' in old IE


      var is = isObject(document) && isObject(document.createElement);

      module.exports = function (it) {
        return is ? document.createElement(it) : {};
      };
    }, {
      "./_global": 22,
      "./_is-object": 29
    }],
    19: [function (require, module, exports) {
      // IE 8- don't enum bug keys
      module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
    }, {}],
    20: [function (require, module, exports) {
      var global = require('./_global');

      var core = require('./_core');

      var ctx = require('./_ctx');

      var hide = require('./_hide');

      var has = require('./_has');

      var PROTOTYPE = 'prototype';

      var $export = function $export(type, name, source) {
        var IS_FORCED = type & $export.F;
        var IS_GLOBAL = type & $export.G;
        var IS_STATIC = type & $export.S;
        var IS_PROTO = type & $export.P;
        var IS_BIND = type & $export.B;
        var IS_WRAP = type & $export.W;
        var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
        var expProto = exports[PROTOTYPE];
        var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
        var key, own, out;
        if (IS_GLOBAL) source = name;

        for (key in source) {
          // contains in native
          own = !IS_FORCED && target && target[key] !== undefined;
          if (own && has(exports, key)) continue; // export native or passed

          out = own ? target[key] : source[key]; // prevent global pollution for namespaces

          exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
          : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library
          : IS_WRAP && target[key] == out ? function (C) {
            var F = function F(a, b, c) {
              if (this instanceof C) {
                switch (arguments.length) {
                  case 0:
                    return new C();

                  case 1:
                    return new C(a);

                  case 2:
                    return new C(a, b);
                }

                return new C(a, b, c);
              }

              return C.apply(this, arguments);
            };

            F[PROTOTYPE] = C[PROTOTYPE];
            return F; // make static versions for prototype methods
          }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

          if (IS_PROTO) {
            (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

            if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
          }
        }
      }; // type bitmap


      $export.F = 1; // forced

      $export.G = 2; // global

      $export.S = 4; // static

      $export.P = 8; // proto

      $export.B = 16; // bind

      $export.W = 32; // wrap

      $export.U = 64; // safe

      $export.R = 128; // real proto method for `library`

      module.exports = $export;
    }, {
      "./_core": 13,
      "./_ctx": 15,
      "./_global": 22,
      "./_has": 23,
      "./_hide": 24
    }],
    21: [function (require, module, exports) {
      module.exports = function (exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
    }, {}],
    22: [function (require, module, exports) {
      // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
      var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
      : Function('return this')();
      if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
    }, {}],
    23: [function (require, module, exports) {
      var hasOwnProperty = {}.hasOwnProperty;

      module.exports = function (it, key) {
        return hasOwnProperty.call(it, key);
      };
    }, {}],
    24: [function (require, module, exports) {
      var dP = require('./_object-dp');

      var createDesc = require('./_property-desc');

      module.exports = require('./_descriptors') ? function (object, key, value) {
        return dP.f(object, key, createDesc(1, value));
      } : function (object, key, value) {
        object[key] = value;
        return object;
      };
    }, {
      "./_descriptors": 17,
      "./_object-dp": 38,
      "./_property-desc": 43
    }],
    25: [function (require, module, exports) {
      var document = require('./_global').document;

      module.exports = document && document.documentElement;
    }, {
      "./_global": 22
    }],
    26: [function (require, module, exports) {
      module.exports = !require('./_descriptors') && !require('./_fails')(function () {
        return Object.defineProperty(require('./_dom-create')('div'), 'a', {
          get: function get() {
            return 7;
          }
        }).a != 7;
      });
    }, {
      "./_descriptors": 17,
      "./_dom-create": 18,
      "./_fails": 21
    }],
    27: [function (require, module, exports) {
      // fallback for non-array-like ES3 and non-enumerable old V8 strings
      var cof = require('./_cof'); // eslint-disable-next-line no-prototype-builtins


      module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
        return cof(it) == 'String' ? it.split('') : Object(it);
      };
    }, {
      "./_cof": 12
    }],
    28: [function (require, module, exports) {
      // check on default Array iterator
      var Iterators = require('./_iterators');

      var ITERATOR = require('./_wks')('iterator');

      var ArrayProto = Array.prototype;

      module.exports = function (it) {
        return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
      };
    }, {
      "./_iterators": 34,
      "./_wks": 56
    }],
    29: [function (require, module, exports) {
      module.exports = function (it) {
        return _typeof2(it) === 'object' ? it !== null : typeof it === 'function';
      };
    }, {}],
    30: [function (require, module, exports) {
      // call something on iterator step with safe closing on error
      var anObject = require('./_an-object');

      module.exports = function (iterator, fn, value, entries) {
        try {
          return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
        } catch (e) {
          var ret = iterator['return'];
          if (ret !== undefined) anObject(ret.call(iterator));
          throw e;
        }
      };
    }, {
      "./_an-object": 9
    }],
    31: [function (require, module, exports) {
      'use strict';

      var create = require('./_object-create');

      var descriptor = require('./_property-desc');

      var setToStringTag = require('./_set-to-string-tag');

      var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

      require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () {
        return this;
      });

      module.exports = function (Constructor, NAME, next) {
        Constructor.prototype = create(IteratorPrototype, {
          next: descriptor(1, next)
        });
        setToStringTag(Constructor, NAME + ' Iterator');
      };
    }, {
      "./_hide": 24,
      "./_object-create": 37,
      "./_property-desc": 43,
      "./_set-to-string-tag": 45,
      "./_wks": 56
    }],
    32: [function (require, module, exports) {
      'use strict';

      var LIBRARY = require('./_library');

      var $export = require('./_export');

      var redefine = require('./_redefine');

      var hide = require('./_hide');

      var Iterators = require('./_iterators');

      var $iterCreate = require('./_iter-create');

      var setToStringTag = require('./_set-to-string-tag');

      var getPrototypeOf = require('./_object-gpo');

      var ITERATOR = require('./_wks')('iterator');

      var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

      var FF_ITERATOR = '@@iterator';
      var KEYS = 'keys';
      var VALUES = 'values';

      var returnThis = function returnThis() {
        return this;
      };

      module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
        $iterCreate(Constructor, NAME, next);

        var getMethod = function getMethod(kind) {
          if (!BUGGY && kind in proto) return proto[kind];

          switch (kind) {
            case KEYS:
              return function keys() {
                return new Constructor(this, kind);
              };

            case VALUES:
              return function values() {
                return new Constructor(this, kind);
              };
          }

          return function entries() {
            return new Constructor(this, kind);
          };
        };

        var TAG = NAME + ' Iterator';
        var DEF_VALUES = DEFAULT == VALUES;
        var VALUES_BUG = false;
        var proto = Base.prototype;
        var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
        var $default = $native || getMethod(DEFAULT);
        var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
        var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
        var methods, key, IteratorPrototype; // Fix native

        if ($anyNative) {
          IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

          if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
            // Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

            if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
          }
        } // fix Array#{values, @@iterator}.name in V8 / FF


        if (DEF_VALUES && $native && $native.name !== VALUES) {
          VALUES_BUG = true;

          $default = function values() {
            return $native.call(this);
          };
        } // Define iterator


        if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
          hide(proto, ITERATOR, $default);
        } // Plug for library


        Iterators[NAME] = $default;
        Iterators[TAG] = returnThis;

        if (DEFAULT) {
          methods = {
            values: DEF_VALUES ? $default : getMethod(VALUES),
            keys: IS_SET ? $default : getMethod(KEYS),
            entries: $entries
          };
          if (FORCED) for (key in methods) {
            if (!(key in proto)) redefine(proto, key, methods[key]);
          } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
        }

        return methods;
      };
    }, {
      "./_export": 20,
      "./_hide": 24,
      "./_iter-create": 31,
      "./_iterators": 34,
      "./_library": 35,
      "./_object-gpo": 40,
      "./_redefine": 44,
      "./_set-to-string-tag": 45,
      "./_wks": 56
    }],
    33: [function (require, module, exports) {
      var ITERATOR = require('./_wks')('iterator');

      var SAFE_CLOSING = false;

      try {
        var riter = [7][ITERATOR]();

        riter['return'] = function () {
          SAFE_CLOSING = true;
        }; // eslint-disable-next-line no-throw-literal


        Array.from(riter, function () {
          throw 2;
        });
      } catch (e) {
        /* empty */
      }

      module.exports = function (exec, skipClosing) {
        if (!skipClosing && !SAFE_CLOSING) return false;
        var safe = false;

        try {
          var arr = [7];
          var iter = arr[ITERATOR]();

          iter.next = function () {
            return {
              done: safe = true
            };
          };

          arr[ITERATOR] = function () {
            return iter;
          };

          exec(arr);
        } catch (e) {
          /* empty */
        }

        return safe;
      };
    }, {
      "./_wks": 56
    }],
    34: [function (require, module, exports) {
      module.exports = {};
    }, {}],
    35: [function (require, module, exports) {
      module.exports = true;
    }, {}],
    36: [function (require, module, exports) {
      // 20.2.2.28 Math.sign(x)
      module.exports = Math.sign || function sign(x) {
        // eslint-disable-next-line no-self-compare
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
    }, {}],
    37: [function (require, module, exports) {
      // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
      var anObject = require('./_an-object');

      var dPs = require('./_object-dps');

      var enumBugKeys = require('./_enum-bug-keys');

      var IE_PROTO = require('./_shared-key')('IE_PROTO');

      var Empty = function Empty() {
        /* empty */
      };

      var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

      var _createDict = function createDict() {
        // Thrash, waste and sodomy: IE GC bug
        var iframe = require('./_dom-create')('iframe');

        var i = enumBugKeys.length;
        var lt = '<';
        var gt = '>';
        var iframeDocument;
        iframe.style.display = 'none';

        require('./_html').appendChild(iframe);

        iframe.src = 'javascript:'; // eslint-disable-line no-script-url
        // createDict = iframe.contentWindow.Object;
        // html.removeChild(iframe);

        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
        iframeDocument.close();
        _createDict = iframeDocument.F;

        while (i--) {
          delete _createDict[PROTOTYPE][enumBugKeys[i]];
        }

        return _createDict();
      };

      module.exports = Object.create || function create(O, Properties) {
        var result;

        if (O !== null) {
          Empty[PROTOTYPE] = anObject(O);
          result = new Empty();
          Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

          result[IE_PROTO] = O;
        } else result = _createDict();

        return Properties === undefined ? result : dPs(result, Properties);
      };
    }, {
      "./_an-object": 9,
      "./_dom-create": 18,
      "./_enum-bug-keys": 19,
      "./_html": 25,
      "./_object-dps": 39,
      "./_shared-key": 46
    }],
    38: [function (require, module, exports) {
      var anObject = require('./_an-object');

      var IE8_DOM_DEFINE = require('./_ie8-dom-define');

      var toPrimitive = require('./_to-primitive');

      var dP = Object.defineProperty;
      exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (IE8_DOM_DEFINE) try {
          return dP(O, P, Attributes);
        } catch (e) {
          /* empty */
        }
        if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
        if ('value' in Attributes) O[P] = Attributes.value;
        return O;
      };
    }, {
      "./_an-object": 9,
      "./_descriptors": 17,
      "./_ie8-dom-define": 26,
      "./_to-primitive": 54
    }],
    39: [function (require, module, exports) {
      var dP = require('./_object-dp');

      var anObject = require('./_an-object');

      var getKeys = require('./_object-keys');

      module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys = getKeys(Properties);
        var length = keys.length;
        var i = 0;
        var P;

        while (length > i) {
          dP.f(O, P = keys[i++], Properties[P]);
        }

        return O;
      };
    }, {
      "./_an-object": 9,
      "./_descriptors": 17,
      "./_object-dp": 38,
      "./_object-keys": 42
    }],
    40: [function (require, module, exports) {
      // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
      var has = require('./_has');

      var toObject = require('./_to-object');

      var IE_PROTO = require('./_shared-key')('IE_PROTO');

      var ObjectProto = Object.prototype;

      module.exports = Object.getPrototypeOf || function (O) {
        O = toObject(O);
        if (has(O, IE_PROTO)) return O[IE_PROTO];

        if (typeof O.constructor == 'function' && O instanceof O.constructor) {
          return O.constructor.prototype;
        }

        return O instanceof Object ? ObjectProto : null;
      };
    }, {
      "./_has": 23,
      "./_shared-key": 46,
      "./_to-object": 53
    }],
    41: [function (require, module, exports) {
      var has = require('./_has');

      var toIObject = require('./_to-iobject');

      var arrayIndexOf = require('./_array-includes')(false);

      var IE_PROTO = require('./_shared-key')('IE_PROTO');

      module.exports = function (object, names) {
        var O = toIObject(object);
        var i = 0;
        var result = [];
        var key;

        for (key in O) {
          if (key != IE_PROTO) has(O, key) && result.push(key);
        } // Don't enum bug & hidden keys


        while (names.length > i) {
          if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }
        }

        return result;
      };
    }, {
      "./_array-includes": 10,
      "./_has": 23,
      "./_shared-key": 46,
      "./_to-iobject": 51
    }],
    42: [function (require, module, exports) {
      // 19.1.2.14 / 15.2.3.14 Object.keys(O)
      var $keys = require('./_object-keys-internal');

      var enumBugKeys = require('./_enum-bug-keys');

      module.exports = Object.keys || function keys(O) {
        return $keys(O, enumBugKeys);
      };
    }, {
      "./_enum-bug-keys": 19,
      "./_object-keys-internal": 41
    }],
    43: [function (require, module, exports) {
      module.exports = function (bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value: value
        };
      };
    }, {}],
    44: [function (require, module, exports) {
      module.exports = require('./_hide');
    }, {
      "./_hide": 24
    }],
    45: [function (require, module, exports) {
      var def = require('./_object-dp').f;

      var has = require('./_has');

      var TAG = require('./_wks')('toStringTag');

      module.exports = function (it, tag, stat) {
        if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
          configurable: true,
          value: tag
        });
      };
    }, {
      "./_has": 23,
      "./_object-dp": 38,
      "./_wks": 56
    }],
    46: [function (require, module, exports) {
      var shared = require('./_shared')('keys');

      var uid = require('./_uid');

      module.exports = function (key) {
        return shared[key] || (shared[key] = uid(key));
      };
    }, {
      "./_shared": 47,
      "./_uid": 55
    }],
    47: [function (require, module, exports) {
      var core = require('./_core');

      var global = require('./_global');

      var SHARED = '__core-js_shared__';
      var store = global[SHARED] || (global[SHARED] = {});
      (module.exports = function (key, value) {
        return store[key] || (store[key] = value !== undefined ? value : {});
      })('versions', []).push({
        version: core.version,
        mode: require('./_library') ? 'pure' : 'global',
        copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
      });
    }, {
      "./_core": 13,
      "./_global": 22,
      "./_library": 35
    }],
    48: [function (require, module, exports) {
      var toInteger = require('./_to-integer');

      var defined = require('./_defined'); // true  -> String#at
      // false -> String#codePointAt


      module.exports = function (TO_STRING) {
        return function (that, pos) {
          var s = String(defined(that));
          var i = toInteger(pos);
          var l = s.length;
          var a, b;
          if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
          a = s.charCodeAt(i);
          return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
        };
      };
    }, {
      "./_defined": 16,
      "./_to-integer": 50
    }],
    49: [function (require, module, exports) {
      var toInteger = require('./_to-integer');

      var max = Math.max;
      var min = Math.min;

      module.exports = function (index, length) {
        index = toInteger(index);
        return index < 0 ? max(index + length, 0) : min(index, length);
      };
    }, {
      "./_to-integer": 50
    }],
    50: [function (require, module, exports) {
      // 7.1.4 ToInteger
      var ceil = Math.ceil;
      var floor = Math.floor;

      module.exports = function (it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
      };
    }, {}],
    51: [function (require, module, exports) {
      // to indexed object, toObject with fallback for non-array-like ES3 strings
      var IObject = require('./_iobject');

      var defined = require('./_defined');

      module.exports = function (it) {
        return IObject(defined(it));
      };
    }, {
      "./_defined": 16,
      "./_iobject": 27
    }],
    52: [function (require, module, exports) {
      // 7.1.15 ToLength
      var toInteger = require('./_to-integer');

      var min = Math.min;

      module.exports = function (it) {
        return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
      };
    }, {
      "./_to-integer": 50
    }],
    53: [function (require, module, exports) {
      // 7.1.13 ToObject(argument)
      var defined = require('./_defined');

      module.exports = function (it) {
        return Object(defined(it));
      };
    }, {
      "./_defined": 16
    }],
    54: [function (require, module, exports) {
      // 7.1.1 ToPrimitive(input [, PreferredType])
      var isObject = require('./_is-object'); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
      // and the second argument - flag - preferred type is a string


      module.exports = function (it, S) {
        if (!isObject(it)) return it;
        var fn, val;
        if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
        if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        throw TypeError("Can't convert object to primitive value");
      };
    }, {
      "./_is-object": 29
    }],
    55: [function (require, module, exports) {
      var id = 0;
      var px = Math.random();

      module.exports = function (key) {
        return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
      };
    }, {}],
    56: [function (require, module, exports) {
      var store = require('./_shared')('wks');

      var uid = require('./_uid');

      var _Symbol = require('./_global').Symbol;

      var USE_SYMBOL = typeof _Symbol == 'function';

      var $exports = module.exports = function (name) {
        return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
      };

      $exports.store = store;
    }, {
      "./_global": 22,
      "./_shared": 47,
      "./_uid": 55
    }],
    57: [function (require, module, exports) {
      var classof = require('./_classof');

      var ITERATOR = require('./_wks')('iterator');

      var Iterators = require('./_iterators');

      module.exports = require('./_core').getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
      };
    }, {
      "./_classof": 11,
      "./_core": 13,
      "./_iterators": 34,
      "./_wks": 56
    }],
    58: [function (require, module, exports) {
      'use strict';

      var ctx = require('./_ctx');

      var $export = require('./_export');

      var toObject = require('./_to-object');

      var call = require('./_iter-call');

      var isArrayIter = require('./_is-array-iter');

      var toLength = require('./_to-length');

      var createProperty = require('./_create-property');

      var getIterFn = require('./core.get-iterator-method');

      $export($export.S + $export.F * !require('./_iter-detect')(function (iter) {
        Array.from(iter);
      }), 'Array', {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function from(arrayLike
        /* , mapfn = undefined, thisArg = undefined */
        ) {
          var O = toObject(arrayLike);
          var C = typeof this == 'function' ? this : Array;
          var aLen = arguments.length;
          var mapfn = aLen > 1 ? arguments[1] : undefined;
          var mapping = mapfn !== undefined;
          var index = 0;
          var iterFn = getIterFn(O);
          var length, result, step, iterator;
          if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

          if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
            for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
              createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
            }
          } else {
            length = toLength(O.length);

            for (result = new C(length); length > index; index++) {
              createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
            }
          }

          result.length = index;
          return result;
        }
      });
    }, {
      "./_create-property": 14,
      "./_ctx": 15,
      "./_export": 20,
      "./_is-array-iter": 28,
      "./_iter-call": 30,
      "./_iter-detect": 33,
      "./_to-length": 52,
      "./_to-object": 53,
      "./core.get-iterator-method": 57
    }],
    59: [function (require, module, exports) {
      // 20.2.2.21 Math.log10(x)
      var $export = require('./_export');

      $export($export.S, 'Math', {
        log10: function log10(x) {
          return Math.log(x) * Math.LOG10E;
        }
      });
    }, {
      "./_export": 20
    }],
    60: [function (require, module, exports) {
      // 20.2.2.28 Math.sign(x)
      var $export = require('./_export');

      $export($export.S, 'Math', {
        sign: require('./_math-sign')
      });
    }, {
      "./_export": 20,
      "./_math-sign": 36
    }],
    61: [function (require, module, exports) {
      'use strict';

      var $at = require('./_string-at')(true); // 21.1.3.27 String.prototype[@@iterator]()


      require('./_iter-define')(String, 'String', function (iterated) {
        this._t = String(iterated); // target

        this._i = 0; // next index
        // 21.1.5.2.1 %StringIteratorPrototype%.next()
      }, function () {
        var O = this._t;
        var index = this._i;
        var point;
        if (index >= O.length) return {
          value: undefined,
          done: true
        };
        point = $at(O, index);
        this._i += point.length;
        return {
          value: point,
          done: false
        };
      });
    }, {
      "./_iter-define": 32,
      "./_string-at": 48
    }],
    62: [function (require, module, exports) {
      // shim for using process in browser
      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }

      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }

      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }

        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();

      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        } // if setTimeout wasn't available but was latter defined


        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }

        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }

      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        } // if clearTimeout wasn't available but was latter defined


        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }

        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }

      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }

        draining = false;

        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }

        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }

        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;

        while (len) {
          currentQueue = queue;
          queue = [];

          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }

          queueIndex = -1;
          len = queue.length;
        }

        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);

        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }

        queue.push(new Item(fun, args));

        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      }; // v8 likes predictible objects


      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }

      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };

      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues

      process.versions = {};

      function noop() {}

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {
        return [];
      };

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {
        return '/';
      };

      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };

      process.umask = function () {
        return 0;
      };
    }, {}],
    63: [function (require, module, exports) {
      (function (setImmediate, clearImmediate) {
        var nextTick = require('process/browser.js').nextTick;

        var apply = Function.prototype.apply;
        var slice = Array.prototype.slice;
        var immediateIds = {};
        var nextImmediateId = 0; // DOM APIs, for completeness

        exports.setTimeout = function () {
          return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
        };

        exports.setInterval = function () {
          return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
        };

        exports.clearTimeout = exports.clearInterval = function (timeout) {
          timeout.close();
        };

        function Timeout(id, clearFn) {
          this._id = id;
          this._clearFn = clearFn;
        }

        Timeout.prototype.unref = Timeout.prototype.ref = function () {};

        Timeout.prototype.close = function () {
          this._clearFn.call(window, this._id);
        }; // Does not start the time, just sets up the members needed.


        exports.enroll = function (item, msecs) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = msecs;
        };

        exports.unenroll = function (item) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = -1;
        };

        exports._unrefActive = exports.active = function (item) {
          clearTimeout(item._idleTimeoutId);
          var msecs = item._idleTimeout;

          if (msecs >= 0) {
            item._idleTimeoutId = setTimeout(function onTimeout() {
              if (item._onTimeout) item._onTimeout();
            }, msecs);
          }
        }; // That's not how node.js implements it but the exposed api is the same.


        exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
          var id = nextImmediateId++;
          var args = arguments.length < 2 ? false : slice.call(arguments, 1);
          immediateIds[id] = true;
          nextTick(function onNextTick() {
            if (immediateIds[id]) {
              // fn.call() is faster so we optimize for the common use-case
              // @see http://jsperf.com/call-apply-segu
              if (args) {
                fn.apply(null, args);
              } else {
                fn.call(null);
              } // Prevent ids from leaking


              exports.clearImmediate(id);
            }
          });
          return id;
        };
        exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
          delete immediateIds[id];
        };
      }).call(this, require("timers").setImmediate, require("timers").clearImmediate);
    }, {
      "process/browser.js": 62,
      "timers": 63
    }],
    64: [function (require, module, exports) {
      var Vue; // late bind

      var version;
      var map = window.__VUE_HOT_MAP__ = Object.create(null);
      var installed = false;
      var isBrowserify = false;
      var initHookName = 'beforeCreate';

      exports.install = function (vue, browserify) {
        if (installed) {
          return;
        }

        installed = true;
        Vue = vue.__esModule ? vue.default : vue;
        version = Vue.version.split('.').map(Number);
        isBrowserify = browserify; // compat with < 2.0.0-alpha.7

        if (Vue.config._lifecycleHooks.indexOf('init') > -1) {
          initHookName = 'init';
        }

        exports.compatible = version[0] >= 2;

        if (!exports.compatible) {
          console.warn('[HMR] You are using a version of vue-hot-reload-api that is ' + 'only compatible with Vue.js core ^2.0.0.');
          return;
        }
      };
      /**
       * Create a record for a hot module, which keeps track of its constructor
       * and instances
       *
       * @param {String} id
       * @param {Object} options
       */


      exports.createRecord = function (id, options) {
        if (map[id]) {
          return;
        }

        var Ctor = null;

        if (typeof options === 'function') {
          Ctor = options;
          options = Ctor.options;
        }

        makeOptionsHot(id, options);
        map[id] = {
          Ctor: Ctor,
          options: options,
          instances: []
        };
      };
      /**
       * Check if module is recorded
       *
       * @param {String} id
       */


      exports.isRecorded = function (id) {
        return typeof map[id] !== 'undefined';
      };
      /**
       * Make a Component options object hot.
       *
       * @param {String} id
       * @param {Object} options
       */


      function makeOptionsHot(id, options) {
        if (options.functional) {
          var render = options.render;

          options.render = function (h, ctx) {
            var instances = map[id].instances;

            if (ctx && instances.indexOf(ctx.parent) < 0) {
              instances.push(ctx.parent);
            }

            return render(h, ctx);
          };
        } else {
          injectHook(options, initHookName, function () {
            var record = map[id];

            if (!record.Ctor) {
              record.Ctor = this.constructor;
            }

            record.instances.push(this);
          });
          injectHook(options, 'beforeDestroy', function () {
            var instances = map[id].instances;
            instances.splice(instances.indexOf(this), 1);
          });
        }
      }
      /**
       * Inject a hook to a hot reloadable component so that
       * we can keep track of it.
       *
       * @param {Object} options
       * @param {String} name
       * @param {Function} hook
       */


      function injectHook(options, name, hook) {
        var existing = options[name];
        options[name] = existing ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook] : [hook];
      }

      function tryWrap(fn) {
        return function (id, arg) {
          try {
            fn(id, arg);
          } catch (e) {
            console.error(e);
            console.warn('Something went wrong during Vue component hot-reload. Full reload required.');
          }
        };
      }

      function updateOptions(oldOptions, newOptions) {
        for (var key in oldOptions) {
          if (!(key in newOptions)) {
            delete oldOptions[key];
          }
        }

        for (var key$1 in newOptions) {
          oldOptions[key$1] = newOptions[key$1];
        }
      }

      exports.rerender = tryWrap(function (id, options) {
        var record = map[id];

        if (!options) {
          record.instances.slice().forEach(function (instance) {
            instance.$forceUpdate();
          });
          return;
        }

        if (typeof options === 'function') {
          options = options.options;
        }

        if (record.Ctor) {
          record.Ctor.options.render = options.render;
          record.Ctor.options.staticRenderFns = options.staticRenderFns;
          record.instances.slice().forEach(function (instance) {
            instance.$options.render = options.render;
            instance.$options.staticRenderFns = options.staticRenderFns; // reset static trees
            // pre 2.5, all static trees are cahced together on the instance

            if (instance._staticTrees) {
              instance._staticTrees = [];
            } // 2.5.0


            if (Array.isArray(record.Ctor.options.cached)) {
              record.Ctor.options.cached = [];
            } // 2.5.3


            if (Array.isArray(instance.$options.cached)) {
              instance.$options.cached = [];
            } // post 2.5.4: v-once trees are cached on instance._staticTrees.
            // Pure static trees are cached on the staticRenderFns array
            // (both already reset above)


            instance.$forceUpdate();
          });
        } else {
          // functional or no instance created yet
          record.options.render = options.render;
          record.options.staticRenderFns = options.staticRenderFns; // handle functional component re-render

          if (record.options.functional) {
            // rerender with full options
            if (Object.keys(options).length > 2) {
              updateOptions(record.options, options);
            } else {
              // template-only rerender.
              // need to inject the style injection code for CSS modules
              // to work properly.
              var injectStyles = record.options._injectStyles;

              if (injectStyles) {
                var render = options.render;

                record.options.render = function (h, ctx) {
                  injectStyles.call(ctx);
                  return render(h, ctx);
                };
              }
            }

            record.options._Ctor = null; // 2.5.3

            if (Array.isArray(record.options.cached)) {
              record.options.cached = [];
            }

            record.instances.slice().forEach(function (instance) {
              instance.$forceUpdate();
            });
          }
        }
      });
      exports.reload = tryWrap(function (id, options) {
        var record = map[id];

        if (options) {
          if (typeof options === 'function') {
            options = options.options;
          }

          makeOptionsHot(id, options);

          if (record.Ctor) {
            if (version[1] < 2) {
              // preserve pre 2.2 behavior for global mixin handling
              record.Ctor.extendOptions = options;
            }

            var newCtor = record.Ctor.super.extend(options);
            record.Ctor.options = newCtor.options;
            record.Ctor.cid = newCtor.cid;
            record.Ctor.prototype = newCtor.prototype;

            if (newCtor.release) {
              // temporary global mixin strategy used in < 2.0.0-alpha.6
              newCtor.release();
            }
          } else {
            updateOptions(record.options, options);
          }
        }

        record.instances.slice().forEach(function (instance) {
          if (instance.$vnode && instance.$vnode.context) {
            instance.$vnode.context.$forceUpdate();
          } else {
            console.warn('Root or manually mounted instance modified. Full reload required.');
          }
        });
      });
    }, {}],
    65: [function (require, module, exports) {
      (function (process, global, setImmediate) {
        /*!
         * Vue.js v2.5.16
         * (c) 2014-2018 Evan You
         * Released under the MIT License.
         */
        'use strict';
        /*  */

        var emptyObject = Object.freeze({}); // these helpers produces better vm code in JS engines due to their
        // explicitness and function inlining

        function isUndef(v) {
          return v === undefined || v === null;
        }

        function isDef(v) {
          return v !== undefined && v !== null;
        }

        function isTrue(v) {
          return v === true;
        }

        function isFalse(v) {
          return v === false;
        }
        /**
         * Check if value is primitive
         */


        function isPrimitive(value) {
          return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
          _typeof2(value) === 'symbol' || typeof value === 'boolean';
        }
        /**
         * Quick object check - this is primarily used to tell
         * Objects from primitive values when we know the value
         * is a JSON-compliant type.
         */


        function isObject(obj) {
          return obj !== null && _typeof2(obj) === 'object';
        }
        /**
         * Get the raw type string of a value e.g. [object Object]
         */


        var _toString = Object.prototype.toString;

        function toRawType(value) {
          return _toString.call(value).slice(8, -1);
        }
        /**
         * Strict object type check. Only returns true
         * for plain JavaScript objects.
         */


        function isPlainObject(obj) {
          return _toString.call(obj) === '[object Object]';
        }

        function isRegExp(v) {
          return _toString.call(v) === '[object RegExp]';
        }
        /**
         * Check if val is a valid array index.
         */


        function isValidArrayIndex(val) {
          var n = parseFloat(String(val));
          return n >= 0 && Math.floor(n) === n && isFinite(val);
        }
        /**
         * Convert a value to a string that is actually rendered.
         */


        function toString(val) {
          return val == null ? '' : _typeof2(val) === 'object' ? JSON.stringify(val, null, 2) : String(val);
        }
        /**
         * Convert a input value to a number for persistence.
         * If the conversion fails, return original string.
         */


        function toNumber(val) {
          var n = parseFloat(val);
          return isNaN(n) ? val : n;
        }
        /**
         * Make a map and return a function for checking if a key
         * is in that map.
         */


        function makeMap(str, expectsLowerCase) {
          var map = Object.create(null);
          var list = str.split(',');

          for (var i = 0; i < list.length; i++) {
            map[list[i]] = true;
          }

          return expectsLowerCase ? function (val) {
            return map[val.toLowerCase()];
          } : function (val) {
            return map[val];
          };
        }
        /**
         * Check if a tag is a built-in tag.
         */


        var isBuiltInTag = makeMap('slot,component', true);
        /**
         * Check if a attribute is a reserved attribute.
         */

        var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
        /**
         * Remove an item from an array
         */

        function remove(arr, item) {
          if (arr.length) {
            var index = arr.indexOf(item);

            if (index > -1) {
              return arr.splice(index, 1);
            }
          }
        }
        /**
         * Check whether the object has the property.
         */


        var hasOwnProperty = Object.prototype.hasOwnProperty;

        function hasOwn(obj, key) {
          return hasOwnProperty.call(obj, key);
        }
        /**
         * Create a cached version of a pure function.
         */


        function cached(fn) {
          var cache = Object.create(null);
          return function cachedFn(str) {
            var hit = cache[str];
            return hit || (cache[str] = fn(str));
          };
        }
        /**
         * Camelize a hyphen-delimited string.
         */


        var camelizeRE = /-(\w)/g;
        var camelize = cached(function (str) {
          return str.replace(camelizeRE, function (_, c) {
            return c ? c.toUpperCase() : '';
          });
        });
        /**
         * Capitalize a string.
         */

        var capitalize = cached(function (str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        });
        /**
         * Hyphenate a camelCase string.
         */

        var hyphenateRE = /\B([A-Z])/g;
        var hyphenate = cached(function (str) {
          return str.replace(hyphenateRE, '-$1').toLowerCase();
        });
        /**
         * Simple bind polyfill for environments that do not support it... e.g.
         * PhantomJS 1.x. Technically we don't need this anymore since native bind is
         * now more performant in most browsers, but removing it would be breaking for
         * code that was able to run in PhantomJS 1.x, so this must be kept for
         * backwards compatibility.
         */

        /* istanbul ignore next */

        function polyfillBind(fn, ctx) {
          function boundFn(a) {
            var l = arguments.length;
            return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
          }

          boundFn._length = fn.length;
          return boundFn;
        }

        function nativeBind(fn, ctx) {
          return fn.bind(ctx);
        }

        var bind = Function.prototype.bind ? nativeBind : polyfillBind;
        /**
         * Convert an Array-like object to a real Array.
         */

        function toArray(list, start) {
          start = start || 0;
          var i = list.length - start;
          var ret = new Array(i);

          while (i--) {
            ret[i] = list[i + start];
          }

          return ret;
        }
        /**
         * Mix properties into target object.
         */


        function extend(to, _from) {
          for (var key in _from) {
            to[key] = _from[key];
          }

          return to;
        }
        /**
         * Merge an Array of Objects into a single Object.
         */


        function toObject(arr) {
          var res = {};

          for (var i = 0; i < arr.length; i++) {
            if (arr[i]) {
              extend(res, arr[i]);
            }
          }

          return res;
        }
        /**
         * Perform no operation.
         * Stubbing args to make Flow happy without leaving useless transpiled code
         * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
         */


        function noop(a, b, c) {}
        /**
         * Always return false.
         */


        var no = function no(a, b, c) {
          return false;
        };
        /**
         * Return same value
         */


        var identity = function identity(_) {
          return _;
        };
        /**
         * Generate a static keys string from compiler modules.
         */

        /**
         * Check if two values are loosely equal - that is,
         * if they are plain objects, do they have the same shape?
         */


        function looseEqual(a, b) {
          if (a === b) {
            return true;
          }

          var isObjectA = isObject(a);
          var isObjectB = isObject(b);

          if (isObjectA && isObjectB) {
            try {
              var isArrayA = Array.isArray(a);
              var isArrayB = Array.isArray(b);

              if (isArrayA && isArrayB) {
                return a.length === b.length && a.every(function (e, i) {
                  return looseEqual(e, b[i]);
                });
              } else if (!isArrayA && !isArrayB) {
                var keysA = Object.keys(a);
                var keysB = Object.keys(b);
                return keysA.length === keysB.length && keysA.every(function (key) {
                  return looseEqual(a[key], b[key]);
                });
              } else {
                /* istanbul ignore next */
                return false;
              }
            } catch (e) {
              /* istanbul ignore next */
              return false;
            }
          } else if (!isObjectA && !isObjectB) {
            return String(a) === String(b);
          } else {
            return false;
          }
        }

        function looseIndexOf(arr, val) {
          for (var i = 0; i < arr.length; i++) {
            if (looseEqual(arr[i], val)) {
              return i;
            }
          }

          return -1;
        }
        /**
         * Ensure a function is called only once.
         */


        function once(fn) {
          var called = false;
          return function () {
            if (!called) {
              called = true;
              fn.apply(this, arguments);
            }
          };
        }

        var SSR_ATTR = 'data-server-rendered';
        var ASSET_TYPES = ['component', 'directive', 'filter'];
        var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];
        /*  */

        var config = {
          /**
           * Option merge strategies (used in core/util/options)
           */
          // $flow-disable-line
          optionMergeStrategies: Object.create(null),

          /**
           * Whether to suppress warnings.
           */
          silent: false,

          /**
           * Show production mode tip message on boot?
           */
          productionTip: process.env.NODE_ENV !== 'production',

          /**
           * Whether to enable devtools
           */
          devtools: process.env.NODE_ENV !== 'production',

          /**
           * Whether to record perf
           */
          performance: false,

          /**
           * Error handler for watcher errors
           */
          errorHandler: null,

          /**
           * Warn handler for watcher warns
           */
          warnHandler: null,

          /**
           * Ignore certain custom elements
           */
          ignoredElements: [],

          /**
           * Custom user key aliases for v-on
           */
          // $flow-disable-line
          keyCodes: Object.create(null),

          /**
           * Check if a tag is reserved so that it cannot be registered as a
           * component. This is platform-dependent and may be overwritten.
           */
          isReservedTag: no,

          /**
           * Check if an attribute is reserved so that it cannot be used as a component
           * prop. This is platform-dependent and may be overwritten.
           */
          isReservedAttr: no,

          /**
           * Check if a tag is an unknown element.
           * Platform-dependent.
           */
          isUnknownElement: no,

          /**
           * Get the namespace of an element
           */
          getTagNamespace: noop,

          /**
           * Parse the real tag name for the specific platform.
           */
          parsePlatformTagName: identity,

          /**
           * Check if an attribute must be bound using property, e.g. value
           * Platform-dependent.
           */
          mustUseProp: no,

          /**
           * Exposed for legacy reasons
           */
          _lifecycleHooks: LIFECYCLE_HOOKS
        };
        /*  */

        /**
         * Check if a string starts with $ or _
         */

        function isReserved(str) {
          var c = (str + '').charCodeAt(0);
          return c === 0x24 || c === 0x5F;
        }
        /**
         * Define a property.
         */


        function def(obj, key, val, enumerable) {
          Object.defineProperty(obj, key, {
            value: val,
            enumerable: !!enumerable,
            writable: true,
            configurable: true
          });
        }
        /**
         * Parse simple path.
         */


        var bailRE = /[^\w.$]/;

        function parsePath(path) {
          if (bailRE.test(path)) {
            return;
          }

          var segments = path.split('.');
          return function (obj) {
            for (var i = 0; i < segments.length; i++) {
              if (!obj) {
                return;
              }

              obj = obj[segments[i]];
            }

            return obj;
          };
        }
        /*  */
        // can we use __proto__?


        var hasProto = '__proto__' in {}; // Browser environment sniffing

        var inBrowser = typeof window !== 'undefined';
        var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
        var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
        var UA = inBrowser && window.navigator.userAgent.toLowerCase();
        var isIE = UA && /msie|trident/.test(UA);
        var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
        var isEdge = UA && UA.indexOf('edge/') > 0;
        var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
        var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
        var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge; // Firefox has a "watch" function on Object.prototype...

        var nativeWatch = {}.watch;
        var supportsPassive = false;

        if (inBrowser) {
          try {
            var opts = {};
            Object.defineProperty(opts, 'passive', {
              get: function get() {
                /* istanbul ignore next */
                supportsPassive = true;
              }
            }); // https://github.com/facebook/flow/issues/285

            window.addEventListener('test-passive', null, opts);
          } catch (e) {}
        } // this needs to be lazy-evaled because vue may be required before
        // vue-server-renderer can set VUE_ENV


        var _isServer;

        var isServerRendering = function isServerRendering() {
          if (_isServer === undefined) {
            /* istanbul ignore if */
            if (!inBrowser && !inWeex && typeof global !== 'undefined') {
              // detect presence of vue-server-renderer and avoid
              // Webpack shimming the process
              _isServer = global['process'].env.VUE_ENV === 'server';
            } else {
              _isServer = false;
            }
          }

          return _isServer;
        }; // detect devtools


        var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
        /* istanbul ignore next */

        function isNative(Ctor) {
          return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
        }

        var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

        var _Set;
        /* istanbul ignore if */
        // $flow-disable-line


        if (typeof Set !== 'undefined' && isNative(Set)) {
          // use native Set when available.
          _Set = Set;
        } else {
          // a non-standard Set polyfill that only works with primitive keys.
          _Set = function () {
            function Set() {
              this.set = Object.create(null);
            }

            Set.prototype.has = function has(key) {
              return this.set[key] === true;
            };

            Set.prototype.add = function add(key) {
              this.set[key] = true;
            };

            Set.prototype.clear = function clear() {
              this.set = Object.create(null);
            };

            return Set;
          }();
        }
        /*  */


        var warn = noop;
        var tip = noop;
        var generateComponentTrace = noop; // work around flow check

        var formatComponentName = noop;

        if (process.env.NODE_ENV !== 'production') {
          var hasConsole = typeof console !== 'undefined';
          var classifyRE = /(?:^|[-_])(\w)/g;

          var classify = function classify(str) {
            return str.replace(classifyRE, function (c) {
              return c.toUpperCase();
            }).replace(/[-_]/g, '');
          };

          warn = function warn(msg, vm) {
            var trace = vm ? generateComponentTrace(vm) : '';

            if (config.warnHandler) {
              config.warnHandler.call(null, msg, vm, trace);
            } else if (hasConsole && !config.silent) {
              console.error("[Vue warn]: " + msg + trace);
            }
          };

          tip = function tip(msg, vm) {
            if (hasConsole && !config.silent) {
              console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
            }
          };

          formatComponentName = function formatComponentName(vm, includeFile) {
            if (vm.$root === vm) {
              return '<Root>';
            }

            var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
            var name = options.name || options._componentTag;
            var file = options.__file;

            if (!name && file) {
              var match = file.match(/([^/\\]+)\.vue$/);
              name = match && match[1];
            }

            return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
          };

          var repeat = function repeat(str, n) {
            var res = '';

            while (n) {
              if (n % 2 === 1) {
                res += str;
              }

              if (n > 1) {
                str += str;
              }

              n >>= 1;
            }

            return res;
          };

          generateComponentTrace = function generateComponentTrace(vm) {
            if (vm._isVue && vm.$parent) {
              var tree = [];
              var currentRecursiveSequence = 0;

              while (vm) {
                if (tree.length > 0) {
                  var last = tree[tree.length - 1];

                  if (last.constructor === vm.constructor) {
                    currentRecursiveSequence++;
                    vm = vm.$parent;
                    continue;
                  } else if (currentRecursiveSequence > 0) {
                    tree[tree.length - 1] = [last, currentRecursiveSequence];
                    currentRecursiveSequence = 0;
                  }
                }

                tree.push(vm);
                vm = vm.$parent;
              }

              return '\n\nfound in\n\n' + tree.map(function (vm, i) {
                return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
              }).join('\n');
            } else {
              return "\n\n(found in " + formatComponentName(vm) + ")";
            }
          };
        }
        /*  */


        var uid = 0;
        /**
         * A dep is an observable that can have multiple
         * directives subscribing to it.
         */

        var Dep = function Dep() {
          this.id = uid++;
          this.subs = [];
        };

        Dep.prototype.addSub = function addSub(sub) {
          this.subs.push(sub);
        };

        Dep.prototype.removeSub = function removeSub(sub) {
          remove(this.subs, sub);
        };

        Dep.prototype.depend = function depend() {
          if (Dep.target) {
            Dep.target.addDep(this);
          }
        };

        Dep.prototype.notify = function notify() {
          // stabilize the subscriber list first
          var subs = this.subs.slice();

          for (var i = 0, l = subs.length; i < l; i++) {
            subs[i].update();
          }
        }; // the current target watcher being evaluated.
        // this is globally unique because there could be only one
        // watcher being evaluated at any time.


        Dep.target = null;
        var targetStack = [];

        function pushTarget(_target) {
          if (Dep.target) {
            targetStack.push(Dep.target);
          }

          Dep.target = _target;
        }

        function popTarget() {
          Dep.target = targetStack.pop();
        }
        /*  */


        var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
          this.tag = tag;
          this.data = data;
          this.children = children;
          this.text = text;
          this.elm = elm;
          this.ns = undefined;
          this.context = context;
          this.fnContext = undefined;
          this.fnOptions = undefined;
          this.fnScopeId = undefined;
          this.key = data && data.key;
          this.componentOptions = componentOptions;
          this.componentInstance = undefined;
          this.parent = undefined;
          this.raw = false;
          this.isStatic = false;
          this.isRootInsert = true;
          this.isComment = false;
          this.isCloned = false;
          this.isOnce = false;
          this.asyncFactory = asyncFactory;
          this.asyncMeta = undefined;
          this.isAsyncPlaceholder = false;
        };

        var prototypeAccessors = {
          child: {
            configurable: true
          }
        }; // DEPRECATED: alias for componentInstance for backwards compat.

        /* istanbul ignore next */

        prototypeAccessors.child.get = function () {
          return this.componentInstance;
        };

        Object.defineProperties(VNode.prototype, prototypeAccessors);

        var createEmptyVNode = function createEmptyVNode(text) {
          if (text === void 0) text = '';
          var node = new VNode();
          node.text = text;
          node.isComment = true;
          return node;
        };

        function createTextVNode(val) {
          return new VNode(undefined, undefined, undefined, String(val));
        } // optimized shallow clone
        // used for static nodes and slot nodes because they may be reused across
        // multiple renders, cloning them avoids errors when DOM manipulations rely
        // on their elm reference.


        function cloneVNode(vnode) {
          var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
          cloned.ns = vnode.ns;
          cloned.isStatic = vnode.isStatic;
          cloned.key = vnode.key;
          cloned.isComment = vnode.isComment;
          cloned.fnContext = vnode.fnContext;
          cloned.fnOptions = vnode.fnOptions;
          cloned.fnScopeId = vnode.fnScopeId;
          cloned.isCloned = true;
          return cloned;
        }
        /*
         * not type checking this file because flow doesn't play well with
         * dynamically accessing methods on Array prototype
         */


        var arrayProto = Array.prototype;
        var arrayMethods = Object.create(arrayProto);
        var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
        /**
         * Intercept mutating methods and emit events
         */

        methodsToPatch.forEach(function (method) {
          // cache original method
          var original = arrayProto[method];
          def(arrayMethods, method, function mutator() {
            var args = [],
                len = arguments.length;

            while (len--) {
              args[len] = arguments[len];
            }

            var result = original.apply(this, args);
            var ob = this.__ob__;
            var inserted;

            switch (method) {
              case 'push':
              case 'unshift':
                inserted = args;
                break;

              case 'splice':
                inserted = args.slice(2);
                break;
            }

            if (inserted) {
              ob.observeArray(inserted);
            } // notify change


            ob.dep.notify();
            return result;
          });
        });
        /*  */

        var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
        /**
         * In some cases we may want to disable observation inside a component's
         * update computation.
         */

        var shouldObserve = true;

        function toggleObserving(value) {
          shouldObserve = value;
        }
        /**
         * Observer class that is attached to each observed
         * object. Once attached, the observer converts the target
         * object's property keys into getter/setters that
         * collect dependencies and dispatch updates.
         */


        var Observer = function Observer(value) {
          this.value = value;
          this.dep = new Dep();
          this.vmCount = 0;
          def(value, '__ob__', this);

          if (Array.isArray(value)) {
            var augment = hasProto ? protoAugment : copyAugment;
            augment(value, arrayMethods, arrayKeys);
            this.observeArray(value);
          } else {
            this.walk(value);
          }
        };
        /**
         * Walk through each property and convert them into
         * getter/setters. This method should only be called when
         * value type is Object.
         */


        Observer.prototype.walk = function walk(obj) {
          var keys = Object.keys(obj);

          for (var i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i]);
          }
        };
        /**
         * Observe a list of Array items.
         */


        Observer.prototype.observeArray = function observeArray(items) {
          for (var i = 0, l = items.length; i < l; i++) {
            observe(items[i]);
          }
        }; // helpers

        /**
         * Augment an target Object or Array by intercepting
         * the prototype chain using __proto__
         */


        function protoAugment(target, src, keys) {
          /* eslint-disable no-proto */
          target.__proto__ = src;
          /* eslint-enable no-proto */
        }
        /**
         * Augment an target Object or Array by defining
         * hidden properties.
         */

        /* istanbul ignore next */


        function copyAugment(target, src, keys) {
          for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            def(target, key, src[key]);
          }
        }
        /**
         * Attempt to create an observer instance for a value,
         * returns the new observer if successfully observed,
         * or the existing observer if the value already has one.
         */


        function observe(value, asRootData) {
          if (!isObject(value) || value instanceof VNode) {
            return;
          }

          var ob;

          if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
            ob = value.__ob__;
          } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
            ob = new Observer(value);
          }

          if (asRootData && ob) {
            ob.vmCount++;
          }

          return ob;
        }
        /**
         * Define a reactive property on an Object.
         */


        function defineReactive(obj, key, val, customSetter, shallow) {
          var dep = new Dep();
          var property = Object.getOwnPropertyDescriptor(obj, key);

          if (property && property.configurable === false) {
            return;
          } // cater for pre-defined getter/setters


          var getter = property && property.get;

          if (!getter && arguments.length === 2) {
            val = obj[key];
          }

          var setter = property && property.set;
          var childOb = !shallow && observe(val);
          Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: function reactiveGetter() {
              var value = getter ? getter.call(obj) : val;

              if (Dep.target) {
                dep.depend();

                if (childOb) {
                  childOb.dep.depend();

                  if (Array.isArray(value)) {
                    dependArray(value);
                  }
                }
              }

              return value;
            },
            set: function reactiveSetter(newVal) {
              var value = getter ? getter.call(obj) : val;
              /* eslint-disable no-self-compare */

              if (newVal === value || newVal !== newVal && value !== value) {
                return;
              }
              /* eslint-enable no-self-compare */


              if (process.env.NODE_ENV !== 'production' && customSetter) {
                customSetter();
              }

              if (setter) {
                setter.call(obj, newVal);
              } else {
                val = newVal;
              }

              childOb = !shallow && observe(newVal);
              dep.notify();
            }
          });
        }
        /**
         * Set a property on an object. Adds the new property and
         * triggers change notification if the property doesn't
         * already exist.
         */


        function set(target, key, val) {
          if (process.env.NODE_ENV !== 'production' && (isUndef(target) || isPrimitive(target))) {
            warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
          }

          if (Array.isArray(target) && isValidArrayIndex(key)) {
            target.length = Math.max(target.length, key);
            target.splice(key, 1, val);
            return val;
          }

          if (key in target && !(key in Object.prototype)) {
            target[key] = val;
            return val;
          }

          var ob = target.__ob__;

          if (target._isVue || ob && ob.vmCount) {
            process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
            return val;
          }

          if (!ob) {
            target[key] = val;
            return val;
          }

          defineReactive(ob.value, key, val);
          ob.dep.notify();
          return val;
        }
        /**
         * Delete a property and trigger change if necessary.
         */


        function del(target, key) {
          if (process.env.NODE_ENV !== 'production' && (isUndef(target) || isPrimitive(target))) {
            warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
          }

          if (Array.isArray(target) && isValidArrayIndex(key)) {
            target.splice(key, 1);
            return;
          }

          var ob = target.__ob__;

          if (target._isVue || ob && ob.vmCount) {
            process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
            return;
          }

          if (!hasOwn(target, key)) {
            return;
          }

          delete target[key];

          if (!ob) {
            return;
          }

          ob.dep.notify();
        }
        /**
         * Collect dependencies on array elements when the array is touched, since
         * we cannot intercept array element access like property getters.
         */


        function dependArray(value) {
          for (var e = void 0, i = 0, l = value.length; i < l; i++) {
            e = value[i];
            e && e.__ob__ && e.__ob__.dep.depend();

            if (Array.isArray(e)) {
              dependArray(e);
            }
          }
        }
        /*  */

        /**
         * Option overwriting strategies are functions that handle
         * how to merge a parent option value and a child option
         * value into the final value.
         */


        var strats = config.optionMergeStrategies;
        /**
         * Options with restrictions
         */

        if (process.env.NODE_ENV !== 'production') {
          strats.el = strats.propsData = function (parent, child, vm, key) {
            if (!vm) {
              warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
            }

            return defaultStrat(parent, child);
          };
        }
        /**
         * Helper that recursively merges two data objects together.
         */


        function mergeData(to, from) {
          if (!from) {
            return to;
          }

          var key, toVal, fromVal;
          var keys = Object.keys(from);

          for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            toVal = to[key];
            fromVal = from[key];

            if (!hasOwn(to, key)) {
              set(to, key, fromVal);
            } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
              mergeData(toVal, fromVal);
            }
          }

          return to;
        }
        /**
         * Data
         */


        function mergeDataOrFn(parentVal, childVal, vm) {
          if (!vm) {
            // in a Vue.extend merge, both should be functions
            if (!childVal) {
              return parentVal;
            }

            if (!parentVal) {
              return childVal;
            } // when parentVal & childVal are both present,
            // we need to return a function that returns the
            // merged result of both functions... no need to
            // check if parentVal is a function here because
            // it has to be a function to pass previous merges.


            return function mergedDataFn() {
              return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
            };
          } else {
            return function mergedInstanceDataFn() {
              // instance merge
              var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
              var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

              if (instanceData) {
                return mergeData(instanceData, defaultData);
              } else {
                return defaultData;
              }
            };
          }
        }

        strats.data = function (parentVal, childVal, vm) {
          if (!vm) {
            if (childVal && typeof childVal !== 'function') {
              process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
              return parentVal;
            }

            return mergeDataOrFn(parentVal, childVal);
          }

          return mergeDataOrFn(parentVal, childVal, vm);
        };
        /**
         * Hooks and props are merged as arrays.
         */


        function mergeHook(parentVal, childVal) {
          return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
        }

        LIFECYCLE_HOOKS.forEach(function (hook) {
          strats[hook] = mergeHook;
        });
        /**
         * Assets
         *
         * When a vm is present (instance creation), we need to do
         * a three-way merge between constructor options, instance
         * options and parent options.
         */

        function mergeAssets(parentVal, childVal, vm, key) {
          var res = Object.create(parentVal || null);

          if (childVal) {
            process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);
            return extend(res, childVal);
          } else {
            return res;
          }
        }

        ASSET_TYPES.forEach(function (type) {
          strats[type + 's'] = mergeAssets;
        });
        /**
         * Watchers.
         *
         * Watchers hashes should not overwrite one
         * another, so we merge them as arrays.
         */

        strats.watch = function (parentVal, childVal, vm, key) {
          // work around Firefox's Object.prototype.watch...
          if (parentVal === nativeWatch) {
            parentVal = undefined;
          }

          if (childVal === nativeWatch) {
            childVal = undefined;
          }
          /* istanbul ignore if */


          if (!childVal) {
            return Object.create(parentVal || null);
          }

          if (process.env.NODE_ENV !== 'production') {
            assertObjectType(key, childVal, vm);
          }

          if (!parentVal) {
            return childVal;
          }

          var ret = {};
          extend(ret, parentVal);

          for (var key$1 in childVal) {
            var parent = ret[key$1];
            var child = childVal[key$1];

            if (parent && !Array.isArray(parent)) {
              parent = [parent];
            }

            ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
          }

          return ret;
        };
        /**
         * Other object hashes.
         */


        strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
          if (childVal && process.env.NODE_ENV !== 'production') {
            assertObjectType(key, childVal, vm);
          }

          if (!parentVal) {
            return childVal;
          }

          var ret = Object.create(null);
          extend(ret, parentVal);

          if (childVal) {
            extend(ret, childVal);
          }

          return ret;
        };

        strats.provide = mergeDataOrFn;
        /**
         * Default strategy.
         */

        var defaultStrat = function defaultStrat(parentVal, childVal) {
          return childVal === undefined ? parentVal : childVal;
        };
        /**
         * Validate component names
         */


        function checkComponents(options) {
          for (var key in options.components) {
            validateComponentName(key);
          }
        }

        function validateComponentName(name) {
          if (!/^[a-zA-Z][\w-]*$/.test(name)) {
            warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
          }

          if (isBuiltInTag(name) || config.isReservedTag(name)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
          }
        }
        /**
         * Ensure all props option syntax are normalized into the
         * Object-based format.
         */


        function normalizeProps(options, vm) {
          var props = options.props;

          if (!props) {
            return;
          }

          var res = {};
          var i, val, name;

          if (Array.isArray(props)) {
            i = props.length;

            while (i--) {
              val = props[i];

              if (typeof val === 'string') {
                name = camelize(val);
                res[name] = {
                  type: null
                };
              } else if (process.env.NODE_ENV !== 'production') {
                warn('props must be strings when using array syntax.');
              }
            }
          } else if (isPlainObject(props)) {
            for (var key in props) {
              val = props[key];
              name = camelize(key);
              res[name] = isPlainObject(val) ? val : {
                type: val
              };
            }
          } else if (process.env.NODE_ENV !== 'production') {
            warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
          }

          options.props = res;
        }
        /**
         * Normalize all injections into Object-based format
         */


        function normalizeInject(options, vm) {
          var inject = options.inject;

          if (!inject) {
            return;
          }

          var normalized = options.inject = {};

          if (Array.isArray(inject)) {
            for (var i = 0; i < inject.length; i++) {
              normalized[inject[i]] = {
                from: inject[i]
              };
            }
          } else if (isPlainObject(inject)) {
            for (var key in inject) {
              var val = inject[key];
              normalized[key] = isPlainObject(val) ? extend({
                from: key
              }, val) : {
                from: val
              };
            }
          } else if (process.env.NODE_ENV !== 'production') {
            warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
          }
        }
        /**
         * Normalize raw function directives into object format.
         */


        function normalizeDirectives(options) {
          var dirs = options.directives;

          if (dirs) {
            for (var key in dirs) {
              var def = dirs[key];

              if (typeof def === 'function') {
                dirs[key] = {
                  bind: def,
                  update: def
                };
              }
            }
          }
        }

        function assertObjectType(name, value, vm) {
          if (!isPlainObject(value)) {
            warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
          }
        }
        /**
         * Merge two option objects into a new one.
         * Core utility used in both instantiation and inheritance.
         */


        function mergeOptions(parent, child, vm) {
          if (process.env.NODE_ENV !== 'production') {
            checkComponents(child);
          }

          if (typeof child === 'function') {
            child = child.options;
          }

          normalizeProps(child, vm);
          normalizeInject(child, vm);
          normalizeDirectives(child);
          var extendsFrom = child.extends;

          if (extendsFrom) {
            parent = mergeOptions(parent, extendsFrom, vm);
          }

          if (child.mixins) {
            for (var i = 0, l = child.mixins.length; i < l; i++) {
              parent = mergeOptions(parent, child.mixins[i], vm);
            }
          }

          var options = {};
          var key;

          for (key in parent) {
            mergeField(key);
          }

          for (key in child) {
            if (!hasOwn(parent, key)) {
              mergeField(key);
            }
          }

          function mergeField(key) {
            var strat = strats[key] || defaultStrat;
            options[key] = strat(parent[key], child[key], vm, key);
          }

          return options;
        }
        /**
         * Resolve an asset.
         * This function is used because child instances need access
         * to assets defined in its ancestor chain.
         */


        function resolveAsset(options, type, id, warnMissing) {
          /* istanbul ignore if */
          if (typeof id !== 'string') {
            return;
          }

          var assets = options[type]; // check local registration variations first

          if (hasOwn(assets, id)) {
            return assets[id];
          }

          var camelizedId = camelize(id);

          if (hasOwn(assets, camelizedId)) {
            return assets[camelizedId];
          }

          var PascalCaseId = capitalize(camelizedId);

          if (hasOwn(assets, PascalCaseId)) {
            return assets[PascalCaseId];
          } // fallback to prototype chain


          var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

          if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
            warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
          }

          return res;
        }
        /*  */


        function validateProp(key, propOptions, propsData, vm) {
          var prop = propOptions[key];
          var absent = !hasOwn(propsData, key);
          var value = propsData[key]; // boolean casting

          var booleanIndex = getTypeIndex(Boolean, prop.type);

          if (booleanIndex > -1) {
            if (absent && !hasOwn(prop, 'default')) {
              value = false;
            } else if (value === '' || value === hyphenate(key)) {
              // only cast empty string / same name to boolean if
              // boolean has higher priority
              var stringIndex = getTypeIndex(String, prop.type);

              if (stringIndex < 0 || booleanIndex < stringIndex) {
                value = true;
              }
            }
          } // check default value


          if (value === undefined) {
            value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
            // make sure to observe it.

            var prevShouldObserve = shouldObserve;
            toggleObserving(true);
            observe(value);
            toggleObserving(prevShouldObserve);
          }

          if (process.env.NODE_ENV !== 'production' && // skip validation for weex recycle-list child component props
          !(false && isObject(value) && '@binding' in value)) {
            assertProp(prop, key, value, vm, absent);
          }

          return value;
        }
        /**
         * Get the default value of a prop.
         */


        function getPropDefaultValue(vm, prop, key) {
          // no default, return undefined
          if (!hasOwn(prop, 'default')) {
            return undefined;
          }

          var def = prop.default; // warn against non-factory defaults for Object & Array

          if (process.env.NODE_ENV !== 'production' && isObject(def)) {
            warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
          } // the raw prop value was also undefined from previous render,
          // return previous default value to avoid unnecessary watcher trigger


          if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
            return vm._props[key];
          } // call factory function for non-Function types
          // a value is Function if its prototype is function even across different execution context


          return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
        }
        /**
         * Assert whether a prop is valid.
         */


        function assertProp(prop, name, value, vm, absent) {
          if (prop.required && absent) {
            warn('Missing required prop: "' + name + '"', vm);
            return;
          }

          if (value == null && !prop.required) {
            return;
          }

          var type = prop.type;
          var valid = !type || type === true;
          var expectedTypes = [];

          if (type) {
            if (!Array.isArray(type)) {
              type = [type];
            }

            for (var i = 0; i < type.length && !valid; i++) {
              var assertedType = assertType(value, type[i]);
              expectedTypes.push(assertedType.expectedType || '');
              valid = assertedType.valid;
            }
          }

          if (!valid) {
            warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
            return;
          }

          var validator = prop.validator;

          if (validator) {
            if (!validator(value)) {
              warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
            }
          }
        }

        var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

        function assertType(value, type) {
          var valid;
          var expectedType = getType(type);

          if (simpleCheckRE.test(expectedType)) {
            var t = _typeof2(value);

            valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

            if (!valid && t === 'object') {
              valid = value instanceof type;
            }
          } else if (expectedType === 'Object') {
            valid = isPlainObject(value);
          } else if (expectedType === 'Array') {
            valid = Array.isArray(value);
          } else {
            valid = value instanceof type;
          }

          return {
            valid: valid,
            expectedType: expectedType
          };
        }
        /**
         * Use function string name to check built-in types,
         * because a simple equality check will fail when running
         * across different vms / iframes.
         */


        function getType(fn) {
          var match = fn && fn.toString().match(/^\s*function (\w+)/);
          return match ? match[1] : '';
        }

        function isSameType(a, b) {
          return getType(a) === getType(b);
        }

        function getTypeIndex(type, expectedTypes) {
          if (!Array.isArray(expectedTypes)) {
            return isSameType(expectedTypes, type) ? 0 : -1;
          }

          for (var i = 0, len = expectedTypes.length; i < len; i++) {
            if (isSameType(expectedTypes[i], type)) {
              return i;
            }
          }

          return -1;
        }
        /*  */


        function handleError(err, vm, info) {
          if (vm) {
            var cur = vm;

            while (cur = cur.$parent) {
              var hooks = cur.$options.errorCaptured;

              if (hooks) {
                for (var i = 0; i < hooks.length; i++) {
                  try {
                    var capture = hooks[i].call(cur, err, vm, info) === false;

                    if (capture) {
                      return;
                    }
                  } catch (e) {
                    globalHandleError(e, cur, 'errorCaptured hook');
                  }
                }
              }
            }
          }

          globalHandleError(err, vm, info);
        }

        function globalHandleError(err, vm, info) {
          if (config.errorHandler) {
            try {
              return config.errorHandler.call(null, err, vm, info);
            } catch (e) {
              logError(e, null, 'config.errorHandler');
            }
          }

          logError(err, vm, info);
        }

        function logError(err, vm, info) {
          if (process.env.NODE_ENV !== 'production') {
            warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
          }
          /* istanbul ignore else */


          if ((inBrowser || inWeex) && typeof console !== 'undefined') {
            console.error(err);
          } else {
            throw err;
          }
        }
        /*  */

        /* globals MessageChannel */


        var callbacks = [];
        var pending = false;

        function flushCallbacks() {
          pending = false;
          var copies = callbacks.slice(0);
          callbacks.length = 0;

          for (var i = 0; i < copies.length; i++) {
            copies[i]();
          }
        } // Here we have async deferring wrappers using both microtasks and (macro) tasks.
        // In < 2.4 we used microtasks everywhere, but there are some scenarios where
        // microtasks have too high a priority and fire in between supposedly
        // sequential events (e.g. #4521, #6690) or even between bubbling of the same
        // event (#6566). However, using (macro) tasks everywhere also has subtle problems
        // when state is changed right before repaint (e.g. #6813, out-in transitions).
        // Here we use microtask by default, but expose a way to force (macro) task when
        // needed (e.g. in event handlers attached by v-on).


        var microTimerFunc;
        var macroTimerFunc;
        var useMacroTask = false; // Determine (macro) task defer implementation.
        // Technically setImmediate should be the ideal choice, but it's only available
        // in IE. The only polyfill that consistently queues the callback after all DOM
        // events triggered in the same loop is by using MessageChannel.

        /* istanbul ignore if */

        if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
          macroTimerFunc = function macroTimerFunc() {
            setImmediate(flushCallbacks);
          };
        } else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) || // PhantomJS
        MessageChannel.toString() === '[object MessageChannelConstructor]')) {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = flushCallbacks;

          macroTimerFunc = function macroTimerFunc() {
            port.postMessage(1);
          };
        } else {
          /* istanbul ignore next */
          macroTimerFunc = function macroTimerFunc() {
            setTimeout(flushCallbacks, 0);
          };
        } // Determine microtask defer implementation.

        /* istanbul ignore next, $flow-disable-line */


        if (typeof Promise !== 'undefined' && isNative(Promise)) {
          var p = Promise.resolve();

          microTimerFunc = function microTimerFunc() {
            p.then(flushCallbacks); // in problematic UIWebViews, Promise.then doesn't completely break, but
            // it can get stuck in a weird state where callbacks are pushed into the
            // microtask queue but the queue isn't being flushed, until the browser
            // needs to do some other work, e.g. handle a timer. Therefore we can
            // "force" the microtask queue to be flushed by adding an empty timer.

            if (isIOS) {
              setTimeout(noop);
            }
          };
        } else {
          // fallback to macro
          microTimerFunc = macroTimerFunc;
        }
        /**
         * Wrap a function so that if any code inside triggers state change,
         * the changes are queued using a (macro) task instead of a microtask.
         */


        function withMacroTask(fn) {
          return fn._withTask || (fn._withTask = function () {
            useMacroTask = true;
            var res = fn.apply(null, arguments);
            useMacroTask = false;
            return res;
          });
        }

        function nextTick(cb, ctx) {
          var _resolve;

          callbacks.push(function () {
            if (cb) {
              try {
                cb.call(ctx);
              } catch (e) {
                handleError(e, ctx, 'nextTick');
              }
            } else if (_resolve) {
              _resolve(ctx);
            }
          });

          if (!pending) {
            pending = true;

            if (useMacroTask) {
              macroTimerFunc();
            } else {
              microTimerFunc();
            }
          } // $flow-disable-line


          if (!cb && typeof Promise !== 'undefined') {
            return new Promise(function (resolve) {
              _resolve = resolve;
            });
          }
        }
        /*  */

        /* not type checking this file because flow doesn't play well with Proxy */


        var initProxy;

        if (process.env.NODE_ENV !== 'production') {
          var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
          );

          var warnNonPresent = function warnNonPresent(target, key) {
            warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
          };

          var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

          if (hasProxy) {
            var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
            config.keyCodes = new Proxy(config.keyCodes, {
              set: function set(target, key, value) {
                if (isBuiltInModifier(key)) {
                  warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
                  return false;
                } else {
                  target[key] = value;
                  return true;
                }
              }
            });
          }

          var hasHandler = {
            has: function has(target, key) {
              var has = key in target;
              var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';

              if (!has && !isAllowed) {
                warnNonPresent(target, key);
              }

              return has || !isAllowed;
            }
          };
          var getHandler = {
            get: function get(target, key) {
              if (typeof key === 'string' && !(key in target)) {
                warnNonPresent(target, key);
              }

              return target[key];
            }
          };

          initProxy = function initProxy(vm) {
            if (hasProxy) {
              // determine which proxy handler to use
              var options = vm.$options;
              var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
              vm._renderProxy = new Proxy(vm, handlers);
            } else {
              vm._renderProxy = vm;
            }
          };
        }
        /*  */


        var seenObjects = new _Set();
        /**
         * Recursively traverse an object to evoke all converted
         * getters, so that every nested property inside the object
         * is collected as a "deep" dependency.
         */

        function traverse(val) {
          _traverse(val, seenObjects);

          seenObjects.clear();
        }

        function _traverse(val, seen) {
          var i, keys;
          var isA = Array.isArray(val);

          if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
            return;
          }

          if (val.__ob__) {
            var depId = val.__ob__.dep.id;

            if (seen.has(depId)) {
              return;
            }

            seen.add(depId);
          }

          if (isA) {
            i = val.length;

            while (i--) {
              _traverse(val[i], seen);
            }
          } else {
            keys = Object.keys(val);
            i = keys.length;

            while (i--) {
              _traverse(val[keys[i]], seen);
            }
          }
        }

        var mark;
        var measure;

        if (process.env.NODE_ENV !== 'production') {
          var perf = inBrowser && window.performance;
          /* istanbul ignore if */

          if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
            mark = function mark(tag) {
              return perf.mark(tag);
            };

            measure = function measure(name, startTag, endTag) {
              perf.measure(name, startTag, endTag);
              perf.clearMarks(startTag);
              perf.clearMarks(endTag);
              perf.clearMeasures(name);
            };
          }
        }
        /*  */


        var normalizeEvent = cached(function (name) {
          var passive = name.charAt(0) === '&';
          name = passive ? name.slice(1) : name;
          var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

          name = once$$1 ? name.slice(1) : name;
          var capture = name.charAt(0) === '!';
          name = capture ? name.slice(1) : name;
          return {
            name: name,
            once: once$$1,
            capture: capture,
            passive: passive
          };
        });

        function createFnInvoker(fns) {
          function invoker() {
            var arguments$1 = arguments;
            var fns = invoker.fns;

            if (Array.isArray(fns)) {
              var cloned = fns.slice();

              for (var i = 0; i < cloned.length; i++) {
                cloned[i].apply(null, arguments$1);
              }
            } else {
              // return handler return value for single handlers
              return fns.apply(null, arguments);
            }
          }

          invoker.fns = fns;
          return invoker;
        }

        function updateListeners(on, oldOn, add, remove$$1, vm) {
          var name, def, cur, old, event;

          for (name in on) {
            def = cur = on[name];
            old = oldOn[name];
            event = normalizeEvent(name);
            /* istanbul ignore if */

            if (isUndef(cur)) {
              process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
            } else if (isUndef(old)) {
              if (isUndef(cur.fns)) {
                cur = on[name] = createFnInvoker(cur);
              }

              add(event.name, cur, event.once, event.capture, event.passive, event.params);
            } else if (cur !== old) {
              old.fns = cur;
              on[name] = old;
            }
          }

          for (name in oldOn) {
            if (isUndef(on[name])) {
              event = normalizeEvent(name);
              remove$$1(event.name, oldOn[name], event.capture);
            }
          }
        }
        /*  */


        function mergeVNodeHook(def, hookKey, hook) {
          if (def instanceof VNode) {
            def = def.data.hook || (def.data.hook = {});
          }

          var invoker;
          var oldHook = def[hookKey];

          function wrappedHook() {
            hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
            // and prevent memory leak

            remove(invoker.fns, wrappedHook);
          }

          if (isUndef(oldHook)) {
            // no existing hook
            invoker = createFnInvoker([wrappedHook]);
          } else {
            /* istanbul ignore if */
            if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
              // already a merged invoker
              invoker = oldHook;
              invoker.fns.push(wrappedHook);
            } else {
              // existing plain hook
              invoker = createFnInvoker([oldHook, wrappedHook]);
            }
          }

          invoker.merged = true;
          def[hookKey] = invoker;
        }
        /*  */


        function extractPropsFromVNodeData(data, Ctor, tag) {
          // we are only extracting raw values here.
          // validation and default values are handled in the child
          // component itself.
          var propOptions = Ctor.options.props;

          if (isUndef(propOptions)) {
            return;
          }

          var res = {};
          var attrs = data.attrs;
          var props = data.props;

          if (isDef(attrs) || isDef(props)) {
            for (var key in propOptions) {
              var altKey = hyphenate(key);

              if (process.env.NODE_ENV !== 'production') {
                var keyInLowerCase = key.toLowerCase();

                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
                  tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
                }
              }

              checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
            }
          }

          return res;
        }

        function checkProp(res, hash, key, altKey, preserve) {
          if (isDef(hash)) {
            if (hasOwn(hash, key)) {
              res[key] = hash[key];

              if (!preserve) {
                delete hash[key];
              }

              return true;
            } else if (hasOwn(hash, altKey)) {
              res[key] = hash[altKey];

              if (!preserve) {
                delete hash[altKey];
              }

              return true;
            }
          }

          return false;
        }
        /*  */
        // The template compiler attempts to minimize the need for normalization by
        // statically analyzing the template at compile time.
        //
        // For plain HTML markup, normalization can be completely skipped because the
        // generated render function is guaranteed to return Array<VNode>. There are
        // two cases where extra normalization is needed:
        // 1. When the children contains components - because a functional component
        // may return an Array instead of a single root. In this case, just a simple
        // normalization is needed - if any child is an Array, we flatten the whole
        // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
        // because functional components already normalize their own children.


        function simpleNormalizeChildren(children) {
          for (var i = 0; i < children.length; i++) {
            if (Array.isArray(children[i])) {
              return Array.prototype.concat.apply([], children);
            }
          }

          return children;
        } // 2. When the children contains constructs that always generated nested Arrays,
        // e.g. <template>, <slot>, v-for, or when the children is provided by user
        // with hand-written render functions / JSX. In such cases a full normalization
        // is needed to cater to all possible types of children values.


        function normalizeChildren(children) {
          return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
        }

        function isTextNode(node) {
          return isDef(node) && isDef(node.text) && isFalse(node.isComment);
        }

        function normalizeArrayChildren(children, nestedIndex) {
          var res = [];
          var i, c, lastIndex, last;

          for (i = 0; i < children.length; i++) {
            c = children[i];

            if (isUndef(c) || typeof c === 'boolean') {
              continue;
            }

            lastIndex = res.length - 1;
            last = res[lastIndex]; //  nested

            if (Array.isArray(c)) {
              if (c.length > 0) {
                c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

                if (isTextNode(c[0]) && isTextNode(last)) {
                  res[lastIndex] = createTextVNode(last.text + c[0].text);
                  c.shift();
                }

                res.push.apply(res, c);
              }
            } else if (isPrimitive(c)) {
              if (isTextNode(last)) {
                // merge adjacent text nodes
                // this is necessary for SSR hydration because text nodes are
                // essentially merged when rendered to HTML strings
                res[lastIndex] = createTextVNode(last.text + c);
              } else if (c !== '') {
                // convert primitive to vnode
                res.push(createTextVNode(c));
              }
            } else {
              if (isTextNode(c) && isTextNode(last)) {
                // merge adjacent text nodes
                res[lastIndex] = createTextVNode(last.text + c.text);
              } else {
                // default key for nested array children (likely generated by v-for)
                if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
                  c.key = "__vlist" + nestedIndex + "_" + i + "__";
                }

                res.push(c);
              }
            }
          }

          return res;
        }
        /*  */


        function ensureCtor(comp, base) {
          if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
            comp = comp.default;
          }

          return isObject(comp) ? base.extend(comp) : comp;
        }

        function createAsyncPlaceholder(factory, data, context, children, tag) {
          var node = createEmptyVNode();
          node.asyncFactory = factory;
          node.asyncMeta = {
            data: data,
            context: context,
            children: children,
            tag: tag
          };
          return node;
        }

        function resolveAsyncComponent(factory, baseCtor, context) {
          if (isTrue(factory.error) && isDef(factory.errorComp)) {
            return factory.errorComp;
          }

          if (isDef(factory.resolved)) {
            return factory.resolved;
          }

          if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
            return factory.loadingComp;
          }

          if (isDef(factory.contexts)) {
            // already pending
            factory.contexts.push(context);
          } else {
            var contexts = factory.contexts = [context];
            var sync = true;

            var forceRender = function forceRender() {
              for (var i = 0, l = contexts.length; i < l; i++) {
                contexts[i].$forceUpdate();
              }
            };

            var resolve = once(function (res) {
              // cache resolved
              factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
              // (async resolves are shimmed as synchronous during SSR)

              if (!sync) {
                forceRender();
              }
            });
            var reject = once(function (reason) {
              process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

              if (isDef(factory.errorComp)) {
                factory.error = true;
                forceRender();
              }
            });
            var res = factory(resolve, reject);

            if (isObject(res)) {
              if (typeof res.then === 'function') {
                // () => Promise
                if (isUndef(factory.resolved)) {
                  res.then(resolve, reject);
                }
              } else if (isDef(res.component) && typeof res.component.then === 'function') {
                res.component.then(resolve, reject);

                if (isDef(res.error)) {
                  factory.errorComp = ensureCtor(res.error, baseCtor);
                }

                if (isDef(res.loading)) {
                  factory.loadingComp = ensureCtor(res.loading, baseCtor);

                  if (res.delay === 0) {
                    factory.loading = true;
                  } else {
                    setTimeout(function () {
                      if (isUndef(factory.resolved) && isUndef(factory.error)) {
                        factory.loading = true;
                        forceRender();
                      }
                    }, res.delay || 200);
                  }
                }

                if (isDef(res.timeout)) {
                  setTimeout(function () {
                    if (isUndef(factory.resolved)) {
                      reject(process.env.NODE_ENV !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
                    }
                  }, res.timeout);
                }
              }
            }

            sync = false; // return in case resolved synchronously

            return factory.loading ? factory.loadingComp : factory.resolved;
          }
        }
        /*  */


        function isAsyncPlaceholder(node) {
          return node.isComment && node.asyncFactory;
        }
        /*  */


        function getFirstComponentChild(children) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              var c = children[i];

              if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                return c;
              }
            }
          }
        }
        /*  */

        /*  */


        function initEvents(vm) {
          vm._events = Object.create(null);
          vm._hasHookEvent = false; // init parent attached events

          var listeners = vm.$options._parentListeners;

          if (listeners) {
            updateComponentListeners(vm, listeners);
          }
        }

        var target;

        function add(event, fn, once) {
          if (once) {
            target.$once(event, fn);
          } else {
            target.$on(event, fn);
          }
        }

        function remove$1(event, fn) {
          target.$off(event, fn);
        }

        function updateComponentListeners(vm, listeners, oldListeners) {
          target = vm;
          updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
          target = undefined;
        }

        function eventsMixin(Vue) {
          var hookRE = /^hook:/;

          Vue.prototype.$on = function (event, fn) {
            var this$1 = this;
            var vm = this;

            if (Array.isArray(event)) {
              for (var i = 0, l = event.length; i < l; i++) {
                this$1.$on(event[i], fn);
              }
            } else {
              (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
              // instead of a hash lookup

              if (hookRE.test(event)) {
                vm._hasHookEvent = true;
              }
            }

            return vm;
          };

          Vue.prototype.$once = function (event, fn) {
            var vm = this;

            function on() {
              vm.$off(event, on);
              fn.apply(vm, arguments);
            }

            on.fn = fn;
            vm.$on(event, on);
            return vm;
          };

          Vue.prototype.$off = function (event, fn) {
            var this$1 = this;
            var vm = this; // all

            if (!arguments.length) {
              vm._events = Object.create(null);
              return vm;
            } // array of events


            if (Array.isArray(event)) {
              for (var i = 0, l = event.length; i < l; i++) {
                this$1.$off(event[i], fn);
              }

              return vm;
            } // specific event


            var cbs = vm._events[event];

            if (!cbs) {
              return vm;
            }

            if (!fn) {
              vm._events[event] = null;
              return vm;
            }

            if (fn) {
              // specific handler
              var cb;
              var i$1 = cbs.length;

              while (i$1--) {
                cb = cbs[i$1];

                if (cb === fn || cb.fn === fn) {
                  cbs.splice(i$1, 1);
                  break;
                }
              }
            }

            return vm;
          };

          Vue.prototype.$emit = function (event) {
            var vm = this;

            if (process.env.NODE_ENV !== 'production') {
              var lowerCaseEvent = event.toLowerCase();

              if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
              }
            }

            var cbs = vm._events[event];

            if (cbs) {
              cbs = cbs.length > 1 ? toArray(cbs) : cbs;
              var args = toArray(arguments, 1);

              for (var i = 0, l = cbs.length; i < l; i++) {
                try {
                  cbs[i].apply(vm, args);
                } catch (e) {
                  handleError(e, vm, "event handler for \"" + event + "\"");
                }
              }
            }

            return vm;
          };
        }
        /*  */

        /**
         * Runtime helper for resolving raw children VNodes into a slot object.
         */


        function resolveSlots(children, context) {
          var slots = {};

          if (!children) {
            return slots;
          }

          for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];
            var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

            if (data && data.attrs && data.attrs.slot) {
              delete data.attrs.slot;
            } // named slots should only be respected if the vnode was rendered in the
            // same context.


            if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
              var name = data.slot;
              var slot = slots[name] || (slots[name] = []);

              if (child.tag === 'template') {
                slot.push.apply(slot, child.children || []);
              } else {
                slot.push(child);
              }
            } else {
              (slots.default || (slots.default = [])).push(child);
            }
          } // ignore slots that contains only whitespace


          for (var name$1 in slots) {
            if (slots[name$1].every(isWhitespace)) {
              delete slots[name$1];
            }
          }

          return slots;
        }

        function isWhitespace(node) {
          return node.isComment && !node.asyncFactory || node.text === ' ';
        }

        function resolveScopedSlots(fns, // see flow/vnode
        res) {
          res = res || {};

          for (var i = 0; i < fns.length; i++) {
            if (Array.isArray(fns[i])) {
              resolveScopedSlots(fns[i], res);
            } else {
              res[fns[i].key] = fns[i].fn;
            }
          }

          return res;
        }
        /*  */


        var activeInstance = null;
        var isUpdatingChildComponent = false;

        function initLifecycle(vm) {
          var options = vm.$options; // locate first non-abstract parent

          var parent = options.parent;

          if (parent && !options.abstract) {
            while (parent.$options.abstract && parent.$parent) {
              parent = parent.$parent;
            }

            parent.$children.push(vm);
          }

          vm.$parent = parent;
          vm.$root = parent ? parent.$root : vm;
          vm.$children = [];
          vm.$refs = {};
          vm._watcher = null;
          vm._inactive = null;
          vm._directInactive = false;
          vm._isMounted = false;
          vm._isDestroyed = false;
          vm._isBeingDestroyed = false;
        }

        function lifecycleMixin(Vue) {
          Vue.prototype._update = function (vnode, hydrating) {
            var vm = this;

            if (vm._isMounted) {
              callHook(vm, 'beforeUpdate');
            }

            var prevEl = vm.$el;
            var prevVnode = vm._vnode;
            var prevActiveInstance = activeInstance;
            activeInstance = vm;
            vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
            // based on the rendering backend used.

            if (!prevVnode) {
              // initial render
              vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
              /* removeOnly */
              , vm.$options._parentElm, vm.$options._refElm); // no need for the ref nodes after initial patch
              // this prevents keeping a detached DOM tree in memory (#5851)

              vm.$options._parentElm = vm.$options._refElm = null;
            } else {
              // updates
              vm.$el = vm.__patch__(prevVnode, vnode);
            }

            activeInstance = prevActiveInstance; // update __vue__ reference

            if (prevEl) {
              prevEl.__vue__ = null;
            }

            if (vm.$el) {
              vm.$el.__vue__ = vm;
            } // if parent is an HOC, update its $el as well


            if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
              vm.$parent.$el = vm.$el;
            } // updated hook is called by the scheduler to ensure that children are
            // updated in a parent's updated hook.

          };

          Vue.prototype.$forceUpdate = function () {
            var vm = this;

            if (vm._watcher) {
              vm._watcher.update();
            }
          };

          Vue.prototype.$destroy = function () {
            var vm = this;

            if (vm._isBeingDestroyed) {
              return;
            }

            callHook(vm, 'beforeDestroy');
            vm._isBeingDestroyed = true; // remove self from parent

            var parent = vm.$parent;

            if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
              remove(parent.$children, vm);
            } // teardown watchers


            if (vm._watcher) {
              vm._watcher.teardown();
            }

            var i = vm._watchers.length;

            while (i--) {
              vm._watchers[i].teardown();
            } // remove reference from data ob
            // frozen object may not have observer.


            if (vm._data.__ob__) {
              vm._data.__ob__.vmCount--;
            } // call the last hook...


            vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

            vm.__patch__(vm._vnode, null); // fire destroyed hook


            callHook(vm, 'destroyed'); // turn off all instance listeners.

            vm.$off(); // remove __vue__ reference

            if (vm.$el) {
              vm.$el.__vue__ = null;
            } // release circular reference (#6759)


            if (vm.$vnode) {
              vm.$vnode.parent = null;
            }
          };
        }

        function mountComponent(vm, el, hydrating) {
          vm.$el = el;

          if (!vm.$options.render) {
            vm.$options.render = createEmptyVNode;

            if (process.env.NODE_ENV !== 'production') {
              /* istanbul ignore if */
              if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
                warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
              } else {
                warn('Failed to mount component: template or render function not defined.', vm);
              }
            }
          }

          callHook(vm, 'beforeMount');
          var updateComponent;
          /* istanbul ignore if */

          if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
            updateComponent = function updateComponent() {
              var name = vm._name;
              var id = vm._uid;
              var startTag = "vue-perf-start:" + id;
              var endTag = "vue-perf-end:" + id;
              mark(startTag);

              var vnode = vm._render();

              mark(endTag);
              measure("vue " + name + " render", startTag, endTag);
              mark(startTag);

              vm._update(vnode, hydrating);

              mark(endTag);
              measure("vue " + name + " patch", startTag, endTag);
            };
          } else {
            updateComponent = function updateComponent() {
              vm._update(vm._render(), hydrating);
            };
          } // we set this to vm._watcher inside the watcher's constructor
          // since the watcher's initial patch may call $forceUpdate (e.g. inside child
          // component's mounted hook), which relies on vm._watcher being already defined


          new Watcher(vm, updateComponent, noop, null, true
          /* isRenderWatcher */
          );
          hydrating = false; // manually mounted instance, call mounted on self
          // mounted is called for render-created child components in its inserted hook

          if (vm.$vnode == null) {
            vm._isMounted = true;
            callHook(vm, 'mounted');
          }

          return vm;
        }

        function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
          if (process.env.NODE_ENV !== 'production') {
            isUpdatingChildComponent = true;
          } // determine whether component has slot children
          // we need to do this before overwriting $options._renderChildren


          var hasChildren = !!(renderChildren || // has new static slots
          vm.$options._renderChildren || // has old static slots
          parentVnode.data.scopedSlots || // has new scoped slots
          vm.$scopedSlots !== emptyObject // has old scoped slots
          );
          vm.$options._parentVnode = parentVnode;
          vm.$vnode = parentVnode; // update vm's placeholder node without re-render

          if (vm._vnode) {
            // update child tree's parent
            vm._vnode.parent = parentVnode;
          }

          vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
          // these are also reactive so they may trigger child update if the child
          // used them during render

          vm.$attrs = parentVnode.data.attrs || emptyObject;
          vm.$listeners = listeners || emptyObject; // update props

          if (propsData && vm.$options.props) {
            toggleObserving(false);
            var props = vm._props;
            var propKeys = vm.$options._propKeys || [];

            for (var i = 0; i < propKeys.length; i++) {
              var key = propKeys[i];
              var propOptions = vm.$options.props; // wtf flow?

              props[key] = validateProp(key, propOptions, propsData, vm);
            }

            toggleObserving(true); // keep a copy of raw propsData

            vm.$options.propsData = propsData;
          } // update listeners


          listeners = listeners || emptyObject;
          var oldListeners = vm.$options._parentListeners;
          vm.$options._parentListeners = listeners;
          updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

          if (hasChildren) {
            vm.$slots = resolveSlots(renderChildren, parentVnode.context);
            vm.$forceUpdate();
          }

          if (process.env.NODE_ENV !== 'production') {
            isUpdatingChildComponent = false;
          }
        }

        function isInInactiveTree(vm) {
          while (vm && (vm = vm.$parent)) {
            if (vm._inactive) {
              return true;
            }
          }

          return false;
        }

        function activateChildComponent(vm, direct) {
          if (direct) {
            vm._directInactive = false;

            if (isInInactiveTree(vm)) {
              return;
            }
          } else if (vm._directInactive) {
            return;
          }

          if (vm._inactive || vm._inactive === null) {
            vm._inactive = false;

            for (var i = 0; i < vm.$children.length; i++) {
              activateChildComponent(vm.$children[i]);
            }

            callHook(vm, 'activated');
          }
        }

        function deactivateChildComponent(vm, direct) {
          if (direct) {
            vm._directInactive = true;

            if (isInInactiveTree(vm)) {
              return;
            }
          }

          if (!vm._inactive) {
            vm._inactive = true;

            for (var i = 0; i < vm.$children.length; i++) {
              deactivateChildComponent(vm.$children[i]);
            }

            callHook(vm, 'deactivated');
          }
        }

        function callHook(vm, hook) {
          // #7573 disable dep collection when invoking lifecycle hooks
          pushTarget();
          var handlers = vm.$options[hook];

          if (handlers) {
            for (var i = 0, j = handlers.length; i < j; i++) {
              try {
                handlers[i].call(vm);
              } catch (e) {
                handleError(e, vm, hook + " hook");
              }
            }
          }

          if (vm._hasHookEvent) {
            vm.$emit('hook:' + hook);
          }

          popTarget();
        }
        /*  */


        var MAX_UPDATE_COUNT = 100;
        var queue = [];
        var activatedChildren = [];
        var has = {};
        var circular = {};
        var waiting = false;
        var flushing = false;
        var index = 0;
        /**
         * Reset the scheduler's state.
         */

        function resetSchedulerState() {
          index = queue.length = activatedChildren.length = 0;
          has = {};

          if (process.env.NODE_ENV !== 'production') {
            circular = {};
          }

          waiting = flushing = false;
        }
        /**
         * Flush both queues and run the watchers.
         */


        function flushSchedulerQueue() {
          flushing = true;
          var watcher, id; // Sort queue before flush.
          // This ensures that:
          // 1. Components are updated from parent to child. (because parent is always
          //    created before the child)
          // 2. A component's user watchers are run before its render watcher (because
          //    user watchers are created before the render watcher)
          // 3. If a component is destroyed during a parent component's watcher run,
          //    its watchers can be skipped.

          queue.sort(function (a, b) {
            return a.id - b.id;
          }); // do not cache length because more watchers might be pushed
          // as we run existing watchers

          for (index = 0; index < queue.length; index++) {
            watcher = queue[index];
            id = watcher.id;
            has[id] = null;
            watcher.run(); // in dev build, check and stop circular updates.

            if (process.env.NODE_ENV !== 'production' && has[id] != null) {
              circular[id] = (circular[id] || 0) + 1;

              if (circular[id] > MAX_UPDATE_COUNT) {
                warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
                break;
              }
            }
          } // keep copies of post queues before resetting state


          var activatedQueue = activatedChildren.slice();
          var updatedQueue = queue.slice();
          resetSchedulerState(); // call component updated and activated hooks

          callActivatedHooks(activatedQueue);
          callUpdatedHooks(updatedQueue); // devtool hook

          /* istanbul ignore if */

          if (devtools && config.devtools) {
            devtools.emit('flush');
          }
        }

        function callUpdatedHooks(queue) {
          var i = queue.length;

          while (i--) {
            var watcher = queue[i];
            var vm = watcher.vm;

            if (vm._watcher === watcher && vm._isMounted) {
              callHook(vm, 'updated');
            }
          }
        }
        /**
         * Queue a kept-alive component that was activated during patch.
         * The queue will be processed after the entire tree has been patched.
         */


        function queueActivatedComponent(vm) {
          // setting _inactive to false here so that a render function can
          // rely on checking whether it's in an inactive tree (e.g. router-view)
          vm._inactive = false;
          activatedChildren.push(vm);
        }

        function callActivatedHooks(queue) {
          for (var i = 0; i < queue.length; i++) {
            queue[i]._inactive = true;
            activateChildComponent(queue[i], true
            /* true */
            );
          }
        }
        /**
         * Push a watcher into the watcher queue.
         * Jobs with duplicate IDs will be skipped unless it's
         * pushed when the queue is being flushed.
         */


        function queueWatcher(watcher) {
          var id = watcher.id;

          if (has[id] == null) {
            has[id] = true;

            if (!flushing) {
              queue.push(watcher);
            } else {
              // if already flushing, splice the watcher based on its id
              // if already past its id, it will be run next immediately.
              var i = queue.length - 1;

              while (i > index && queue[i].id > watcher.id) {
                i--;
              }

              queue.splice(i + 1, 0, watcher);
            } // queue the flush


            if (!waiting) {
              waiting = true;
              nextTick(flushSchedulerQueue);
            }
          }
        }
        /*  */


        var uid$1 = 0;
        /**
         * A watcher parses an expression, collects dependencies,
         * and fires callback when the expression value changes.
         * This is used for both the $watch() api and directives.
         */

        var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
          this.vm = vm;

          if (isRenderWatcher) {
            vm._watcher = this;
          }

          vm._watchers.push(this); // options


          if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.lazy = !!options.lazy;
            this.sync = !!options.sync;
          } else {
            this.deep = this.user = this.lazy = this.sync = false;
          }

          this.cb = cb;
          this.id = ++uid$1; // uid for batching

          this.active = true;
          this.dirty = this.lazy; // for lazy watchers

          this.deps = [];
          this.newDeps = [];
          this.depIds = new _Set();
          this.newDepIds = new _Set();
          this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : ''; // parse expression for getter

          if (typeof expOrFn === 'function') {
            this.getter = expOrFn;
          } else {
            this.getter = parsePath(expOrFn);

            if (!this.getter) {
              this.getter = function () {};

              process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
            }
          }

          this.value = this.lazy ? undefined : this.get();
        };
        /**
         * Evaluate the getter, and re-collect dependencies.
         */


        Watcher.prototype.get = function get() {
          pushTarget(this);
          var value;
          var vm = this.vm;

          try {
            value = this.getter.call(vm, vm);
          } catch (e) {
            if (this.user) {
              handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
            } else {
              throw e;
            }
          } finally {
            // "touch" every property so they are all tracked as
            // dependencies for deep watching
            if (this.deep) {
              traverse(value);
            }

            popTarget();
            this.cleanupDeps();
          }

          return value;
        };
        /**
         * Add a dependency to this directive.
         */


        Watcher.prototype.addDep = function addDep(dep) {
          var id = dep.id;

          if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);

            if (!this.depIds.has(id)) {
              dep.addSub(this);
            }
          }
        };
        /**
         * Clean up for dependency collection.
         */


        Watcher.prototype.cleanupDeps = function cleanupDeps() {
          var this$1 = this;
          var i = this.deps.length;

          while (i--) {
            var dep = this$1.deps[i];

            if (!this$1.newDepIds.has(dep.id)) {
              dep.removeSub(this$1);
            }
          }

          var tmp = this.depIds;
          this.depIds = this.newDepIds;
          this.newDepIds = tmp;
          this.newDepIds.clear();
          tmp = this.deps;
          this.deps = this.newDeps;
          this.newDeps = tmp;
          this.newDeps.length = 0;
        };
        /**
         * Subscriber interface.
         * Will be called when a dependency changes.
         */


        Watcher.prototype.update = function update() {
          /* istanbul ignore else */
          if (this.lazy) {
            this.dirty = true;
          } else if (this.sync) {
            this.run();
          } else {
            queueWatcher(this);
          }
        };
        /**
         * Scheduler job interface.
         * Will be called by the scheduler.
         */


        Watcher.prototype.run = function run() {
          if (this.active) {
            var value = this.get();

            if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
            // when the value is the same, because the value may
            // have mutated.
            isObject(value) || this.deep) {
              // set new value
              var oldValue = this.value;
              this.value = value;

              if (this.user) {
                try {
                  this.cb.call(this.vm, value, oldValue);
                } catch (e) {
                  handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
                }
              } else {
                this.cb.call(this.vm, value, oldValue);
              }
            }
          }
        };
        /**
         * Evaluate the value of the watcher.
         * This only gets called for lazy watchers.
         */


        Watcher.prototype.evaluate = function evaluate() {
          this.value = this.get();
          this.dirty = false;
        };
        /**
         * Depend on all deps collected by this watcher.
         */


        Watcher.prototype.depend = function depend() {
          var this$1 = this;
          var i = this.deps.length;

          while (i--) {
            this$1.deps[i].depend();
          }
        };
        /**
         * Remove self from all dependencies' subscriber list.
         */


        Watcher.prototype.teardown = function teardown() {
          var this$1 = this;

          if (this.active) {
            // remove self from vm's watcher list
            // this is a somewhat expensive operation so we skip it
            // if the vm is being destroyed.
            if (!this.vm._isBeingDestroyed) {
              remove(this.vm._watchers, this);
            }

            var i = this.deps.length;

            while (i--) {
              this$1.deps[i].removeSub(this$1);
            }

            this.active = false;
          }
        };
        /*  */


        var sharedPropertyDefinition = {
          enumerable: true,
          configurable: true,
          get: noop,
          set: noop
        };

        function proxy(target, sourceKey, key) {
          sharedPropertyDefinition.get = function proxyGetter() {
            return this[sourceKey][key];
          };

          sharedPropertyDefinition.set = function proxySetter(val) {
            this[sourceKey][key] = val;
          };

          Object.defineProperty(target, key, sharedPropertyDefinition);
        }

        function initState(vm) {
          vm._watchers = [];
          var opts = vm.$options;

          if (opts.props) {
            initProps(vm, opts.props);
          }

          if (opts.methods) {
            initMethods(vm, opts.methods);
          }

          if (opts.data) {
            initData(vm);
          } else {
            observe(vm._data = {}, true
            /* asRootData */
            );
          }

          if (opts.computed) {
            initComputed(vm, opts.computed);
          }

          if (opts.watch && opts.watch !== nativeWatch) {
            initWatch(vm, opts.watch);
          }
        }

        function initProps(vm, propsOptions) {
          var propsData = vm.$options.propsData || {};
          var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
          // instead of dynamic object key enumeration.

          var keys = vm.$options._propKeys = [];
          var isRoot = !vm.$parent; // root instance props should be converted

          if (!isRoot) {
            toggleObserving(false);
          }

          var loop = function loop(key) {
            keys.push(key);
            var value = validateProp(key, propsOptions, propsData, vm);
            /* istanbul ignore else */

            if (process.env.NODE_ENV !== 'production') {
              var hyphenatedKey = hyphenate(key);

              if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
                warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
              }

              defineReactive(props, key, value, function () {
                if (vm.$parent && !isUpdatingChildComponent) {
                  warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
                }
              });
            } else {
              defineReactive(props, key, value);
            } // static props are already proxied on the component's prototype
            // during Vue.extend(). We only need to proxy props defined at
            // instantiation here.


            if (!(key in vm)) {
              proxy(vm, "_props", key);
            }
          };

          for (var key in propsOptions) {
            loop(key);
          }

          toggleObserving(true);
        }

        function initData(vm) {
          var data = vm.$options.data;
          data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

          if (!isPlainObject(data)) {
            data = {};
            process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
          } // proxy data on instance


          var keys = Object.keys(data);
          var props = vm.$options.props;
          var methods = vm.$options.methods;
          var i = keys.length;

          while (i--) {
            var key = keys[i];

            if (process.env.NODE_ENV !== 'production') {
              if (methods && hasOwn(methods, key)) {
                warn("Method \"" + key + "\" has already been defined as a data property.", vm);
              }
            }

            if (props && hasOwn(props, key)) {
              process.env.NODE_ENV !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
            } else if (!isReserved(key)) {
              proxy(vm, "_data", key);
            }
          } // observe data


          observe(data, true
          /* asRootData */
          );
        }

        function getData(data, vm) {
          // #7573 disable dep collection when invoking data getters
          pushTarget();

          try {
            return data.call(vm, vm);
          } catch (e) {
            handleError(e, vm, "data()");
            return {};
          } finally {
            popTarget();
          }
        }

        var computedWatcherOptions = {
          lazy: true
        };

        function initComputed(vm, computed) {
          // $flow-disable-line
          var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

          var isSSR = isServerRendering();

          for (var key in computed) {
            var userDef = computed[key];
            var getter = typeof userDef === 'function' ? userDef : userDef.get;

            if (process.env.NODE_ENV !== 'production' && getter == null) {
              warn("Getter is missing for computed property \"" + key + "\".", vm);
            }

            if (!isSSR) {
              // create internal watcher for the computed property.
              watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
            } // component-defined computed properties are already defined on the
            // component prototype. We only need to define computed properties defined
            // at instantiation here.


            if (!(key in vm)) {
              defineComputed(vm, key, userDef);
            } else if (process.env.NODE_ENV !== 'production') {
              if (key in vm.$data) {
                warn("The computed property \"" + key + "\" is already defined in data.", vm);
              } else if (vm.$options.props && key in vm.$options.props) {
                warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
              }
            }
          }
        }

        function defineComputed(target, key, userDef) {
          var shouldCache = !isServerRendering();

          if (typeof userDef === 'function') {
            sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
            sharedPropertyDefinition.set = noop;
          } else {
            sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
            sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
          }

          if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {
            sharedPropertyDefinition.set = function () {
              warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
            };
          }

          Object.defineProperty(target, key, sharedPropertyDefinition);
        }

        function createComputedGetter(key) {
          return function computedGetter() {
            var watcher = this._computedWatchers && this._computedWatchers[key];

            if (watcher) {
              if (watcher.dirty) {
                watcher.evaluate();
              }

              if (Dep.target) {
                watcher.depend();
              }

              return watcher.value;
            }
          };
        }

        function initMethods(vm, methods) {
          var props = vm.$options.props;

          for (var key in methods) {
            if (process.env.NODE_ENV !== 'production') {
              if (methods[key] == null) {
                warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
              }

              if (props && hasOwn(props, key)) {
                warn("Method \"" + key + "\" has already been defined as a prop.", vm);
              }

              if (key in vm && isReserved(key)) {
                warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
              }
            }

            vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
          }
        }

        function initWatch(vm, watch) {
          for (var key in watch) {
            var handler = watch[key];

            if (Array.isArray(handler)) {
              for (var i = 0; i < handler.length; i++) {
                createWatcher(vm, key, handler[i]);
              }
            } else {
              createWatcher(vm, key, handler);
            }
          }
        }

        function createWatcher(vm, expOrFn, handler, options) {
          if (isPlainObject(handler)) {
            options = handler;
            handler = handler.handler;
          }

          if (typeof handler === 'string') {
            handler = vm[handler];
          }

          return vm.$watch(expOrFn, handler, options);
        }

        function stateMixin(Vue) {
          // flow somehow has problems with directly declared definition object
          // when using Object.defineProperty, so we have to procedurally build up
          // the object here.
          var dataDef = {};

          dataDef.get = function () {
            return this._data;
          };

          var propsDef = {};

          propsDef.get = function () {
            return this._props;
          };

          if (process.env.NODE_ENV !== 'production') {
            dataDef.set = function (newData) {
              warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
            };

            propsDef.set = function () {
              warn("$props is readonly.", this);
            };
          }

          Object.defineProperty(Vue.prototype, '$data', dataDef);
          Object.defineProperty(Vue.prototype, '$props', propsDef);
          Vue.prototype.$set = set;
          Vue.prototype.$delete = del;

          Vue.prototype.$watch = function (expOrFn, cb, options) {
            var vm = this;

            if (isPlainObject(cb)) {
              return createWatcher(vm, expOrFn, cb, options);
            }

            options = options || {};
            options.user = true;
            var watcher = new Watcher(vm, expOrFn, cb, options);

            if (options.immediate) {
              cb.call(vm, watcher.value);
            }

            return function unwatchFn() {
              watcher.teardown();
            };
          };
        }
        /*  */


        function initProvide(vm) {
          var provide = vm.$options.provide;

          if (provide) {
            vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
          }
        }

        function initInjections(vm) {
          var result = resolveInject(vm.$options.inject, vm);

          if (result) {
            toggleObserving(false);
            Object.keys(result).forEach(function (key) {
              /* istanbul ignore else */
              if (process.env.NODE_ENV !== 'production') {
                defineReactive(vm, key, result[key], function () {
                  warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
                });
              } else {
                defineReactive(vm, key, result[key]);
              }
            });
            toggleObserving(true);
          }
        }

        function resolveInject(inject, vm) {
          if (inject) {
            // inject is :any because flow is not smart enough to figure out cached
            var result = Object.create(null);
            var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
              /* istanbul ignore next */
              return Object.getOwnPropertyDescriptor(inject, key).enumerable;
            }) : Object.keys(inject);

            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              var provideKey = inject[key].from;
              var source = vm;

              while (source) {
                if (source._provided && hasOwn(source._provided, provideKey)) {
                  result[key] = source._provided[provideKey];
                  break;
                }

                source = source.$parent;
              }

              if (!source) {
                if ('default' in inject[key]) {
                  var provideDefault = inject[key].default;
                  result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
                } else if (process.env.NODE_ENV !== 'production') {
                  warn("Injection \"" + key + "\" not found", vm);
                }
              }
            }

            return result;
          }
        }
        /*  */

        /**
         * Runtime helper for rendering v-for lists.
         */


        function renderList(val, render) {
          var ret, i, l, keys, key;

          if (Array.isArray(val) || typeof val === 'string') {
            ret = new Array(val.length);

            for (i = 0, l = val.length; i < l; i++) {
              ret[i] = render(val[i], i);
            }
          } else if (typeof val === 'number') {
            ret = new Array(val);

            for (i = 0; i < val; i++) {
              ret[i] = render(i + 1, i);
            }
          } else if (isObject(val)) {
            keys = Object.keys(val);
            ret = new Array(keys.length);

            for (i = 0, l = keys.length; i < l; i++) {
              key = keys[i];
              ret[i] = render(val[key], key, i);
            }
          }

          if (isDef(ret)) {
            ret._isVList = true;
          }

          return ret;
        }
        /*  */

        /**
         * Runtime helper for rendering <slot>
         */


        function renderSlot(name, fallback, props, bindObject) {
          var scopedSlotFn = this.$scopedSlots[name];
          var nodes;

          if (scopedSlotFn) {
            // scoped slot
            props = props || {};

            if (bindObject) {
              if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {
                warn('slot v-bind without argument expects an Object', this);
              }

              props = extend(extend({}, bindObject), props);
            }

            nodes = scopedSlotFn(props) || fallback;
          } else {
            var slotNodes = this.$slots[name]; // warn duplicate slot usage

            if (slotNodes) {
              if (process.env.NODE_ENV !== 'production' && slotNodes._rendered) {
                warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
              }

              slotNodes._rendered = true;
            }

            nodes = slotNodes || fallback;
          }

          var target = props && props.slot;

          if (target) {
            return this.$createElement('template', {
              slot: target
            }, nodes);
          } else {
            return nodes;
          }
        }
        /*  */

        /**
         * Runtime helper for resolving filters
         */


        function resolveFilter(id) {
          return resolveAsset(this.$options, 'filters', id, true) || identity;
        }
        /*  */


        function isKeyNotMatch(expect, actual) {
          if (Array.isArray(expect)) {
            return expect.indexOf(actual) === -1;
          } else {
            return expect !== actual;
          }
        }
        /**
         * Runtime helper for checking keyCodes from config.
         * exposed as Vue.prototype._k
         * passing in eventKeyName as last argument separately for backwards compat
         */


        function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
          var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

          if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
            return isKeyNotMatch(builtInKeyName, eventKeyName);
          } else if (mappedKeyCode) {
            return isKeyNotMatch(mappedKeyCode, eventKeyCode);
          } else if (eventKeyName) {
            return hyphenate(eventKeyName) !== key;
          }
        }
        /*  */

        /**
         * Runtime helper for merging v-bind="object" into a VNode's data.
         */


        function bindObjectProps(data, tag, value, asProp, isSync) {
          if (value) {
            if (!isObject(value)) {
              process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
            } else {
              if (Array.isArray(value)) {
                value = toObject(value);
              }

              var hash;

              var loop = function loop(key) {
                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
                  hash = data;
                } else {
                  var type = data.attrs && data.attrs.type;
                  hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
                }

                if (!(key in hash)) {
                  hash[key] = value[key];

                  if (isSync) {
                    var on = data.on || (data.on = {});

                    on["update:" + key] = function ($event) {
                      value[key] = $event;
                    };
                  }
                }
              };

              for (var key in value) {
                loop(key);
              }
            }
          }

          return data;
        }
        /*  */

        /**
         * Runtime helper for rendering static trees.
         */


        function renderStatic(index, isInFor) {
          var cached = this._staticTrees || (this._staticTrees = []);
          var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
          // we can reuse the same tree.

          if (tree && !isInFor) {
            return tree;
          } // otherwise, render a fresh tree.


          tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
          );
          markStatic(tree, "__static__" + index, false);
          return tree;
        }
        /**
         * Runtime helper for v-once.
         * Effectively it means marking the node as static with a unique key.
         */


        function markOnce(tree, index, key) {
          markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
          return tree;
        }

        function markStatic(tree, key, isOnce) {
          if (Array.isArray(tree)) {
            for (var i = 0; i < tree.length; i++) {
              if (tree[i] && typeof tree[i] !== 'string') {
                markStaticNode(tree[i], key + "_" + i, isOnce);
              }
            }
          } else {
            markStaticNode(tree, key, isOnce);
          }
        }

        function markStaticNode(node, key, isOnce) {
          node.isStatic = true;
          node.key = key;
          node.isOnce = isOnce;
        }
        /*  */


        function bindObjectListeners(data, value) {
          if (value) {
            if (!isPlainObject(value)) {
              process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);
            } else {
              var on = data.on = data.on ? extend({}, data.on) : {};

              for (var key in value) {
                var existing = on[key];
                var ours = value[key];
                on[key] = existing ? [].concat(existing, ours) : ours;
              }
            }
          }

          return data;
        }
        /*  */


        function installRenderHelpers(target) {
          target._o = markOnce;
          target._n = toNumber;
          target._s = toString;
          target._l = renderList;
          target._t = renderSlot;
          target._q = looseEqual;
          target._i = looseIndexOf;
          target._m = renderStatic;
          target._f = resolveFilter;
          target._k = checkKeyCodes;
          target._b = bindObjectProps;
          target._v = createTextVNode;
          target._e = createEmptyVNode;
          target._u = resolveScopedSlots;
          target._g = bindObjectListeners;
        }
        /*  */


        function FunctionalRenderContext(data, props, children, parent, Ctor) {
          var options = Ctor.options; // ensure the createElement function in functional components
          // gets a unique context - this is necessary for correct named slot check

          var contextVm;

          if (hasOwn(parent, '_uid')) {
            contextVm = Object.create(parent); // $flow-disable-line

            contextVm._original = parent;
          } else {
            // the context vm passed in is a functional context as well.
            // in this case we want to make sure we are able to get a hold to the
            // real context instance.
            contextVm = parent; // $flow-disable-line

            parent = parent._original;
          }

          var isCompiled = isTrue(options._compiled);
          var needNormalization = !isCompiled;
          this.data = data;
          this.props = props;
          this.children = children;
          this.parent = parent;
          this.listeners = data.on || emptyObject;
          this.injections = resolveInject(options.inject, parent);

          this.slots = function () {
            return resolveSlots(children, parent);
          }; // support for compiled functional template


          if (isCompiled) {
            // exposing $options for renderStatic()
            this.$options = options; // pre-resolve slots for renderSlot()

            this.$slots = this.slots();
            this.$scopedSlots = data.scopedSlots || emptyObject;
          }

          if (options._scopeId) {
            this._c = function (a, b, c, d) {
              var vnode = createElement(contextVm, a, b, c, d, needNormalization);

              if (vnode && !Array.isArray(vnode)) {
                vnode.fnScopeId = options._scopeId;
                vnode.fnContext = parent;
              }

              return vnode;
            };
          } else {
            this._c = function (a, b, c, d) {
              return createElement(contextVm, a, b, c, d, needNormalization);
            };
          }
        }

        installRenderHelpers(FunctionalRenderContext.prototype);

        function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
          var options = Ctor.options;
          var props = {};
          var propOptions = options.props;

          if (isDef(propOptions)) {
            for (var key in propOptions) {
              props[key] = validateProp(key, propOptions, propsData || emptyObject);
            }
          } else {
            if (isDef(data.attrs)) {
              mergeProps(props, data.attrs);
            }

            if (isDef(data.props)) {
              mergeProps(props, data.props);
            }
          }

          var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
          var vnode = options.render.call(null, renderContext._c, renderContext);

          if (vnode instanceof VNode) {
            return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);
          } else if (Array.isArray(vnode)) {
            var vnodes = normalizeChildren(vnode) || [];
            var res = new Array(vnodes.length);

            for (var i = 0; i < vnodes.length; i++) {
              res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
            }

            return res;
          }
        }

        function cloneAndMarkFunctionalResult(vnode, data, contextVm, options) {
          // #7817 clone node before setting fnContext, otherwise if the node is reused
          // (e.g. it was from a cached normal slot) the fnContext causes named slots
          // that should not be matched to match.
          var clone = cloneVNode(vnode);
          clone.fnContext = contextVm;
          clone.fnOptions = options;

          if (data.slot) {
            (clone.data || (clone.data = {})).slot = data.slot;
          }

          return clone;
        }

        function mergeProps(to, from) {
          for (var key in from) {
            to[camelize(key)] = from[key];
          }
        }
        /*  */
        // Register the component hook to weex native render engine.
        // The hook will be triggered by native, not javascript.
        // Updates the state of the component to weex native render engine.

        /*  */
        // https://github.com/Hanks10100/weex-native-directive/tree/master/component
        // listening on native callback

        /*  */

        /*  */
        // inline hooks to be invoked on component VNodes during patch


        var componentVNodeHooks = {
          init: function init(vnode, hydrating, parentElm, refElm) {
            if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
              // kept-alive components, treat as a patch
              var mountedNode = vnode; // work around flow

              componentVNodeHooks.prepatch(mountedNode, mountedNode);
            } else {
              var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
              child.$mount(hydrating ? vnode.elm : undefined, hydrating);
            }
          },
          prepatch: function prepatch(oldVnode, vnode) {
            var options = vnode.componentOptions;
            var child = vnode.componentInstance = oldVnode.componentInstance;
            updateChildComponent(child, options.propsData, // updated props
            options.listeners, // updated listeners
            vnode, // new parent vnode
            options.children // new children
            );
          },
          insert: function insert(vnode) {
            var context = vnode.context;
            var componentInstance = vnode.componentInstance;

            if (!componentInstance._isMounted) {
              componentInstance._isMounted = true;
              callHook(componentInstance, 'mounted');
            }

            if (vnode.data.keepAlive) {
              if (context._isMounted) {
                // vue-router#1212
                // During updates, a kept-alive component's child components may
                // change, so directly walking the tree here may call activated hooks
                // on incorrect children. Instead we push them into a queue which will
                // be processed after the whole patch process ended.
                queueActivatedComponent(componentInstance);
              } else {
                activateChildComponent(componentInstance, true
                /* direct */
                );
              }
            }
          },
          destroy: function destroy(vnode) {
            var componentInstance = vnode.componentInstance;

            if (!componentInstance._isDestroyed) {
              if (!vnode.data.keepAlive) {
                componentInstance.$destroy();
              } else {
                deactivateChildComponent(componentInstance, true
                /* direct */
                );
              }
            }
          }
        };
        var hooksToMerge = Object.keys(componentVNodeHooks);

        function createComponent(Ctor, data, context, children, tag) {
          if (isUndef(Ctor)) {
            return;
          }

          var baseCtor = context.$options._base; // plain options object: turn it into a constructor

          if (isObject(Ctor)) {
            Ctor = baseCtor.extend(Ctor);
          } // if at this stage it's not a constructor or an async component factory,
          // reject.


          if (typeof Ctor !== 'function') {
            if (process.env.NODE_ENV !== 'production') {
              warn("Invalid Component definition: " + String(Ctor), context);
            }

            return;
          } // async component


          var asyncFactory;

          if (isUndef(Ctor.cid)) {
            asyncFactory = Ctor;
            Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);

            if (Ctor === undefined) {
              // return a placeholder node for async component, which is rendered
              // as a comment node but preserves all the raw information for the node.
              // the information will be used for async server-rendering and hydration.
              return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
            }
          }

          data = data || {}; // resolve constructor options in case global mixins are applied after
          // component constructor creation

          resolveConstructorOptions(Ctor); // transform component v-model data into props & events

          if (isDef(data.model)) {
            transformModel(Ctor.options, data);
          } // extract props


          var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

          if (isTrue(Ctor.options.functional)) {
            return createFunctionalComponent(Ctor, propsData, data, context, children);
          } // extract listeners, since these needs to be treated as
          // child component listeners instead of DOM listeners


          var listeners = data.on; // replace with listeners with .native modifier
          // so it gets processed during parent component patch.

          data.on = data.nativeOn;

          if (isTrue(Ctor.options.abstract)) {
            // abstract components do not keep anything
            // other than props & listeners & slot
            // work around flow
            var slot = data.slot;
            data = {};

            if (slot) {
              data.slot = slot;
            }
          } // install component management hooks onto the placeholder node


          installComponentHooks(data); // return a placeholder vnode

          var name = Ctor.options.name || tag;
          var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
            Ctor: Ctor,
            propsData: propsData,
            listeners: listeners,
            tag: tag,
            children: children
          }, asyncFactory); // Weex specific: invoke recycle-list optimized @render function for
          // extracting cell-slot template.
          // https://github.com/Hanks10100/weex-native-directive/tree/master/component

          /* istanbul ignore if */

          return vnode;
        }

        function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
        parent, // activeInstance in lifecycle state
        parentElm, refElm) {
          var options = {
            _isComponent: true,
            parent: parent,
            _parentVnode: vnode,
            _parentElm: parentElm || null,
            _refElm: refElm || null
          }; // check inline-template render functions

          var inlineTemplate = vnode.data.inlineTemplate;

          if (isDef(inlineTemplate)) {
            options.render = inlineTemplate.render;
            options.staticRenderFns = inlineTemplate.staticRenderFns;
          }

          return new vnode.componentOptions.Ctor(options);
        }

        function installComponentHooks(data) {
          var hooks = data.hook || (data.hook = {});

          for (var i = 0; i < hooksToMerge.length; i++) {
            var key = hooksToMerge[i];
            hooks[key] = componentVNodeHooks[key];
          }
        } // transform component v-model info (value and callback) into
        // prop and event handler respectively.


        function transformModel(options, data) {
          var prop = options.model && options.model.prop || 'value';
          var event = options.model && options.model.event || 'input';
          (data.props || (data.props = {}))[prop] = data.model.value;
          var on = data.on || (data.on = {});

          if (isDef(on[event])) {
            on[event] = [data.model.callback].concat(on[event]);
          } else {
            on[event] = data.model.callback;
          }
        }
        /*  */


        var SIMPLE_NORMALIZE = 1;
        var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
        // without getting yelled at by flow

        function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
          if (Array.isArray(data) || isPrimitive(data)) {
            normalizationType = children;
            children = data;
            data = undefined;
          }

          if (isTrue(alwaysNormalize)) {
            normalizationType = ALWAYS_NORMALIZE;
          }

          return _createElement(context, tag, data, children, normalizationType);
        }

        function _createElement(context, tag, data, children, normalizationType) {
          if (isDef(data) && isDef(data.__ob__)) {
            process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
            return createEmptyVNode();
          } // object syntax in v-bind


          if (isDef(data) && isDef(data.is)) {
            tag = data.is;
          }

          if (!tag) {
            // in case of component :is set to falsy value
            return createEmptyVNode();
          } // warn against non-primitive key


          if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
            {
              warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
            }
          } // support single function children as default scoped slot


          if (Array.isArray(children) && typeof children[0] === 'function') {
            data = data || {};
            data.scopedSlots = {
              default: children[0]
            };
            children.length = 0;
          }

          if (normalizationType === ALWAYS_NORMALIZE) {
            children = normalizeChildren(children);
          } else if (normalizationType === SIMPLE_NORMALIZE) {
            children = simpleNormalizeChildren(children);
          }

          var vnode, ns;

          if (typeof tag === 'string') {
            var Ctor;
            ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

            if (config.isReservedTag(tag)) {
              // platform built-in elements
              vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
            } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
              // component
              vnode = createComponent(Ctor, data, context, children, tag);
            } else {
              // unknown or unlisted namespaced elements
              // check at runtime because it may get assigned a namespace when its
              // parent normalizes children
              vnode = new VNode(tag, data, children, undefined, undefined, context);
            }
          } else {
            // direct component options / constructor
            vnode = createComponent(tag, data, context, children);
          }

          if (Array.isArray(vnode)) {
            return vnode;
          } else if (isDef(vnode)) {
            if (isDef(ns)) {
              applyNS(vnode, ns);
            }

            if (isDef(data)) {
              registerDeepBindings(data);
            }

            return vnode;
          } else {
            return createEmptyVNode();
          }
        }

        function applyNS(vnode, ns, force) {
          vnode.ns = ns;

          if (vnode.tag === 'foreignObject') {
            // use default namespace inside foreignObject
            ns = undefined;
            force = true;
          }

          if (isDef(vnode.children)) {
            for (var i = 0, l = vnode.children.length; i < l; i++) {
              var child = vnode.children[i];

              if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
                applyNS(child, ns, force);
              }
            }
          }
        } // ref #5318
        // necessary to ensure parent re-render when deep bindings like :style and
        // :class are used on slot nodes


        function registerDeepBindings(data) {
          if (isObject(data.style)) {
            traverse(data.style);
          }

          if (isObject(data.class)) {
            traverse(data.class);
          }
        }
        /*  */


        function initRender(vm) {
          vm._vnode = null; // the root of the child tree

          vm._staticTrees = null; // v-once cached trees

          var options = vm.$options;
          var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

          var renderContext = parentVnode && parentVnode.context;
          vm.$slots = resolveSlots(options._renderChildren, renderContext);
          vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
          // so that we get proper render context inside it.
          // args order: tag, data, children, normalizationType, alwaysNormalize
          // internal version is used by render functions compiled from templates

          vm._c = function (a, b, c, d) {
            return createElement(vm, a, b, c, d, false);
          }; // normalization is always applied for the public version, used in
          // user-written render functions.


          vm.$createElement = function (a, b, c, d) {
            return createElement(vm, a, b, c, d, true);
          }; // $attrs & $listeners are exposed for easier HOC creation.
          // they need to be reactive so that HOCs using them are always updated


          var parentData = parentVnode && parentVnode.data;
          /* istanbul ignore else */

          if (process.env.NODE_ENV !== 'production') {
            defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
              !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
            }, true);
            defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
              !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
            }, true);
          } else {
            defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
            defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
          }
        }

        function renderMixin(Vue) {
          // install runtime convenience helpers
          installRenderHelpers(Vue.prototype);

          Vue.prototype.$nextTick = function (fn) {
            return nextTick(fn, this);
          };

          Vue.prototype._render = function () {
            var vm = this;
            var ref = vm.$options;
            var render = ref.render;
            var _parentVnode = ref._parentVnode; // reset _rendered flag on slots for duplicate slot check

            if (process.env.NODE_ENV !== 'production') {
              for (var key in vm.$slots) {
                // $flow-disable-line
                vm.$slots[key]._rendered = false;
              }
            }

            if (_parentVnode) {
              vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;
            } // set parent vnode. this allows render functions to have access
            // to the data on the placeholder node.


            vm.$vnode = _parentVnode; // render self

            var vnode;

            try {
              vnode = render.call(vm._renderProxy, vm.$createElement);
            } catch (e) {
              handleError(e, vm, "render"); // return error render result,
              // or previous vnode to prevent render error causing blank component

              /* istanbul ignore else */

              if (process.env.NODE_ENV !== 'production') {
                if (vm.$options.renderError) {
                  try {
                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                  } catch (e) {
                    handleError(e, vm, "renderError");
                    vnode = vm._vnode;
                  }
                } else {
                  vnode = vm._vnode;
                }
              } else {
                vnode = vm._vnode;
              }
            } // return empty vnode in case the render function errored out


            if (!(vnode instanceof VNode)) {
              if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
                warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
              }

              vnode = createEmptyVNode();
            } // set parent


            vnode.parent = _parentVnode;
            return vnode;
          };
        }
        /*  */


        var uid$3 = 0;

        function initMixin(Vue) {
          Vue.prototype._init = function (options) {
            var vm = this; // a uid

            vm._uid = uid$3++;
            var startTag, endTag;
            /* istanbul ignore if */

            if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
              startTag = "vue-perf-start:" + vm._uid;
              endTag = "vue-perf-end:" + vm._uid;
              mark(startTag);
            } // a flag to avoid this being observed


            vm._isVue = true; // merge options

            if (options && options._isComponent) {
              // optimize internal component instantiation
              // since dynamic options merging is pretty slow, and none of the
              // internal component options needs special treatment.
              initInternalComponent(vm, options);
            } else {
              vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
            }
            /* istanbul ignore else */


            if (process.env.NODE_ENV !== 'production') {
              initProxy(vm);
            } else {
              vm._renderProxy = vm;
            } // expose real self


            vm._self = vm;
            initLifecycle(vm);
            initEvents(vm);
            initRender(vm);
            callHook(vm, 'beforeCreate');
            initInjections(vm); // resolve injections before data/props

            initState(vm);
            initProvide(vm); // resolve provide after data/props

            callHook(vm, 'created');
            /* istanbul ignore if */

            if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
              vm._name = formatComponentName(vm, false);
              mark(endTag);
              measure("vue " + vm._name + " init", startTag, endTag);
            }

            if (vm.$options.el) {
              vm.$mount(vm.$options.el);
            }
          };
        }

        function initInternalComponent(vm, options) {
          var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

          var parentVnode = options._parentVnode;
          opts.parent = options.parent;
          opts._parentVnode = parentVnode;
          opts._parentElm = options._parentElm;
          opts._refElm = options._refElm;
          var vnodeComponentOptions = parentVnode.componentOptions;
          opts.propsData = vnodeComponentOptions.propsData;
          opts._parentListeners = vnodeComponentOptions.listeners;
          opts._renderChildren = vnodeComponentOptions.children;
          opts._componentTag = vnodeComponentOptions.tag;

          if (options.render) {
            opts.render = options.render;
            opts.staticRenderFns = options.staticRenderFns;
          }
        }

        function resolveConstructorOptions(Ctor) {
          var options = Ctor.options;

          if (Ctor.super) {
            var superOptions = resolveConstructorOptions(Ctor.super);
            var cachedSuperOptions = Ctor.superOptions;

            if (superOptions !== cachedSuperOptions) {
              // super option changed,
              // need to resolve new options.
              Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

              var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

              if (modifiedOptions) {
                extend(Ctor.extendOptions, modifiedOptions);
              }

              options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

              if (options.name) {
                options.components[options.name] = Ctor;
              }
            }
          }

          return options;
        }

        function resolveModifiedOptions(Ctor) {
          var modified;
          var latest = Ctor.options;
          var extended = Ctor.extendOptions;
          var sealed = Ctor.sealedOptions;

          for (var key in latest) {
            if (latest[key] !== sealed[key]) {
              if (!modified) {
                modified = {};
              }

              modified[key] = dedupe(latest[key], extended[key], sealed[key]);
            }
          }

          return modified;
        }

        function dedupe(latest, extended, sealed) {
          // compare latest and sealed to ensure lifecycle hooks won't be duplicated
          // between merges
          if (Array.isArray(latest)) {
            var res = [];
            sealed = Array.isArray(sealed) ? sealed : [sealed];
            extended = Array.isArray(extended) ? extended : [extended];

            for (var i = 0; i < latest.length; i++) {
              // push original options and not sealed options to exclude duplicated options
              if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
                res.push(latest[i]);
              }
            }

            return res;
          } else {
            return latest;
          }
        }

        function Vue(options) {
          if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue)) {
            warn('Vue is a constructor and should be called with the `new` keyword');
          }

          this._init(options);
        }

        initMixin(Vue);
        stateMixin(Vue);
        eventsMixin(Vue);
        lifecycleMixin(Vue);
        renderMixin(Vue);
        /*  */

        function initUse(Vue) {
          Vue.use = function (plugin) {
            var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

            if (installedPlugins.indexOf(plugin) > -1) {
              return this;
            } // additional parameters


            var args = toArray(arguments, 1);
            args.unshift(this);

            if (typeof plugin.install === 'function') {
              plugin.install.apply(plugin, args);
            } else if (typeof plugin === 'function') {
              plugin.apply(null, args);
            }

            installedPlugins.push(plugin);
            return this;
          };
        }
        /*  */


        function initMixin$1(Vue) {
          Vue.mixin = function (mixin) {
            this.options = mergeOptions(this.options, mixin);
            return this;
          };
        }
        /*  */


        function initExtend(Vue) {
          /**
           * Each instance constructor, including Vue, has a unique
           * cid. This enables us to create wrapped "child
           * constructors" for prototypal inheritance and cache them.
           */
          Vue.cid = 0;
          var cid = 1;
          /**
           * Class inheritance
           */

          Vue.extend = function (extendOptions) {
            extendOptions = extendOptions || {};
            var Super = this;
            var SuperId = Super.cid;
            var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

            if (cachedCtors[SuperId]) {
              return cachedCtors[SuperId];
            }

            var name = extendOptions.name || Super.options.name;

            if (process.env.NODE_ENV !== 'production' && name) {
              validateComponentName(name);
            }

            var Sub = function VueComponent(options) {
              this._init(options);
            };

            Sub.prototype = Object.create(Super.prototype);
            Sub.prototype.constructor = Sub;
            Sub.cid = cid++;
            Sub.options = mergeOptions(Super.options, extendOptions);
            Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
            // the Vue instances at extension time, on the extended prototype. This
            // avoids Object.defineProperty calls for each instance created.

            if (Sub.options.props) {
              initProps$1(Sub);
            }

            if (Sub.options.computed) {
              initComputed$1(Sub);
            } // allow further extension/mixin/plugin usage


            Sub.extend = Super.extend;
            Sub.mixin = Super.mixin;
            Sub.use = Super.use; // create asset registers, so extended classes
            // can have their private assets too.

            ASSET_TYPES.forEach(function (type) {
              Sub[type] = Super[type];
            }); // enable recursive self-lookup

            if (name) {
              Sub.options.components[name] = Sub;
            } // keep a reference to the super options at extension time.
            // later at instantiation we can check if Super's options have
            // been updated.


            Sub.superOptions = Super.options;
            Sub.extendOptions = extendOptions;
            Sub.sealedOptions = extend({}, Sub.options); // cache constructor

            cachedCtors[SuperId] = Sub;
            return Sub;
          };
        }

        function initProps$1(Comp) {
          var props = Comp.options.props;

          for (var key in props) {
            proxy(Comp.prototype, "_props", key);
          }
        }

        function initComputed$1(Comp) {
          var computed = Comp.options.computed;

          for (var key in computed) {
            defineComputed(Comp.prototype, key, computed[key]);
          }
        }
        /*  */


        function initAssetRegisters(Vue) {
          /**
           * Create asset registration methods.
           */
          ASSET_TYPES.forEach(function (type) {
            Vue[type] = function (id, definition) {
              if (!definition) {
                return this.options[type + 's'][id];
              } else {
                /* istanbul ignore if */
                if (process.env.NODE_ENV !== 'production' && type === 'component') {
                  validateComponentName(id);
                }

                if (type === 'component' && isPlainObject(definition)) {
                  definition.name = definition.name || id;
                  definition = this.options._base.extend(definition);
                }

                if (type === 'directive' && typeof definition === 'function') {
                  definition = {
                    bind: definition,
                    update: definition
                  };
                }

                this.options[type + 's'][id] = definition;
                return definition;
              }
            };
          });
        }
        /*  */


        function getComponentName(opts) {
          return opts && (opts.Ctor.options.name || opts.tag);
        }

        function matches(pattern, name) {
          if (Array.isArray(pattern)) {
            return pattern.indexOf(name) > -1;
          } else if (typeof pattern === 'string') {
            return pattern.split(',').indexOf(name) > -1;
          } else if (isRegExp(pattern)) {
            return pattern.test(name);
          }
          /* istanbul ignore next */


          return false;
        }

        function pruneCache(keepAliveInstance, filter) {
          var cache = keepAliveInstance.cache;
          var keys = keepAliveInstance.keys;
          var _vnode = keepAliveInstance._vnode;

          for (var key in cache) {
            var cachedNode = cache[key];

            if (cachedNode) {
              var name = getComponentName(cachedNode.componentOptions);

              if (name && !filter(name)) {
                pruneCacheEntry(cache, key, keys, _vnode);
              }
            }
          }
        }

        function pruneCacheEntry(cache, key, keys, current) {
          var cached$$1 = cache[key];

          if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
            cached$$1.componentInstance.$destroy();
          }

          cache[key] = null;
          remove(keys, key);
        }

        var patternTypes = [String, RegExp, Array];
        var KeepAlive = {
          name: 'keep-alive',
          abstract: true,
          props: {
            include: patternTypes,
            exclude: patternTypes,
            max: [String, Number]
          },
          created: function created() {
            this.cache = Object.create(null);
            this.keys = [];
          },
          destroyed: function destroyed() {
            var this$1 = this;

            for (var key in this$1.cache) {
              pruneCacheEntry(this$1.cache, key, this$1.keys);
            }
          },
          mounted: function mounted() {
            var this$1 = this;
            this.$watch('include', function (val) {
              pruneCache(this$1, function (name) {
                return matches(val, name);
              });
            });
            this.$watch('exclude', function (val) {
              pruneCache(this$1, function (name) {
                return !matches(val, name);
              });
            });
          },
          render: function render() {
            var slot = this.$slots.default;
            var vnode = getFirstComponentChild(slot);
            var componentOptions = vnode && vnode.componentOptions;

            if (componentOptions) {
              // check pattern
              var name = getComponentName(componentOptions);
              var ref = this;
              var include = ref.include;
              var exclude = ref.exclude;

              if ( // not included
              include && (!name || !matches(include, name)) || // excluded
              exclude && name && matches(exclude, name)) {
                return vnode;
              }

              var ref$1 = this;
              var cache = ref$1.cache;
              var keys = ref$1.keys;
              var key = vnode.key == null // same constructor may get registered as different local components
              // so cid alone is not enough (#3269)
              ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

              if (cache[key]) {
                vnode.componentInstance = cache[key].componentInstance; // make current key freshest

                remove(keys, key);
                keys.push(key);
              } else {
                cache[key] = vnode;
                keys.push(key); // prune oldest entry

                if (this.max && keys.length > parseInt(this.max)) {
                  pruneCacheEntry(cache, keys[0], keys, this._vnode);
                }
              }

              vnode.data.keepAlive = true;
            }

            return vnode || slot && slot[0];
          }
        };
        var builtInComponents = {
          KeepAlive: KeepAlive
          /*  */

        };

        function initGlobalAPI(Vue) {
          // config
          var configDef = {};

          configDef.get = function () {
            return config;
          };

          if (process.env.NODE_ENV !== 'production') {
            configDef.set = function () {
              warn('Do not replace the Vue.config object, set individual fields instead.');
            };
          }

          Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
          // NOTE: these are not considered part of the public API - avoid relying on
          // them unless you are aware of the risk.

          Vue.util = {
            warn: warn,
            extend: extend,
            mergeOptions: mergeOptions,
            defineReactive: defineReactive
          };
          Vue.set = set;
          Vue.delete = del;
          Vue.nextTick = nextTick;
          Vue.options = Object.create(null);
          ASSET_TYPES.forEach(function (type) {
            Vue.options[type + 's'] = Object.create(null);
          }); // this is used to identify the "base" constructor to extend all plain-object
          // components with in Weex's multi-instance scenarios.

          Vue.options._base = Vue;
          extend(Vue.options.components, builtInComponents);
          initUse(Vue);
          initMixin$1(Vue);
          initExtend(Vue);
          initAssetRegisters(Vue);
        }

        initGlobalAPI(Vue);
        Object.defineProperty(Vue.prototype, '$isServer', {
          get: isServerRendering
        });
        Object.defineProperty(Vue.prototype, '$ssrContext', {
          get: function get() {
            /* istanbul ignore next */
            return this.$vnode && this.$vnode.ssrContext;
          }
        }); // expose FunctionalRenderContext for ssr runtime helper installation

        Object.defineProperty(Vue, 'FunctionalRenderContext', {
          value: FunctionalRenderContext
        });
        Vue.version = '2.5.16';
        /*  */
        // these are reserved for web because they are directly compiled away
        // during template compilation

        var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

        var acceptValue = makeMap('input,textarea,option,select,progress');

        var mustUseProp = function mustUseProp(tag, type, attr) {
          return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
        };

        var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
        var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
        var xlinkNS = 'http://www.w3.org/1999/xlink';

        var isXlink = function isXlink(name) {
          return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
        };

        var getXlinkProp = function getXlinkProp(name) {
          return isXlink(name) ? name.slice(6, name.length) : '';
        };

        var isFalsyAttrValue = function isFalsyAttrValue(val) {
          return val == null || val === false;
        };
        /*  */


        function genClassForVnode(vnode) {
          var data = vnode.data;
          var parentNode = vnode;
          var childNode = vnode;

          while (isDef(childNode.componentInstance)) {
            childNode = childNode.componentInstance._vnode;

            if (childNode && childNode.data) {
              data = mergeClassData(childNode.data, data);
            }
          }

          while (isDef(parentNode = parentNode.parent)) {
            if (parentNode && parentNode.data) {
              data = mergeClassData(data, parentNode.data);
            }
          }

          return renderClass(data.staticClass, data.class);
        }

        function mergeClassData(child, parent) {
          return {
            staticClass: concat(child.staticClass, parent.staticClass),
            class: isDef(child.class) ? [child.class, parent.class] : parent.class
          };
        }

        function renderClass(staticClass, dynamicClass) {
          if (isDef(staticClass) || isDef(dynamicClass)) {
            return concat(staticClass, stringifyClass(dynamicClass));
          }
          /* istanbul ignore next */


          return '';
        }

        function concat(a, b) {
          return a ? b ? a + ' ' + b : a : b || '';
        }

        function stringifyClass(value) {
          if (Array.isArray(value)) {
            return stringifyArray(value);
          }

          if (isObject(value)) {
            return stringifyObject(value);
          }

          if (typeof value === 'string') {
            return value;
          }
          /* istanbul ignore next */


          return '';
        }

        function stringifyArray(value) {
          var res = '';
          var stringified;

          for (var i = 0, l = value.length; i < l; i++) {
            if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
              if (res) {
                res += ' ';
              }

              res += stringified;
            }
          }

          return res;
        }

        function stringifyObject(value) {
          var res = '';

          for (var key in value) {
            if (value[key]) {
              if (res) {
                res += ' ';
              }

              res += key;
            }
          }

          return res;
        }
        /*  */


        var namespaceMap = {
          svg: 'http://www.w3.org/2000/svg',
          math: 'http://www.w3.org/1998/Math/MathML'
        };
        var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
        // contain child elements.

        var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

        var isReservedTag = function isReservedTag(tag) {
          return isHTMLTag(tag) || isSVG(tag);
        };

        function getTagNamespace(tag) {
          if (isSVG(tag)) {
            return 'svg';
          } // basic support for MathML
          // note it doesn't support other MathML elements being component roots


          if (tag === 'math') {
            return 'math';
          }
        }

        var unknownElementCache = Object.create(null);

        function isUnknownElement(tag) {
          /* istanbul ignore if */
          if (!inBrowser) {
            return true;
          }

          if (isReservedTag(tag)) {
            return false;
          }

          tag = tag.toLowerCase();
          /* istanbul ignore if */

          if (unknownElementCache[tag] != null) {
            return unknownElementCache[tag];
          }

          var el = document.createElement(tag);

          if (tag.indexOf('-') > -1) {
            // http://stackoverflow.com/a/28210364/1070244
            return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
          } else {
            return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
          }
        }

        var isTextInputType = makeMap('text,number,password,search,email,tel,url');
        /*  */

        /**
         * Query an element selector if it's not an element already.
         */

        function query(el) {
          if (typeof el === 'string') {
            var selected = document.querySelector(el);

            if (!selected) {
              process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
              return document.createElement('div');
            }

            return selected;
          } else {
            return el;
          }
        }
        /*  */


        function createElement$1(tagName, vnode) {
          var elm = document.createElement(tagName);

          if (tagName !== 'select') {
            return elm;
          } // false or null will remove the attribute but undefined will not


          if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
            elm.setAttribute('multiple', 'multiple');
          }

          return elm;
        }

        function createElementNS(namespace, tagName) {
          return document.createElementNS(namespaceMap[namespace], tagName);
        }

        function createTextNode(text) {
          return document.createTextNode(text);
        }

        function createComment(text) {
          return document.createComment(text);
        }

        function insertBefore(parentNode, newNode, referenceNode) {
          parentNode.insertBefore(newNode, referenceNode);
        }

        function removeChild(node, child) {
          node.removeChild(child);
        }

        function appendChild(node, child) {
          node.appendChild(child);
        }

        function parentNode(node) {
          return node.parentNode;
        }

        function nextSibling(node) {
          return node.nextSibling;
        }

        function tagName(node) {
          return node.tagName;
        }

        function setTextContent(node, text) {
          node.textContent = text;
        }

        function setStyleScope(node, scopeId) {
          node.setAttribute(scopeId, '');
        }

        var nodeOps = Object.freeze({
          createElement: createElement$1,
          createElementNS: createElementNS,
          createTextNode: createTextNode,
          createComment: createComment,
          insertBefore: insertBefore,
          removeChild: removeChild,
          appendChild: appendChild,
          parentNode: parentNode,
          nextSibling: nextSibling,
          tagName: tagName,
          setTextContent: setTextContent,
          setStyleScope: setStyleScope
        });
        /*  */

        var ref = {
          create: function create(_, vnode) {
            registerRef(vnode);
          },
          update: function update(oldVnode, vnode) {
            if (oldVnode.data.ref !== vnode.data.ref) {
              registerRef(oldVnode, true);
              registerRef(vnode);
            }
          },
          destroy: function destroy(vnode) {
            registerRef(vnode, true);
          }
        };

        function registerRef(vnode, isRemoval) {
          var key = vnode.data.ref;

          if (!isDef(key)) {
            return;
          }

          var vm = vnode.context;
          var ref = vnode.componentInstance || vnode.elm;
          var refs = vm.$refs;

          if (isRemoval) {
            if (Array.isArray(refs[key])) {
              remove(refs[key], ref);
            } else if (refs[key] === ref) {
              refs[key] = undefined;
            }
          } else {
            if (vnode.data.refInFor) {
              if (!Array.isArray(refs[key])) {
                refs[key] = [ref];
              } else if (refs[key].indexOf(ref) < 0) {
                // $flow-disable-line
                refs[key].push(ref);
              }
            } else {
              refs[key] = ref;
            }
          }
        }
        /**
         * Virtual DOM patching algorithm based on Snabbdom by
         * Simon Friis Vindum (@paldepind)
         * Licensed under the MIT License
         * https://github.com/paldepind/snabbdom/blob/master/LICENSE
         *
         * modified by Evan You (@yyx990803)
         *
         * Not type-checking this because this file is perf-critical and the cost
         * of making flow understand it is not worth it.
         */


        var emptyNode = new VNode('', {}, []);
        var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

        function sameVnode(a, b) {
          return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
        }

        function sameInputType(a, b) {
          if (a.tag !== 'input') {
            return true;
          }

          var i;
          var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
          var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
          return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
        }

        function createKeyToOldIdx(children, beginIdx, endIdx) {
          var i, key;
          var map = {};

          for (i = beginIdx; i <= endIdx; ++i) {
            key = children[i].key;

            if (isDef(key)) {
              map[key] = i;
            }
          }

          return map;
        }

        function createPatchFunction(backend) {
          var i, j;
          var cbs = {};
          var modules = backend.modules;
          var nodeOps = backend.nodeOps;

          for (i = 0; i < hooks.length; ++i) {
            cbs[hooks[i]] = [];

            for (j = 0; j < modules.length; ++j) {
              if (isDef(modules[j][hooks[i]])) {
                cbs[hooks[i]].push(modules[j][hooks[i]]);
              }
            }
          }

          function emptyNodeAt(elm) {
            return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
          }

          function createRmCb(childElm, listeners) {
            function remove() {
              if (--remove.listeners === 0) {
                removeNode(childElm);
              }
            }

            remove.listeners = listeners;
            return remove;
          }

          function removeNode(el) {
            var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

            if (isDef(parent)) {
              nodeOps.removeChild(parent, el);
            }
          }

          function isUnknownElement$$1(vnode, inVPre) {
            return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
              return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
            })) && config.isUnknownElement(vnode.tag);
          }

          var creatingElmInVPre = 0;

          function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
            if (isDef(vnode.elm) && isDef(ownerArray)) {
              // This vnode was used in a previous render!
              // now it's used as a new node, overwriting its elm would cause
              // potential patch errors down the road when it's used as an insertion
              // reference node. Instead, we clone the node on-demand before creating
              // associated DOM element for it.
              vnode = ownerArray[index] = cloneVNode(vnode);
            }

            vnode.isRootInsert = !nested; // for transition enter check

            if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
              return;
            }

            var data = vnode.data;
            var children = vnode.children;
            var tag = vnode.tag;

            if (isDef(tag)) {
              if (process.env.NODE_ENV !== 'production') {
                if (data && data.pre) {
                  creatingElmInVPre++;
                }

                if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
                  warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
                }
              }

              vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
              setScope(vnode);
              /* istanbul ignore if */

              {
                createChildren(vnode, children, insertedVnodeQueue);

                if (isDef(data)) {
                  invokeCreateHooks(vnode, insertedVnodeQueue);
                }

                insert(parentElm, vnode.elm, refElm);
              }

              if (process.env.NODE_ENV !== 'production' && data && data.pre) {
                creatingElmInVPre--;
              }
            } else if (isTrue(vnode.isComment)) {
              vnode.elm = nodeOps.createComment(vnode.text);
              insert(parentElm, vnode.elm, refElm);
            } else {
              vnode.elm = nodeOps.createTextNode(vnode.text);
              insert(parentElm, vnode.elm, refElm);
            }
          }

          function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
            var i = vnode.data;

            if (isDef(i)) {
              var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

              if (isDef(i = i.hook) && isDef(i = i.init)) {
                i(vnode, false
                /* hydrating */
                , parentElm, refElm);
              } // after calling the init hook, if the vnode is a child component
              // it should've created a child instance and mounted it. the child
              // component also has set the placeholder vnode's elm.
              // in that case we can just return the element and be done.


              if (isDef(vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue);

                if (isTrue(isReactivated)) {
                  reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                }

                return true;
              }
            }
          }

          function initComponent(vnode, insertedVnodeQueue) {
            if (isDef(vnode.data.pendingInsert)) {
              insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
              vnode.data.pendingInsert = null;
            }

            vnode.elm = vnode.componentInstance.$el;

            if (isPatchable(vnode)) {
              invokeCreateHooks(vnode, insertedVnodeQueue);
              setScope(vnode);
            } else {
              // empty component root.
              // skip all element-related modules except for ref (#3455)
              registerRef(vnode); // make sure to invoke the insert hook

              insertedVnodeQueue.push(vnode);
            }
          }

          function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
            var i; // hack for #4339: a reactivated component with inner transition
            // does not trigger because the inner node's created hooks are not called
            // again. It's not ideal to involve module-specific logic in here but
            // there doesn't seem to be a better way to do it.

            var innerNode = vnode;

            while (innerNode.componentInstance) {
              innerNode = innerNode.componentInstance._vnode;

              if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
                for (i = 0; i < cbs.activate.length; ++i) {
                  cbs.activate[i](emptyNode, innerNode);
                }

                insertedVnodeQueue.push(innerNode);
                break;
              }
            } // unlike a newly created component,
            // a reactivated keep-alive component doesn't insert itself


            insert(parentElm, vnode.elm, refElm);
          }

          function insert(parent, elm, ref$$1) {
            if (isDef(parent)) {
              if (isDef(ref$$1)) {
                if (ref$$1.parentNode === parent) {
                  nodeOps.insertBefore(parent, elm, ref$$1);
                }
              } else {
                nodeOps.appendChild(parent, elm);
              }
            }
          }

          function createChildren(vnode, children, insertedVnodeQueue) {
            if (Array.isArray(children)) {
              if (process.env.NODE_ENV !== 'production') {
                checkDuplicateKeys(children);
              }

              for (var i = 0; i < children.length; ++i) {
                createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
              }
            } else if (isPrimitive(vnode.text)) {
              nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
            }
          }

          function isPatchable(vnode) {
            while (vnode.componentInstance) {
              vnode = vnode.componentInstance._vnode;
            }

            return isDef(vnode.tag);
          }

          function invokeCreateHooks(vnode, insertedVnodeQueue) {
            for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
              cbs.create[i$1](emptyNode, vnode);
            }

            i = vnode.data.hook; // Reuse variable

            if (isDef(i)) {
              if (isDef(i.create)) {
                i.create(emptyNode, vnode);
              }

              if (isDef(i.insert)) {
                insertedVnodeQueue.push(vnode);
              }
            }
          } // set scope id attribute for scoped CSS.
          // this is implemented as a special case to avoid the overhead
          // of going through the normal attribute patching process.


          function setScope(vnode) {
            var i;

            if (isDef(i = vnode.fnScopeId)) {
              nodeOps.setStyleScope(vnode.elm, i);
            } else {
              var ancestor = vnode;

              while (ancestor) {
                if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
                  nodeOps.setStyleScope(vnode.elm, i);
                }

                ancestor = ancestor.parent;
              }
            } // for slot content they should also get the scopeId from the host instance.


            if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
              nodeOps.setStyleScope(vnode.elm, i);
            }
          }

          function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
            for (; startIdx <= endIdx; ++startIdx) {
              createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
            }
          }

          function invokeDestroyHook(vnode) {
            var i, j;
            var data = vnode.data;

            if (isDef(data)) {
              if (isDef(i = data.hook) && isDef(i = i.destroy)) {
                i(vnode);
              }

              for (i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](vnode);
              }
            }

            if (isDef(i = vnode.children)) {
              for (j = 0; j < vnode.children.length; ++j) {
                invokeDestroyHook(vnode.children[j]);
              }
            }
          }

          function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
            for (; startIdx <= endIdx; ++startIdx) {
              var ch = vnodes[startIdx];

              if (isDef(ch)) {
                if (isDef(ch.tag)) {
                  removeAndInvokeRemoveHook(ch);
                  invokeDestroyHook(ch);
                } else {
                  // Text node
                  removeNode(ch.elm);
                }
              }
            }
          }

          function removeAndInvokeRemoveHook(vnode, rm) {
            if (isDef(rm) || isDef(vnode.data)) {
              var i;
              var listeners = cbs.remove.length + 1;

              if (isDef(rm)) {
                // we have a recursively passed down rm callback
                // increase the listeners count
                rm.listeners += listeners;
              } else {
                // directly removing
                rm = createRmCb(vnode.elm, listeners);
              } // recursively invoke hooks on child component root node


              if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
                removeAndInvokeRemoveHook(i, rm);
              }

              for (i = 0; i < cbs.remove.length; ++i) {
                cbs.remove[i](vnode, rm);
              }

              if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
                i(vnode, rm);
              } else {
                rm();
              }
            } else {
              removeNode(vnode.elm);
            }
          }

          function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
            var oldStartIdx = 0;
            var newStartIdx = 0;
            var oldEndIdx = oldCh.length - 1;
            var oldStartVnode = oldCh[0];
            var oldEndVnode = oldCh[oldEndIdx];
            var newEndIdx = newCh.length - 1;
            var newStartVnode = newCh[0];
            var newEndVnode = newCh[newEndIdx];
            var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
            // to ensure removed elements stay in correct relative positions
            // during leaving transitions

            var canMove = !removeOnly;

            if (process.env.NODE_ENV !== 'production') {
              checkDuplicateKeys(newCh);
            }

            while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
              if (isUndef(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
              } else if (isUndef(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
              } else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
              } else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
              } else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
              } else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
              } else {
                if (isUndef(oldKeyToIdx)) {
                  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }

                idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

                if (isUndef(idxInOld)) {
                  // New element
                  createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                } else {
                  vnodeToMove = oldCh[idxInOld];

                  if (sameVnode(vnodeToMove, newStartVnode)) {
                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
                    oldCh[idxInOld] = undefined;
                    canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                  } else {
                    // same key but different element. treat as new element
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                  }
                }

                newStartVnode = newCh[++newStartIdx];
              }
            }

            if (oldStartIdx > oldEndIdx) {
              refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
              addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
            } else if (newStartIdx > newEndIdx) {
              removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
          }

          function checkDuplicateKeys(children) {
            var seenKeys = {};

            for (var i = 0; i < children.length; i++) {
              var vnode = children[i];
              var key = vnode.key;

              if (isDef(key)) {
                if (seenKeys[key]) {
                  warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
                } else {
                  seenKeys[key] = true;
                }
              }
            }
          }

          function findIdxInOld(node, oldCh, start, end) {
            for (var i = start; i < end; i++) {
              var c = oldCh[i];

              if (isDef(c) && sameVnode(node, c)) {
                return i;
              }
            }
          }

          function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
            if (oldVnode === vnode) {
              return;
            }

            var elm = vnode.elm = oldVnode.elm;

            if (isTrue(oldVnode.isAsyncPlaceholder)) {
              if (isDef(vnode.asyncFactory.resolved)) {
                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
              } else {
                vnode.isAsyncPlaceholder = true;
              }

              return;
            } // reuse element for static trees.
            // note we only do this if the vnode is cloned -
            // if the new node is not cloned it means the render functions have been
            // reset by the hot-reload-api and we need to do a proper re-render.


            if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
              vnode.componentInstance = oldVnode.componentInstance;
              return;
            }

            var i;
            var data = vnode.data;

            if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
              i(oldVnode, vnode);
            }

            var oldCh = oldVnode.children;
            var ch = vnode.children;

            if (isDef(data) && isPatchable(vnode)) {
              for (i = 0; i < cbs.update.length; ++i) {
                cbs.update[i](oldVnode, vnode);
              }

              if (isDef(i = data.hook) && isDef(i = i.update)) {
                i(oldVnode, vnode);
              }
            }

            if (isUndef(vnode.text)) {
              if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch) {
                  updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
                }
              } else if (isDef(ch)) {
                if (isDef(oldVnode.text)) {
                  nodeOps.setTextContent(elm, '');
                }

                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
              } else if (isDef(oldCh)) {
                removeVnodes(elm, oldCh, 0, oldCh.length - 1);
              } else if (isDef(oldVnode.text)) {
                nodeOps.setTextContent(elm, '');
              }
            } else if (oldVnode.text !== vnode.text) {
              nodeOps.setTextContent(elm, vnode.text);
            }

            if (isDef(data)) {
              if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
                i(oldVnode, vnode);
              }
            }
          }

          function invokeInsertHook(vnode, queue, initial) {
            // delay insert hooks for component root nodes, invoke them after the
            // element is really inserted
            if (isTrue(initial) && isDef(vnode.parent)) {
              vnode.parent.data.pendingInsert = queue;
            } else {
              for (var i = 0; i < queue.length; ++i) {
                queue[i].data.hook.insert(queue[i]);
              }
            }
          }

          var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
          // are already rendered on the client or has no need for initialization
          // Note: style is excluded because it relies on initial clone for future
          // deep updates (#7063).

          var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

          function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
            var i;
            var tag = vnode.tag;
            var data = vnode.data;
            var children = vnode.children;
            inVPre = inVPre || data && data.pre;
            vnode.elm = elm;

            if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
              vnode.isAsyncPlaceholder = true;
              return true;
            } // assert node match


            if (process.env.NODE_ENV !== 'production') {
              if (!assertNodeMatch(elm, vnode, inVPre)) {
                return false;
              }
            }

            if (isDef(data)) {
              if (isDef(i = data.hook) && isDef(i = i.init)) {
                i(vnode, true
                /* hydrating */
                );
              }

              if (isDef(i = vnode.componentInstance)) {
                // child component. it should have hydrated its own tree.
                initComponent(vnode, insertedVnodeQueue);
                return true;
              }
            }

            if (isDef(tag)) {
              if (isDef(children)) {
                // empty element, allow client to pick up and populate children
                if (!elm.hasChildNodes()) {
                  createChildren(vnode, children, insertedVnodeQueue);
                } else {
                  // v-html and domProps: innerHTML
                  if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
                    if (i !== elm.innerHTML) {
                      /* istanbul ignore if */
                      if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                        hydrationBailed = true;
                        console.warn('Parent: ', elm);
                        console.warn('server innerHTML: ', i);
                        console.warn('client innerHTML: ', elm.innerHTML);
                      }

                      return false;
                    }
                  } else {
                    // iterate and compare children lists
                    var childrenMatch = true;
                    var childNode = elm.firstChild;

                    for (var i$1 = 0; i$1 < children.length; i$1++) {
                      if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                        childrenMatch = false;
                        break;
                      }

                      childNode = childNode.nextSibling;
                    } // if childNode is not null, it means the actual childNodes list is
                    // longer than the virtual children list.


                    if (!childrenMatch || childNode) {
                      /* istanbul ignore if */
                      if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                        hydrationBailed = true;
                        console.warn('Parent: ', elm);
                        console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                      }

                      return false;
                    }
                  }
                }
              }

              if (isDef(data)) {
                var fullInvoke = false;

                for (var key in data) {
                  if (!isRenderedModule(key)) {
                    fullInvoke = true;
                    invokeCreateHooks(vnode, insertedVnodeQueue);
                    break;
                  }
                }

                if (!fullInvoke && data['class']) {
                  // ensure collecting deps for deep class bindings for future updates
                  traverse(data['class']);
                }
              }
            } else if (elm.data !== vnode.text) {
              elm.data = vnode.text;
            }

            return true;
          }

          function assertNodeMatch(node, vnode, inVPre) {
            if (isDef(vnode.tag)) {
              return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
            } else {
              return node.nodeType === (vnode.isComment ? 8 : 3);
            }
          }

          return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
            if (isUndef(vnode)) {
              if (isDef(oldVnode)) {
                invokeDestroyHook(oldVnode);
              }

              return;
            }

            var isInitialPatch = false;
            var insertedVnodeQueue = [];

            if (isUndef(oldVnode)) {
              // empty mount (likely as component), create new root element
              isInitialPatch = true;
              createElm(vnode, insertedVnodeQueue, parentElm, refElm);
            } else {
              var isRealElement = isDef(oldVnode.nodeType);

              if (!isRealElement && sameVnode(oldVnode, vnode)) {
                // patch existing root node
                patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
              } else {
                if (isRealElement) {
                  // mounting to a real element
                  // check if this is server-rendered content and if we can perform
                  // a successful hydration.
                  if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                    oldVnode.removeAttribute(SSR_ATTR);
                    hydrating = true;
                  }

                  if (isTrue(hydrating)) {
                    if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                      invokeInsertHook(vnode, insertedVnodeQueue, true);
                      return oldVnode;
                    } else if (process.env.NODE_ENV !== 'production') {
                      warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
                    }
                  } // either not server-rendered, or hydration failed.
                  // create an empty node and replace it


                  oldVnode = emptyNodeAt(oldVnode);
                } // replacing existing element


                var oldElm = oldVnode.elm;
                var parentElm$1 = nodeOps.parentNode(oldElm); // create new node

                createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
                // leaving transition. Only happens when combining transition +
                // keep-alive + HOCs. (#4590)
                oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

                if (isDef(vnode.parent)) {
                  var ancestor = vnode.parent;
                  var patchable = isPatchable(vnode);

                  while (ancestor) {
                    for (var i = 0; i < cbs.destroy.length; ++i) {
                      cbs.destroy[i](ancestor);
                    }

                    ancestor.elm = vnode.elm;

                    if (patchable) {
                      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                        cbs.create[i$1](emptyNode, ancestor);
                      } // #6513
                      // invoke insert hooks that may have been merged by create hooks.
                      // e.g. for directives that uses the "inserted" hook.


                      var insert = ancestor.data.hook.insert;

                      if (insert.merged) {
                        // start at index 1 to avoid re-invoking component mounted hook
                        for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                          insert.fns[i$2]();
                        }
                      }
                    } else {
                      registerRef(ancestor);
                    }

                    ancestor = ancestor.parent;
                  }
                } // destroy old node


                if (isDef(parentElm$1)) {
                  removeVnodes(parentElm$1, [oldVnode], 0, 0);
                } else if (isDef(oldVnode.tag)) {
                  invokeDestroyHook(oldVnode);
                }
              }
            }

            invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
            return vnode.elm;
          };
        }
        /*  */


        var directives = {
          create: updateDirectives,
          update: updateDirectives,
          destroy: function unbindDirectives(vnode) {
            updateDirectives(vnode, emptyNode);
          }
        };

        function updateDirectives(oldVnode, vnode) {
          if (oldVnode.data.directives || vnode.data.directives) {
            _update(oldVnode, vnode);
          }
        }

        function _update(oldVnode, vnode) {
          var isCreate = oldVnode === emptyNode;
          var isDestroy = vnode === emptyNode;
          var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
          var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
          var dirsWithInsert = [];
          var dirsWithPostpatch = [];
          var key, oldDir, dir;

          for (key in newDirs) {
            oldDir = oldDirs[key];
            dir = newDirs[key];

            if (!oldDir) {
              // new directive, bind
              callHook$1(dir, 'bind', vnode, oldVnode);

              if (dir.def && dir.def.inserted) {
                dirsWithInsert.push(dir);
              }
            } else {
              // existing directive, update
              dir.oldValue = oldDir.value;
              callHook$1(dir, 'update', vnode, oldVnode);

              if (dir.def && dir.def.componentUpdated) {
                dirsWithPostpatch.push(dir);
              }
            }
          }

          if (dirsWithInsert.length) {
            var callInsert = function callInsert() {
              for (var i = 0; i < dirsWithInsert.length; i++) {
                callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
              }
            };

            if (isCreate) {
              mergeVNodeHook(vnode, 'insert', callInsert);
            } else {
              callInsert();
            }
          }

          if (dirsWithPostpatch.length) {
            mergeVNodeHook(vnode, 'postpatch', function () {
              for (var i = 0; i < dirsWithPostpatch.length; i++) {
                callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
              }
            });
          }

          if (!isCreate) {
            for (key in oldDirs) {
              if (!newDirs[key]) {
                // no longer present, unbind
                callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
              }
            }
          }
        }

        var emptyModifiers = Object.create(null);

        function normalizeDirectives$1(dirs, vm) {
          var res = Object.create(null);

          if (!dirs) {
            // $flow-disable-line
            return res;
          }

          var i, dir;

          for (i = 0; i < dirs.length; i++) {
            dir = dirs[i];

            if (!dir.modifiers) {
              // $flow-disable-line
              dir.modifiers = emptyModifiers;
            }

            res[getRawDirName(dir)] = dir;
            dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
          } // $flow-disable-line


          return res;
        }

        function getRawDirName(dir) {
          return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
        }

        function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
          var fn = dir.def && dir.def[hook];

          if (fn) {
            try {
              fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
            } catch (e) {
              handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
            }
          }
        }

        var baseModules = [ref, directives];
        /*  */

        function updateAttrs(oldVnode, vnode) {
          var opts = vnode.componentOptions;

          if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
            return;
          }

          if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
            return;
          }

          var key, cur, old;
          var elm = vnode.elm;
          var oldAttrs = oldVnode.data.attrs || {};
          var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

          if (isDef(attrs.__ob__)) {
            attrs = vnode.data.attrs = extend({}, attrs);
          }

          for (key in attrs) {
            cur = attrs[key];
            old = oldAttrs[key];

            if (old !== cur) {
              setAttr(elm, key, cur);
            }
          } // #4391: in IE9, setting type can reset value for input[type=radio]
          // #6666: IE/Edge forces progress value down to 1 before setting a max

          /* istanbul ignore if */


          if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
            setAttr(elm, 'value', attrs.value);
          }

          for (key in oldAttrs) {
            if (isUndef(attrs[key])) {
              if (isXlink(key)) {
                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
              } else if (!isEnumeratedAttr(key)) {
                elm.removeAttribute(key);
              }
            }
          }
        }

        function setAttr(el, key, value) {
          if (el.tagName.indexOf('-') > -1) {
            baseSetAttr(el, key, value);
          } else if (isBooleanAttr(key)) {
            // set attribute for blank value
            // e.g. <option disabled>Select one</option>
            if (isFalsyAttrValue(value)) {
              el.removeAttribute(key);
            } else {
              // technically allowfullscreen is a boolean attribute for <iframe>,
              // but Flash expects a value of "true" when used on <embed> tag
              value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
              el.setAttribute(key, value);
            }
          } else if (isEnumeratedAttr(key)) {
            el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
          } else if (isXlink(key)) {
            if (isFalsyAttrValue(value)) {
              el.removeAttributeNS(xlinkNS, getXlinkProp(key));
            } else {
              el.setAttributeNS(xlinkNS, key, value);
            }
          } else {
            baseSetAttr(el, key, value);
          }
        }

        function baseSetAttr(el, key, value) {
          if (isFalsyAttrValue(value)) {
            el.removeAttribute(key);
          } else {
            // #7138: IE10 & 11 fires input event when setting placeholder on
            // <textarea>... block the first input event and remove the blocker
            // immediately.

            /* istanbul ignore if */
            if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {
              var blocker = function blocker(e) {
                e.stopImmediatePropagation();
                el.removeEventListener('input', blocker);
              };

              el.addEventListener('input', blocker); // $flow-disable-line

              el.__ieph = true;
              /* IE placeholder patched */
            }

            el.setAttribute(key, value);
          }
        }

        var attrs = {
          create: updateAttrs,
          update: updateAttrs
          /*  */

        };

        function updateClass(oldVnode, vnode) {
          var el = vnode.elm;
          var data = vnode.data;
          var oldData = oldVnode.data;

          if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
            return;
          }

          var cls = genClassForVnode(vnode); // handle transition classes

          var transitionClass = el._transitionClasses;

          if (isDef(transitionClass)) {
            cls = concat(cls, stringifyClass(transitionClass));
          } // set the class


          if (cls !== el._prevClass) {
            el.setAttribute('class', cls);
            el._prevClass = cls;
          }
        }

        var klass = {
          create: updateClass,
          update: updateClass
          /*  */

          /*  */
          // add a raw attr (use this in preTransforms)
          // note: this only removes the attr from the Array (attrsList) so that it
          // doesn't get processed by processAttrs.
          // By default it does NOT remove it from the map (attrsMap) because the map is
          // needed during codegen.

          /*  */

          /**
           * Cross-platform code generation for component v-model
           */

          /**
           * Cross-platform codegen helper for generating v-model value assignment code.
           */

          /*  */
          // in some cases, the event used has to be determined at runtime
          // so we used some reserved tokens during compile.

        };
        var RANGE_TOKEN = '__r';
        var CHECKBOX_RADIO_TOKEN = '__c';
        /*  */
        // normalize v-model event tokens that can only be determined at runtime.
        // it's important to place the event as the first in the array because
        // the whole point is ensuring the v-model callback gets called before
        // user-attached handlers.

        function normalizeEvents(on) {
          /* istanbul ignore if */
          if (isDef(on[RANGE_TOKEN])) {
            // IE input[type=range] only supports `change` event
            var event = isIE ? 'change' : 'input';
            on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
            delete on[RANGE_TOKEN];
          } // This was originally intended to fix #4521 but no longer necessary
          // after 2.5. Keeping it for backwards compat with generated code from < 2.4

          /* istanbul ignore if */


          if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
            on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
            delete on[CHECKBOX_RADIO_TOKEN];
          }
        }

        var target$1;

        function createOnceHandler(handler, event, capture) {
          var _target = target$1; // save current target element in closure

          return function onceHandler() {
            var res = handler.apply(null, arguments);

            if (res !== null) {
              remove$2(event, onceHandler, capture, _target);
            }
          };
        }

        function add$1(event, handler, once$$1, capture, passive) {
          handler = withMacroTask(handler);

          if (once$$1) {
            handler = createOnceHandler(handler, event, capture);
          }

          target$1.addEventListener(event, handler, supportsPassive ? {
            capture: capture,
            passive: passive
          } : capture);
        }

        function remove$2(event, handler, capture, _target) {
          (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
        }

        function updateDOMListeners(oldVnode, vnode) {
          if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
            return;
          }

          var on = vnode.data.on || {};
          var oldOn = oldVnode.data.on || {};
          target$1 = vnode.elm;
          normalizeEvents(on);
          updateListeners(on, oldOn, add$1, remove$2, vnode.context);
          target$1 = undefined;
        }

        var events = {
          create: updateDOMListeners,
          update: updateDOMListeners
          /*  */

        };

        function updateDOMProps(oldVnode, vnode) {
          if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
            return;
          }

          var key, cur;
          var elm = vnode.elm;
          var oldProps = oldVnode.data.domProps || {};
          var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

          if (isDef(props.__ob__)) {
            props = vnode.data.domProps = extend({}, props);
          }

          for (key in oldProps) {
            if (isUndef(props[key])) {
              elm[key] = '';
            }
          }

          for (key in props) {
            cur = props[key]; // ignore children if the node has textContent or innerHTML,
            // as these will throw away existing DOM nodes and cause removal errors
            // on subsequent patches (#3360)

            if (key === 'textContent' || key === 'innerHTML') {
              if (vnode.children) {
                vnode.children.length = 0;
              }

              if (cur === oldProps[key]) {
                continue;
              } // #6601 work around Chrome version <= 55 bug where single textNode
              // replaced by innerHTML/textContent retains its parentNode property


              if (elm.childNodes.length === 1) {
                elm.removeChild(elm.childNodes[0]);
              }
            }

            if (key === 'value') {
              // store value as _value as well since
              // non-string values will be stringified
              elm._value = cur; // avoid resetting cursor position when value is the same

              var strCur = isUndef(cur) ? '' : String(cur);

              if (shouldUpdateValue(elm, strCur)) {
                elm.value = strCur;
              }
            } else {
              elm[key] = cur;
            }
          }
        } // check platforms/web/util/attrs.js acceptValue


        function shouldUpdateValue(elm, checkVal) {
          return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
        }

        function isNotInFocusAndDirty(elm, checkVal) {
          // return true when textbox (.number and .trim) loses focus and its value is
          // not equal to the updated value
          var notInFocus = true; // #6157
          // work around IE bug when accessing document.activeElement in an iframe

          try {
            notInFocus = document.activeElement !== elm;
          } catch (e) {}

          return notInFocus && elm.value !== checkVal;
        }

        function isDirtyWithModifiers(elm, newVal) {
          var value = elm.value;
          var modifiers = elm._vModifiers; // injected by v-model runtime

          if (isDef(modifiers)) {
            if (modifiers.lazy) {
              // inputs with lazy should only be updated when not in focus
              return false;
            }

            if (modifiers.number) {
              return toNumber(value) !== toNumber(newVal);
            }

            if (modifiers.trim) {
              return value.trim() !== newVal.trim();
            }
          }

          return value !== newVal;
        }

        var domProps = {
          create: updateDOMProps,
          update: updateDOMProps
          /*  */

        };
        var parseStyleText = cached(function (cssText) {
          var res = {};
          var listDelimiter = /;(?![^(]*\))/g;
          var propertyDelimiter = /:(.+)/;
          cssText.split(listDelimiter).forEach(function (item) {
            if (item) {
              var tmp = item.split(propertyDelimiter);
              tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
            }
          });
          return res;
        }); // merge static and dynamic style data on the same vnode

        function normalizeStyleData(data) {
          var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
          // and is always a fresh object, so it's safe to merge into it

          return data.staticStyle ? extend(data.staticStyle, style) : style;
        } // normalize possible array / string values into Object


        function normalizeStyleBinding(bindingStyle) {
          if (Array.isArray(bindingStyle)) {
            return toObject(bindingStyle);
          }

          if (typeof bindingStyle === 'string') {
            return parseStyleText(bindingStyle);
          }

          return bindingStyle;
        }
        /**
         * parent component style should be after child's
         * so that parent component's style could override it
         */


        function getStyle(vnode, checkChild) {
          var res = {};
          var styleData;

          if (checkChild) {
            var childNode = vnode;

            while (childNode.componentInstance) {
              childNode = childNode.componentInstance._vnode;

              if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
                extend(res, styleData);
              }
            }
          }

          if (styleData = normalizeStyleData(vnode.data)) {
            extend(res, styleData);
          }

          var parentNode = vnode;

          while (parentNode = parentNode.parent) {
            if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
              extend(res, styleData);
            }
          }

          return res;
        }
        /*  */


        var cssVarRE = /^--/;
        var importantRE = /\s*!important$/;

        var setProp = function setProp(el, name, val) {
          /* istanbul ignore if */
          if (cssVarRE.test(name)) {
            el.style.setProperty(name, val);
          } else if (importantRE.test(val)) {
            el.style.setProperty(name, val.replace(importantRE, ''), 'important');
          } else {
            var normalizedName = normalize(name);

            if (Array.isArray(val)) {
              // Support values array created by autoprefixer, e.g.
              // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
              // Set them one by one, and the browser will only set those it can recognize
              for (var i = 0, len = val.length; i < len; i++) {
                el.style[normalizedName] = val[i];
              }
            } else {
              el.style[normalizedName] = val;
            }
          }
        };

        var vendorNames = ['Webkit', 'Moz', 'ms'];
        var emptyStyle;
        var normalize = cached(function (prop) {
          emptyStyle = emptyStyle || document.createElement('div').style;
          prop = camelize(prop);

          if (prop !== 'filter' && prop in emptyStyle) {
            return prop;
          }

          var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

          for (var i = 0; i < vendorNames.length; i++) {
            var name = vendorNames[i] + capName;

            if (name in emptyStyle) {
              return name;
            }
          }
        });

        function updateStyle(oldVnode, vnode) {
          var data = vnode.data;
          var oldData = oldVnode.data;

          if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
            return;
          }

          var cur, name;
          var el = vnode.elm;
          var oldStaticStyle = oldData.staticStyle;
          var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

          var oldStyle = oldStaticStyle || oldStyleBinding;
          var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
          // make sure to clone it if it's reactive, since the user likely wants
          // to mutate it.

          vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
          var newStyle = getStyle(vnode, true);

          for (name in oldStyle) {
            if (isUndef(newStyle[name])) {
              setProp(el, name, '');
            }
          }

          for (name in newStyle) {
            cur = newStyle[name];

            if (cur !== oldStyle[name]) {
              // ie9 setting to null has no effect, must use empty string
              setProp(el, name, cur == null ? '' : cur);
            }
          }
        }

        var style = {
          create: updateStyle,
          update: updateStyle
          /*  */

          /**
           * Add class with compatibility for SVG since classList is not supported on
           * SVG elements in IE
           */

        };

        function addClass(el, cls) {
          /* istanbul ignore if */
          if (!cls || !(cls = cls.trim())) {
            return;
          }
          /* istanbul ignore else */


          if (el.classList) {
            if (cls.indexOf(' ') > -1) {
              cls.split(/\s+/).forEach(function (c) {
                return el.classList.add(c);
              });
            } else {
              el.classList.add(cls);
            }
          } else {
            var cur = " " + (el.getAttribute('class') || '') + " ";

            if (cur.indexOf(' ' + cls + ' ') < 0) {
              el.setAttribute('class', (cur + cls).trim());
            }
          }
        }
        /**
         * Remove class with compatibility for SVG since classList is not supported on
         * SVG elements in IE
         */


        function removeClass(el, cls) {
          /* istanbul ignore if */
          if (!cls || !(cls = cls.trim())) {
            return;
          }
          /* istanbul ignore else */


          if (el.classList) {
            if (cls.indexOf(' ') > -1) {
              cls.split(/\s+/).forEach(function (c) {
                return el.classList.remove(c);
              });
            } else {
              el.classList.remove(cls);
            }

            if (!el.classList.length) {
              el.removeAttribute('class');
            }
          } else {
            var cur = " " + (el.getAttribute('class') || '') + " ";
            var tar = ' ' + cls + ' ';

            while (cur.indexOf(tar) >= 0) {
              cur = cur.replace(tar, ' ');
            }

            cur = cur.trim();

            if (cur) {
              el.setAttribute('class', cur);
            } else {
              el.removeAttribute('class');
            }
          }
        }
        /*  */


        function resolveTransition(def) {
          if (!def) {
            return;
          }
          /* istanbul ignore else */


          if (_typeof2(def) === 'object') {
            var res = {};

            if (def.css !== false) {
              extend(res, autoCssTransition(def.name || 'v'));
            }

            extend(res, def);
            return res;
          } else if (typeof def === 'string') {
            return autoCssTransition(def);
          }
        }

        var autoCssTransition = cached(function (name) {
          return {
            enterClass: name + "-enter",
            enterToClass: name + "-enter-to",
            enterActiveClass: name + "-enter-active",
            leaveClass: name + "-leave",
            leaveToClass: name + "-leave-to",
            leaveActiveClass: name + "-leave-active"
          };
        });
        var hasTransition = inBrowser && !isIE9;
        var TRANSITION = 'transition';
        var ANIMATION = 'animation'; // Transition property/event sniffing

        var transitionProp = 'transition';
        var transitionEndEvent = 'transitionend';
        var animationProp = 'animation';
        var animationEndEvent = 'animationend';

        if (hasTransition) {
          /* istanbul ignore if */
          if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
            transitionProp = 'WebkitTransition';
            transitionEndEvent = 'webkitTransitionEnd';
          }

          if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
            animationProp = 'WebkitAnimation';
            animationEndEvent = 'webkitAnimationEnd';
          }
        } // binding to window is necessary to make hot reload work in IE in strict mode


        var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
        /* istanbul ignore next */
        function (fn) {
          return fn();
        };

        function nextFrame(fn) {
          raf(function () {
            raf(fn);
          });
        }

        function addTransitionClass(el, cls) {
          var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

          if (transitionClasses.indexOf(cls) < 0) {
            transitionClasses.push(cls);
            addClass(el, cls);
          }
        }

        function removeTransitionClass(el, cls) {
          if (el._transitionClasses) {
            remove(el._transitionClasses, cls);
          }

          removeClass(el, cls);
        }

        function whenTransitionEnds(el, expectedType, cb) {
          var ref = getTransitionInfo(el, expectedType);
          var type = ref.type;
          var timeout = ref.timeout;
          var propCount = ref.propCount;

          if (!type) {
            return cb();
          }

          var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
          var ended = 0;

          var end = function end() {
            el.removeEventListener(event, onEnd);
            cb();
          };

          var onEnd = function onEnd(e) {
            if (e.target === el) {
              if (++ended >= propCount) {
                end();
              }
            }
          };

          setTimeout(function () {
            if (ended < propCount) {
              end();
            }
          }, timeout + 1);
          el.addEventListener(event, onEnd);
        }

        var transformRE = /\b(transform|all)(,|$)/;

        function getTransitionInfo(el, expectedType) {
          var styles = window.getComputedStyle(el);
          var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
          var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
          var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
          var animationDelays = styles[animationProp + 'Delay'].split(', ');
          var animationDurations = styles[animationProp + 'Duration'].split(', ');
          var animationTimeout = getTimeout(animationDelays, animationDurations);
          var type;
          var timeout = 0;
          var propCount = 0;
          /* istanbul ignore if */

          if (expectedType === TRANSITION) {
            if (transitionTimeout > 0) {
              type = TRANSITION;
              timeout = transitionTimeout;
              propCount = transitionDurations.length;
            }
          } else if (expectedType === ANIMATION) {
            if (animationTimeout > 0) {
              type = ANIMATION;
              timeout = animationTimeout;
              propCount = animationDurations.length;
            }
          } else {
            timeout = Math.max(transitionTimeout, animationTimeout);
            type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
            propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
          }

          var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
          return {
            type: type,
            timeout: timeout,
            propCount: propCount,
            hasTransform: hasTransform
          };
        }

        function getTimeout(delays, durations) {
          /* istanbul ignore next */
          while (delays.length < durations.length) {
            delays = delays.concat(delays);
          }

          return Math.max.apply(null, durations.map(function (d, i) {
            return toMs(d) + toMs(delays[i]);
          }));
        }

        function toMs(s) {
          return Number(s.slice(0, -1)) * 1000;
        }
        /*  */


        function enter(vnode, toggleDisplay) {
          var el = vnode.elm; // call leave callback now

          if (isDef(el._leaveCb)) {
            el._leaveCb.cancelled = true;

            el._leaveCb();
          }

          var data = resolveTransition(vnode.data.transition);

          if (isUndef(data)) {
            return;
          }
          /* istanbul ignore if */


          if (isDef(el._enterCb) || el.nodeType !== 1) {
            return;
          }

          var css = data.css;
          var type = data.type;
          var enterClass = data.enterClass;
          var enterToClass = data.enterToClass;
          var enterActiveClass = data.enterActiveClass;
          var appearClass = data.appearClass;
          var appearToClass = data.appearToClass;
          var appearActiveClass = data.appearActiveClass;
          var beforeEnter = data.beforeEnter;
          var enter = data.enter;
          var afterEnter = data.afterEnter;
          var enterCancelled = data.enterCancelled;
          var beforeAppear = data.beforeAppear;
          var appear = data.appear;
          var afterAppear = data.afterAppear;
          var appearCancelled = data.appearCancelled;
          var duration = data.duration; // activeInstance will always be the <transition> component managing this
          // transition. One edge case to check is when the <transition> is placed
          // as the root node of a child component. In that case we need to check
          // <transition>'s parent for appear check.

          var context = activeInstance;
          var transitionNode = activeInstance.$vnode;

          while (transitionNode && transitionNode.parent) {
            transitionNode = transitionNode.parent;
            context = transitionNode.context;
          }

          var isAppear = !context._isMounted || !vnode.isRootInsert;

          if (isAppear && !appear && appear !== '') {
            return;
          }

          var startClass = isAppear && appearClass ? appearClass : enterClass;
          var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
          var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
          var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
          var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
          var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
          var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
          var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

          if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
            checkDuration(explicitEnterDuration, 'enter', vnode);
          }

          var expectsCSS = css !== false && !isIE9;
          var userWantsControl = getHookArgumentsLength(enterHook);
          var cb = el._enterCb = once(function () {
            if (expectsCSS) {
              removeTransitionClass(el, toClass);
              removeTransitionClass(el, activeClass);
            }

            if (cb.cancelled) {
              if (expectsCSS) {
                removeTransitionClass(el, startClass);
              }

              enterCancelledHook && enterCancelledHook(el);
            } else {
              afterEnterHook && afterEnterHook(el);
            }

            el._enterCb = null;
          });

          if (!vnode.data.show) {
            // remove pending leave element on enter by injecting an insert hook
            mergeVNodeHook(vnode, 'insert', function () {
              var parent = el.parentNode;
              var pendingNode = parent && parent._pending && parent._pending[vnode.key];

              if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
                pendingNode.elm._leaveCb();
              }

              enterHook && enterHook(el, cb);
            });
          } // start enter transition


          beforeEnterHook && beforeEnterHook(el);

          if (expectsCSS) {
            addTransitionClass(el, startClass);
            addTransitionClass(el, activeClass);
            nextFrame(function () {
              removeTransitionClass(el, startClass);

              if (!cb.cancelled) {
                addTransitionClass(el, toClass);

                if (!userWantsControl) {
                  if (isValidDuration(explicitEnterDuration)) {
                    setTimeout(cb, explicitEnterDuration);
                  } else {
                    whenTransitionEnds(el, type, cb);
                  }
                }
              }
            });
          }

          if (vnode.data.show) {
            toggleDisplay && toggleDisplay();
            enterHook && enterHook(el, cb);
          }

          if (!expectsCSS && !userWantsControl) {
            cb();
          }
        }

        function leave(vnode, rm) {
          var el = vnode.elm; // call enter callback now

          if (isDef(el._enterCb)) {
            el._enterCb.cancelled = true;

            el._enterCb();
          }

          var data = resolveTransition(vnode.data.transition);

          if (isUndef(data) || el.nodeType !== 1) {
            return rm();
          }
          /* istanbul ignore if */


          if (isDef(el._leaveCb)) {
            return;
          }

          var css = data.css;
          var type = data.type;
          var leaveClass = data.leaveClass;
          var leaveToClass = data.leaveToClass;
          var leaveActiveClass = data.leaveActiveClass;
          var beforeLeave = data.beforeLeave;
          var leave = data.leave;
          var afterLeave = data.afterLeave;
          var leaveCancelled = data.leaveCancelled;
          var delayLeave = data.delayLeave;
          var duration = data.duration;
          var expectsCSS = css !== false && !isIE9;
          var userWantsControl = getHookArgumentsLength(leave);
          var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

          if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
            checkDuration(explicitLeaveDuration, 'leave', vnode);
          }

          var cb = el._leaveCb = once(function () {
            if (el.parentNode && el.parentNode._pending) {
              el.parentNode._pending[vnode.key] = null;
            }

            if (expectsCSS) {
              removeTransitionClass(el, leaveToClass);
              removeTransitionClass(el, leaveActiveClass);
            }

            if (cb.cancelled) {
              if (expectsCSS) {
                removeTransitionClass(el, leaveClass);
              }

              leaveCancelled && leaveCancelled(el);
            } else {
              rm();
              afterLeave && afterLeave(el);
            }

            el._leaveCb = null;
          });

          if (delayLeave) {
            delayLeave(performLeave);
          } else {
            performLeave();
          }

          function performLeave() {
            // the delayed leave may have already been cancelled
            if (cb.cancelled) {
              return;
            } // record leaving element


            if (!vnode.data.show) {
              (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
            }

            beforeLeave && beforeLeave(el);

            if (expectsCSS) {
              addTransitionClass(el, leaveClass);
              addTransitionClass(el, leaveActiveClass);
              nextFrame(function () {
                removeTransitionClass(el, leaveClass);

                if (!cb.cancelled) {
                  addTransitionClass(el, leaveToClass);

                  if (!userWantsControl) {
                    if (isValidDuration(explicitLeaveDuration)) {
                      setTimeout(cb, explicitLeaveDuration);
                    } else {
                      whenTransitionEnds(el, type, cb);
                    }
                  }
                }
              });
            }

            leave && leave(el, cb);

            if (!expectsCSS && !userWantsControl) {
              cb();
            }
          }
        } // only used in dev mode


        function checkDuration(val, name, vnode) {
          if (typeof val !== 'number') {
            warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
          } else if (isNaN(val)) {
            warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
          }
        }

        function isValidDuration(val) {
          return typeof val === 'number' && !isNaN(val);
        }
        /**
         * Normalize a transition hook's argument length. The hook may be:
         * - a merged hook (invoker) with the original in .fns
         * - a wrapped component method (check ._length)
         * - a plain function (.length)
         */


        function getHookArgumentsLength(fn) {
          if (isUndef(fn)) {
            return false;
          }

          var invokerFns = fn.fns;

          if (isDef(invokerFns)) {
            // invoker
            return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
          } else {
            return (fn._length || fn.length) > 1;
          }
        }

        function _enter(_, vnode) {
          if (vnode.data.show !== true) {
            enter(vnode);
          }
        }

        var transition = inBrowser ? {
          create: _enter,
          activate: _enter,
          remove: function remove$$1(vnode, rm) {
            /* istanbul ignore else */
            if (vnode.data.show !== true) {
              leave(vnode, rm);
            } else {
              rm();
            }
          }
        } : {};
        var platformModules = [attrs, klass, events, domProps, style, transition];
        /*  */
        // the directive module should be applied last, after all
        // built-in modules have been applied.

        var modules = platformModules.concat(baseModules);
        var patch = createPatchFunction({
          nodeOps: nodeOps,
          modules: modules
        });
        /**
         * Not type checking this file because flow doesn't like attaching
         * properties to Elements.
         */

        /* istanbul ignore if */

        if (isIE9) {
          // http://www.matts411.com/post/internet-explorer-9-oninput/
          document.addEventListener('selectionchange', function () {
            var el = document.activeElement;

            if (el && el.vmodel) {
              trigger(el, 'input');
            }
          });
        }

        var directive = {
          inserted: function inserted(el, binding, vnode, oldVnode) {
            if (vnode.tag === 'select') {
              // #6903
              if (oldVnode.elm && !oldVnode.elm._vOptions) {
                mergeVNodeHook(vnode, 'postpatch', function () {
                  directive.componentUpdated(el, binding, vnode);
                });
              } else {
                setSelected(el, binding, vnode.context);
              }

              el._vOptions = [].map.call(el.options, getValue);
            } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
              el._vModifiers = binding.modifiers;

              if (!binding.modifiers.lazy) {
                el.addEventListener('compositionstart', onCompositionStart);
                el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
                // switching focus before confirming composition choice
                // this also fixes the issue where some browsers e.g. iOS Chrome
                // fires "change" instead of "input" on autocomplete.

                el.addEventListener('change', onCompositionEnd);
                /* istanbul ignore if */

                if (isIE9) {
                  el.vmodel = true;
                }
              }
            }
          },
          componentUpdated: function componentUpdated(el, binding, vnode) {
            if (vnode.tag === 'select') {
              setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
              // it's possible that the value is out-of-sync with the rendered options.
              // detect such cases and filter out values that no longer has a matching
              // option in the DOM.

              var prevOptions = el._vOptions;
              var curOptions = el._vOptions = [].map.call(el.options, getValue);

              if (curOptions.some(function (o, i) {
                return !looseEqual(o, prevOptions[i]);
              })) {
                // trigger change event if
                // no matching option found for at least one value
                var needReset = el.multiple ? binding.value.some(function (v) {
                  return hasNoMatchingOption(v, curOptions);
                }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

                if (needReset) {
                  trigger(el, 'change');
                }
              }
            }
          }
        };

        function setSelected(el, binding, vm) {
          actuallySetSelected(el, binding, vm);
          /* istanbul ignore if */

          if (isIE || isEdge) {
            setTimeout(function () {
              actuallySetSelected(el, binding, vm);
            }, 0);
          }
        }

        function actuallySetSelected(el, binding, vm) {
          var value = binding.value;
          var isMultiple = el.multiple;

          if (isMultiple && !Array.isArray(value)) {
            process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
            return;
          }

          var selected, option;

          for (var i = 0, l = el.options.length; i < l; i++) {
            option = el.options[i];

            if (isMultiple) {
              selected = looseIndexOf(value, getValue(option)) > -1;

              if (option.selected !== selected) {
                option.selected = selected;
              }
            } else {
              if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i) {
                  el.selectedIndex = i;
                }

                return;
              }
            }
          }

          if (!isMultiple) {
            el.selectedIndex = -1;
          }
        }

        function hasNoMatchingOption(value, options) {
          return options.every(function (o) {
            return !looseEqual(o, value);
          });
        }

        function getValue(option) {
          return '_value' in option ? option._value : option.value;
        }

        function onCompositionStart(e) {
          e.target.composing = true;
        }

        function onCompositionEnd(e) {
          // prevent triggering an input event for no reason
          if (!e.target.composing) {
            return;
          }

          e.target.composing = false;
          trigger(e.target, 'input');
        }

        function trigger(el, type) {
          var e = document.createEvent('HTMLEvents');
          e.initEvent(type, true, true);
          el.dispatchEvent(e);
        }
        /*  */
        // recursively search for possible transition defined inside the component root


        function locateNode(vnode) {
          return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
        }

        var show = {
          bind: function bind(el, ref, vnode) {
            var value = ref.value;
            vnode = locateNode(vnode);
            var transition$$1 = vnode.data && vnode.data.transition;
            var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

            if (value && transition$$1) {
              vnode.data.show = true;
              enter(vnode, function () {
                el.style.display = originalDisplay;
              });
            } else {
              el.style.display = value ? originalDisplay : 'none';
            }
          },
          update: function update(el, ref, vnode) {
            var value = ref.value;
            var oldValue = ref.oldValue;
            /* istanbul ignore if */

            if (!value === !oldValue) {
              return;
            }

            vnode = locateNode(vnode);
            var transition$$1 = vnode.data && vnode.data.transition;

            if (transition$$1) {
              vnode.data.show = true;

              if (value) {
                enter(vnode, function () {
                  el.style.display = el.__vOriginalDisplay;
                });
              } else {
                leave(vnode, function () {
                  el.style.display = 'none';
                });
              }
            } else {
              el.style.display = value ? el.__vOriginalDisplay : 'none';
            }
          },
          unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
            if (!isDestroy) {
              el.style.display = el.__vOriginalDisplay;
            }
          }
        };
        var platformDirectives = {
          model: directive,
          show: show
          /*  */
          // Provides transition support for a single element/component.
          // supports transition mode (out-in / in-out)

        };
        var transitionProps = {
          name: String,
          appear: Boolean,
          css: Boolean,
          mode: String,
          type: String,
          enterClass: String,
          leaveClass: String,
          enterToClass: String,
          leaveToClass: String,
          enterActiveClass: String,
          leaveActiveClass: String,
          appearClass: String,
          appearActiveClass: String,
          appearToClass: String,
          duration: [Number, String, Object]
        }; // in case the child is also an abstract component, e.g. <keep-alive>
        // we want to recursively retrieve the real component to be rendered

        function getRealChild(vnode) {
          var compOptions = vnode && vnode.componentOptions;

          if (compOptions && compOptions.Ctor.options.abstract) {
            return getRealChild(getFirstComponentChild(compOptions.children));
          } else {
            return vnode;
          }
        }

        function extractTransitionData(comp) {
          var data = {};
          var options = comp.$options; // props

          for (var key in options.propsData) {
            data[key] = comp[key];
          } // events.
          // extract listeners and pass them directly to the transition methods


          var listeners = options._parentListeners;

          for (var key$1 in listeners) {
            data[camelize(key$1)] = listeners[key$1];
          }

          return data;
        }

        function placeholder(h, rawChild) {
          if (/\d-keep-alive$/.test(rawChild.tag)) {
            return h('keep-alive', {
              props: rawChild.componentOptions.propsData
            });
          }
        }

        function hasParentTransition(vnode) {
          while (vnode = vnode.parent) {
            if (vnode.data.transition) {
              return true;
            }
          }
        }

        function isSameChild(child, oldChild) {
          return oldChild.key === child.key && oldChild.tag === child.tag;
        }

        var Transition = {
          name: 'transition',
          props: transitionProps,
          abstract: true,
          render: function render(h) {
            var this$1 = this;
            var children = this.$slots.default;

            if (!children) {
              return;
            } // filter out text nodes (possible whitespaces)


            children = children.filter(function (c) {
              return c.tag || isAsyncPlaceholder(c);
            });
            /* istanbul ignore if */

            if (!children.length) {
              return;
            } // warn multiple elements


            if (process.env.NODE_ENV !== 'production' && children.length > 1) {
              warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
            }

            var mode = this.mode; // warn invalid mode

            if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
              warn('invalid <transition> mode: ' + mode, this.$parent);
            }

            var rawChild = children[0]; // if this is a component root node and the component's
            // parent container node also has transition, skip.

            if (hasParentTransition(this.$vnode)) {
              return rawChild;
            } // apply transition data to child
            // use getRealChild() to ignore abstract components e.g. keep-alive


            var child = getRealChild(rawChild);
            /* istanbul ignore if */

            if (!child) {
              return rawChild;
            }

            if (this._leaving) {
              return placeholder(h, rawChild);
            } // ensure a key that is unique to the vnode type and to this transition
            // component instance. This key will be used to remove pending leaving nodes
            // during entering.


            var id = "__transition-" + this._uid + "-";
            child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
            var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
            var oldRawChild = this._vnode;
            var oldChild = getRealChild(oldRawChild); // mark v-show
            // so that the transition module can hand over the control to the directive

            if (child.data.directives && child.data.directives.some(function (d) {
              return d.name === 'show';
            })) {
              child.data.show = true;
            }

            if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
            !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
              // replace old child transition data with fresh one
              // important for dynamic transitions!
              var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

              if (mode === 'out-in') {
                // return placeholder node and queue update when leave finishes
                this._leaving = true;
                mergeVNodeHook(oldData, 'afterLeave', function () {
                  this$1._leaving = false;
                  this$1.$forceUpdate();
                });
                return placeholder(h, rawChild);
              } else if (mode === 'in-out') {
                if (isAsyncPlaceholder(child)) {
                  return oldRawChild;
                }

                var delayedLeave;

                var performLeave = function performLeave() {
                  delayedLeave();
                };

                mergeVNodeHook(data, 'afterEnter', performLeave);
                mergeVNodeHook(data, 'enterCancelled', performLeave);
                mergeVNodeHook(oldData, 'delayLeave', function (leave) {
                  delayedLeave = leave;
                });
              }
            }

            return rawChild;
          }
          /*  */
          // Provides transition support for list items.
          // supports move transitions using the FLIP technique.
          // Because the vdom's children update algorithm is "unstable" - i.e.
          // it doesn't guarantee the relative positioning of removed elements,
          // we force transition-group to update its children into two passes:
          // in the first pass, we remove all nodes that need to be removed,
          // triggering their leaving transition; in the second pass, we insert/move
          // into the final desired state. This way in the second pass removed
          // nodes will remain where they should be.

        };
        var props = extend({
          tag: String,
          moveClass: String
        }, transitionProps);
        delete props.mode;
        var TransitionGroup = {
          props: props,
          render: function render(h) {
            var tag = this.tag || this.$vnode.data.tag || 'span';
            var map = Object.create(null);
            var prevChildren = this.prevChildren = this.children;
            var rawChildren = this.$slots.default || [];
            var children = this.children = [];
            var transitionData = extractTransitionData(this);

            for (var i = 0; i < rawChildren.length; i++) {
              var c = rawChildren[i];

              if (c.tag) {
                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                  children.push(c);
                  map[c.key] = c;
                  (c.data || (c.data = {})).transition = transitionData;
                } else if (process.env.NODE_ENV !== 'production') {
                  var opts = c.componentOptions;
                  var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
                  warn("<transition-group> children must be keyed: <" + name + ">");
                }
              }
            }

            if (prevChildren) {
              var kept = [];
              var removed = [];

              for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
                var c$1 = prevChildren[i$1];
                c$1.data.transition = transitionData;
                c$1.data.pos = c$1.elm.getBoundingClientRect();

                if (map[c$1.key]) {
                  kept.push(c$1);
                } else {
                  removed.push(c$1);
                }
              }

              this.kept = h(tag, null, kept);
              this.removed = removed;
            }

            return h(tag, null, children);
          },
          beforeUpdate: function beforeUpdate() {
            // force removing pass
            this.__patch__(this._vnode, this.kept, false, // hydrating
            true // removeOnly (!important, avoids unnecessary moves)
            );

            this._vnode = this.kept;
          },
          updated: function updated() {
            var children = this.prevChildren;
            var moveClass = this.moveClass || (this.name || 'v') + '-move';

            if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
              return;
            } // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.


            children.forEach(callPendingCbs);
            children.forEach(recordPosition);
            children.forEach(applyTranslation); // force reflow to put everything in position
            // assign to this to avoid being removed in tree-shaking
            // $flow-disable-line

            this._reflow = document.body.offsetHeight;
            children.forEach(function (c) {
              if (c.data.moved) {
                var el = c.elm;
                var s = el.style;
                addTransitionClass(el, moveClass);
                s.transform = s.WebkitTransform = s.transitionDuration = '';
                el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
                  if (!e || /transform$/.test(e.propertyName)) {
                    el.removeEventListener(transitionEndEvent, cb);
                    el._moveCb = null;
                    removeTransitionClass(el, moveClass);
                  }
                });
              }
            });
          },
          methods: {
            hasMove: function hasMove(el, moveClass) {
              /* istanbul ignore if */
              if (!hasTransition) {
                return false;
              }
              /* istanbul ignore if */


              if (this._hasMove) {
                return this._hasMove;
              } // Detect whether an element with the move class applied has
              // CSS transitions. Since the element may be inside an entering
              // transition at this very moment, we make a clone of it and remove
              // all other transition classes applied to ensure only the move class
              // is applied.


              var clone = el.cloneNode();

              if (el._transitionClasses) {
                el._transitionClasses.forEach(function (cls) {
                  removeClass(clone, cls);
                });
              }

              addClass(clone, moveClass);
              clone.style.display = 'none';
              this.$el.appendChild(clone);
              var info = getTransitionInfo(clone);
              this.$el.removeChild(clone);
              return this._hasMove = info.hasTransform;
            }
          }
        };

        function callPendingCbs(c) {
          /* istanbul ignore if */
          if (c.elm._moveCb) {
            c.elm._moveCb();
          }
          /* istanbul ignore if */


          if (c.elm._enterCb) {
            c.elm._enterCb();
          }
        }

        function recordPosition(c) {
          c.data.newPos = c.elm.getBoundingClientRect();
        }

        function applyTranslation(c) {
          var oldPos = c.data.pos;
          var newPos = c.data.newPos;
          var dx = oldPos.left - newPos.left;
          var dy = oldPos.top - newPos.top;

          if (dx || dy) {
            c.data.moved = true;
            var s = c.elm.style;
            s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
            s.transitionDuration = '0s';
          }
        }

        var platformComponents = {
          Transition: Transition,
          TransitionGroup: TransitionGroup
          /*  */
          // install platform specific utils

        };
        Vue.config.mustUseProp = mustUseProp;
        Vue.config.isReservedTag = isReservedTag;
        Vue.config.isReservedAttr = isReservedAttr;
        Vue.config.getTagNamespace = getTagNamespace;
        Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

        extend(Vue.options.directives, platformDirectives);
        extend(Vue.options.components, platformComponents); // install platform patch function

        Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method

        Vue.prototype.$mount = function (el, hydrating) {
          el = el && inBrowser ? query(el) : undefined;
          return mountComponent(this, el, hydrating);
        }; // devtools global hook

        /* istanbul ignore next */


        if (inBrowser) {
          setTimeout(function () {
            if (config.devtools) {
              if (devtools) {
                devtools.emit('init', Vue);
              } else if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test' && isChrome) {
                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
              }
            }

            if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test' && config.productionTip !== false && typeof console !== 'undefined') {
              console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
            }
          }, 0);
        }
        /*  */


        module.exports = Vue;
      }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("timers").setImmediate);
    }, {
      "_process": 62,
      "timers": 63
    }],
    66: [function (require, module, exports) {
      var inserted = exports.cache = {};

      function noop() {}

      exports.insert = function (css) {
        if (inserted[css]) return noop;
        inserted[css] = true;
        var elem = document.createElement('style');
        elem.setAttribute('type', 'text/css');

        if ('textContent' in elem) {
          elem.textContent = css;
        } else {
          elem.styleSheet.cssText = css;
        }

        document.getElementsByTagName('head')[0].appendChild(elem);
        return function () {
          document.getElementsByTagName('head')[0].removeChild(elem);
          inserted[css] = false;
        };
      };
    }, {}],
    67: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      exports.default = function (value, message) {
        if (value) {
          return true;
        } else {
          throw new Error(message);
        }
      };
    }, {}],
    68: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _clock = require('./clock');

      var _clock2 = _interopRequireDefault(_clock);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      /**
       * **Usually you don't need to know about this class.**
       * Class that deals with time.
       * This is "frame" type clock, the frame increases every update call.
       * @extends Clock
       * @param {Automaton} _automaton Parent automaton object
       * @param {number} _fps Frames per second
       */


      var ClockFrame = function (_Clock) {
        _inherits(ClockFrame, _Clock);

        function ClockFrame(_automaton, _fps) {
          _classCallCheck(this, ClockFrame);

          var _this = _possibleConstructorReturn(this, (ClockFrame.__proto__ || Object.getPrototypeOf(ClockFrame)).call(this, _automaton));

          _this.frame = 0.0;
          _this.fps = _fps;
          return _this;
        }
        /**
         * Update the clock. It will increase the frame by 1.
         * @returns {void} void
         */


        _createClass(ClockFrame, [{
          key: 'update',
          value: function update() {
            if (this.isPlaying) {
              this.time = this.frame / this.fps;
              this.deltaTime = 1.0 / this.fps;
              this.frame++;
            } else {
              this.deltaTime = 0.0;
            }
          }
        }]);

        return ClockFrame;
      }(_clock2.default);

      exports.default = ClockFrame;
    }, {
      "./clock": 70
    }],
    69: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _clock = require('./clock');

      var _clock2 = _interopRequireDefault(_clock);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      /**
       * **Usually you don't need to know about this class.**
       * Class that deals with time.
       * This is "realtime" type clock, the time goes on as real world.
       * @extends Clock
       * @param {Automaton} _automaton Parent automaton object
       */


      var ClockRealtime = function (_Clock) {
        _inherits(ClockRealtime, _Clock);

        function ClockRealtime(_automaton) {
          _classCallCheck(this, ClockRealtime);

          var _this = _possibleConstructorReturn(this, (ClockRealtime.__proto__ || Object.getPrototypeOf(ClockRealtime)).call(this, _automaton));

          _this.realtime = true;
          _this.rtTime = 0.0;
          _this.rtDate = +new Date();
          return _this;
        }
        /**
         * Update the clock. Time is calculated based on time in real world.
         * @returns {void} void
         */


        _createClass(ClockRealtime, [{
          key: 'update',
          value: function update() {
            if (this.isPlaying) {
              var prevTime = this.time;
              var now = Date.now();
              var deltaDate = now - this.rtDate;
              this.time = this.rtTime + deltaDate / 1000.0;
              this.deltaTime = this.time - prevTime;
            } else {
              this.rtTime = this.time;
              this.rtDate = +new Date();
              this.deltaTime = 0.0;
            }
          }
          /**
           * Set the time manually.
           * @param {number} _time Time
           * @returns {void} void
           */

        }, {
          key: 'setTime',
          value: function setTime(_time) {
            this.time = _time;
            this.rtTime = this.time;
            this.rtDate = +new Date();
          }
        }]);

        return ClockRealtime;
      }(_clock2.default);

      exports.default = ClockRealtime;
    }, {
      "./clock": 70
    }],
    70: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      /**
       * **Usually you don't need to know about this class.**
       * Class that deals with time.
       * In this base class, you need to set time manually from `Automaton.update()`.
       * Best for sync with external clock stuff.
       * @param {Automaton} _automaton Parent automaton object
       */


      var Clock = function () {
        function Clock(_automaton) {
          _classCallCheck(this, Clock);

          this.automaton = _automaton;
          this.time = 0.0;
          this.deltaTime = 0.0;
          this.isPlaying = true;
        }
        /**
         * Update the clock.
         * @param {number} _time Time. You need to set manually
         * @returns {void} void
         */


        _createClass(Clock, [{
          key: "update",
          value: function update(_time) {
            var prevTime = this.time;
            this.time = _time;
            this.deltaTime = this.time - prevTime;
          }
          /**
           * Start the clock.
           * @returns {void} void
           */

        }, {
          key: "play",
          value: function play() {
            this.isPlaying = true;
          }
          /**
           * Stop the clock.
           * @returns {void} void
           */

        }, {
          key: "pause",
          value: function pause() {
            this.isPlaying = false;
          }
          /**
           * Set the time manually.
           * @param {number} _time Time
           * @returns {void} void
           */

        }, {
          key: "setTime",
          value: function setTime(_time) {
            this.time = _time;
          }
        }]);

        return Clock;
      }();

      exports.default = Clock;
    }, {}],
    71: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return _typeof2(obj);
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };

      var defaultData = {
        v: "2.0.1",
        length: 1.0,
        resolution: 1000.0,
        params: {},
        guiSettings: {
          snapActive: false,
          snapTime: 0.1,
          snapValue: 0.1
        }
      };

      var compat = function compat(_data) {
        if (!_data) {
          return Object.assign({}, defaultData);
        }

        var data = void 0;

        if ((typeof _data === 'undefined' ? 'undefined' : _typeof(_data)) === 'object') {
          data = _data;
        } else if (typeof _data === 'string') {
          try {
            data = JSON.parse(_data);
          } catch (e) {
            console.error('Loaded data is invalid');
            return Object.assign({}, defaultData);
          }
        } else {
          console.error('Loaded data is invalid');
          return Object.assign({}, defaultData);
        }

        var v = parseFloat(data.v);

        if (!v && !data.rev) {
          if (data.gui) {
            // "Shift" version of automaton, has incompatible gui params
            delete data.gui;
            data.gui = Object.assign({}, defaultData.gui);
          } else {
            // wtf is this
            console.error('Loaded data is not compatible with this revision');
            return Object.assign({}, defaultData);
          }
        }

        if (data.rev) {
          // fuck
          v = 1.0;
          delete data.rev;
        }

        if (v < 2.0) {
          var _loop = function _loop(name) {
            var oldParam = data.params[name];
            var newParam = {
              nodes: oldParam.map(function (node, i) {
                return {
                  time: node.time,
                  value: node.value,
                  in: i === 0 ? undefined : {
                    time: 0.0,
                    value: 0.0
                  },
                  out: i === oldParam.length - 1 ? undefined : {
                    time: 0.0,
                    value: 0.0
                  }
                };
              }),
              fxs: []
            };
            var head = 0;

            for (var i = 1; i < oldParam.length; i++) {
              head++;

              if (oldParam[i].mode === 0) {
                // hold
                newParam.nodes.splice(head, 0, {
                  time: oldParam[i].time,
                  value: oldParam[i - 1].value,
                  in: {
                    time: 0.0,
                    value: 0.0
                  },
                  out: {
                    time: 0.0,
                    value: 0.0
                  }
                });
                head++;
              } else if (oldParam[i].mode === 1) {// linear
                // do nothing
              } else if (oldParam[i].mode === 2) {
                // cosine
                var l = newParam.nodes[head].time - newParam.nodes[head - 1].time;
                newParam.nodes[head - 1].out = {
                  time: l * 0.37,
                  value: 0.0
                };
                newParam.nodes[head].in = {
                  time: -l * 0.37,
                  value: 0.0
                };
              } else {
                newParam.nodes.splice(head, 0, {
                  time: oldParam[i - 1].time,
                  value: oldParam[i].value,
                  in: {
                    time: 0.0,
                    value: 0.0
                  },
                  out: {
                    time: 0.0,
                    value: 0.0
                  }
                });
                head++;

                if (oldParam[i].mode === 3) {
                  // exp
                  newParam.fxs.push({
                    name: 'Exponential Smoothing',
                    bypass: false,
                    row: 0,
                    time: oldParam[i - 1].time - 1.0 / data.resolution,
                    // 🔥
                    length: oldParam[i].time - oldParam[i - 1].time,
                    params: {
                      factor: oldParam[i].params.factor,
                      preserve: true
                    }
                  });
                } else if (oldParam[i].mode === 4) {
                  // spring
                  newParam.fxs.push({
                    name: 'Critically Damped Spring',
                    bypass: false,
                    row: 0,
                    time: oldParam[i - 1].time - 1.0 / data.resolution,
                    // 🔥
                    length: oldParam[i].time - oldParam[i - 1].time,
                    params: {
                      factor: oldParam[i].params.rate,
                      ratio: oldParam[i].params.damp,
                      preserve: true
                    }
                  });
                } else if (oldParam[i].mode === 5) {
                  // gravity
                  newParam.fxs.push({
                    name: 'Gravity',
                    bypass: false,
                    row: 0,
                    time: oldParam[i - 1].time - 1.0 / data.resolution,
                    // 🔥
                    length: oldParam[i].time - oldParam[i - 1].time,
                    params: {
                      a: oldParam[i].params.gravity,
                      e: oldParam[i].params.bounce,
                      preserve: true
                    }
                  });
                }
              }

              if (oldParam[i].mods[1]) {
                newParam.fxs.push({
                  name: 'Sinewave',
                  bypass: false,
                  row: 1,
                  time: oldParam[i - 1].time,
                  length: oldParam[i].time - oldParam[i - 1].time,
                  params: {
                    freq: oldParam[i].mods[1].freq,
                    amp: oldParam[i].mods[1].amp,
                    phase: oldParam[i].mods[1].phase
                  }
                });
              }

              if (oldParam[i].mods[2]) {
                newParam.fxs.push({
                  name: 'Fractal Noise',
                  bypass: false,
                  row: 2,
                  time: oldParam[i - 1].time,
                  length: oldParam[i].time - oldParam[i - 1].time,
                  params: {
                    amp: oldParam[i].mods[2].amp,
                    recursion: oldParam[i].mods[2].recursion,
                    freq: oldParam[i].mods[2].freq,
                    reso: oldParam[i].mods[2].reso,
                    seed: oldParam[i].mods[2].seed
                  }
                });
              }

              if (oldParam[i].mods[3]) {
                newParam.fxs.push({
                  name: 'Lo-Fi',
                  bypass: false,
                  row: 3,
                  time: oldParam[i - 1].time,
                  length: oldParam[i].time - oldParam[i - 1].time,
                  params: {
                    resolution: oldParam[i].mods[3].freq,
                    relative: true
                  }
                });
              }
            }

            data.params[name] = newParam;
          }; // v1, modes and modifiers, CURSED


          for (var name in data.params) {
            _loop(name);
          }

          data.guiSettings = {
            snapActive: false,
            snapTime: 0.1,
            snapValue: 0.1
          };
        }

        data.v = "2.0.1";
        return data;
      };

      exports.default = compat;
    }, {}],
    72: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      }); // ref: https://github.com/gre/bezier-easing/blob/master/src/index.js

      var NEWTON_ITER = 4;
      var NEWTON_EPSILON = 0.001;
      var SUBDIV_ITER = 10;
      var SUBDIV_EPSILON = 0.000001;
      var TABLE_SIZE = 21;
      var tab = [];

      var A = function A(a1, a2) {
        return 1.0 - 3.0 * a2 + 3.0 * a1;
      };

      var B = function B(a1, a2) {
        return 3.0 * a2 - 6.0 * a1;
      };

      var C = function C(a1) {
        return 3.0 * a1;
      };

      var saturate = function saturate(x) {
        return Math.min(Math.max(x, 0.0), 1.0);
      };

      var calc = function calc(t, a1, a2) {
        return ((A(a1, a2) * t + B(a1, a2)) * t + C(a1)) * t;
      };

      var delta = function delta(t, a1, a2) {
        return 3.0 * A(a1, a2) * t * t + 2.0 * B(a1, a2) * t + C(a1);
      };

      var subdiv = function subdiv(x, a, b, x1, x2) {
        var cx = 0;
        var ct = 0;

        for (var i = 0; i < SUBDIV_ITER; i++) {
          ct = a + (b - a) / 2.0;
          cx = calc(ct, x1, x2) - x;
          0.0 < cx ? b = ct : a = ct;

          if (SUBDIV_EPSILON < Math.abs(cx)) {
            break;
          }
        }

        return ct;
      };

      var newton = function newton(x, gt, x1, x2) {
        for (var i = 0; i < NEWTON_ITER; i++) {
          var d = delta(gt, x1, x2);

          if (d === 0.0) {
            return gt;
          }

          var cx = calc(gt, x1, x2) - x;
          gt = gt - cx / d;
        }

        return gt;
      };

      var rawCubicBezier = function rawCubicBezier(x1, y1, x2, y2, x) {
        if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {
          return x;
        } // heh


        if (x1 === y1 && x2 === y2) {
          return x;
        } // linear


        if (x <= 0.0) {
          return 0.0;
        }

        if (1.0 <= x) {
          return 1.0;
        }

        x1 = saturate(x1);
        x2 = saturate(x2);

        for (var i = 0; i < TABLE_SIZE; i++) {
          tab[i] = calc(i / (TABLE_SIZE - 1.0), x1, x2);
        }

        var sample = 1;

        for (var _i = 1; _i < TABLE_SIZE; _i++) {
          sample = _i - 1;

          if (x < tab[_i]) {
            break;
          }
        }

        var dist = (x - tab[sample]) / (tab[sample + 1] - tab[sample]);
        var t = (sample + dist) / (TABLE_SIZE - 1);
        var d = delta(t, x1, x2);

        if (NEWTON_EPSILON <= d) {
          t = newton(x, t, x1, x2);
        } else if (d !== 0.0) {
          t = subdiv(x, sample / (TABLE_SIZE - 1), (sample + 1.0) / (TABLE_SIZE - 1), x1, x2);
        }

        return calc(t, y1, y2);
      };

      var cubicBezier = function cubicBezier(node0, node1, time) {
        var tL = node1.time - node0.time;
        var vL = node1.value - node0.value;
        var x1 = node0.out.time / tL;
        var y1 = node0.out.value / vL;
        var x2 = (node1.time + node1.in.time - node0.time) / tL;
        var y2 = (node1.value + node1.in.value - node0.value) / vL;
        var x = (time - node0.time) / tL;
        return node0.value + rawCubicBezier(x1, y1, x2, y2, x) * vL;
      };

      exports.default = cubicBezier;
    }, {}],
    73: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = [require('./fxs/add').default, require('./fxs/cds').default, require('./fxs/clamp').default, require('./fxs/exp').default, require('./fxs/gravity').default, require('./fxs/lofi').default, require('./fxs/noise').default, require('./fxs/pow').default, require('./fxs/sine').default];
    }, {
      "./fxs/add": 74,
      "./fxs/cds": 75,
      "./fxs/clamp": 76,
      "./fxs/exp": 77,
      "./fxs/gravity": 78,
      "./fxs/lofi": 79,
      "./fxs/noise": 81,
      "./fxs/pow": 82,
      "./fxs/sine": 83
    }],
    74: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['add', {
        name: 'Add',
        description: 'The simplest fx ever. Just add a constant value to the curve.',
        params: {
          value: {
            name: 'Value',
            type: 'float',
            default: 1.0
          }
        },
        func: function func(context) {
          return context.v + context.params.value;
        }
      }];
    }, {}],
    75: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['cds', {
        name: 'Critically Damped Spring',
        description: 'Basically the best smoothing method. Shoutouts to Keijiro Takahashi',
        params: {
          factor: {
            name: 'Factor',
            type: 'float',
            default: 100.0,
            min: 0.0
          },
          ratio: {
            name: 'Damp Ratio',
            type: 'float',
            default: 1.0
          },
          preserve: {
            name: 'Preserve Velocity',
            type: 'boolean',
            default: false
          }
        },
        func: function func(context) {
          var dt = context.dt;
          var v = context.v;
          var k = context.params.factor;

          if (context.init) {
            context.pos = context.v;

            if (context.params.preserve) {
              var dv = v - context.getValue(context.t - dt);
              context.vel = dv / dt;
            } else {
              context.vel = 0.0;
            }
          }

          context.vel += (-k * (context.pos - v) - 2.0 * context.vel * Math.sqrt(k) * context.params.ratio) * dt;
          context.pos += context.vel * dt;
          return context.pos;
        }
      }];
    }, {}],
    76: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var clamp = function clamp(x, a, b) {
        return Math.min(Math.max(x, a), b);
      };

      var smin = function smin(a, b, k) {
        var h = Math.max(k - Math.abs(a - b), 0.0);
        return Math.min(a, b) - h * h * h / (6.0 * k * k);
      };

      exports.default = ['clamp', {
        name: 'Clamp',
        description: 'Constrain the curve between two values, featuring smooth minimum.',
        params: {
          min: {
            name: 'Min',
            type: 'float',
            default: 0.0
          },
          max: {
            name: 'Max',
            type: 'float',
            default: 1.0
          },
          smooth: {
            name: 'Smooth',
            type: 'float',
            default: 0.0,
            min: 0.0
          }
        },
        func: function func(context) {
          if (context.params.smooth === 0.0) {
            return clamp(context.v, context.params.min, context.params.max);
          }

          var v = -smin(-context.params.min, -context.v, context.params.smooth);
          return smin(context.params.max, v, context.params.smooth);
        }
      }];
    }, {}],
    77: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['exp', {
        name: 'Exponential Smoothing',
        description: 'Smooth the curve. Simple but good.',
        params: {
          factor: {
            name: 'Factor',
            type: 'float',
            default: 10.0,
            min: 0.0
          }
        },
        func: function func(context) {
          var v = context.v;

          if (context.init) {
            context.pos = v;
          }

          var k = Math.exp(-context.dt * context.params.factor);
          context.pos = context.pos * k + v * (1.0 - k);
          return context.pos;
        }
      }];
    }, {}],
    78: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['gravity', {
        name: 'Gravity',
        description: 'Accelerate and bounce the curve.',
        params: {
          a: {
            name: 'Acceleration',
            type: 'float',
            default: 9.8
          },
          e: {
            name: 'Restitution',
            type: 'float',
            default: 0.5,
            min: 0.0
          },
          preserve: {
            name: 'Preserve Velocity',
            type: 'boolean',
            default: false
          }
        },
        func: function func(context) {
          var dt = context.dt;
          var v = context.v;

          if (context.init) {
            context.pos = v;

            if (context.params.preserve) {
              var dv = v - context.getValue(context.t - dt);
              context.vel = dv / dt;
            } else {
              context.vel = 0.0;
            }
          }

          var a = Math.sign(v - context.pos) * context.params.a;
          context.vel += a * dt;
          context.pos += context.vel * dt;

          if (Math.sign(a) !== Math.sign(v - context.pos)) {
            context.vel *= -context.params.e;
            context.pos = v + context.params.e * (v - context.pos);
          }

          return context.pos;
        }
      }];
    }, {}],
    79: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['lofi', {
        name: 'Lo-Fi',
        description: 'Make curve more crunchy.',
        params: {
          rate: {
            name: 'Frame Rate',
            type: 'float',
            default: 10.0,
            min: 0.0,
            max: 1000.0
          },
          relative: {
            name: 'Relative',
            type: 'boolean',
            default: false
          },
          reso: {
            name: 'Reso Per Unit',
            type: 'float',
            default: 0.1,
            min: 0.0,
            max: 1000.0
          },
          round: {
            name: 'Round',
            type: 'boolean',
            default: false
          }
        },
        func: function func(context) {
          var t = void 0;

          if (context.params.rate === 0.0) {
            t = context.t;
          } else if (context.params.relative) {
            t = context.t0 + Math.floor((context.t - context.t0) * context.params.rate) / context.params.rate;
          } else {
            t = Math.floor(context.t * context.params.rate) / context.params.rate;
          }

          var v = context.getValue(t);

          if (context.params.reso !== 0.0) {
            v = Math.floor(v * context.params.reso + (context.params.round ? 0.5 : 0.0)) / context.params.reso;
          }

          return v;
        }
      }];
    }, {}],
    80: [function (require, module, exports) {
      "use strict";

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var Xorshift = function () {
        function Xorshift(_seed) {
          _classCallCheck(this, Xorshift);

          this.set(_seed);
        }

        _createClass(Xorshift, [{
          key: "gen",
          value: function gen(_seed) {
            if (_seed) {
              this.set(_seed);
            }

            this.seed = this.seed ^ this.seed << 13;
            this.seed = this.seed ^ this.seed >>> 17;
            this.seed = this.seed ^ this.seed << 5;
            return this.seed / Math.pow(2, 32) + 0.5;
          }
        }, {
          key: "set",
          value: function set(_seed) {
            this.seed = _seed || this.seed || 1;
          }
        }]);

        return Xorshift;
      }();

      module.exports = Xorshift;
    }, {}],
    81: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _xorshift = require('./modules/xorshift');

      var _xorshift2 = _interopRequireDefault(_xorshift);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      var xorshift = new _xorshift2.default();

      var smoothstep = function smoothstep(_a, _b, _k) {
        var smooth = _k * _k * (3.0 - 2.0 * _k);
        return _a + (_b - _a) * smooth;
      };

      exports.default = ['noise', {
        name: 'Fractal Noise',
        description: 'wiggle()',
        params: {
          recursion: {
            name: 'Recursion',
            type: 'int',
            default: 4,
            min: 1,
            max: 99
          },
          freq: {
            name: 'Frequency',
            type: 'float',
            default: 1.0,
            min: 0.0
          },
          reso: {
            name: 'Resolution',
            type: 'float',
            default: 8.0,
            min: 1.0
          },
          seed: {
            name: 'Seed',
            type: 'int',
            default: 1,
            min: 0
          },
          amp: {
            name: 'Amp',
            type: 'float',
            default: 0.2
          }
        },
        func: function func(context) {
          if (context.init) {
            xorshift.gen(context.params.seed);
            context.table = new Float32Array(Math.floor(context.params.reso) + 2);

            for (var i = 1; i < context.params.reso; i++) {
              context.table[i] = xorshift.gen() * 2.0 - 1.0;
            }
          }

          var v = context.v;
          var p = context.progress;

          for (var _i = 0; _i < context.params.recursion; _i++) {
            var index = p * context.params.freq * context.params.reso * Math.pow(2.0, _i) % context.params.reso;
            var indexi = Math.floor(index);
            var indexf = index - indexi;
            var factor = Math.pow(0.5, _i + 1.0);
            v += context.params.amp * factor * smoothstep(context.table[indexi], context.table[indexi + 1], indexf);
          }

          return v;
        }
      }];
    }, {
      "./modules/xorshift": 80
    }],
    82: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ['pow', {
        name: 'Power',
        description: 'You got boost power!',
        params: {
          pow: {
            name: 'Power',
            type: 'float',
            default: 2.0
          },
          bias: {
            name: 'Bias',
            type: 'float',
            default: 0.0
          },
          positive: {
            name: 'Force Positive',
            type: 'boolean',
            default: false
          }
        },
        func: function func(context) {
          var v = context.v - context.params.bias;
          var sign = context.params.positive ? 1.0 : Math.sign(v);
          return Math.pow(Math.abs(v), context.params.pow) * sign + context.params.bias;
        }
      }];
    }, {}],
    83: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var TAU = Math.PI * 2.0;
      exports.default = ['sine', {
        name: 'Sinewave',
        description: 'Overlay a sinewave to the curve.',
        params: {
          amp: {
            name: 'Amp',
            type: 'float',
            default: 0.1
          },
          freq: {
            name: 'Frequency',
            type: 'float',
            default: 5.0
          },
          phase: {
            name: 'Phase',
            type: 'float',
            default: 0.0,
            min: 0.0,
            max: 1.0
          }
        },
        func: function func(context) {
          var v = context.v;
          var p = context.progress * context.params.freq + context.params.phase;
          return v + context.params.amp * Math.sin(p * TAU);
        }
      }];
    }, {}],
    84: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      exports.default = function () {
        var ret = '';

        for (var i = 0; i < 16; i++) {
          ret += Math.floor(16.0 * Math.random()).toString(16);
        }

        return ret;
      };
    }, {}],
    85: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var hasOverwrap = function hasOverwrap(t1, l1, t2, l2) {
        if (l2 < l1) {
          return hasOverwrap(t2, l2, t1, l1);
        }

        return t2 < t1 && t1 < t2 + l2 || t2 < t1 + l1 && t1 + l1 < t2 + l2;
      };

      exports.default = hasOverwrap;
    }, {}],
    86: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E %3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E %3Csvg width='100%25' height='100%25' viewBox='0 0 128 128' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3Bclip-rule:evenodd%3Bstroke-linejoin:round%3Bstroke-miterlimit:1.41421%3B'%3E     %3Cpath d='M64%2C55.537L105.023%2C14.513L113.487%2C22.977L72.463%2C64L113.487%2C105.023L105.023%2C113.487L64%2C72.463L22.977%2C113.487L14.513%2C105.023L55.537%2C64L14.513%2C22.977L22.977%2C14.513L64%2C55.537Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E %3C/svg%3E";
    }, {}],
    87: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E %3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E %3Csvg width='100%25' height='100%25' viewBox='0 0 64 64' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3Bclip-rule:evenodd%3Bstroke-linejoin:round%3Bstroke-miterlimit:1.41421%3B'%3E     %3Cg id='a' transform='matrix(1.10297%2C0%2C0%2C1.10297%2C-22.0454%2C-38.5886)'%3E         %3Cpath d='M44.397%2C47.274C42.928%2C45.991 42%2C44.104 42%2C42L42%2C41.998C42%2C38.133 45.133%2C35 48.998%2C35L49.002%2C35C52.867%2C35 56%2C38.133 56%2C41.998L56%2C42C56%2C44.113 55.063%2C46.008 53.583%2C47.292L68.047%2C79.064C68.358%2C79.022 68.676%2C79 68.998%2C79L69.002%2C79C72.867%2C79 76%2C82.133 76%2C85.998L76%2C86C76%2C89.866 72.866%2C93 69%2C93L69%2C93C65.134%2C93 62%2C89.866 62%2C86L62%2C85.998C62%2C83.891 62.931%2C82.001 64.405%2C80.718L49.937%2C48.938C49.631%2C48.979 49.318%2C49 49%2C49L49%2C49C48.673%2C49 48.351%2C48.978 48.036%2C48.934L33.591%2C80.715C35.067%2C81.998 36%2C83.889 36%2C85.998L36%2C86C36%2C89.866 32.866%2C93 29%2C93L29%2C93C25.134%2C93 22%2C89.866 22%2C86L22%2C85.998C22%2C82.133 25.133%2C79 28.998%2C79L29.002%2C79C29.323%2C79 29.639%2C79.022 29.948%2C79.064L44.397%2C47.274ZM29%2C89C30.657%2C89 32%2C87.657 32%2C86L32%2C86C32%2C84.343 30.657%2C83 29%2C83L29%2C83C27.343%2C83 26%2C84.343 26%2C86L26%2C86C26%2C87.657 27.343%2C89 29%2C89L29%2C89ZM69%2C89C70.657%2C89 72%2C87.657 72%2C86L72%2C86C72%2C84.343 70.657%2C83 69%2C83L69%2C83C67.343%2C83 66%2C84.343 66%2C86L66%2C86C66%2C87.657 67.343%2C89 69%2C89L69%2C89ZM49%2C45C50.657%2C45 52%2C43.657 52%2C42L52%2C42C52%2C40.343 50.657%2C39 49%2C39L49%2C39C47.343%2C39 46%2C40.343 46%2C42L46%2C42C46%2C43.657 47.343%2C45 49%2C45L49%2C45Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E     %3C/g%3E %3C/svg%3E";
    }, {}],
    88: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E %3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E %3Csvg width='100%25' height='100%25' viewBox='0 0 720 64' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3Bclip-rule:evenodd%3Bstroke-linejoin:round%3Bstroke-miterlimit:1.41421%3B'%3E     %3Cg transform='matrix(1.10297%2C0%2C0%2C1.10297%2C78.1502%2C-38.5886)'%3E         %3Cg id='a' transform='matrix(1%2C0%2C0%2C1%2C-92.3303%2C0)'%3E             %3Cpath d='M44.397%2C47.274C42.928%2C45.991 42%2C44.104 42%2C42L42%2C41.998C42%2C38.133 45.133%2C35 48.998%2C35L49.002%2C35C52.867%2C35 56%2C38.133 56%2C41.998L56%2C42C56%2C44.113 55.063%2C46.008 53.583%2C47.292L68.047%2C79.064C68.358%2C79.022 68.676%2C79 68.998%2C79L69.002%2C79C72.867%2C79 76%2C82.133 76%2C85.998L76%2C86C76%2C89.866 72.866%2C93 69%2C93L69%2C93C65.134%2C93 62%2C89.866 62%2C86L62%2C85.998C62%2C83.891 62.931%2C82.001 64.405%2C80.718L49.937%2C48.938C49.631%2C48.979 49.318%2C49 49%2C49L49%2C49C48.673%2C49 48.351%2C48.978 48.036%2C48.934L33.591%2C80.715C35.067%2C81.998 36%2C83.889 36%2C85.998L36%2C86C36%2C89.866 32.866%2C93 29%2C93L29%2C93C25.134%2C93 22%2C89.866 22%2C86L22%2C85.998C22%2C82.133 25.133%2C79 28.998%2C79L29.002%2C79C29.323%2C79 29.639%2C79.022 29.948%2C79.064L44.397%2C47.274ZM29%2C89C30.657%2C89 32%2C87.657 32%2C86L32%2C86C32%2C84.343 30.657%2C83 29%2C83L29%2C83C27.343%2C83 26%2C84.343 26%2C86L26%2C86C26%2C87.657 27.343%2C89 29%2C89L29%2C89ZM69%2C89C70.657%2C89 72%2C87.657 72%2C86L72%2C86C72%2C84.343 70.657%2C83 69%2C83L69%2C83C67.343%2C83 66%2C84.343 66%2C86L66%2C86C66%2C87.657 67.343%2C89 69%2C89L69%2C89ZM49%2C45C50.657%2C45 52%2C43.657 52%2C42L52%2C42C52%2C40.343 50.657%2C39 49%2C39L49%2C39C47.343%2C39 46%2C40.343 46%2C42L46%2C42C46%2C43.657 47.343%2C45 49%2C45L49%2C45Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E         %3C/g%3E         %3Cg id='u' transform='matrix(1%2C0%2C0%2C1%2C-69.252%2C0)'%3E             %3Cpath d='M78%2C35L82%2C35L82%2C73C82%2C81.836 89.154%2C89 98%2C89C106.827%2C89 114%2C81.712 114%2C73L114%2C34.975L118%2C35L118%2C73C118%2C84.046 109%2C93 97.99%2C93C86.945%2C93 78%2C84.046 78%2C73L78%2C35Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E         %3C/g%3E         %3Cg id='t' transform='matrix(1%2C0%2C0%2C1%2C-46.171%2C0)'%3E             %3Cpath d='M125%2C35L167%2C35L167%2C39.032L148%2C39.032L148%2C93L144%2C93L144%2C39.032L125%2C39.032L125%2C35Z' style='fill:rgb(201%2C226%2C255)%3Bfill-rule:nonzero%3B'/%3E         %3C/g%3E         %3Cg id='o' transform='matrix(1%2C0%2C0%2C1%2C-23.1034%2C0)'%3E             %3Cpath d='M228%2C63.986C228%2C56.298 224.946%2C48.926 219.51%2C43.49C214.074%2C38.054 206.702%2C35 199.014%2C35C199.005%2C35 199%2C35 199%2C35C199%2C35 199%2C35 198.999%2C35C191.31%2C34.993 183.934%2C38.043 178.495%2C43.477C173.056%2C48.912 170%2C56.285 170%2C63.974L170%2C64C170%2C71.691 173.055%2C79.068 178.494%2C84.506C183.932%2C89.945 191.309%2C93 199%2C93L199%2C93C206.691%2C93 214.068%2C89.945 219.506%2C84.506C224.945%2C79.068 228%2C71.691 228%2C64C228%2C63.992 228%2C63.987 228%2C63.987C228%2C63.987 228%2C63.987 228%2C63.986ZM223.977%2C63.986C223.977%2C50.198 212.8%2C39.022 199.013%2C39.022C199.004%2C39.022 199%2C39.022 199%2C39.022C199%2C39.022 199%2C39.022 198.999%2C39.022C192.377%2C39.016 186.024%2C41.642 181.34%2C46.323C176.655%2C51.003 174.023%2C57.354 174.023%2C63.976L174.023%2C63.999C174.023%2C70.623 176.655%2C76.976 181.339%2C81.66C186.023%2C86.343 192.375%2C88.975 198.999%2C88.975L199.001%2C88.975C205.625%2C88.975 211.977%2C86.343 216.661%2C81.66C221.345%2C76.976 223.977%2C70.623 223.977%2C63.999C223.977%2C63.991 223.977%2C63.987 223.977%2C63.987C223.977%2C63.987 223.977%2C63.987 223.977%2C63.986Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E         %3C/g%3E         %3Cpath id='m' d='M285%2C93L281%2C93L281%2C42.284L261.606%2C72.99L258.402%2C73.005L239%2C42.324L239%2C93L235%2C93L235%2C35L239.102%2C35L259.998%2C68.045L280.869%2C35L285%2C35C285%2C54.333 285%2C73.667 285%2C93Z' style='fill:rgb(201%2C226%2C255)%3Bfill-rule:nonzero%3B'/%3E         %3Cg id='a2' transform='matrix(1%2C0%2C0%2C1%2C20.0558%2C32)'%3E             %3Cpath d='M346.8%2C61L342.445%2C61L335.557%2C45L308.865%2C45L310.587%2C41L333.835%2C41L320.017%2C8.899L297.622%2C61L293.268%2C61L318.198%2C3L321.832%2C3L346.8%2C61Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E         %3C/g%3E         %3Cg id='t2' transform='matrix(1%2C0%2C0%2C1%2C259.187%2C0)'%3E             %3Cpath d='M125%2C35L167%2C35L167%2C39.032L148%2C39.032L148%2C93L144%2C93L144%2C39.032L125%2C39.032L125%2C35Z' style='fill:rgb(201%2C226%2C255)%3Bfill-rule:nonzero%3B'/%3E         %3C/g%3E         %3Cg id='o2' transform='matrix(1%2C0%2C0%2C1%2C281.257%2C1.16685e-05)'%3E             %3Cpath d='M228%2C63.986C228%2C56.298 224.946%2C48.926 219.51%2C43.49C214.074%2C38.054 206.702%2C35 199.014%2C35C199.005%2C35 199%2C35 199%2C35C199%2C35 199%2C35 198.999%2C35C191.31%2C34.993 183.934%2C38.043 178.495%2C43.477C173.056%2C48.912 170%2C56.285 170%2C63.974L170%2C64C170%2C71.691 173.055%2C79.068 178.494%2C84.506C183.932%2C89.945 191.309%2C93 199%2C93L199%2C93C206.691%2C93 214.068%2C89.945 219.506%2C84.506C224.945%2C79.068 228%2C71.691 228%2C64C228%2C63.992 228%2C63.987 228%2C63.987C228%2C63.987 228%2C63.987 228%2C63.986ZM223.977%2C63.986C223.977%2C50.198 212.8%2C39.022 199.013%2C39.022C199.004%2C39.022 199%2C39.022 199%2C39.022C199%2C39.022 199%2C39.022 198.999%2C39.022C192.377%2C39.016 186.024%2C41.642 181.34%2C46.323C176.655%2C51.003 174.023%2C57.354 174.023%2C63.976L174.023%2C63.999C174.023%2C70.623 176.655%2C76.976 181.339%2C81.66C186.023%2C86.343 192.375%2C88.975 198.999%2C88.975L199.001%2C88.975C205.625%2C88.975 211.977%2C86.343 216.661%2C81.66C221.345%2C76.976 223.977%2C70.623 223.977%2C63.999C223.977%2C63.991 223.977%2C63.987 223.977%2C63.987C223.977%2C63.987 223.977%2C63.987 223.977%2C63.986Z' style='fill:rgb(201%2C226%2C255)%3B'/%3E         %3C/g%3E         %3Cg id='n' transform='matrix(1%2C0%2C0%2C1%2C92.4061%2C0)'%3E             %3Cpath d='M484.93%2C93L451.002%2C42.108L450.998%2C93L446.998%2C93L447.002%2C35L451.07%2C35L485%2C85.894L485%2C35L489%2C35L489%2C93C487.643%2C93 486.286%2C93 484.93%2C93Z' style='fill:rgb(201%2C226%2C255)%3Bfill-rule:nonzero%3B'/%3E         %3C/g%3E     %3C/g%3E %3C/svg%3E";
    }, {}],
    89: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 100 100'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 92 45       L 92 55       L 78 61       L 74 68       L 76 83       L 66 89       L 54 80       L 46 80       L 34 89       L 24 83       L 26 68       L 22 61       L 8 55       L 8 45       L 22 39       L 26 32       L 24 17       L 34 11       L 46 20       L 54 20       L 66 11       L 76 17       L 74 32       L 78 39       z       M 50 50       m 0 -12       a 12 12 0 0 0 0 24       a 12 12 0 0 0 0 -24       z     '   /%3E %3C/svg%3E";
    }, {}],
    90: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 18 65       L 33 65       L 33 15       L 18 15       z       M 47 65       L 62 65       L 62 15       L 47 15       z     '   /%3E %3C/svg%3E";
    }, {}],
    91: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 15 70       L 65 40       L 15 10       z     '   /%3E %3C/svg%3E";
    }, {}],
    92: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 10 65       L 10 30       L 20 20       L 50 20       L 50 10       L 70 30       L 50 50       L 50 40       L 30 40       L 30 65       z     '   /%3E %3C/svg%3E";
    }, {}],
    93: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 10 10       L 10 70       L 70 70       L 70 20       L 60 10       z       M 20 40       L 60 40       L 60 65       L 20 65       z       M 54 13       L 54 32       L 25 32       L 25 13       z       M 42 15       L 50 15       L 50 30       L 42 30       z     '   /%3E %3C/svg%3E";
    }, {}],
    94: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 10 60       L 10 70       L 30 70       L 30 60       z              M 50 60       L 50 70       L 70 70       L 70 60       z       M 10 55       L 10 40       A 30 30 0 0 1 70 40       L 70 55       L 50 55       L 50 40       A 10 10 0 0 0 30 40       L 30 55       z     '   /%3E %3C/svg%3E";
    }, {}],
    95: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 80 80'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='%232af'     d='       M 70 65       L 70 30       L 60 20       L 30 20       L 30 10       L 10 30       L 30 50       L 30 40       L 50 40       L 50 65       z     '   /%3E %3C/svg%3E";
    }, {}],
    96: [function (require, module, exports) {
      module.exports = "data:image/svg+xml,%3Csvg   xmlns='http://www.w3.org/2000/svg'   viewBox='0 0 100 100'   width='256'   height='256'   font-family='Helvetica Neue'   font-weight='300' %3E   %3Cpath     fill='none'     stroke='%23222'     stroke-width='20'     stroke-linecap='round'     stroke-linejoin='round'      d='       M 50 50       m -6 -32       l 12 0       l 30 50       l -8 12       l -56 0       l -8 -12       l 30 -50       z     '   /%3E   %3Cpath     fill='%23f92'     stroke='%23f92'     stroke-width='5'     stroke-linecap='round'     stroke-linejoin='round'      d='       M 50 50       m -6 -32       l 12 0       l 30 50       l -8 12       l -56 0       l -8 -12       l 30 -50       z     '   /%3E   %3Cpath     fill='%23222'     stroke='%23222'     stroke-width='5'     stroke-linecap='round'     stroke-linejoin='round'      d='       M 50 30       m -6 0       l 12 0       l 0 27       l -12 0       z       M 50 66       m -6 0       l 12 0       l 0 8       l -12 0       z     '   /%3E %3C/svg%3E";
    }, {}],
    97: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      exports.default = function (data) {
        return JSON.parse(JSON.stringify(data));
      };
    }, {}],
    98: [function (require, module, exports) {
      'use strict';

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _get = function get(object, property, receiver) {
        if (object === null) object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);

        if (desc === undefined) {
          var parent = Object.getPrototypeOf(object);

          if (parent === null) {
            return undefined;
          } else {
            return get(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;

          if (getter === undefined) {
            return undefined;
          }

          return getter.call(receiver);
        }
      };

      var _ass = require('./ass');

      var _ass2 = _interopRequireDefault(_ass);

      var _compat = require('./compat');

      var _compat2 = _interopRequireDefault(_compat);

      var _jsonCopy = require('./json-copy');

      var _jsonCopy2 = _interopRequireDefault(_jsonCopy);

      var _paramGui = require('./param-gui');

      var _paramGui2 = _interopRequireDefault(_paramGui);

      var _main = require('./main');

      var _main2 = _interopRequireDefault(_main);

      var _fxDefinitions = require('./fx-definitions');

      var _fxDefinitions2 = _interopRequireDefault(_fxDefinitions);

      var _vue = require('vue');

      var _vue2 = _interopRequireDefault(_vue);

      var _main3 = require('./vue/main.vue');

      var _main4 = _interopRequireDefault(_main3);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        } else {
          return Array.from(arr);
        }
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      /**
       * IT'S AUTOMATON!
       * It's `automaton.js` and `automaton.min.js` version.
       * Since GUI stuff is pretty big for intro heh
       * @extends Automaton
       * @param {Object} [_props]
       * @param {boolean} [_props.loop] Whether let the time loop or not
       * @param {number} [_props.fps] If this is set, the clock will become frame mode
       * @param {boolean} [_props.realtime] If this is true, the clock will become realtime mode
       * @param {DOM} [_props.gui] DOM element where you want to attach the Automaton GUI
       * @param {string|Object} [_props.data] Data of the automaton. Don't worry, I can generate an initial data for you!
       */


      var AutomatonWithGUI = function (_Automaton) {
        _inherits(AutomatonWithGUI, _Automaton);

        function AutomatonWithGUI(_props) {
          _classCallCheck(this, AutomatonWithGUI);

          var props = Object.assign({}, _props);
          (0, _ass2.default)(!_props.onseek, 'The handler "onseek" is no longer supported. Use Automaton.on( "seek", ... ) instead.');
          (0, _ass2.default)(!_props.onplay, 'The handler "onplay" is no longer supported. Use Automaton.on( "play", ... ) instead.');
          (0, _ass2.default)(!_props.onpause, 'The handler "onpause" is no longer supported. Use Automaton.on( "pause", ... ) instead.');
          /**
           * History stack.
           * Will be managed from {@link AutomatonWithGUI#pushHistory|pushHistory()}, navigated from {@link AutomatonWithGUI#undo|undo()} and {@link AutomatonWithGUI#redo|redo()}.
           * @type {Object[]}
           * @protected
           */

          var _this = _possibleConstructorReturn(this, (AutomatonWithGUI.__proto__ || Object.getPrototypeOf(AutomatonWithGUI)).call(this, props));

          _this.__history = [];
          /**
           * Current position of history stack.
           * @type {number}
           * @protected
           */

          _this.__historyIndex = 0;

          _fxDefinitions2.default.map(function (fxDef) {
            _this.addFxDefinition.apply(_this, _toConsumableArray(fxDef));
          });

          if (_props.gui) {
            _this.__prepareGUI(_props.gui);
          }

          window.addEventListener('beforeunload', function (event) {
            if (_this.__historyIndex !== 0) {
              var confirmationMessage = 'Automaton: Did you saved your progress?';
              event.returnValue = confirmationMessage;
              return confirmationMessage;
            }
          });
          return _this;
        }
        /**
         * Prepare GUI.
         * @param {DOM} _target DOM element where you want to attach the Automaton GUI
         * @returns {void} void
         * @protected
         */


        _createClass(AutomatonWithGUI, [{
          key: '__prepareGUI',
          value: function __prepareGUI(_target) {
            var el = document.createElement('div');

            _target.appendChild(el);
            /**
             * Vue instance that manages automaton gui.
             * @type {Vue}
             */


            this.__vue = new _vue2.default({
              el: el,
              data: {
                automaton: this
              },
              render: function render(createElement) {
                return createElement(_main4.default, {
                  props: {
                    automaton: this.automaton
                  }
                });
              }
            });
          }
          /**
           * Generate default fx params object.
           * @param {string} _id Id of the fx
           * @returns {Object} Default fx params object
           */

        }, {
          key: 'generateDefaultFxParams',
          value: function generateDefaultFxParams(_id) {
            var fxDef = this.__paramFxDefs[_id];

            if (!fxDef) {
              throw new Error('Fx definition called ' + _id + ' is not defined');
            }

            var ret = {};

            for (var key in fxDef.params) {
              ret[key] = fxDef.params[key].default;
            }

            return ret;
          }
          /**
           * Toggle play / pause.
           * @returns {void} void
           */

        }, {
          key: 'togglePlay',
          value: function togglePlay() {
            if (this.isPlaying) {
              this.pause();
            } else {
              this.play();
            }
          }
          /**
           * Put some operation into the history stack.
           * Since it should accessible from GUI this function is public, basically `-- DON'T TOUCH IT KIDDO --`
           * @param {string} _desc Description of the operation
           * @param {function} _do Operation
           * @param {function} _undo Operation that undoes the `_do`
           * @param {boolean} [_execute=false] _do will be executed instantly if true
           * @returns {any} any if `_execute` is true, void otherwise
           */

        }, {
          key: 'pushHistory',
          value: function pushHistory(_desc, _do, _undo, _execute) {
            this.__history.splice(this.__historyIndex);

            this.__history.push({
              desc: _desc,
              do: _do,
              undo: _undo
            });

            this.__historyIndex++;

            if (_execute || false) {
              return _do();
            }
          }
          /**
           * Undo the operation based on history stack.
           * Can be performed via GUI.
           * @returns {any} Result of _undo
           */

        }, {
          key: 'undo',
          value: function undo() {
            if (this.__historyIndex <= 0) {
              return;
            }

            this.__historyIndex--;
            return this.__history[this.__historyIndex].undo();
          }
          /**
           * Redo the operation based on history stack.
           * Can be performed via GUI.
           * @returns {any} Result of _do
           */

        }, {
          key: 'redo',
          value: function redo() {
            if (this.__history.length <= this.__historyIndex) {
              return;
            }

            this.__historyIndex++;
            return this.__history[this.__historyIndex - 1].do();
          }
          /**
           * Return description of latest operation.
           * If there are no operation before the current state, it will return empty string instead.
           * @returns {string} Description of operation
           */

        }, {
          key: 'getUndoDesc',
          value: function getUndoDesc() {
            return this.__history[this.__historyIndex - 1] ? this.__history[this.__historyIndex - 1].desc : '';
          }
          /**
           * Return description of recently undo-ed operation.
           * If there are no operation after the current state, it will return empty string instead.
           * @returns {string} Description of operation
           */

        }, {
          key: 'getRedoDesc',
          value: function getRedoDesc() {
            return this.__history[this.__historyIndex] ? this.__history[this.__historyIndex].desc : '';
          }
          /**
           * Drop all the history. YABAI.
           */

        }, {
          key: 'dropHistory',
          value: function dropHistory() {
            this.__history.splice(0);

            this.__historyIndex = 0;
          }
          /**
           * Set new length for this automaton instance.
           * **Some nodes / fxs might be automatically removed / changed.**
           * Can be performed via GUI.
           * @param {number} _length New length for the automaton
           * @returns {void} void
           */

        }, {
          key: 'setLength',
          value: function setLength(_length) {
            // if length is invalid then throw error
            if (isNaN(_length)) {
              throw new Error('Automaton.setLength: _length is invalid');
            } // if length is not changed then do fast-return


            if (_length === this.length) {
              return;
            } // changeLength is a good method


            for (var paramName in this.__params) {
              var param = this.__params[paramName];
              param.changeLength(_length);
            } // finally set the length


            this.__length = _length; // It's irreversible operation, sorry.

            this.dropHistory(); // Poke vue

            this.__vue.$emit('changedLength');
          }
          /**
           * Set new resolution for this automaton instance.
           * @param {number} _resolultion New resolution for the automaton lul
           * @returns {void} void
           */

        }, {
          key: 'setResolution',
          value: function setResolution(_resolultion) {
            // lul
            this.__resolution = _resolultion; // lul

            this.precalcAll();
          }
          /**
           * Create a new param.
           * @param {string} _name Name of param
           * @returns {Param} Created param
           */

        }, {
          key: 'createParam',
          value: function createParam(_name, _data) {
            var param = new _paramGui2.default({
              automaton: this,
              data: _data
            });

            _vue2.default.set(this.__params, _name, param);

            return param;
          }
          /**
           * Remove a param.
           * @param {string} _name Name of param
           * @returns {void} void
           */

        }, {
          key: 'removeParam',
          value: function removeParam(_name) {
            _vue2.default.delete(this.__params, _name);
          }
          /**
           * Get a param.
           * @param {string} _name Name of the param
           * @returns {Param} Param object
           */

        }, {
          key: 'getParam',
          value: function getParam(_name) {
            return this.__params[_name] || null;
          }
          /**
           * Return list of name of params. Sorted.
           * @returns {Array} List of name of params
           */

        }, {
          key: 'getParamNames',
          value: function getParamNames() {
            var arr = [];

            for (var name in this.__params) {
              arr.push(name);
            }

            arr = arr.sort();
            return arr;
          }
          /**
           * Return list of id of fx definitions. Sorted.
           * @returns {Array} List of id of fx definitions
           */

        }, {
          key: 'getFxDefinitionIds',
          value: function getFxDefinitionIds() {
            var arr = [];

            for (var id in this.__paramFxDefs) {
              arr.push(id);
            }

            arr = arr.sort();
            return arr;
          }
          /**
           * Return display name of a fx definition.
           * @param {string} _id Id of the fx definition you want to grab
           * @returns {string} Name of the fx definition
           */

        }, {
          key: 'getFxDefinitionName',
          value: function getFxDefinitionName(_id) {
            if (this.__paramFxDefs[_id]) {
              return this.__paramFxDefs[_id].name || _id;
            } else {
              return undefined;
            }
          }
          /**
           * Return description of a fx definition.
           * @param {string} _id Id of the fx definition you want to grab
           * @returns {string} Description of the fx definition
           */

        }, {
          key: 'getFxDefinitionDescription',
          value: function getFxDefinitionDescription(_id) {
            if (this.__paramFxDefs[_id]) {
              return this.__paramFxDefs[_id].description || '';
            } else {
              return undefined;
            }
          }
          /**
           * Return params section of a fx definition.
           * @param {string} _id Id of the fx definition you want to grab
           * @returns {Object} Params section
           */

        }, {
          key: 'getFxDefinitionParams',
          value: function getFxDefinitionParams(_id) {
            if (this.__paramFxDefs[_id]) {
              return (0, _jsonCopy2.default)(this.__paramFxDefs[_id].params || {});
            } else {
              return undefined;
            }
          }
          /**
           * Return count of params.
           * @returns {number} Count of params
           */

        }, {
          key: 'countParams',
          value: function countParams() {
            var sum = 0;

            for (var name in this.__params) {
              sum++;
            }

            return sum;
          }
          /**
           * Assigned to `Automaton.auto` at constructor.
           * @param {string} _name name of the param
           * @returns {number} Current value of the param
           * @protected
           */

        }, {
          key: '__auto',
          value: function __auto(_name) {
            var param = this.__params[_name];

            if (!param) {
              param = this.createParam(_name);
            }

            param.markAsUsed();
            return param.getValue();
          }
          /**
           * Load automaton state data.
           * @param {Object} _data Object contains automaton data.
           * @returns {void} void
           */

        }, {
          key: 'load',
          value: function load(_data) {
            var data = (0, _compat2.default)(_data);

            _get(AutomatonWithGUI.prototype.__proto__ || Object.getPrototypeOf(AutomatonWithGUI.prototype), 'load', this).call(this, data);
            /**
             * GUI settings.
             * Feel free to get / set these values.
             * @type {Object}
             */


            this.guiSettings = data.guiSettings; // Poke vue

            if (this.__vue) {
              this.__vue.$emit('loaded');
            } // Bye history


            if (this.__history) {
              this.dropHistory();
            }
          }
          /**
           * Export current state as JSON.
           * @returns {string} Saved object as JSON
           * @example
           * あとでやる
           * @todo はい
           */

        }, {
          key: 'save',
          value: function save() {
            var ret = {
              v: this.version,
              length: this.length,
              resolution: this.resolution,
              params: {},
              // will be filled later
              guiSettings: this.guiSettings
            };
            ret.params = {};

            for (var name in this.__params) {
              var param = this.__params[name];
              ret.params[name] = {
                nodes: param.dumpNodesWithoutId(),
                fxs: param.dumpFxsWithoutId()
              };
            }

            return JSON.stringify(ret);
          }
          /**
           * Poke the vue renderer.
           * @returns {void} void
           */

        }, {
          key: 'pokeRenderer',
          value: function pokeRenderer() {
            if (this.__vue) {
              this.__vue.$emit('poke');
            }
          }
        }]);

        return AutomatonWithGUI;
      }(_main2.default);

      module.exports = AutomatonWithGUI;
      AutomatonWithGUI.default = AutomatonWithGUI;
    }, {
      "./ass": 67,
      "./compat": 71,
      "./fx-definitions": 73,
      "./json-copy": 97,
      "./main": 99,
      "./param-gui": 100,
      "./vue/main.vue": 105,
      "vue": 65
    }],
    99: [function (require, module, exports) {
      'use strict';

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _clock = require('./clock');

      var _clock2 = _interopRequireDefault(_clock);

      var _clockFrame = require('./clock-frame');

      var _clockFrame2 = _interopRequireDefault(_clockFrame);

      var _clockRealtime = require('./clock-realtime');

      var _clockRealtime2 = _interopRequireDefault(_clockRealtime);

      var _param = require('./param');

      var _param2 = _interopRequireDefault(_param);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      /**
       * IT'S AUTOMATON!
       * It's `automaton.nogui.js` version and also base class for {@link AutomatonWithGUI}.
       * @param {Object} _props
       * @param {boolean} [_props.loop] Whether let the time loop or not
       * @param {number} [_props.fps] If this is set, the clock will become frame mode
       * @param {boolean} [_props.realtime] If this is true, the clock will become realtime mode
       * @param {Object} _props.data Data of the automaton. **Required in noGUI mode**
       */


      var Automaton = function () {
        function Automaton(_props) {
          var _this = this;

          _classCallCheck(this, Automaton);
          /**
           * Version of the automaton.
           * @type {number}
           * @protected
           */


          this.__version = "2.0.1";
          /**
           * Whether the animation will be looped or not.
           * @type {boolean}
           */

          this.loop = _props.loop || false;
          /**
           * Clock of the automaton.
           * @type {Clock}
           * @protected
           */

          this.__clock = _props.fps ? new _clockFrame2.default(this, _props.fps) : _props.realtime ? new _clockRealtime2.default(this) : new _clock2.default(this);
          /**
           * List of event listeners.
           * @type {Object.<string, function[]>}
           */

          this.__listeners = {};
          /**
           * A list of param fx definitions.
           * @type {Object.<string, Fx>}
           * @protected
           */

          this.__paramFxDefs = {};
          var data = _props.data;
          this.load(data);
          /**
           * **THE MIGHTY `auto()` FUNCTION!! GRAB IT**
           * It creates a new param automatically if there are no param called `_name` (GUI mode only).
           * Otherwise it returns current value of the param called `_name`.
           * @param {string} _name name of the param
           * @returns {number} Current value of the param
           */

          this.auto = function (_name) {
            return _this.__auto(_name);
          };
        }
        /**
         * Version of the automaton.
         * @type {number}
         * @readonly
         */


        _createClass(Automaton, [{
          key: 'createParam',

          /**
           * Create a new param.
           * @param _name Name of the param
           * @param _data Data for the param
           * @returns {void} void
           */
          value: function createParam(_name, _data) {
            this.__params[name] = new _param2.default({
              automaton: this,
              data: _data
            });
          }
          /**
           * Load automaton state data.
           * @param {Object} _data Object contains automaton data.
           * @returns {void} void
           */

        }, {
          key: 'load',
          value: function load(_data) {
            /**
             * Total length of animation in seconds.
             * @type {number}
             * @protected
             */
            this.__length = _data.length;
            /**
             * Resolution = Sampling point per second.
             * @type {number}
             * @protected
             */

            this.__resolution = _data.resolution;
            /**
             * List of Param.
             * @type {Object.<string, Param>}
             * @protected
             */

            this.__params = {};

            for (var _name2 in _data.params) {
              this.createParam(_name2, _data.params[_name2]);
            }
          }
          /**
           * Seek the timeline.
           * Can be performed via GUI.
           * @param {number} _time Time
           * @returns {void} void
           */

        }, {
          key: 'seek',
          value: function seek(_time) {
            this.__clock.setTime(_time);

            this.__emit('seek');
          }
          /**
           * Play the timeline.
           * @returns {void} void
           * @todo SHOULD be performed via GUI.
           */

        }, {
          key: 'play',
          value: function play() {
            this.__clock.play();

            this.__emit('play');
          }
          /**
           * Pause the timeline.
           * @returns {void} void
           * @todo SHOULD be performed via GUI.
           */

        }, {
          key: 'pause',
          value: function pause() {
            this.__clock.pause();

            this.__emit('pause');
          }
          /**
           * Add a fx definition.
           * @param {string} _id Unique id for the Fx definition
           * @param {FxDefinition} _fxDef Fx definition object
           * @returns {void} void
           */

        }, {
          key: 'addFxDefinition',
          value: function addFxDefinition(_id, _fxDef) {
            this.__paramFxDefs[_id] = _fxDef;
            this.precalcAll();
          }
          /**
           * Emit an event.
           * @param {string} _event Event name
           * @param {...any} _arg Arguments passed to listeners
           * @returns {void} void
           * @protected
           */

        }, {
          key: '__emit',
          value: function __emit(_event) {
            for (var _len = arguments.length, _arg = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              _arg[_key - 1] = arguments[_key];
            }

            if (!this.__listeners[_event]) {
              return;
            }

            this.__listeners[_event].map(function (listener) {
              return listener.apply(undefined, _arg);
            });
          }
          /**
           * Register a listener function.
           * @param {string} _event Event name
           * @param {function} _func Listener function
           * @returns {void} void
           */

        }, {
          key: 'on',
          value: function on(_event, _func) {
            if (!this.__listeners[_event]) {
              this.__listeners[_event] = [];
            }

            this.__listeners[_event].push(_func);
          }
          /**
           * Precalculate all params.
           * @returns {void} void
           */

        }, {
          key: 'precalcAll',
          value: function precalcAll() {
            for (var _name3 in this.__params) {
              this.__params[_name3].precalc();
            }
          }
          /**
           * Update the entire automaton.
           * **You may want to call this in your update loop.**
           * @param {number} [_time] Current time, **Required if the clock mode is manual**
           * @returns {void} void
           */

        }, {
          key: 'update',
          value: function update(_time) {
            // update the clock
            this.__clock.update(_time); // if loop is enabled, loop the time


            if (this.loop && (this.time < 0 || this.length < this.time)) {
              this.__clock.setTime(this.time - Math.floor(this.time / this.length) * this.length);
            } // grab current value for each param


            for (var _name4 in this.__params) {
              this.__params[_name4].getValue();
            }
          }
          /**
           * Assigned to Automaton.auto at constructor.
           * @param {string} _name name of the param
           * @returns {number} Current value of the param
           * @protected
           */

        }, {
          key: '__auto',
          value: function __auto(_name) {
            return this.params[_name].__currentValue;
          }
        }, {
          key: 'version',
          get: function get() {
            return this.__version;
          }
          /**
           * Current time. Same as `automaton.__clock.time`.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'time',
          get: function get() {
            return this.__clock.time;
          }
          /**
           * Total length of animation in seconds.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'length',
          get: function get() {
            return this.__length;
          }
          /**
           * Resolution = Sampling point per second.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'resolution',
          get: function get() {
            return this.__resolution;
          }
          /**
           * Delta of time between now and previous update call.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'deltaTime',
          get: function get() {
            return this.__clock.deltaTime;
          }
          /**
           * Whether it's playing or not.
           * @type {boolean}
           * @readonly
           */

        }, {
          key: 'isPlaying',
          get: function get() {
            return this.__clock.isPlaying;
          }
          /**
           * Current progress by whole length. Might NOT be [0-1] unless `_props.loop` (see constructor) is true.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'progress',
          get: function get() {
            return this.time / this.length;
          }
          /**
           * Frame per second. If the clock type is not fps, it will return `0` instead.
           * @type {number}
           * @readonly
           */

        }, {
          key: 'fps',
          get: function get() {
            return this.__clock.fps ? this.__clock.fps : 0;
          }
          /**
           * Boolean that represents whether the clock is based on realtime or not.
           * @type {boolean}
           * @readonly
           */

        }, {
          key: 'realtime',
          get: function get() {
            return Boolean(this.__clock.realtime);
          }
        }]);

        return Automaton;
      }();

      module.exports = Automaton;
      Automaton.default = Automaton;
    }, {
      "./clock": 70,
      "./clock-frame": 68,
      "./clock-realtime": 69,
      "./param": 101
    }],
    100: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _get = function get(object, property, receiver) {
        if (object === null) object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);

        if (desc === undefined) {
          var parent = Object.getPrototypeOf(object);

          if (parent === null) {
            return undefined;
          } else {
            return get(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;

          if (getter === undefined) {
            return undefined;
          }

          return getter.call(receiver);
        }
      };

      var _jsonCopy = require('./json-copy');

      var _jsonCopy2 = _interopRequireDefault(_jsonCopy);

      var _ass = require('./ass');

      var _ass2 = _interopRequireDefault(_ass);

      var _genId = require('./gen-id');

      var _genId2 = _interopRequireDefault(_genId);

      var _hasOverwrap = require('./has-overwrap');

      var _hasOverwrap2 = _interopRequireDefault(_hasOverwrap);

      var _mainGui = require('./main-gui');

      var _mainGui2 = _interopRequireDefault(_mainGui);

      var _param = require('./param');

      var _param2 = _interopRequireDefault(_param);

      var _vue = require('vue');

      var _vue2 = _interopRequireDefault(_vue);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      /**
       * It represents a param of Automaton.
       * It's `automaton.js` and `automaton.min.js` version.
       * It has even more pretty APIs yay
       * @param {Object} _props
       * @param {Automaton} _props.automaton Parent automaton
       * @param {Object} [_props.data] Data of the param. Don't worry, I can generate an initial data for you!
       */


      var ParamWithGUI = function (_Param) {
        _inherits(ParamWithGUI, _Param);

        function ParamWithGUI(_props) {
          _classCallCheck(this, ParamWithGUI);

          var props = Object.assign({}, _props);
          var len = _props.automaton.length;
          props.data = props.data ? props.data : {
            nodes: [{
              time: 0.0,
              value: 0.0,
              out: {
                time: ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                value: 0.0
              }
            }, {
              time: len,
              value: 0.0,
              in: {
                time: -ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                value: 0.0
              }
            }],
            fxs: []
          };
          /**
           * True if the param is used once at least in current session.
           * Can be operated by {@link ParamWithGUI#markAsUsed}.
           * @type {boolean}
           * @protected
           */

          var _this = _possibleConstructorReturn(this, (ParamWithGUI.__proto__ || Object.getPrototypeOf(ParamWithGUI)).call(this, props));

          _this.__isUsed = false;
          return _this;
        }
        /**
         * Load a param data.
         * @param {object} _data Data of param
         * @returns {void} void
         */


        _createClass(ParamWithGUI, [{
          key: 'load',
          value: function load(_data) {
            var data = (0, _jsonCopy2.default)(_data);

            _get(ParamWithGUI.prototype.__proto__ || Object.getPrototypeOf(ParamWithGUI.prototype), 'load', this).call(this, data);

            this.__nodes.forEach(function (node) {
              return node.$id = (0, _genId2.default)();
            });

            this.__fxs.forEach(function (fx) {
              return fx.$id = (0, _genId2.default)();
            });
          }
          /**
           * Precalculate values.
           * @returns {void} void
           */

        }, {
          key: 'precalc',
          value: function precalc() {
            _get(ParamWithGUI.prototype.__proto__ || Object.getPrototypeOf(ParamWithGUI.prototype), 'precalc', this).call(this);

            this.__automaton.pokeRenderer();
          }
          /**
           * Mark this param as used.
           * @returns {void} void
           */

        }, {
          key: 'markAsUsed',
          value: function markAsUsed() {
            this.__isUsed = true;
          }
          /**
           * Return whether this is used param or not.
           * @returns {bool} True if the param is used at least once in current session
           */

        }, {
          key: 'isUsed',
          value: function isUsed() {
            return this.__isUsed;
          }
          /**
           * Sort nodes by time.
           * @returns {void} void
           * @protected
           */

        }, {
          key: '__sortNodes',
          value: function __sortNodes() {
            this.__nodes = this.__nodes.sort(function (a, b) {
              return a.time - b.time;
            });
          }
          /**
           * Search for node that has given id then return index of it.
           * If it couldn't find the node, it will throw an error instead.
           * @param {number} _id Id of node you want to grab
           * @protected
           */

        }, {
          key: '__getNodeIndexById',
          value: function __getNodeIndexById(_id) {
            var index = this.__nodes.findIndex(function (node) {
              return node.$id === _id;
            });

            if (index === -1) {
              throw new Error('Searched for node id: ' + _id + ' but not found');
            }

            return index;
          }
          /**
           * Return how many node the param currently have.
           * @returns {number} Nodes count
           */

        }, {
          key: 'getNumNode',
          value: function getNumNode() {
            return this.__nodes.length;
          }
          /**
           * Dump data of a node.
           * @param {string} _id Id of the node you want to dump
           * @returns {object} Data of the node
           */

        }, {
          key: 'dumpNode',
          value: function dumpNode(_id) {
            var index = this.__getNodeIndexById(_id);

            return (0, _jsonCopy2.default)(this.__nodes[index]);
          }
          /**
           * Dump data of nodes.
           * @returns {object[]} Data of nodes
           */

        }, {
          key: 'dumpNodes',
          value: function dumpNodes() {
            return (0, _jsonCopy2.default)(this.__nodes);
          }
          /**
           * Dump data of nodes, without `$id`.
           * @returns {object[]} Data of nodes
           */

        }, {
          key: 'dumpNodesWithoutId',
          value: function dumpNodesWithoutId() {
            var nodes = this.dumpNodes();
            return nodes.map(function (node) {
              delete node.$id;
              return node;
            });
          }
          /**
           * Create a node.
           * @param {number} _time Time of new node
           * @param {number} _value Value of new node
           * @returns {string} Id of the new node
           */

        }, {
          key: 'createNode',
          value: function createNode(_time, _value) {
            var data = {
              $id: (0, _genId2.default)(),
              time: _time,
              value: _value,
              in: {
                time: -ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                value: 0.0
              },
              out: {
                time: ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                value: 0.0
              }
            };

            this.__nodes.push(data);

            this.__sortNodes();

            this.precalc();
            return data.$id;
          }
          /**
           * Create a node from dumped data.
           * @param {object} _obj Dumped node data
           * @returns {string} Id of the new node
           */

        }, {
          key: 'createNodeFromData',
          value: function createNodeFromData(_obj) {
            var data = (0, _jsonCopy2.default)(_obj);

            this.__nodes.push(data);

            this.__sortNodes();

            this.precalc();
            return data.$id;
          }
          /**
           * Remove a node.
           * @param {string} _id Id of the node you want to remove
           * @returns {void} void
           */

        }, {
          key: 'removeNode',
          value: function removeNode(_id) {
            var index = this.__getNodeIndexById(_id);

            this.__nodes.splice(index, 1);

            this.precalc();
          }
          /**
           * Move a node.
           * @param {string} _id Id of the node you want to move
           * @param {number} _time Time
           * @param {number} _value Value
           * @returns {void} void
           */

        }, {
          key: 'moveNode',
          value: function moveNode(_id, _time, _value) {
            var index = this.__getNodeIndexById(_id);

            var node = this.__nodes[index];
            var time = typeof _time === 'number' ? _time : node.time;

            if (index === 0) {
              time = 0;
            } else if (index === this.__nodes.length - 1) {
              time = this.__automaton.length;
            } else {
              time = Math.min(Math.max(time, this.__nodes[index - 1].time), this.__nodes[index + 1].time);
            }

            node.time = time;
            node.value = typeof _value === 'number' ? _value : node.value;
            this.precalc();
          }
          /**
           * Move a handle of a node.
           * @param {string} _id Id of the node you want to operate
           * @param {boolean} _isOut Input handle if false, output handle if true
           * @param {number} _time Time
           * @param {number} _value Value
           * @returns {void} void
           */

        }, {
          key: 'moveHandle',
          value: function moveHandle(_id, _isOut, _time, _value) {
            var index = this.__getNodeIndexById(_id);

            if (index === 0 && !_isOut || index === this.getNumNode() - 1 && _isOut) {
              return;
            }

            var node = this.__nodes[index];
            var handle = _isOut ? node.out : node.in;
            var time = typeof _time === 'number' ? _time : handle.time;

            if (_isOut) {
              time = Math.max(0.0, time);
            } else {
              time = Math.min(0.0, time);
            }

            handle.time = time;
            handle.value = typeof _value === 'number' ? _value : handle.value;
            this.precalc();
          }
          /**
           * Reset a handle of a node.
           * @param {string} _id Id of the node you want to operate
           * @param {boolean} _isOut Input handle if false, output handle if true
           * @returns {void} void
           */

        }, {
          key: 'resetHandle',
          value: function resetHandle(_id, _isOut) {
            var index = this.__getNodeIndexById(_id);

            if (index === 0 && !_isOut || index === this.getNumNode() - 1 && _isOut) {
              return;
            }

            var node = this.__nodes[index];
            var handle = _isOut ? node.out : node.in;
            handle.time = (_isOut ? 1.0 : -1.0) * ParamWithGUI.DEFAULT_HANDLE_LENGTH;
            handle.value = 0.0;
            this.precalc();
          }
          /**
           * Sort fxs by time.
           * @returns {void} void
           * @protected
           */

        }, {
          key: '__sortFxs',
          value: function __sortFxs() {
            this.__fxs = this.__fxs.sort(function (a, b) {
              return a.time - b.time;
            }).sort(function (a, b) {
              return a.row - b.row;
            });
          }
          /**
           * Search for fx that has given id then return index of it.
           * If it couldn't find the fx, it will throw an error instead.
           * @param {number} _id Id of fx you want to grab
           * @protected
           */

        }, {
          key: '__getFxIndexById',
          value: function __getFxIndexById(_id) {
            var index = this.__fxs.findIndex(function (fx) {
              return fx.$id === _id;
            });

            if (index === -1) {
              throw new Error('Searched for fx id: ' + _id + ' but not found');
            }

            return index;
          }
          /**
           * Search for vacance fx row for given time and length.
           * @param {number} _time Beginning time of fx
           * @param {number} _length Length of fx
           * @param {number} [_row=0] If given, rows lower than this value will not be searched.
           * @returns {number} Minimal free fx row
           * @protected
           */

        }, {
          key: '__getFreeRow',
          value: function __getFreeRow(_time, _length, _row) {
            var row = _row || 0;

            for (var iFx = 0; iFx < this.__fxs.length; iFx++) {
              var fx = this.__fxs[iFx];

              if (fx.row < row) {
                continue;
              }

              if (row < fx.row) {
                break;
              }

              if ((0, _hasOverwrap2.default)(_time, _length, fx.time, fx.length)) {
                row++;
              }
            }

            return row;
          }
          /**
           * Dump data of a fx.
           * @param {number} _id Id of a fx you want to dump
           * @returns {object} Data of the fx
           */

        }, {
          key: 'dumpFx',
          value: function dumpFx(_id) {
            var index = this.__getFxIndexById(_id);

            return (0, _jsonCopy2.default)(this.__fxs[index]);
          }
          /**
           * Dump data of fxs.
           * @returns {object[]} Data of fxs
           */

        }, {
          key: 'dumpFxs',
          value: function dumpFxs() {
            return (0, _jsonCopy2.default)(this.__fxs);
          }
          /**
           * Dump data of fxs, without `$id`.
           * @returns {object[]} Data of fxs
           */

        }, {
          key: 'dumpFxsWithoutId',
          value: function dumpFxsWithoutId() {
            var fxs = this.dumpFxs();
            return fxs.map(function (fx) {
              delete fx.$id;
              return fx;
            });
          }
          /**
           * Create a fx.
           * If it couldn't create param, it will return empty string instead.
           * @param {number} _time Beginning time of new fx
           * @param {number} _length Length of new fx
           * @param {string} _def Definition id (kind) of new fx
           * @returns {string} Id of the new fx
           */

        }, {
          key: 'createFx',
          value: function createFx(_time, _length, _def) {
            var row = this.__getFreeRow(_time, _length);

            if (ParamWithGUI.FX_ROW_MAX < row) {
              console.error('Too many fx stacks at here!');
              return '';
            }

            var data = {
              $id: (0, _genId2.default)(),
              time: _time,
              length: _length,
              row: row,
              def: _def,
              params: this.__automaton.generateDefaultFxParams(_def)
            };

            this.__fxs.push(data);

            this.__sortFxs();

            this.precalc();
            return data.$id;
          }
          /**
           * Create a fx from dumped data.
           * If it couldn't create param, it will return empty string instead.
           * @param {object} _obj Dumped fx data
           * @returns {string} Id of the new fx
           */

        }, {
          key: 'createFxFromData',
          value: function createFxFromData(_obj) {
            var row = this.__getFreeRow(_obj.time, _obj.length, _obj.row);

            if (ParamWithGUI.FX_ROW_MAX < row) {
              console.error('Too many fx stacks at here!');
              return '';
            }

            var data = (0, _jsonCopy2.default)(_obj);
            data.row = row;

            this.__fxs.push(data);

            this.__sortFxs();

            this.precalc();
            return data.$id;
          }
          /**
           * Remove a fx.
           * @param {string} _id Id of the fx you want to remove
           * @returns {void} void
           */

        }, {
          key: 'removeFx',
          value: function removeFx(_id) {
            var index = this.__getFxIndexById(_id);

            this.__fxs.splice(index, 1);

            this.precalc();
          }
          /**
           * Move a fx.
           * @param {string} _id Id of the fx you want to move
           * @param {number} _time Beginning time
           * @returns {void} void
           */

        }, {
          key: 'moveFx',
          value: function moveFx(_id, _time) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];

            var sameRow = this.__fxs.filter(function (fxOp) {
              return fxOp.row === fx.row;
            });

            var indexInRow = sameRow.indexOf(fx);
            var prev = sameRow[indexInRow - 1];
            var next = sameRow[indexInRow + 1];
            var left = prev ? prev.time + prev.length : 0.0;
            var right = next ? next.time : this.__automaton.length;
            fx.time = Math.min(Math.max(_time, left), right - fx.length);
            this.precalc();
          }
          /**
           * Change row of a fx.
           * @param {string} _id Id of the fx you want to move
           * @param {number} _row Row
           * @returns {void} void
           */

        }, {
          key: 'changeFxRow',
          value: function changeFxRow(_id, _row) {
            var index = this.__getFxIndexById(_id);

            if (_row < 0 || ParamWithGUI.FX_ROW_MAX < _row) {
              throw new Error('Row number ' + _row + ' is invalid');
            }

            var fx = this.__fxs[index];

            if (fx.row === _row) {
              return;
            }

            var sameRow = this.__fxs.filter(function (fxOp) {
              return fxOp.row === _row;
            });

            var isValid = sameRow.every(function (fxOp) {
              return !(fxOp.time < fx.time && fx.time < fxOp.time + fxOp.length) && !(fxOp.time < fx.time + fx.length && fx.time + fx.length < fxOp.time + fxOp.length) && !(fx.time < fxOp.time && fxOp.time < fx.time + fx.length) && !(fx.time < fxOp.time + fxOp.length && fxOp.time + fxOp.length < fx.time + fx.length);
            });

            if (!isValid) {
              return;
            }

            fx.row = _row;

            this.__sortFxs();

            this.precalc();
          }
          /**
           * Bypass or unbypass a fx.
           * @param {string} _id Id of the fx you want to change
           * @param {boolean} _bypass If true, fx will be bypassed
           * @returns {void} void
           */

        }, {
          key: 'bypassFx',
          value: function bypassFx(_id, _bypass) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];

            _vue2.default.set(fx, 'bypass', !!_bypass);

            this.precalc();
          }
          /**
           * Change a param of a fx.
           * @param {string} _id Id of the fx you want to change
           * @param {string} _name Name of the param you want to change
           * @param {any} _value Your desired value
           * @returns {void} void
           */

        }, {
          key: 'changeFxParam',
          value: function changeFxParam(_id, _name, _value) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];

            var params = this.__automaton.getFxDefinitionParams(fx.def);

            var value = _value;

            if (typeof params[_name].min === 'number') {
              value = Math.max(params[_name].min, value);
            }

            if (typeof params[_name].max === 'number') {
              value = Math.min(params[_name].max, value);
            }

            _vue2.default.set(fx.params, _name, value);

            this.precalc();
          }
          /**
           * Move a fx --force.
           * Best for undo-redo operation. probably.
           * @param {string} _id Id of the fx you want to move
           * @param {number} _time Beginning time
           * @param {number} _row Row
           * @returns {void} void
           */

        }, {
          key: 'forceMoveFx',
          value: function forceMoveFx(_id, _time, _row) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];
            fx.time = _time;
            fx.row = _row;

            this.__sortFxs();

            this.precalc();
          }
          /**
           * Resize a fx.
           * @param {string} _id Index of the fx you want to resize
           * @param {number} _length Length
           * @returns {void} void
           */

        }, {
          key: 'resizeFx',
          value: function resizeFx(_id, _length) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];

            var sameRow = this.__fxs.filter(function (fxOp) {
              return fxOp.row === fx.row;
            });

            var indexInRow = sameRow.indexOf(fx);
            var next = sameRow[indexInRow + 1];
            var right = next ? next.time : this.__automaton.length;
            fx.length = Math.min(Math.max(_length, 0.0), right - fx.time);
            this.precalc();
          }
          /**
           * Resize a fx by left side of the end.
           * It's very GUI dev friendly method. yeah.
           * @param {string} _id Index of the fx you want to resize
           * @param {number} _length Length
           * @returns {void} void
           */

        }, {
          key: 'resizeFxByLeft',
          value: function resizeFxByLeft(_id, _length) {
            var index = this.__getFxIndexById(_id);

            var fx = this.__fxs[index];
            var end = fx.time + fx.length;

            var sameRow = this.__fxs.filter(function (fxOp) {
              return fxOp.row === fx.row;
            });

            var indexInRow = sameRow.indexOf(fx);
            var prev = sameRow[indexInRow - 1];
            var left = prev ? prev.time + prev.length : 0.0;
            fx.length = Math.min(Math.max(_length, 0.0), end - left);
            fx.time = end - fx.length;
            this.precalc();
          }
          /**
           * Call when you need to change automaton length.
           * This is very hardcore method. Should not be called by anywhere except {@link AutomatonWithGUI#setLength}.
           * @param {number} _length Desired length
           * @returns {void} void
           */

        }, {
          key: 'changeLength',
          value: function changeLength(_length) {
            for (var i = this.__nodes.length - 1; 0 <= i; i--) {
              var node = this.__nodes[i];

              if (_length < node.time) {
                this.__nodes.splice(i, 1);
              } else if (node.time === _length) {
                delete node.out;
                break;
              } else {
                var lastNode = this.__nodes[this.__nodes.length - 1];

                if (lastNode) {
                  lastNode.out = {
                    time: ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                    value: 0.0
                  };
                }

                this.__nodes.push({
                  time: _length,
                  value: 0.0,
                  in: {
                    time: -ParamWithGUI.DEFAULT_HANDLE_LENGTH,
                    value: 0.0
                  }
                });

                break;
              }
            }

            for (var _i = this.__fxs.length - 1; 0 <= _i; _i--) {
              var fx = this.__fxs[_i];

              if (_length < fx.time) {
                this.__fxs.splice(_i, 1);
              } else if (_length < fx.time + fx.length) {
                fx.length = _length - fx.time;
              }
            }

            this.__values = new Float32Array(this.__automaton.resolution * _length + 1);
            this.precalc();
          }
        }]);

        return ParamWithGUI;
      }(_param2.default);
      /**
       * Handles of a new node will be created in this length.
       * @type {number}
       * @constant
       */


      ParamWithGUI.DEFAULT_HANDLE_LENGTH = 0.5;
      ParamWithGUI.FX_ROW_MAX = 4;
      exports.default = ParamWithGUI;
    }, {
      "./ass": 67,
      "./gen-id": 84,
      "./has-overwrap": 85,
      "./json-copy": 97,
      "./main-gui": 98,
      "./param": 101,
      "vue": 65
    }],
    101: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var _cubicBezier = require('./cubic-bezier');

      var _cubicBezier2 = _interopRequireDefault(_cubicBezier);

      var _main = require('./main');

      var _main2 = _interopRequireDefault(_main);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      /**
       * It represents a param of Automaton.
       * It's `automaton.nogui.js` version and also base class for {@link ParamWithGUI}
       * @param {Object} _props
       * @param {Automaton} _props.automaton Parent automaton
       * @param {Object} [_props.data] Data of the param. **Required in noGUI mode**
       */


      var Param = function () {
        function Param(_props) {
          _classCallCheck(this, Param);
          /**
           * The parent automaton.
           * @type {Automaton}
           * @protected
           */


          this.__automaton = _props.automaton;
          /**
           * An array of precalculated value.
           * Its length is same as `param.__automaton.resolution * param.__automaton.length + 1`.
           * @type {number[]}
           * @protected
           */

          this.__values = new Float32Array(this.__automaton.resolution * this.__automaton.length + 1);
          this.load(_props.data);
          /**
           * A buffer of last calculated value.
           * @type {number}
           * @protected
           */

          this.__lastValue = 0.0;
          /**
           * Will be used for calculation of `param.__lastValue`.
           * @type {number}
           * @protected
           */

          this.__lastTime = 0.0;
        }
        /**
         * Load a param data.
         * @param {object} _data Data of param
         * @returns {void} void
         */


        _createClass(Param, [{
          key: 'load',
          value: function load(_data) {
            /**
             * List of node.
             * @type {ParamNode[]}
             * @protected
             */
            this.__nodes = _data.nodes;
            /**
             * List of fx.
             * @type {ParamFxStrip[]}
             * @protected
             */

            this.__fxs = _data.fxs;
            this.precalc();
          }
          /**
           * Precalculate value of a sample.
           * @returns {void} void
           */

        }, {
          key: 'precalc',
          value: function precalc() {
            for (var iNode = 0; iNode < this.__nodes.length - 1; iNode++) {
              var node0 = this.__nodes[iNode];
              var node1 = this.__nodes[iNode + 1];
              var i0 = Math.floor(node0.time * this.__automaton.resolution);
              var i1 = Math.floor(node1.time * this.__automaton.resolution);
              this.__values[i0] = node0.value;

              for (var i = i0 + 1; i <= i1; i++) {
                var time = i / this.__automaton.resolution;
                var value = (0, _cubicBezier2.default)(node0, node1, time);
                this.__values[i] = value;
              }
            }

            for (var iFx = 0; iFx < this.__fxs.length; iFx++) {
              var fx = this.__fxs[iFx];

              if (fx.bypass) {
                continue;
              }

              var fxDef = this.__automaton.__paramFxDefs[fx.def];

              if (!fxDef) {
                continue;
              }

              var _i = Math.ceil(this.__automaton.resolution * fx.time);

              var _i2 = Math.floor(this.__automaton.resolution * (fx.time + fx.length));

              var tempValues = new Float32Array(_i2 - _i);
              var tempLength = tempValues.length;
              var context = {
                i0: _i,
                i1: _i2,
                t0: fx.time,
                t1: fx.time + fx.length,
                dt: 1.0 / this.__automaton.resolution,
                resolution: this.__automaton.resolution,
                length: fx.length,
                params: fx.params,
                array: this.__values,
                getValue: this.getValue.bind(this),
                init: true
              };

              for (var _i3 = 0; _i3 < tempLength; _i3++) {
                context.i = _i3 + _i;
                context.t = context.i / this.__automaton.resolution;
                context.v = this.__values[_i3 + _i];
                context.progress = (context.t - fx.time) / fx.length;
                tempValues[_i3] = fxDef.func(context);
                context.init = false;
              }

              this.__values.set(tempValues, _i);
            }
          }
          /**
           * Return the value of specified time point.
           * @param {number} {_time} Time at the point you want to grab the value.
           * If it is not given, use current time of parent automaton instead
           * @returns {number} Result value
           */

        }, {
          key: 'getValue',
          value: function getValue(_time) {
            var time = _time;

            if (typeof time !== 'number') {
              // use parent automaton time instead
              time = this.__automaton.time;
            }

            if (time === this.__lastTime) {
              // use the buffer!
              return this.__lastValue;
            }

            if (this.__automaton.loop) {
              time = time - Math.floor(time / this.__automaton.length) * this.__automaton.length;
            }

            if (time <= 0.0) {
              // left clamp
              return this.__values[0];
            } else if (this.__automaton.length <= time) {
              // right clamp
              return this.__values[this.__values.length - 1];
            } else {
              // fetch two value then do linear interpolation
              var index = time * this.__automaton.resolution;
              var indexi = Math.floor(index);
              var indexf = index % 1.0;
              var v0 = this.__values[indexi];
              var v1 = this.__values[indexi + 1];
              var v = v0 + (v1 - v0) * indexf; // store lastValue

              this.__lastTime = time;
              this.__lastValue = v;
              return v;
            }
          }
        }]);

        return Param;
      }(); // ------


      exports.default = Param;
    }, {
      "./cubic-bezier": 72,
      "./main": 99
    }],
    102: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 54, stdin */\n.blur-layer[data-v-548efbdb] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: #00000066; }\n\n/* line 64, stdin */\n.root[data-v-548efbdb] {\n  position: absolute;\n  left: calc( 50% - 17em);\n  top: 1em;\n  width: 30em;\n  padding: 1em;\n  overflow: hidden;\n  background: #2c3236;\n  border-radius: 0.5em;\n  color: #c9e2ff;\n  font-size: 0.8em;\n  line-height: 1.2;\n  filter: drop-shadow(0 0 2px #000000); }\n  /* line 80, stdin */\n  .root a[data-v-548efbdb] {\n    color: #22aaff;\n    text-decoration: none; }\n    /* line 84, stdin */\n    .root a[data-v-548efbdb]:hover {\n      opacity: 0.7; }\n  /* line 87, stdin */\n  .root .logo-bg[data-v-548efbdb] {\n    position: absolute;\n    right: -1em;\n    bottom: -1em;\n    width: 14em;\n    opacity: 0.07; }\n  /* line 96, stdin */\n  .root .logo[data-v-548efbdb] {\n    width: 20em;\n    margin-bottom: 0.3em; }\n  /* line 101, stdin */\n  .root .version[data-v-548efbdb] {\n    display: inline-block;\n    vertical-align: bottom;\n    margin-left: 4px;\n    margin-bottom: 0.3em; }\n  /* line 108, stdin */\n  .root .logo-hr[data-v-548efbdb] {\n    width: 100%;\n    height: 1px;\n    margin: 0.5em 0;\n    background: #bad0eb; }\n  /* line 116, stdin */\n  .root .close[data-v-548efbdb] {\n    position: absolute;\n    right: 0.5em;\n    top: 0.5em;\n    width: 1em;\n    cursor: pointer; }\n    /* line 124, stdin */\n    .root .close[data-v-548efbdb]:hover {\n      opacity: 0.7; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = {
          name: 'about',
          props: ['automaton'],
          data: function data() {
            return {};
          },
          methods: {
            blur: function blur() {
              this.$emit('blur');
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          staticClass: "blur-layer",
          on: {
            "mousedown": _vm.blur
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "root"
        }, [_c('img', {
          staticClass: "logo-bg",
          attrs: {
            "src": require('../images/automaton-a.svg')
          }
        }), _vm._v(" "), _c('img', {
          staticClass: "logo",
          attrs: {
            "src": require('../images/automaton.svg')
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "version"
        }, [_vm._v(_vm._s(_vm.automaton.version))]), _c('br'), _vm._v("\n    Animation engine with Timeline GUI for creative coding\n\n    "), _c('div', {
          staticClass: "logo-hr"
        }), _vm._v("\n\n    Author: "), _c('a', {
          attrs: {
            "href": "https://github.com/fms-cat/",
            "target": "_blank"
          }
        }, [_vm._v("@FMS_Cat")]), _c('br'), _vm._v("\n    Repository: "), _c('a', {
          attrs: {
            "href": "https://github.com/fms-cat/automaton/",
            "target": "_blank"
          }
        }, [_vm._v("https://github.com/fms-cat/automaton/")]), _c('br'), _vm._v("\n    Automaton is distributed under permissive "), _c('a', {
          attrs: {
            "href": "https://opensource.org/licenses/MIT",
            "target": "_blank"
          }
        }, [_vm._v("MIT License")]), _vm._v("."), _c('br'), _vm._v("\n    Shoutouts to "), _c('a', {
          attrs: {
            "href": "https://www.image-line.com/flstudio/",
            "target": "_blank"
          }
        }, [_vm._v("Image Line Software")]), _vm._v(" <3\n\n    "), _c('img', {
          staticClass: "close",
          attrs: {
            "src": require('../images/about-close.svg')
          },
          on: {
            "mousedown": _vm.blur
          }
        })])]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-548efbdb";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-548efbdb", __vue__options__);
          } else {
            hotAPI.rerender("data-v-548efbdb", __vue__options__);
          }
        })();
      }
    }, {
      "../images/about-close.svg": 86,
      "../images/automaton-a.svg": 87,
      "../images/automaton.svg": 88,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    103: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 81, stdin */\n.blur-layer[data-v-123585df] {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%; }\n\n/* line 89, stdin */\n.root[data-v-123585df] {\n  position: fixed;\n  white-space: nowrap;\n  padding: 0.4em;\n  font-size: 0.8em;\n  background: rgba(0, 0, 0, 0.5);\n  border: solid 1px #3d4449;\n  color: #bad0eb;\n  border-radius: 0.2em;\n  filter: drop-shadow(0 0 2px #000000); }\n  /* line 102, stdin */\n  .root .command[data-v-123585df] {\n    padding-left: 0.2em;\n    padding-right: 2em;\n    border-radius: 0.2em;\n    cursor: pointer; }\n    /* line 110, stdin */\n    .root .command[data-v-123585df]:hover {\n      background: #3d4449;\n      color: #c9e2ff; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = {
          name: 'context-menu',
          props: ['active', 'x', 'y', 'commands'],
          data: function data() {
            return {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            };
          },
          methods: {
            blur: function blur() {
              this.$emit('blur');
            },
            moveRoot: function moveRoot() {
              var x = this.x;
              var y = this.y;
              var w = document.documentElement.clientWidth;
              var h = document.documentElement.clientHeight;
              var bLeftSide = w - 240 < x;
              var bUpSide = h - 40 < y;
              this.left = bLeftSide ? null : x;
              this.right = bLeftSide ? w - x : null;
              this.top = bUpSide ? null : y;
              this.bottom = bUpSide ? h - y : null;
            },
            selectCommand: function selectCommand(index) {
              this.commands[index].func();
              this.$emit('blur');
            }
          },
          watch: {
            x: function x() {
              this.moveRoot();
            },
            y: function y() {
              this.moveRoot();
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_vm.active ? _c('div', {
          staticClass: "blur-layer",
          on: {
            "mousedown": _vm.blur
          }
        }) : _vm._e(), _vm._v(" "), _vm.active ? _c('div', {
          staticClass: "root",
          style: {
            left: typeof _vm.left === 'number' ? _vm.left + "px" : undefined,
            right: typeof _vm.right === 'number' ? _vm.right + "px" : undefined,
            top: typeof _vm.top === 'number' ? _vm.top + "px" : undefined,
            bottom: typeof _vm.bottom === 'number' ? _vm.bottom + "px" : undefined
          }
        }, _vm._l(_vm.commands, function (command, index) {
          return _c('div', {
            key: 'command' + index,
            staticClass: "command",
            on: {
              "mouseup": function mouseup($event) {
                _vm.selectCommand(index);
              }
            }
          }, [_vm._v(_vm._s(command.text))]);
        })) : _vm._e()]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-123585df";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-123585df", __vue__options__);
          } else {
            hotAPI.rerender("data-v-123585df", __vue__options__);
          }
        })();
      }
    }, {
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    104: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 155, stdin */\n.root[data-v-608a592f] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: #3d4449; }\n  /* line 164, stdin */\n  .root .row[data-v-608a592f] {\n    position: absolute;\n    height: calc( 100% - 0.25em);\n    margin: 0.125em; }\n    /* line 169, stdin */\n    .root .row.row-center[data-v-608a592f] {\n      width: calc( 100% - 0.25em);\n      text-align: center; }\n    /* line 173, stdin */\n    .root .row.row-left[data-v-608a592f] {\n      left: 0.125em; }\n    /* line 174, stdin */\n    .root .row.row-right[data-v-608a592f] {\n      right: 0.125em; }\n    /* line 176, stdin */\n    .root .row > *[data-v-608a592f] {\n      display: inline-block;\n      position: relative;\n      vertical-align: bottom;\n      margin: 0 0.125em;\n      height: 100%; }\n    /* line 184, stdin */\n    .root .row .logobox[data-v-608a592f] {\n      color: #c9e2ff;\n      opacity: 0.5;\n      cursor: pointer; }\n      /* line 190, stdin */\n      .root .row .logobox[data-v-608a592f]:hover {\n        opacity: 0.8; }\n      /* line 192, stdin */\n      .root .row .logobox .logo[data-v-608a592f] {\n        display: inline-block;\n        position: relative;\n        height: 60%;\n        top: 20%; }\n    /* line 200, stdin */\n    .root .row .button[data-v-608a592f] {\n      height: 100%;\n      cursor: pointer; }\n      /* line 205, stdin */\n      .root .row .button[data-v-608a592f]:hover {\n        opacity: 0.7; }\n    /* line 208, stdin */\n    .root .row .time[data-v-608a592f] {\n      width: 8em;\n      white-space: nowrap;\n      text-align: right;\n      cursor: pointer; }\n      /* line 216, stdin */\n      .root .row .time *[data-v-608a592f] {\n        pointer-events: none; }\n      /* line 220, stdin */\n      .root .row .time .current[data-v-608a592f] {\n        position: relative;\n        font-size: 0.8em;\n        margin-right: 0;\n        color: #c9e2ff; }\n      /* line 229, stdin */\n      .root .row .time .length[data-v-608a592f] {\n        position: relative;\n        font-size: 0.6em;\n        margin-left: 0;\n        color: #bad0eb; }\n      /* line 237, stdin */\n      .root .row .time .bar[data-v-608a592f] {\n        display: block;\n        position: absolute;\n        bottom: 0.25em;\n        left: 0px;\n        height: 2px;\n        margin: 0; }\n        /* line 245, stdin */\n        .root .row .time .bar.bar-bg[data-v-608a592f] {\n          background: #000000; }\n        /* line 246, stdin */\n        .root .row .time .bar.bar-fg[data-v-608a592f] {\n          background: #c9e2ff; }\n      /* line 250, stdin */\n      .root .row .time:hover .bar-fg[data-v-608a592f] {\n        background: #22aaff; }\n      /* line 254, stdin */\n      .root .row .time.seeking .bar-fg[data-v-608a592f] {\n        background: #22aaff; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = {
          mounted: function mounted() {},
          beforeDestroy: function beforeDestroy() {},
          props: ["automaton"],
          data: function data() {
            return {
              saveText: 'Copy current state as JSON',
              seeking: false,
              cantUndoThis: 0
            };
          },
          methods: {
            seek: function seek(event) {
              var _this = this;

              var width = event.target.offsetWidth;
              var xOffset0 = event.offsetX;
              var xClient0 = event.clientX;
              var isPlaying0 = this.automaton.isPlaying;

              if (isPlaying0) {
                this.automaton.pause();
              }

              this.automaton.seek(this.automaton.length * xOffset0 / width);
              this.seeking = true;

              var move = function move(event) {
                var x = xOffset0 + event.clientX - xClient0;

                _this.automaton.seek(_this.automaton.length * x / width);
              };

              var up = function up(event) {
                if (isPlaying0) {
                  _this.automaton.play();
                }

                _this.seeking = false;
                window.removeEventListener('mousemove', move);
                window.removeEventListener('mouseup', up);
              };

              window.addEventListener('mousemove', move);
              window.addEventListener('mouseup', up);
            },
            undo: function undo() {
              if (this.automaton.getUndoDesc()) {
                this.automaton.undo();
                this.cantUndoThis = 0;
              } else {
                this.cantUndoThis++;

                if (10 === this.cantUndoThis) {
                  window.open('https://youtu.be/bzY7J0Xle08', '_blank');
                  this.cantUndoThis = 0;
                }
              }

              this.$emit('historyMoved');
            },
            redo: function redo() {
              this.automaton.redo();
              this.$emit('historyMoved');
            },
            save: function save() {
              var _this2 = this;

              var el = document.createElement('textarea');
              el.value = this.automaton.save();
              document.body.appendChild(el);
              el.select();
              document.execCommand('copy');
              document.body.removeChild(el);
              this.saveText = 'Copied!';
              setTimeout(function () {
                _this2.saveText = 'Copy current state as JSON';
              }, 3000);
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          staticClass: "root"
        }, [_c('div', {
          staticClass: "row row-center"
        }, [_c('div', {
          staticClass: "logobox",
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.$emit('logoClicked');
            }
          }
        }, [_c('img', {
          staticClass: "logo",
          attrs: {
            "src": require('../images/automaton.svg')
          }
        })])]), _vm._v(" "), _c('div', {
          staticClass: "row row-left"
        }, [_c('img', {
          staticClass: "button",
          attrs: {
            "src": _vm.automaton.isPlaying ? require('../images/pause.svg') : require('../images/play.svg')
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.automaton.togglePlay();
            }
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "time",
          class: {
            seeking: _vm.seeking
          },
          on: {
            "mousedown": function mousedown($event) {
              $event.stopPropagation();
              return _vm.seek($event);
            }
          }
        }, [_c('span', {
          staticClass: "current"
        }, [_vm._v(_vm._s(_vm.automaton.time.toFixed(3)))]), _vm._v(" "), _c('span', {
          staticClass: "length"
        }, [_vm._v(" / " + _vm._s(_vm.automaton.length.toFixed(3)))]), _vm._v(" "), _c('div', {
          staticClass: "bar bar-bg",
          style: {
            width: '100%'
          }
        }), _vm._v(" "), _c('div', {
          staticClass: "bar bar-fg",
          style: {
            width: _vm.automaton.progress * 100 + "%"
          }
        })])]), _vm._v(" "), _c('div', {
          staticClass: "row row-right"
        }, [_c('img', {
          staticClass: "button",
          attrs: {
            "src": require('../images/undo.svg'),
            "stalker-text": _vm.automaton.getUndoDesc() ? "Undo: " + _vm.automaton.getUndoDesc() : 'Can\'t undo'
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.undo();
            }
          }
        }), _vm._v(" "), _c('img', {
          staticClass: "button",
          attrs: {
            "src": require('../images/redo.svg'),
            "stalker-text": _vm.automaton.getRedoDesc() ? "Redo: " + _vm.automaton.getRedoDesc() : 'Can\'t redo'
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.redo();
            }
          }
        }), _vm._v(" "), _c('img', {
          staticClass: "button",
          attrs: {
            "src": require('../images/snap.svg'),
            "stalker-text": "Snap Settings"
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.$emit('configSelected', 'snap');
            }
          }
        }), _vm._v(" "), _c('img', {
          staticClass: "button",
          attrs: {
            "src": require('../images/cog.svg'),
            "stalker-text": "General Config"
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();

              _vm.$emit('configSelected', 'general');
            }
          }
        }), _vm._v(" "), _c('img', {
          staticClass: "button",
          attrs: {
            "src": require('../images/save.svg'),
            "stalker-text": _vm.saveText
          },
          on: {
            "click": function click($event) {
              $event.stopPropagation();
              return _vm.save($event);
            }
          }
        })])])]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-608a592f";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-608a592f", __vue__options__);
          } else {
            hotAPI.rerender("data-v-608a592f", __vue__options__);
          }
        })();
      }
    }, {
      "../images/automaton.svg": 88,
      "../images/cog.svg": 89,
      "../images/pause.svg": 90,
      "../images/play.svg": 91,
      "../images/redo.svg": 92,
      "../images/save.svg": 93,
      "../images/snap.svg": 94,
      "../images/undo.svg": 95,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    105: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("@import url(\"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,900\");\n/* line 142, stdin */\n.automaton {\n  font-family: 'Roboto', sans-serif;\n  font-weight: 300;\n  font-size: 16px; }\n/* line 152, stdin */\n.root[data-v-491bbe4a] {\n  user-select: none; }\n  /* line 156, stdin */\n  .root .header[data-v-491bbe4a] {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 2em; }\n  /* line 165, stdin */\n  .root .paramlist[data-v-491bbe4a] {\n    position: absolute;\n    left: 0;\n    top: 2em;\n    width: 8em;\n    height: calc( 100% - 2em); }\n  /* line 174, stdin */\n  .root .propmenu[data-v-491bbe4a] {\n    position: absolute;\n    right: 0;\n    top: 2em;\n    width: 12em;\n    height: calc( 100% - 2em); }\n  /* line 182, stdin */\n  .root .timeline[data-v-491bbe4a] {\n    position: absolute;\n    left: 8em;\n    top: 2em;\n    width: calc( 100% - 20em);\n    height: calc( 100% - 2em); }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _about = require('./about.vue');

        var _about2 = _interopRequireDefault(_about);

        var _header = require('./header.vue');

        var _header2 = _interopRequireDefault(_header);

        var _paramlist = require('./paramlist.vue');

        var _paramlist2 = _interopRequireDefault(_paramlist);

        var _propmenu = require('./propmenu.vue');

        var _propmenu2 = _interopRequireDefault(_propmenu);

        var _timeline = require('./timeline.vue');

        var _timeline2 = _interopRequireDefault(_timeline);

        var _contextMenu = require('./context-menu.vue');

        var _contextMenu2 = _interopRequireDefault(_contextMenu);

        var _stalker = require('./stalker.vue');

        var _stalker2 = _interopRequireDefault(_stalker);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        exports.default = {
          components: {
            About: _about2.default,
            Header: _header2.default,
            ParamList: _paramlist2.default,
            PropMenu: _propmenu2.default,
            Timeline: _timeline2.default,
            ContextMenu: _contextMenu2.default,
            Stalker: _stalker2.default
          },
          props: ['automaton'],
          data: function data() {
            return {
              aboutActive: false,
              selectedParamName: null,
              selectedNodeIds: [],
              selectedFxIds: [],
              config: '',
              contextMenuActive: false,
              contextMenuX: 0,
              contextMenuY: 0,
              contextMenuCommands: []
            };
          },
          methods: {
            selectParam: function selectParam(name) {
              this.selectedParamName = name;
              this.selectNodes([]);
              this.selectFxs([]);
            },
            selectNodes: function selectNodes(arr) {
              this.selectedNodeIds = arr;
              this.config = '';
            },
            selectFxs: function selectFxs(arr) {
              this.selectedFxIds = arr;
              this.config = '';
            },
            onHistoryMoved: function onHistoryMoved() {
              this.selectNodes([]);
              this.selectFxs([]);
            },
            onConfigSelected: function onConfigSelected(config) {
              this.selectNodes([]);
              this.selectFxs([]);
              this.config = config;
            },
            openContextMenu: function openContextMenu(event) {
              this.contextMenuActive = true;
              this.contextMenuX = event.clientX;
              this.contextMenuY = event.clientY;
              this.contextMenuCommands = event.commands;
            }
          },
          mounted: function mounted() {
            var _this = this;

            this.$root.$on('loaded', function () {
              _this.selectParam(null);

              _this.selectNodes([]);

              _this.selectFxs([]);

              _this.config = '';
            });
          },
          beforeDestroy: function beforeDestroy() {}
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          staticClass: "root automaton color-theme-dark"
        }, [_c('Header', {
          staticClass: "header",
          attrs: {
            "automaton": _vm.automaton
          },
          on: {
            "historyMoved": _vm.onHistoryMoved,
            "configSelected": _vm.onConfigSelected,
            "context": _vm.openContextMenu,
            "logoClicked": function logoClicked($event) {
              _vm.aboutActive = true;
            }
          }
        }), _vm._v(" "), _c('ParamList', {
          staticClass: "paramlist",
          attrs: {
            "automaton": _vm.automaton,
            "selectedParamName": _vm.selectedParamName
          },
          on: {
            "selected": function selected($event) {
              _vm.selectParam($event);
            },
            "context": _vm.openContextMenu
          }
        }), _vm._v(" "), _c('PropMenu', {
          staticClass: "propmenu",
          attrs: {
            "automaton": _vm.automaton,
            "selectedParamName": _vm.selectedParamName,
            "selectedNodeIds": _vm.selectedNodeIds,
            "selectedFxIds": _vm.selectedFxIds,
            "config": _vm.config
          },
          on: {
            "context": _vm.openContextMenu
          }
        }), _vm._v(" "), _c('Timeline', {
          staticClass: "timeline",
          attrs: {
            "automaton": _vm.automaton,
            "selectedParamName": _vm.selectedParamName,
            "selectedNodeIds": _vm.selectedNodeIds,
            "selectedFxIds": _vm.selectedFxIds
          },
          on: {
            "nodeSelected": function nodeSelected($event) {
              _vm.selectNodes($event);
            },
            "fxSelected": function fxSelected($event) {
              _vm.selectFxs($event);
            },
            "context": _vm.openContextMenu
          }
        }), _vm._v(" "), _vm.aboutActive ? _c('About', {
          staticClass: "about",
          attrs: {
            "automaton": _vm.automaton
          },
          on: {
            "blur": function blur($event) {
              _vm.aboutActive = false;
            }
          }
        }) : _vm._e(), _vm._v(" "), _c('ContextMenu', {
          staticClass: "context-menu",
          attrs: {
            "active": _vm.contextMenuActive,
            "x": _vm.contextMenuX,
            "y": _vm.contextMenuY,
            "commands": _vm.contextMenuCommands
          },
          on: {
            "blur": function blur($event) {
              _vm.contextMenuActive = false;
            }
          }
        }), _vm._v(" "), _c('Stalker', {
          staticClass: "stalker"
        })], 1)]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-491bbe4a";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-491bbe4a", __vue__options__);
          } else {
            hotAPI.rerender("data-v-491bbe4a", __vue__options__);
          }
        })();
      }
    }, {
      "./about.vue": 102,
      "./context-menu.vue": 103,
      "./header.vue": 104,
      "./paramlist.vue": 106,
      "./propmenu.vue": 108,
      "./stalker.vue": 110,
      "./timeline.vue": 112,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    106: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 75, stdin */\n.root[data-v-3e0dc8f9] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: #202325;\n  color: #c9e2ff; }\n  /* line 85, stdin */\n  .root .param[data-v-3e0dc8f9] {\n    position: relative;\n    width: calc( 100% - 4px);\n    height: 1.25em;\n    margin: 2px;\n    background: #2c3236;\n    color: #bad0eb;\n    cursor: pointer; }\n    /* line 96, stdin */\n    .root .param.selected[data-v-3e0dc8f9] {\n      background: #3d4449;\n      color: #c9e2ff; }\n    /* line 101, stdin */\n    .root .param .name[data-v-3e0dc8f9] {\n      position: absolute;\n      left: 0.2em;\n      top: 0;\n      width: calc( 100% - 2em);\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: nowrap;\n      user-select: none; }\n    /* line 113, stdin */\n    .root .param .value[data-v-3e0dc8f9] {\n      position: absolute;\n      right: 0.2em;\n      bottom: 0.1em;\n      font-size: 0.6em;\n      opacity: 0.7;\n      user-select: none; }\n    /* line 124, stdin */\n    .root .param .warning[data-v-3e0dc8f9] {\n      position: absolute;\n      right: 0.1em;\n      bottom: 0.1em;\n      height: calc( 100% - 0.2em); }");

      (function () {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _scrollable = require("./scrollable.vue");

        var _scrollable2 = _interopRequireDefault(_scrollable);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        exports.default = {
          components: {
            Scrollable: _scrollable2.default
          },
          props: ["automaton", "selectedParamName"],
          data: function data() {
            return {};
          },
          methods: {
            contextParam: function contextParam(event, name) {
              var _this = this;

              this.$emit('context', {
                clientX: event.clientX,
                clientY: event.clientY,
                commands: [{
                  text: 'Select Param',
                  func: function func() {
                    _this.$emit('selected', name);
                  }
                }, {
                  text: 'Remove Param',
                  func: function func() {
                    _this.automaton.removeParam(name);

                    _this.$emit('selected', null);
                  }
                }]
              });
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('Scrollable', {
          staticClass: "root",
          attrs: {
            "bar": "left"
          }
        }, _vm._l(_vm.automaton.getParamNames(), function (name) {
          return _c('div', {
            key: 'param' + name,
            staticClass: "param",
            class: {
              selected: name === _vm.selectedParamName
            },
            attrs: {
              "stalker-text": name
            },
            on: {
              "click": function click($event) {
                _vm.$emit('selected', name);
              },
              "contextmenu": function contextmenu($event) {
                $event.stopPropagation();
                $event.preventDefault();

                _vm.contextParam($event, name);
              }
            }
          }, [_c('div', {
            staticClass: "name",
            attrs: {
              "stalker-text": name
            }
          }, [_vm._v(_vm._s(name))]), _vm._v(" "), _vm.automaton.getParam(name).isUsed() ? _c('div', {
            staticClass: "value",
            attrs: {
              "stalker-text": name
            }
          }, [_vm._v(_vm._s(_vm.automaton.auto(name).toFixed(3)))]) : _vm._e(), _vm._v(" "), !_vm.automaton.getParam(name).isUsed() ? _c('img', {
            staticClass: "warning",
            attrs: {
              "src": require('../images/warning.svg'),
              "stalker-text": "This param has not been used yet"
            }
          }) : _vm._e()]);
        }))], 1);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-3e0dc8f9";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-3e0dc8f9", __vue__options__);
          } else {
            hotAPI.rerender("data-v-3e0dc8f9", __vue__options__);
          }
        })();
      }
    }, {
      "../images/warning.svg": 96,
      "./scrollable.vue": 109,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    107: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 144, stdin */\n.propbox {\n  position: relative;\n  width: 100%;\n  height: 1.25em;\n  margin-bottom: 0.25em; }\n  /* line 150, stdin */\n  .propbox .name {\n    position: absolute;\n    left: 0;\n    top: 0;\n    height: 100%;\n    margin-top: 0.1em; }\n  /* line 159, stdin */\n  .propbox .value {\n    background: #2c3236;\n    cursor: pointer; }\n    /* line 162, stdin */\n    .propbox .value:active:not(.readonly) {\n      background: #0e1011; }\n    /* line 168, stdin */\n    .propbox .value.readonly {\n      cursor: not-allowed; }\n  /* line 173, stdin */\n  .propbox .number {\n    position: absolute;\n    right: 0;\n    top: 0;\n    width: 5em;\n    height: 100%; }\n    /* line 180, stdin */\n    .propbox .number .valueText {\n      width: 100%;\n      margin-top: 0.1em;\n      text-align: center; }\n      /* line 186, stdin */\n      .propbox .number .valueText.readonly {\n        opacity: 0.5; }\n    /* line 191, stdin */\n    .propbox .number .valueInput {\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      border: none;\n      padding: 0;\n      text-align: center;\n      background: #4a545a;\n      color: #c9e2ff; }\n  /* line 206, stdin */\n  .propbox .boolean {\n    position: absolute;\n    right: 1.875em;\n    top: 0;\n    width: 1.25em;\n    height: 100%; }\n    /* line 213, stdin */\n    .propbox .boolean .booleanCheck {\n      position: absolute;\n      left: 20%;\n      top: 20%;\n      width: 60%;\n      height: 60%;\n      background: #22aaff; }\n      /* line 222, stdin */\n      .propbox .boolean .booleanCheck.readonly {\n        background: #687788;\n        opacity: 0.5; }");

      (function () {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _log = require("babel-runtime/core-js/math/log10");

        var _log2 = _interopRequireDefault(_log);

        var _sign = require("babel-runtime/core-js/math/sign");

        var _sign2 = _interopRequireDefault(_sign);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        var mouseEvents = function mouseEvents(move, up) {
          var u = function u(event) {
            if (typeof up === "function") {
              up(event);
            }

            window.removeEventListener("mousemove", move);
            window.removeEventListener("mouseup", u);
          };

          window.addEventListener("mousemove", move);
          window.addEventListener("mouseup", u);
        };

        exports.default = {
          name: 'propbox',
          props: ['name', 'value', 'type', 'min', 'max', 'readonly'],
          data: function data() {
            return {
              input: false,
              lastClick: 0
            };
          },
          methods: {
            nMousedown: function nMousedown(event) {
              var _this = this;

              if (this.readonly) {
                return;
              }

              var now = Date.now();

              if (now - this.lastClick < 500) {
                this.input = true;
                this.$refs.valueInput.value = this.value;
                setTimeout(function () {
                  _this.$refs.valueInput.focus();

                  _this.$refs.valueInput.select();
                }, 10);
              }

              this.lastClick = now;
              var y0 = event.clientY;
              var lastY = y0;
              var v0 = Number(this.value);
              mouseEvents(function (event) {
                var v = Number(_this.value);
                var y = event.clientY;
                var dy = lastY - y;
                lastY = y;

                if (_this.type === 'int') {
                  v = v0 - Math.floor((y - y0) / 10.0);
                } else if (event.shiftKey) {
                  var dyAbs = Math.abs(dy);
                  var dySign = (0, _sign2.default)(dy);

                  for (var i = 0; i < dyAbs; i++) {
                    var vAbs = Math.abs(v);
                    var vSign = (0, _sign2.default)(v + 1E-4 * dySign);
                    var order = Math.floor((0, _log2.default)(vAbs + 1E-4 * dySign * vSign)) - 1 - (event.altKey ? 1 : 0);
                    v += Math.max(0.001, Math.pow(10.0, order)) * dySign;
                  }
                } else {
                  v += dy * (event.altKey ? 0.001 : 0.01);
                }

                if (_this.max) {
                  v = Math.min(v, parseFloat(_this.max));
                }

                if (_this.min) {
                  v = Math.max(v, parseFloat(_this.min));
                }

                v = _this.type === 'int' ? v : Number(v.toFixed(3));

                _this.$emit('changed', v);
              }, function (event) {
                if (v0 === Number(_this.value)) {
                  return;
                }

                _this.$emit('finished', [v0, Number(_this.value)]);
              });
            },
            nEnter: function nEnter(event) {
              var v = parseFloat(this.$refs.valueInput.value);

              if (this.type === 'int') {
                v = Math.round(v);
              }

              this.$emit('changed', v);
              this.$emit('finished', [Number(this.value), v]);
              this.input = false;
            },
            nBlur: function nBlur(event) {
              this.input = false;
            },
            bToggle: function bToggle(event) {
              if (this.readonly) {
                return;
              }

              var v = !this.value;
              this.$emit('changed', v);
              this.$emit('finished', [!v, v]);
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          staticClass: "propbox"
        }, [_c('div', {
          staticClass: "name"
        }, [_vm._v(_vm._s(_vm.name))]), _vm._v(" "), _vm.type === 'float' || _vm.type === 'int' ? _c('div', {
          staticClass: "value number",
          class: {
            readonly: _vm.readonly
          }
        }, [_c('div', {
          staticClass: "valueText",
          class: {
            readonly: _vm.readonly
          },
          on: {
            "mousedown": _vm.nMousedown
          }
        }, [_vm._v(_vm._s(_vm.type === 'int' ? _vm.value : _vm.value.toFixed(3)))]), _vm._v(" "), _c('input', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.input,
            expression: "input"
          }],
          ref: "valueInput",
          staticClass: "valueInput",
          on: {
            "keydown": function keydown($event) {
              if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
                return null;
              }

              return _vm.nEnter($event);
            },
            "blur": _vm.nBlur
          }
        })]) : _vm._e(), _vm._v(" "), _vm.type === 'boolean' ? _c('div', {
          staticClass: "value boolean",
          class: {
            readonly: _vm.readonly
          },
          on: {
            "click": _vm.bToggle
          }
        }, [_c('div', {
          directives: [{
            name: "show",
            rawName: "v-show",
            value: _vm.value,
            expression: "value"
          }],
          staticClass: "booleanCheck"
        })]) : _vm._e()])]);
      };

      __vue__options__.staticRenderFns = [];

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-1a0e28d6", __vue__options__);
          } else {
            hotAPI.rerender("data-v-1a0e28d6", __vue__options__);
          }
        })();
      }
    }, {
      "babel-runtime/core-js/math/log10": 2,
      "babel-runtime/core-js/math/sign": 3,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    108: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 331, stdin */\n.root[data-v-ffc62e38] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: #202325;\n  color: #c9e2ff; }\n  /* line 341, stdin */\n  .root .props[data-v-ffc62e38] {\n    padding: 0.75em 1.5em;\n    font-size: 0.75em; }\n    /* line 345, stdin */\n    .root .props .title[data-v-ffc62e38] {\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: nowrap;\n      font-size: 1.5em;\n      color: #22aaff; }\n    /* line 354, stdin */\n    .root .props hr[data-v-ffc62e38] {\n      border: solid 1px #2c3236; }\n    /* line 358, stdin */\n    .root .props .centering[data-v-ffc62e38] {\n      text-align: center; }\n      /* line 361, stdin */\n      .root .props .centering .button-confirm[data-v-ffc62e38] {\n        display: inline-block;\n        width: 4em;\n        padding: 0.25em;\n        background: #2c3236;\n        cursor: pointer; }\n        /* line 370, stdin */\n        .root .props .centering .button-confirm[data-v-ffc62e38]:hover {\n          background: #0e1011; }\n  /* line 375, stdin */\n  .root .logobox[data-v-ffc62e38] {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden; }\n    /* line 383, stdin */\n    .root .logobox .logo[data-v-ffc62e38] {\n      position: absolute;\n      width: 8em;\n      left: calc( 50% - 4em);\n      top: calc( 50% - 4em);\n      opacity: 0.1; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _propbox = require('./propbox.vue');

        var _propbox2 = _interopRequireDefault(_propbox);

        var _scrollable = require('./scrollable.vue');

        var _scrollable2 = _interopRequireDefault(_scrollable);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        exports.default = {
          name: 'propmenu',
          props: ['automaton', 'selectedParamName', 'selectedNodeIds', 'selectedFxIds', 'config'],
          components: {
            Propbox: _propbox2.default,
            Scrollable: _scrollable2.default
          },
          data: function data() {
            return {
              generalConfigs: {
                length: 0,
                resolution: 0
              }
            };
          },
          methods: {
            confirmGeneralConfigs: function confirmGeneralConfigs() {
              this.automaton.setLength(this.generalConfigs.length);
              this.automaton.setResolution(this.generalConfigs.resolution);
            }
          },
          computed: {
            selectedParam: function selectedParam() {
              return this.automaton.getParam(this.selectedParamName);
            },
            selectedNodeId: function selectedNodeId() {
              return this.selectedNodeIds.length === 1 ? this.selectedNodeIds[0] : null;
            },
            selectedNode: function selectedNode() {
              return this.selectedNodeIds.length === 1 ? this.selectedParam.dumpNode(this.selectedNodeId) : null;
            },
            selectedFxId: function selectedFxId() {
              return this.selectedFxIds.length === 1 ? this.selectedFxIds[0] : null;
            },
            selectedFx: function selectedFx() {
              return this.selectedFxIds.length === 1 ? this.selectedParam.dumpFx(this.selectedFxId) : null;
            }
          },
          watch: {
            config: function config() {
              if (this.config === 'general') {
                this.generalConfigs.length = this.automaton.length;
                this.generalConfigs.resolution = this.automaton.resolution;
              }
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('Scrollable', {
          staticClass: "root",
          attrs: {
            "bar": "right"
          }
        }, [_vm.selectedNode ? _c('div', {
          staticClass: "props"
        }, [_c('div', {
          staticClass: "title"
        }, [_vm._v("Node")]), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Time",
            "value": _vm.selectedNode.time,
            "readonly": !(_vm.selectedNode.in && _vm.selectedNode.out)
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveNode(_vm.selectedNodeId, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Time', function () {
                _vm.selectedParam.moveNode(_vm.selectedNodeId, $event[1]);
              }, function () {
                _vm.selectedParam.moveNode(_vm.selectedNodeId, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Value",
            "value": _vm.selectedNode.value
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveNode(_vm.selectedNodeId, undefined, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Value', function () {
                _vm.selectedParam.moveNode(_vm.selectedNodeId, undefined, $event[1]);
              }, function () {
                _vm.selectedParam.moveNode(_vm.selectedNodeId, undefined, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "In Time",
            "value": _vm.selectedNode.in ? _vm.selectedNode.in.time : 0,
            "readonly": !_vm.selectedNode.in
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Time', function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, $event[1]);
              }, function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "In Value",
            "value": _vm.selectedNode.in ? _vm.selectedNode.in.value : 0,
            "readonly": !_vm.selectedNode.in
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, undefined, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Value', function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, undefined, $event[1]);
              }, function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, false, undefined, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Out Time",
            "value": _vm.selectedNode.out ? _vm.selectedNode.out.time : 0,
            "readonly": !_vm.selectedNode.out
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Time', function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, $event[1]);
              }, function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Out Value",
            "value": _vm.selectedNode.out ? _vm.selectedNode.out.value : 0,
            "readonly": !_vm.selectedNode.out
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, undefined, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Change Node Value', function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, undefined, $event[1]);
              }, function () {
                _vm.selectedParam.moveHandle(_vm.selectedNodeId, true, undefined, $event[0]);
              });
            }
          }
        })], 1) : _vm._e(), _vm._v(" "), _vm.selectedFx ? _c('div', {
          staticClass: "props"
        }, [_c('div', {
          staticClass: "title"
        }, [_vm._v("Fx: " + _vm._s(_vm.automaton.getFxDefinitionName(_vm.selectedFx.def)))]), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Time",
            "value": _vm.selectedFx.time
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.moveFx(_vm.selectedFxId, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Move Fx', function () {
                _vm.selectedParam.moveFx(_vm.selectedFxId, $event[1]);
              }, function () {
                _vm.selectedParam.moveFx(_vm.selectedFxId, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "float",
            "name": "Length",
            "value": _vm.selectedFx.length
          },
          on: {
            "changed": function changed($event) {
              _vm.selectedParam.resizeFx(_vm.selectedFxId, $event);
            },
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Move Fx', function () {
                _vm.selectedParam.resizeFx(_vm.selectedFxId, $event[1]);
              }, function () {
                _vm.selectedParam.resizeFx(_vm.selectedFxId, $event[0]);
              });
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "type": "boolean",
            "name": "Bypass",
            "value": _vm.selectedFx.bypass
          },
          on: {
            "finished": function finished($event) {
              _vm.automaton.pushHistory('Toggle Bypass Fx', function () {
                _vm.selectedParam.bypassFx(_vm.selectedFxId, $event[1]);
              }, function () {
                _vm.selectedParam.bypassFx(_vm.selectedFxId, $event[0]);
              }, true);
            }
          }
        }), _vm._v(" "), _c('hr'), _vm._v(" "), _vm._l(_vm.automaton.getFxDefinitionParams(_vm.selectedFx.def), function (param, key) {
          return _c('Propbox', {
            key: 'fxParam-' + key,
            staticClass: "prop",
            attrs: {
              "type": param.type,
              "name": param.name || key,
              "value": _vm.selectedFx.params[key]
            },
            on: {
              "changed": function changed($event) {
                _vm.selectedParam.changeFxParam(_vm.selectedFxId, key, $event);
              },
              "finished": function finished($event) {
                _vm.automaton.pushHistory('Change Fx Param', function () {
                  _vm.selectedParam.changeFxParam(_vm.selectedFxId, key, $event[1]);
                }, function () {
                  _vm.selectedParam.changeFxParam(_vm.selectedFxId, key, $event[0]);
                });
              }
            }
          });
        })], 2) : _vm._e(), _vm._v(" "), _vm.config === 'snap' ? _c('div', {
          staticClass: "props"
        }, [_c('div', {
          staticClass: "title"
        }, [_vm._v("Snap Settings")]), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "name": "Enable Snap",
            "type": "boolean",
            "value": _vm.automaton.guiSettings.snapActive
          },
          on: {
            "changed": function changed($event) {
              _vm.automaton.guiSettings.snapActive = $event;
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "name": "Interval (Time)",
            "min": "0.0",
            "type": "float",
            "value": _vm.automaton.guiSettings.snapTime
          },
          on: {
            "changed": function changed($event) {
              _vm.automaton.guiSettings.snapTime = $event;
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "name": "Interval (Value)",
            "min": "0.0",
            "type": "float",
            "value": _vm.automaton.guiSettings.snapValue
          },
          on: {
            "changed": function changed($event) {
              _vm.automaton.guiSettings.snapValue = $event;
            }
          }
        })], 1) : _vm._e(), _vm._v(" "), _vm.config === 'general' ? _c('div', {
          staticClass: "props"
        }, [_c('div', {
          staticClass: "title"
        }, [_vm._v("General Config")]), _vm._v(" "), _c('hr'), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "name": "Length",
            "type": "float",
            "min": "0",
            "value": _vm.generalConfigs.length
          },
          on: {
            "changed": function changed($event) {
              _vm.generalConfigs.length = $event;
            }
          }
        }), _vm._v(" "), _c('Propbox', {
          staticClass: "prop",
          attrs: {
            "name": "Resolution",
            "type": "int",
            "min": "1",
            "value": _vm.generalConfigs.resolution
          },
          on: {
            "changed": function changed($event) {
              _vm.generalConfigs.resolution = $event;
            }
          }
        }), _vm._v(" "), _c('hr'), _vm._v(" "), _c('div', {
          staticClass: "centering"
        }, [_vm._v("\n        This cannot be undone!\n        "), _c('div', {
          staticClass: "button-confirm",
          on: {
            "click": _vm.confirmGeneralConfigs
          }
        }, [_vm._v("Apply")])])], 1) : _vm._e()]), _vm._v(" "), !_vm.selectedNode && !_vm.selectedFx && !_vm.config ? _c('div', {
          staticClass: "logobox"
        }, [_c('img', {
          staticClass: "logo",
          attrs: {
            "src": require('../images/automaton-a.svg')
          }
        })]) : _vm._e()], 1);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-ffc62e38";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-ffc62e38", __vue__options__);
          } else {
            hotAPI.rerender("data-v-ffc62e38", __vue__options__);
          }
        })();
      }
    }, {
      "../images/automaton-a.svg": 87,
      "./propbox.vue": 107,
      "./scrollable.vue": 109,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    109: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 77, stdin */\n.root[data-v-696f5249] {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden; }\n  /* line 83, stdin */\n  .root .inside[data-v-696f5249] {\n    position: absolute;\n    left: 0;\n    width: 100%; }\n  /* line 89, stdin */\n  .root .bar[data-v-696f5249] {\n    position: absolute;\n    width: 4px;\n    background: #22aaff;\n    border-radius: 2px; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = {
          props: ['bar'],
          data: function data() {
            return {
              top: 0,
              barOpacity: 0.0
            };
          },
          methods: {
            onWheel: function onWheel(event) {
              event.preventDefault();
              this.top = this.top - event.deltaY;
              var scrollMax = this.$refs.inside.clientHeight - this.$refs.root.clientHeight;

              if (this.top < -scrollMax) {
                var overrun = -scrollMax - this.top;
                this.top = -scrollMax;
              }

              if (0 < this.top) {
                var _overrun = this.top;
                this.top = 0;
              }

              this.barHeight = 100.0 * this.$refs.root.clientHeight / this.$refs.inside.clientHeight;
              this.barTop = -100.0 * this.top / this.$refs.inside.clientHeight;
              this.barOpacity += Math.min(this.barOpacity + 0.1 * Math.abs(event.deltaY), 1.0);
            },
            update: function update() {
              this.barOpacity *= 0.9;
            }
          },
          mounted: function mounted() {
            var _this = this;

            var update = function update() {
              _this.update();

              requestAnimationFrame(update);
            };

            update();
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          ref: "root",
          staticClass: "root",
          on: {
            "wheel": function wheel($event) {
              $event.stopPropagation();
              return _vm.onWheel($event);
            }
          }
        }, [_c('div', {
          ref: "inside",
          staticClass: "inside",
          style: {
            top: _vm.top + 'px'
          }
        }, [_vm._t("default")], 2), _vm._v(" "), _c('div', {
          staticClass: "bar",
          style: {
            top: _vm.barTop + '%',
            height: _vm.barHeight + '%',
            left: _vm.bar === 'left' ? 0 : undefined,
            right: _vm.bar === 'right' ? 0 : undefined,
            opacity: _vm.barOpacity
          }
        })])]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-696f5249";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-696f5249", __vue__options__);
          } else {
            hotAPI.rerender("data-v-696f5249", __vue__options__);
          }
        })();
      }
    }, {
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    110: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 71, stdin */\n.root[data-v-5e81204c] {\n  position: fixed;\n  pointer-events: none;\n  white-space: nowrap;\n  padding: 0.2em 0.4em;\n  margin: 10px;\n  font-size: 0.8em;\n  background: rgba(0, 0, 0, 0.8);\n  color: #c9e2ff;\n  border-radius: 0.2em; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = {
          name: 'stalker',
          data: function data() {
            return {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              text: ''
            };
          },
          methods: {
            applyStalkerText: function applyStalkerText(el) {
              var _this = this;

              setTimeout(function () {
                _this.text = el.getAttribute('stalker-text');
              }, 10);
            }
          },
          mounted: function mounted() {
            var _this2 = this;

            window.addEventListener('mousemove', function (event) {
              var x = event.clientX;
              var y = event.clientY;
              var w = document.documentElement.clientWidth;
              var h = document.documentElement.clientHeight;
              var bLeftSide = w - 240 < x;
              var bUpSide = h - 40 < y;
              _this2.left = bLeftSide ? null : x;
              _this2.right = bLeftSide ? w - x : null;
              _this2.top = bUpSide ? null : y;
              _this2.bottom = bUpSide ? h - y : null;

              _this2.applyStalkerText(event.target);
            });
            window.addEventListener('mousedown', function (event) {
              _this2.applyStalkerText(event.target);
            });
            window.addEventListener('mouseup', function (event) {
              _this2.applyStalkerText(event.target);
            });
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_vm.text ? _c('div', {
          staticClass: "root",
          style: {
            left: typeof _vm.left === 'number' ? _vm.left + "px" : undefined,
            right: typeof _vm.right === 'number' ? _vm.right + "px" : undefined,
            top: typeof _vm.top === 'number' ? _vm.top + "px" : undefined,
            bottom: typeof _vm.bottom === 'number' ? _vm.bottom + "px" : undefined
          }
        }, [_vm._v("\n    " + _vm._s(_vm.text) + "\n  ")]) : _vm._e()]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-5e81204c";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-5e81204c", __vue__options__);
          } else {
            hotAPI.rerender("data-v-5e81204c", __vue__options__);
          }
        })();
      }
    }, {
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    111: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 125, stdin */\n.blur-layer[data-v-6e78990b] {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%; }\n\n/* line 133, stdin */\n.root[data-v-6e78990b] {\n  position: absolute;\n  left: calc( 50% - 10em);\n  top: 1em;\n  width: 20em;\n  height: calc( 100% - 2em);\n  overflow: hidden;\n  background: #0e1011;\n  font-size: 0.8em;\n  filter: drop-shadow(0 0 2px #000000); }\n  /* line 146, stdin */\n  .root .search-box[data-v-6e78990b] {\n    position: relative;\n    font-size: 1em;\n    width: calc( 100% - 12px);\n    margin: 2px;\n    padding: 2px 4px;\n    border: none;\n    background: #3d4449;\n    color: #c9e2ff; }\n  /* line 158, stdin */\n  .root .fx-names[data-v-6e78990b] {\n    position: relative;\n    width: 100%;\n    height: calc( 100% - 1em - 12px); }\n    /* line 163, stdin */\n    .root .fx-names .fx-name[data-v-6e78990b] {\n      position: relative;\n      width: calc( 100% - 12px);\n      margin: 2px;\n      padding: 2px 4px;\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      background: #202325;\n      cursor: pointer; }\n      /* line 176, stdin */\n      .root .fx-names .fx-name[data-v-6e78990b]:hover {\n        background: #2c3236; }\n      /* line 177, stdin */\n      .root .fx-names .fx-name.selected[data-v-6e78990b] {\n        background: #2c3236; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

        var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

        var _scrollable = require('./scrollable.vue');

        var _scrollable2 = _interopRequireDefault(_scrollable);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        exports.default = {
          props: ['automaton', 'active'],
          components: {
            Scrollable: _scrollable2.default
          },
          data: function data() {
            return {
              fxDefs: [],
              searchText: '',
              selectedIndex: 0
            };
          },
          methods: {
            filterDef: function filterDef(id) {
              var queries = this.searchText.split(/\s+/);
              var name = this.automaton.getFxDefinitionName(id);
              return queries.every(function (query) {
                return name.toLowerCase().includes(query.toLowerCase()) || id.toLowerCase().includes(query.toLowerCase());
              });
            },
            select: function select(id) {
              if (id === '') {
                this.blur();
                return;
              }

              this.$emit('selected', id);
              this.fxDefs.splice(this.fxDefs.indexOf(id), 1);
              this.fxDefs.unshift(id);
              this.blur();
            },
            blur: function blur() {
              this.$emit('blur');
              this.searchText = '';
              this.selectedIndex = 0;
            },
            onSearchBoxKeydown: function onSearchBoxKeydown(event) {
              if (event.which === 13) {
                this.select(this.fxDefsFiltered[this.selectedIndex]);
              } else if (event.which === 27) {
                this.blur();
              } else if (event.which === 38) {
                this.selectedIndex = (this.selectedIndex - 1 + this.fxDefsFiltered.length) % this.fxDefsFiltered.length;
              } else if (event.which === 40) {
                this.selectedIndex = (this.selectedIndex + 1) % this.fxDefsFiltered.length;
              } else {
                this.selectedIndex = 0;
              }
            }
          },
          mounted: function mounted() {
            this.fxDefs = this.automaton.getFxDefinitionIds();
          },
          computed: {
            fxDefsFiltered: function fxDefsFiltered() {
              var _fxDefs,
                  _this = this;

              (_fxDefs = this.fxDefs).push.apply(_fxDefs, (0, _toConsumableArray3.default)(this.automaton.getFxDefinitionIds().filter(function (id) {
                return _this.fxDefs.indexOf(id) === -1;
              })));

              var arr = this.fxDefs.filter(function (id) {
                return _this.filterDef(id);
              });
              return arr.length === 0 ? [''] : arr;
            }
          },
          watch: {
            active: function active(v) {
              var _this2 = this;

              if (!v) {
                return;
              }

              setTimeout(function () {
                _this2.$refs.searchBox.focus();
              }, 10);
            }
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_vm.active ? _c('div', {
          staticClass: "blur-layer",
          on: {
            "mousedown": _vm.blur
          }
        }) : _vm._e(), _vm._v(" "), _vm.active ? _c('div', {
          staticClass: "root"
        }, [_c('input', {
          directives: [{
            name: "model",
            rawName: "v-model",
            value: _vm.searchText,
            expression: "searchText"
          }],
          ref: "searchBox",
          staticClass: "search-box",
          attrs: {
            "type": "text",
            "placeholder": "Add a fx..."
          },
          domProps: {
            "value": _vm.searchText
          },
          on: {
            "keydown": _vm.onSearchBoxKeydown,
            "input": function input($event) {
              if ($event.target.composing) {
                return;
              }

              _vm.searchText = $event.target.value;
            }
          }
        }), _vm._v(" "), _c('Scrollable', {
          staticClass: "fx-names",
          attrs: {
            "bar": "right"
          }
        }, _vm._l(_vm.fxDefsFiltered, function (id, index) {
          return _c('div', {
            key: id,
            staticClass: "fx-name",
            class: {
              selected: index === _vm.selectedIndex
            },
            attrs: {
              "stalker-text": _vm.automaton.getFxDefinitionDescription(id) || '(no description provided)'
            },
            on: {
              "mousedown": function mousedown($event) {
                _vm.select(id);
              }
            }
          }, [_vm._v("\n        " + _vm._s(id ? _vm.automaton.getFxDefinitionName(id) : '(No result found)') + "\n      ")]);
        }))], 1) : _vm._e()]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-6e78990b";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-6e78990b", __vue__options__);
          } else {
            hotAPI.rerender("data-v-6e78990b", __vue__options__);
          }
        })();
      }
    }, {
      "./scrollable.vue": 109,
      "babel-runtime/helpers/toConsumableArray": 4,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }],
    112: [function (require, module, exports) {
      var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("/* line 1036, stdin */\n.root[data-v-f3a8533a] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  color: #c9e2ff; }\n  /* line 1045, stdin */\n  .root .hbar[data-v-f3a8533a] {\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    height: 4px;\n    background: #000000; }\n    /* line 1054, stdin */\n    .root .hbar .vision[data-v-f3a8533a] {\n      position: absolute;\n      bottom: 0;\n      height: 100%;\n      border-radius: 2px;\n      background: #22aaff; }\n  /* line 1065, stdin */\n  .root .svg[data-v-f3a8533a] {\n    background: #0e1011;\n    font-size: 10px;\n    pointer-events: none; }\n    /* line 1072, stdin */\n    .root .svg .grid[data-v-f3a8533a] {\n      stroke: #c9e2ff;\n      stroke-width: 1; }\n    /* line 1077, stdin */\n    .root .svg .grid-text[data-v-f3a8533a] {\n      fill: #c9e2ff; }\n    /* line 1081, stdin */\n    .root .svg .graph[data-v-f3a8533a] {\n      fill: none;\n      stroke: #c9e2ff;\n      stroke-width: 2; }\n    /* line 1087, stdin */\n    .root .svg .currentLine[data-v-f3a8533a] {\n      stroke: #22aaff;\n      stroke-width: 2; }\n    /* line 1092, stdin */\n    .root .svg .currentText[data-v-f3a8533a] {\n      fill: #22aaff; }\n    /* line 1096, stdin */\n    .root .svg .currentPoint[data-v-f3a8533a] {\n      fill: #22aaff; }\n    /* line 1102, stdin */\n    .root .svg .node .handle .line[data-v-f3a8533a] {\n      stroke: #22aaff;\n      stroke-width: 1; }\n    /* line 1107, stdin */\n    .root .svg .node .handle .circle[data-v-f3a8533a] {\n      fill: #22aaff;\n      pointer-events: auto;\n      cursor: pointer; }\n    /* line 1115, stdin */\n    .root .svg .node .body[data-v-f3a8533a] {\n      fill: #0e1011;\n      stroke: #22aaff;\n      stroke-width: 2;\n      pointer-events: auto;\n      cursor: pointer; }\n      /* line 1123, stdin */\n      .root .svg .node .body.selected[data-v-f3a8533a] {\n        fill: #22aaff; }\n    /* line 1130, stdin */\n    .root .svg .fx .line[data-v-f3a8533a] {\n      stroke: #0fd895;\n      stroke-width: 1;\n      stroke-dasharray: 4; }\n    /* line 1136, stdin */\n    .root .svg .fx .fill[data-v-f3a8533a] {\n      fill: #0fd895;\n      opacity: 0.1; }\n    /* line 1141, stdin */\n    .root .svg .fx .body[data-v-f3a8533a] {\n      fill: #0e1011;\n      stroke: #0fd895;\n      stroke-width: 2;\n      pointer-events: auto;\n      cursor: pointer; }\n      /* line 1146, stdin */\n      .root .svg .fx .body.bypass[data-v-f3a8533a] {\n        fill: #0e1011;\n        stroke: #687788; }\n      /* line 1151, stdin */\n      .root .svg .fx .body.selected[data-v-f3a8533a] {\n        fill: #0fd895;\n        stroke: #0e1011; }\n        /* line 1155, stdin */\n        .root .svg .fx .body.selected.bypass[data-v-f3a8533a] {\n          fill: #687788;\n          stroke: #0e1011; }\n    /* line 1165, stdin */\n    .root .svg .fx .text[data-v-f3a8533a] {\n      fill: #0fd895; }\n      /* line 1167, stdin */\n      .root .svg .fx .text.bypass[data-v-f3a8533a] {\n        fill: #687788; }\n      /* line 1168, stdin */\n      .root .svg .fx .text.selected[data-v-f3a8533a] {\n        fill: #0e1011; }\n    /* line 1171, stdin */\n    .root .svg .fx .side[data-v-f3a8533a] {\n      fill: rgba(0, 0, 0, 0);\n      pointer-events: auto;\n      cursor: ew-resize; }");

      (function () {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _log = require('babel-runtime/core-js/math/log10');

        var _log2 = _interopRequireDefault(_log);

        var _paramGui = require('../param-gui');

        var _paramGui2 = _interopRequireDefault(_paramGui);

        var _timelineFxmenu = require('./timeline-fxmenu.vue');

        var _timelineFxmenu2 = _interopRequireDefault(_timelineFxmenu);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }

        var mouseEvents = function mouseEvents(move, up) {
          var u = function u(event) {
            if (up) {
              up(event);
            }

            window.removeEventListener("mousemove", move);
            window.removeEventListener("mouseup", u);
          };

          window.addEventListener("mousemove", move);
          window.addEventListener("mouseup", u);
        };

        exports.default = {
          components: {
            FxMenu: _timelineFxmenu2.default
          },
          props: ["automaton", "selectedParamName", "selectedNodeIds", "selectedFxIds"],
          data: function data() {
            return {
              width: 100,
              height: 100,
              t0: 0.0,
              t1: this.automaton.length,
              v0: -0.25,
              v1: 1.25,
              grid: {
                x: [],
                y: []
              },
              graphPoints: '',
              fxmenuActive: false,
              fxmenuTime: 0
            };
          },
          methods: {
            updateGrid: function updateGrid() {
              this.grid = {
                x: [],
                y: []
              };
              {
                var delta = this.t1 - this.t0;
                var logDelta = (0, _log2.default)(delta);
                var scale = Math.pow(10.0, Math.floor(logDelta) - 1.0);
                var intrv = logDelta - Math.floor(logDelta);
                var num = Math.floor(this.t0 / scale);
                var begin = num * scale;
                var accent10 = num - Math.floor(num / 10) * 10;
                var accent100 = num - Math.floor(num / 100) * 100;

                for (var v = begin; v < this.t1; v += scale) {
                  var op = accent100 === 0 ? 0.4 : accent10 === 0 ? 0.4 - intrv * 0.3 : 0.1 - intrv * 0.3;

                  if (0.0 < op) {
                    this.grid.x.push({
                      val: v + 1E-9,
                      pos: this.t2x(v),
                      op: op
                    });
                  }

                  accent10 = (accent10 + 1) % 10;
                  accent100 = (accent100 + 1) % 100;
                }
              }
              {
                var _delta = this.v1 - this.v0;

                var _logDelta = (0, _log2.default)(_delta);

                var _scale = Math.pow(10.0, Math.floor(_logDelta) - 1.0);

                var _intrv = _logDelta - Math.floor(_logDelta);

                var _num = Math.floor(this.v0 / _scale);

                var _begin = _num * _scale;

                var _accent = _num - Math.floor(_num / 10) * 10;

                var _accent2 = _num - Math.floor(_num / 100) * 100;

                for (var _v = _begin; _v < this.v1; _v += _scale) {
                  var _op = _accent2 === 0 ? 0.4 : _accent === 0 ? 0.4 - _intrv * 0.3 : 0.1 - _intrv * 0.3;

                  if (0.0 < _op) {
                    this.grid.y.push({
                      val: _v + 1E-9,
                      pos: this.v2y(_v),
                      op: _op
                    });
                  }

                  _accent = (_accent + 1) % 10;
                  _accent2 = (_accent2 + 1) % 100;
                }
              }
            },
            updateGraph: function updateGraph() {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var points = '';

              for (var x = 0; x <= this.width; x++) {
                var t = this.x2t(x);
                var v = param.getValue(t);
                var y = this.v2y(v);
                points += x + ' ' + y + ' ';
              }

              this.graphPoints = points;
            },
            x2t: function x2t(x) {
              var u = x / this.width;
              return u * (this.t1 - this.t0) + this.t0;
            },
            t2x: function t2x(t) {
              var u = (t - this.t0) / (this.t1 - this.t0);
              return u * this.width;
            },
            y2v: function y2v(y) {
              var u = 1.0 - y / this.height;
              return u * (this.v1 - this.v0) + this.v0;
            },
            v2y: function v2y(v) {
              var u = 1.0 - (v - this.v0) / (this.v1 - this.v0);
              return u * this.height;
            },
            moveView: function moveView(dx, dy) {
              var dt = this.x2t(0.0) - this.x2t(dx);
              var dv = this.y2v(0.0) - this.y2v(dy);
              dt = Math.min(Math.max(dt, -this.t0), this.automaton.length - this.t1);
              this.t0 += dt;
              this.t1 += dt;
              this.v0 += dv;
              this.v1 += dv;
              this.updateGrid();
              this.updateGraph();
            },
            zoomView: function zoomView(ct, cv, dx, dy) {
              var rt = (ct - this.t0) / (this.t1 - this.t0);
              var rv = (cv - this.v0) / (this.v1 - this.v0);
              var dt = this.t1 - this.t0;
              dt *= Math.pow((this.width + 1.0) / this.width, dx * 2.0);
              dt = Math.min(Math.max(dt, 0.01), 1000.0);
              var dv = this.v1 - this.v0;
              dv *= Math.pow((this.width + 1.0) / this.width, dy * 2.0);
              dv = Math.min(Math.max(dv, 0.01), 1000.0);
              this.t0 = ct - rt * dt;
              this.t1 = ct + (1.0 - rt) * dt;
              this.v0 = cv - rv * dv;
              this.v1 = cv + (1.0 - rv) * dv;

              if (this.t0 < 0.0) {
                this.t1 = Math.max(this.t1 - this.t0, this.t1);
              }

              if (this.automaton.length < this.t1) {
                this.t0 += this.automaton.length - this.t1;
              }

              if (this.t0 < 0.0) {
                this.t0 = 0.0;
              }

              if (this.automaton.length < this.t1) {
                this.t1 = this.automaton.length;
              }

              this.updateGrid();
              this.updateGraph();
            },
            createNode: function createNode(t, v) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var id = param.createNode(t, v);
              var data = param.dumpNode(id);
              this.$emit('nodeSelected', [id]);
              this.$emit('fxSelected', []);
              this.automaton.pushHistory('Create Node', function () {
                return param.createNodeFromData(data);
              }, function () {
                return param.removeNode(id);
              });
            },
            removeNode: function removeNode(id) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var node = param.dumpNode(id);

              if (!(node.in && node.out)) {
                return;
              }

              this.automaton.pushHistory('Remove Node', function () {
                return param.removeNode(id);
              }, function () {
                return param.createNodeFromData(node);
              }, true);
              this.$emit('nodeSelected', []);
            },
            removeHandle: function removeHandle(id, isOut) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var node = param.dumpNode(id);
              var t0 = isOut ? node.out.time : node.in.time;
              var v0 = isOut ? node.out.value : node.in.value;
              param.moveHandle(id, isOut, 0.0, 0.0);
              this.automaton.pushHistory('Remove Handle', function () {
                return param.moveHandle(id, isOut, 0.0, 0.0);
              }, function () {
                return param.moveHandle(id, isOut, t0, v0);
              }, true);
            },
            resetHandles: function resetHandles(id) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var node = param.dumpNode(id);
              this.automaton.pushHistory('Reset Handle', function () {
                param.resetHandle(id, false);
                param.resetHandle(id, true);
              }, function () {
                param.moveHandle(id, false, node.in.time, node.in.value);
                param.moveHandle(id, true, node.out.time, node.out.value);
              }, true);
            },
            grabHelper: function grabHelper(event, callback) {
              var _this = this;

              var x0 = event.clientX;
              var y0 = event.clientY;
              var t0 = this.x2t(x0);
              var v0 = this.y2v(y0);
              var moved = false;

              var move = function move(event) {
                var dt = _this.x2t(event.clientX) - t0;
                var dv = _this.y2v(event.clientY) - v0;
                moved = true;
                callback(dt, dv, event);
              };

              var up = function up(event) {
                if (moved) {
                  var dt = _this.x2t(event.clientX) - t0;
                  var dv = _this.y2v(event.clientY) - v0;
                  callback(dt, dv, event, true);
                }

                window.removeEventListener('mousemove', move);
                window.removeEventListener('mouseup', up);
              };

              window.addEventListener('mousemove', move);
              window.addEventListener('mouseup', up);
            },
            snapTime: function snapTime(time) {
              if (!this.automaton.guiSettings.snapActive) {
                return time;
              }

              var interval = this.automaton.guiSettings.snapTime;
              var width = 5.0 / this.width * (this.t1 - this.t0);
              var nearest = Math.round(time / interval) * interval;
              return Math.abs(time - nearest) < width ? nearest : time;
            },
            snapValue: function snapValue(value) {
              if (!this.automaton.guiSettings.snapActive) {
                return value;
              }

              var interval = this.automaton.guiSettings.snapValue;
              var width = 5.0 / this.height * (this.v1 - this.v0);
              var nearest = Math.round(value / interval) * interval;
              return Math.abs(value - nearest) < width ? nearest : value;
            },
            grabNode: function grabNode(id, event) {
              var _this2 = this;

              var param = this.selectedParam;

              if (!param) {
                return;
              }

              this.$emit('nodeSelected', [id]);
              this.$emit('fxSelected', []);
              var node = param.dumpNode(id);
              var t0 = node.time;
              var v0 = node.value;
              this.grabHelper(event, function (dt, dv, event, isUp) {
                var t = t0 + dt;
                var v = v0 + dv;

                if (!event.altKey) {
                  t = _this2.snapTime(t);
                  v = _this2.snapValue(v);
                }

                if (event.shiftKey) {
                  v = v0;
                } else if (event.ctrlKey || event.metaKey) {
                  t = t0;
                }

                param.moveNode(id, t, v);

                if (isUp) {
                  _this2.automaton.pushHistory('Move Node', function () {
                    return param.moveNode(id, t, v);
                  }, function () {
                    return param.moveNode(id, t0, v0);
                  });
                }
              });
            },
            grabHandle: function grabHandle(id, isOut, event) {
              var _this3 = this;

              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var node = param.dumpNode(id);
              var handle = isOut ? node.out : node.in;
              var t0 = handle.time;
              var v0 = handle.value;
              var len0 = Math.sqrt(t0 * t0 + v0 * v0);
              var nt0 = t0 / len0;
              var nv0 = v0 / len0;
              var handleOp = isOut ? node.in : node.out;
              var tOp0 = handleOp ? handleOp.time : 0.0;
              var vOp0 = handleOp ? handleOp.value : 0.0;
              this.grabHelper(event, function (dt, dv, event, isUp) {
                var t = t0 + dt;
                var v = v0 + dv;
                var tOp = tOp0;
                var vOp = vOp0;

                if (event.shiftKey) {
                  var dot = t * nt0 + v * nv0;
                  t = dot * nt0;
                  v = dot * nv0;
                } else if (event.ctrlKey || event.metaKey) {
                  tOp = -t;
                  vOp = -v;
                }

                param.moveHandle(id, isOut, t, v);
                param.moveHandle(id, !isOut, tOp, vOp);

                if (isUp) {
                  _this3.automaton.pushHistory('Move Handle', function () {
                    param.moveHandle(id, isOut, t, v);
                    param.moveHandle(id, !isOut, tOp, vOp);
                  }, function () {
                    param.moveHandle(id, isOut, t0, v0);
                    param.moveHandle(id, !isOut, tOp0, vOp0);
                  });
                }
              });
            },
            openFxMenu: function openFxMenu(time) {
              this.fxmenuActive = true;
              this.fxmenuTime = time;
            },
            createFx: function createFx(event, name) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var t = this.fxmenuTime;
              var l = Math.min(1.0, this.automaton.length - this.fxmenuTime);
              var id = param.createFx(t, l, name);
              var data = param.dumpFx(id);

              if (!id) {
                return;
              }

              this.$emit('nodeSelected', []);
              this.$emit('fxSelected', [id]);
              this.automaton.pushHistory('Create Fx', function () {
                return param.createFxFromData(data);
              }, function () {
                return param.removeFx(id);
              });
            },
            removeFx: function removeFx(id) {
              var param = this.selectedParam;

              if (!param) {
                return;
              }

              var fx = param.dumpFx(id);
              this.automaton.pushHistory('Remove Fx', function () {
                return param.removeFx(id);
              }, function () {
                return param.createFxFromData(fx);
              }, true);
              this.$emit('fxSelected', []);
            },
            grabFxBody: function grabFxBody(id, event) {
              var _this4 = this;

              var param = this.selectedParam;

              if (!param) {
                return;
              }

              this.$emit('nodeSelected', []);
              this.$emit('fxSelected', [id]);
              var fx = param.dumpFx(id);
              var t0 = fx.time;
              var r0 = fx.row;
              var y0 = event.clientY;
              this.grabHelper(event, function (dt, dv, event, isUp) {
                var dy = event.clientY - y0;
                var newRow = Math.min(Math.max(r0 + Math.round(dy / 16.0), 0), _paramGui2.default.FX_ROW_MAX);
                var t = t0 + dt;

                if (!event.altKey) {
                  t = _this4.snapTime(t);
                }

                param.moveFx(id, t);
                param.changeFxRow(id, newRow);

                if (isUp) {
                  _this4.automaton.pushHistory('Move Fx', function () {
                    return param.forceMoveFx(id, t, newRow);
                  }, function () {
                    return param.forceMoveFx(id, t0, r0);
                  });
                }
              });
            },
            grabFxLeft: function grabFxLeft(id, event) {
              var _this5 = this;

              var param = this.selectedParam;

              if (!param) {
                return;
              }

              this.$emit('nodeSelected', []);
              this.$emit('fxSelected', [id]);
              var fx = param.dumpFx(id);
              var l0 = fx.length;
              var end0 = fx.time + l0;
              this.grabHelper(event, function (dt, dv, event, isUp) {
                var l = l0 - dt;

                if (!event.altKey) {
                  l = _this5.snapTime(l - end0) + end0;
                }

                param.resizeFxByLeft(id, l);

                if (isUp) {
                  _this5.automaton.pushHistory('Resize Fx', function () {
                    return param.resizeFxByLeft(id, l);
                  }, function () {
                    return param.resizeFxByLeft(id, l0);
                  });
                }
              });
            },
            grabFxRight: function grabFxRight(id, event) {
              var _this6 = this;

              var param = this.selectedParam;

              if (!param) {
                return;
              }

              this.$emit('nodeSelected', []);
              this.$emit('fxSelected', [id]);
              var fx = param.dumpFx(id);
              var l0 = fx.length;
              var t0 = fx.time;
              this.grabHelper(event, function (dt, dv, event, isUp) {
                var l = l0 + dt;

                if (!event.altKey) {
                  l = _this6.snapTime(l + t0) - t0;
                }

                param.resizeFx(id, l);

                if (isUp) {
                  _this6.automaton.pushHistory('Resize Fx', function () {
                    return param.resizeFx(id, l);
                  }, function () {
                    return param.resizeFx(id, l0);
                  });
                }
              });
            },
            dragBg: function dragBg(event) {
              var _this7 = this;

              var t0 = this.x2t(event.offsetX);
              var v0 = this.y2v(event.offsetY);
              var which = event.which;
              var shiftKey = event.shiftKey;
              var altKey = event.altKey;
              var x0 = event.clientX;
              var y0 = event.clientY;
              var xPrev = x0;
              var yPrev = y0;
              var isPlaying0 = this.automaton.isPlaying;

              if (altKey) {
                this.automaton.seek(t0);

                if (isPlaying0) {
                  this.automaton.pause();
                }
              }

              var move = function move(event) {
                var x = event.clientX;
                var y = event.clientY;
                var dx = event.clientX - xPrev;
                var dy = event.clientY - yPrev;

                if (which === 1) {
                  if (altKey) {
                    _this7.automaton.seek(t0 + _this7.x2t(x - x0));
                  }
                } else if (which === 2) {
                  if (shiftKey) {
                    _this7.zoomView(t0, v0, -dx, dy);
                  } else {
                    _this7.moveView(dx, dy);
                  }
                }

                xPrev = x;
                yPrev = y;
              };

              var up = function up(event) {
                if (altKey && isPlaying0) {
                  _this7.automaton.play();
                }

                window.removeEventListener('mousemove', move);
                window.removeEventListener('mouseup', up);
              };

              window.addEventListener('mousemove', move);
              window.addEventListener('mouseup', up);
            },
            contextBg: function contextBg(event) {
              var _this8 = this;

              if (!this.selectedParam) {
                return;
              }

              var t = this.x2t(event.offsetX);
              var v = this.y2v(event.offsetY);
              this.$emit('context', {
                clientX: event.clientX,
                clientY: event.clientY,
                commands: [{
                  text: 'Add Node',
                  func: function func() {
                    _this8.createNode(t, v);
                  }
                }, {
                  text: 'Add Fx',
                  func: function func() {
                    _this8.openFxMenu(t);
                  }
                }]
              });
            },
            onWheel: function onWheel(event) {
              var t0 = this.x2t(event.offsetX);
              var v0 = this.y2v(event.offsetY);

              if (event.shiftKey) {
                this.zoomView(t0, v0, -event.deltaY, 0);
              } else if (event.ctrlKey || event.metaKey) {
                this.zoomView(t0, v0, 0, -event.deltaY);
              } else {
                this.moveView(event.deltaX, -event.deltaY);
              }

              this.updateGrid();
              this.updateGraph();
            },
            onResize: function onResize() {
              var _this9 = this;

              var el = this.$refs.root;
              this.width = el.clientWidth;
              this.height = el.clientHeight - 4;
              this.$nextTick(function () {
                _this9.updateGrid();

                _this9.updateGraph();
              });
            }
          },
          computed: {
            selectedParam: function selectedParam() {
              return this.automaton.getParam(this.selectedParamName);
            }
          },
          watch: {
            selectedParamName: function selectedParamName() {
              this.updateGraph();
            }
          },
          mounted: function mounted() {
            var _this10 = this;

            this.$root.$on('loaded', function () {
              _this10.t0 = 0.0;
              _this10.t1 = _this10.automaton.length;
            });
            this.$root.$on('changedLength', function () {
              _this10.t0 = 0.0;
              _this10.t1 = _this10.automaton.length;

              _this10.updateGraph();
            });
            this.$root.$on('poke', function () {
              _this10.updateGraph();
            });
            this.$nextTick(function () {
              _this10.onResize();
            });
            window.addEventListener('resize', this.onResize);
          },
          beforeDestroy: function beforeDestroy() {
            window.removeEventListener('resize', this.onResize);
          }
        };
      })();

      if (module.exports.__esModule) module.exports = module.exports.default;

      var __vue__options__ = typeof module.exports === "function" ? module.exports.options : module.exports;

      if (__vue__options__.functional) {
        console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.");
      }

      __vue__options__.render = function render() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c('div', [_c('div', {
          ref: "root",
          staticClass: "root",
          on: {
            "wheel": function wheel($event) {
              $event.preventDefault();
              return _vm.onWheel($event);
            },
            "dragstart": function dragstart($event) {
              $event.preventDefault();
            },
            "mousedown": function mousedown($event) {
              $event.preventDefault();
              $event.stopPropagation();
              return _vm.dragBg($event);
            },
            "dblclick": function dblclick($event) {
              if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                return null;
              }

              if ('button' in $event && $event.button !== 0) {
                return null;
              }

              $event.stopPropagation();

              _vm.createNode(_vm.x2t($event.offsetX), _vm.y2v($event.offsetY));
            },
            "contextmenu": function contextmenu($event) {
              $event.stopPropagation();
              $event.preventDefault();
              return _vm.contextBg($event);
            }
          }
        }, [_c('div', {
          staticClass: "hbar"
        }, [_c('div', {
          staticClass: "vision",
          style: {
            left: _vm.t0 / _vm.automaton.length * _vm.width + "px",
            width: (_vm.t1 - _vm.t0) / _vm.automaton.length * _vm.width + "px"
          }
        })]), _vm._v(" "), _c('svg', {
          staticClass: "svg",
          attrs: {
            "width": _vm.width,
            "height": _vm.height,
            "viewBox": "0 0 " + _vm.width + " " + _vm.height
          }
        }, [_vm._l(_vm.grid.x, function (line, index) {
          return _c('line', {
            key: 'grid-x' + index,
            staticClass: "grid",
            attrs: {
              "x1": line.pos,
              "y1": 0,
              "x2": line.pos,
              "y2": _vm.height,
              "opacity": line.op
            }
          });
        }), _vm._v(" "), _vm._l(_vm.grid.y, function (line, index) {
          return _c('line', {
            key: 'grid-y' + index,
            staticClass: "grid",
            attrs: {
              "x1": 0,
              "y1": line.pos,
              "x2": _vm.width,
              "y2": line.pos,
              "opacity": line.op
            }
          });
        }), _vm._v(" "), _vm._l(_vm.grid.x, function (line, index) {
          return _c('text', {
            key: 'grid-text-x' + index,
            staticClass: "grid-text",
            attrs: {
              "x": line.pos + 2,
              "y": _vm.height - 2,
              "opacity": line.op
            }
          }, [_vm._v(_vm._s(line.val.toFixed(3)))]);
        }), _vm._v(" "), _vm._l(_vm.grid.y, function (line, index) {
          return _c('text', {
            key: 'grid-text-y' + index,
            staticClass: "grid-text",
            attrs: {
              "x": "2",
              "y": line.pos - 2,
              "opacity": line.op
            }
          }, [_vm._v(_vm._s(line.val.toFixed(3)))]);
        }), _vm._v(" "), _vm.selectedParam ? _c('g', [_vm._l(_vm.selectedParam.dumpFxs(), function (fx) {
          return _c('g', {
            key: fx.$id,
            staticClass: "fx"
          }, [_c('line', {
            staticClass: "line",
            attrs: {
              "x1": _vm.t2x(fx.time),
              "y1": "4",
              "x2": _vm.t2x(fx.time),
              "y2": _vm.height
            }
          }), _vm._v(" "), _c('line', {
            staticClass: "line",
            attrs: {
              "x1": _vm.t2x(fx.time + fx.length),
              "y1": "4",
              "x2": _vm.t2x(fx.time + fx.length),
              "y2": _vm.height
            }
          }), _vm._v(" "), _c('rect', {
            staticClass: "fill",
            attrs: {
              "x": _vm.t2x(fx.time),
              "y": "0",
              "width": _vm.t2x(fx.time + fx.length) - _vm.t2x(fx.time),
              "height": _vm.height
            }
          }), _vm._v(" "), _c('g', {
            attrs: {
              "transform": 'translate(0,' + (1 + 16 * fx.row) + ')'
            }
          }, [_c('rect', {
            staticClass: "body",
            class: {
              selected: _vm.selectedFxIds.some(function (id) {
                return id === fx.$id;
              }),
              bypass: fx.bypass
            },
            attrs: {
              "x": _vm.t2x(fx.time),
              "width": _vm.t2x(fx.time + fx.length) - _vm.t2x(fx.time),
              "height": "16",
              "rx": "5",
              "ry": "5"
            },
            on: {
              "mousedown": function mousedown($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabFxBody(fx.$id, $event);
              },
              "dblclick": function dblclick($event) {
                $event.stopPropagation();

                _vm.removeFx(fx.$id);
              }
            }
          }), _vm._v(" "), _c('rect', {
            staticClass: "side",
            attrs: {
              "x": _vm.t2x(fx.time) - 1,
              "width": "6",
              "height": "16"
            },
            on: {
              "mousedown": function mousedown($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabFxLeft(fx.$id, $event);
              }
            }
          }), _vm._v(" "), _c('rect', {
            staticClass: "side",
            attrs: {
              "x": _vm.t2x(fx.time + fx.length) - 5,
              "width": "6",
              "height": "16"
            },
            on: {
              "mousedown": function mousedown($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabFxRight(fx.$id, $event);
              }
            }
          }), _vm._v(" "), _c('clipPath', {
            attrs: {
              "id": 'fxclip' + fx.$id
            }
          }, [_c('rect', {
            attrs: {
              "x": _vm.t2x(fx.time),
              "width": _vm.t2x(fx.time + fx.length) - _vm.t2x(fx.time),
              "height": "16"
            }
          })]), _vm._v(" "), _c('g', {
            attrs: {
              "clip-path": 'url(#fxclip' + fx.$id + ')'
            }
          }, [_c('text', {
            staticClass: "text",
            class: {
              selected: _vm.selectedFxIds.some(function (id) {
                return id === fx.$id;
              }),
              bypass: fx.bypass
            },
            attrs: {
              "x": _vm.t2x(fx.time) + 4,
              "y": "12"
            }
          }, [_vm._v(_vm._s(_vm.automaton.getFxDefinitionName(fx.def)))])])])]);
        }), _vm._v(" "), _vm.selectedParam ? _c('polyline', {
          staticClass: "graph",
          attrs: {
            "points": _vm.graphPoints
          }
        }) : _vm._e(), _vm._v(" "), _c('line', {
          staticClass: "currentLine",
          attrs: {
            "x1": _vm.t2x(_vm.automaton.time),
            "y1": "0",
            "x2": _vm.t2x(_vm.automaton.time),
            "y2": _vm.height
          }
        }), _vm._v(" "), _c('text', {
          staticClass: "currentText",
          attrs: {
            "x": _vm.t2x(_vm.automaton.time) + 2,
            "y": _vm.height - 2
          }
        }, [_vm._v(_vm._s(_vm.automaton.time.toFixed(3)))]), _vm._v(" "), _vm.selectedParam ? _c('g', [_c('line', {
          staticClass: "currentLine",
          attrs: {
            "x1": "0",
            "y1": _vm.v2y(_vm.selectedParam.getValue()),
            "x2": _vm.width,
            "y2": _vm.v2y(_vm.selectedParam.getValue())
          }
        }), _vm._v(" "), _c('text', {
          staticClass: "currentText",
          attrs: {
            "x": "2",
            "y": _vm.v2y(_vm.selectedParam.getValue()) - 2
          }
        }, [_vm._v(_vm._s(_vm.selectedParam.getValue().toFixed(3)))]), _vm._v(" "), _c('circle', {
          staticClass: "currentPoint",
          attrs: {
            "r": "5",
            "cx": _vm.t2x(_vm.automaton.time),
            "cy": _vm.v2y(_vm.selectedParam.getValue())
          }
        })]) : _vm._e()], 2) : _vm._e(), _vm._v(" "), _vm.selectedParam ? _c('g', _vm._l(_vm.selectedParam.dumpNodes(), function (node) {
          return _c('g', {
            key: node.$id,
            staticClass: "node"
          }, [_c('g', {
            staticClass: "handle"
          }, [node.in ? _c('line', {
            staticClass: "line",
            attrs: {
              "x1": _vm.t2x(node.time),
              "y1": _vm.v2y(node.value),
              "x2": _vm.t2x(node.time + node.in.time),
              "y2": _vm.v2y(node.value + node.in.value)
            }
          }) : _vm._e(), _vm._v(" "), node.in ? _c('circle', {
            staticClass: "circle",
            attrs: {
              "r": "4",
              "transform": 'translate(' + _vm.t2x(node.time + node.in.time) + ',' + _vm.v2y(node.value + node.in.value) + ')'
            },
            on: {
              "mousedown": function mousedown($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabHandle(node.$id, false, $event);
              },
              "dblclick": function dblclick($event) {
                $event.stopPropagation();

                _vm.removeHandle(node.$id, false);
              }
            }
          }) : _vm._e(), _vm._v(" "), node.out ? _c('line', {
            staticClass: "line",
            attrs: {
              "x1": _vm.t2x(node.time),
              "y1": _vm.v2y(node.value),
              "x2": _vm.t2x(node.time + node.out.time),
              "y2": _vm.v2y(node.value + node.out.value)
            }
          }) : _vm._e(), _vm._v(" "), node.out ? _c('circle', {
            staticClass: "circle",
            attrs: {
              "r": "4",
              "transform": 'translate(' + _vm.t2x(node.time + node.out.time) + ',' + _vm.v2y(node.value + node.out.value) + ')'
            },
            on: {
              "mousedown": function mousedown($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabHandle(node.$id, true, $event);
              },
              "dblclick": function dblclick($event) {
                $event.stopPropagation();

                _vm.removeHandle(node.$id, true);
              }
            }
          }) : _vm._e()]), _vm._v(" "), _c('g', {
            staticClass: "body",
            class: {
              selected: _vm.selectedNodeIds.some(function (id) {
                return id === node.$id;
              })
            },
            on: {
              "dblclick": function dblclick($event) {
                $event.stopPropagation();

                _vm.removeNode(node.$id);
              },
              "mousedown": [function ($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                if (!$event.shiftKey) {
                  return null;
                }

                $event.stopPropagation();

                _vm.resetHandles(node.$id);
              }, function ($event) {
                if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
                  return null;
                }

                if ('button' in $event && $event.button !== 0) {
                  return null;
                }

                $event.stopPropagation();

                _vm.grabNode(node.$id, $event);
              }]
            }
          }, [_vm.v0 <= node.value && node.value <= _vm.v1 ? _c('circle', {
            staticClass: "circle",
            attrs: {
              "transform": 'translate(' + _vm.t2x(node.time) + ',' + _vm.v2y(node.value) + ')',
              "r": "5"
            }
          }) : _vm._e(), _vm._v(" "), node.value < _vm.v0 ? _c('path', {
            staticClass: "triangle",
            attrs: {
              "transform": 'translate(' + _vm.t2x(node.time) + ',' + _vm.height + ')',
              "d": "M 0 -4 L 5 -12 L -5 -12 z"
            }
          }) : _vm._e(), _vm._v(" "), _vm.v1 < node.value ? _c('path', {
            staticClass: "triangle",
            attrs: {
              "transform": 'translate(' + _vm.t2x(node.time) + ',0)',
              "d": "M 0 4 L -5 12 L 5 12 z"
            }
          }) : _vm._e()])]);
        })) : _vm._e()], 2), _vm._v(" "), _c('FxMenu', {
          attrs: {
            "automaton": _vm.automaton,
            "active": _vm.fxmenuActive
          },
          on: {
            "selected": function selected($event) {
              _vm.createFx(_vm.fxmenuTime, $event);
            },
            "blur": function blur($event) {
              _vm.fxmenuActive = false;
            }
          }
        })], 1)]);
      };

      __vue__options__.staticRenderFns = [];
      __vue__options__._scopeId = "data-v-f3a8533a";

      if (module.hot) {
        (function () {
          var hotAPI = require("vue-hot-reload-api");

          hotAPI.install(require("vue"), true);
          if (!hotAPI.compatible) return;
          module.hot.accept();
          module.hot.dispose(__vueify_style_dispose__);

          if (!module.hot.data) {
            hotAPI.createRecord("data-v-f3a8533a", __vue__options__);
          } else {
            hotAPI.rerender("data-v-f3a8533a", __vue__options__);
          }
        })();
      }
    }, {
      "../param-gui": 100,
      "./timeline-fxmenu.vue": 111,
      "babel-runtime/core-js/math/log10": 2,
      "vue": 65,
      "vue-hot-reload-api": 64,
      "vueify/lib/insert-css": 66
    }]
  }, {}, [98])(98);
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  for (var i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");

var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return _typeof(arg) === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js!./src/styles/main.scss":
/*!*************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js!./src/styles/main.scss ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "body {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  font: 500 10px 'Wt-Position', sans-serif;\n  background: #000;\n  color: #fff; }\n  body #divActive {\n    position: fixed;\n    left: 8px;\n    bottom: 248px; }\n  body #divMidi {\n    position: fixed;\n    left: 8px;\n    bottom: 248px; }\n  body #divPath {\n    position: fixed;\n    right: 8px;\n    bottom: 248px;\n    text-align: right; }\n  body #divAutomaton {\n    position: fixed;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    height: 240px; }\n  body #canvas {\n    position: fixed;\n    left: 0;\n    top: 0; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media " + item[2] + "{" + content + "}";
      } else {
        return content;
      }
    }).join("");
  }; // import a list of modules into the list


  list.i = function (modules, mediaQuery) {
    if (typeof modules === "string") modules = [[null, modules, ""]];
    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      var id = this[i][0];
      if (typeof id === "number") alreadyImportedModules[id] = true;
    }

    for (i = 0; i < modules.length; i++) {
      var item = modules[i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      //  when a module is imported multiple times with different media queries.
      //  I hope this will never occur (Hey this way we have smaller bundles)

      if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || '';
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return '/*# ' + data + ' */';
}

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

EventEmitter.defaultMaxListeners = 10; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.

EventEmitter.prototype.setMaxListeners = function (n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function (type) {
  var er, handler, len, args, i, listeners;
  if (!this._events) this._events = {}; // If there is no 'error' event listener then throw.

  if (type === 'error') {
    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
      er = arguments[1];

      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];
  if (isUndefined(handler)) return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;

      case 2:
        handler.call(this, arguments[1]);
        break;

      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower

      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;

    for (i = 0; i < len; i++) {
      listeners[i].apply(this, args);
    }
  }

  return true;
};

EventEmitter.prototype.addListener = function (type, listener) {
  var m;
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  if (!this._events) this._events = {}; // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".

  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
  if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;else if (isObject(this._events[type])) // If we've already got an array, just append.
    this._events[type].push(listener);else // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener]; // Check for listener leak

  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);

      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function (type, listener) {
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);
  return this;
}; // emits a 'removeListener' event iff the listener was removed


EventEmitter.prototype.removeListener = function (type, listener) {
  var list, position, length, i;
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  if (!this._events || !this._events[type]) return this;
  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type];
    if (this._events.removeListener) this.emit('removeListener', type, listener);
  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener) this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function (type) {
  var key, listeners;
  if (!this._events) return this; // not listening for removeListener, no need to emit

  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length) {
      this.removeListener(type, listeners[listeners.length - 1]);
    }
  }

  delete this._events[type];
  return this;
};

EventEmitter.prototype.listeners = function (type) {
  var ret;
  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function (type) {
  if (this._events) {
    var evlistener = this._events[type];
    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
  }

  return 0;
};

EventEmitter.listenerCount = function (emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/immediate/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/immediate/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var Mutation = global.MutationObserver || global.WebKitMutationObserver;
var scheduleDrain;
{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });

    scheduleDrain = function scheduleDrain() {
      element.data = called = ++called % 2;
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;

    scheduleDrain = function scheduleDrain() {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function scheduleDrain() {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');

      scriptEl.onreadystatechange = function () {
        nextTick();
        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };

      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function scheduleDrain() {
      setTimeout(nextTick, 0);
    };
  }
}
var draining;
var queue = []; //named nextTick for less confusing stack traces

function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;

  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;

    while (++i < len) {
      oldQueue[i]();
    }

    len = queue.length;
  }

  draining = false;
}

module.exports = immediate;

function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function TempCtor() {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "./node_modules/jszip/lib/base64.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/lib/base64.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js"); // private property


var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; // public method for encoding

exports.encode = function (input) {
  var output = [];
  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  var i = 0,
      len = input.length,
      remainingBytes = len;
  var isArray = utils.getTypeOf(input) !== "string";

  while (i < input.length) {
    remainingBytes = len - i;

    if (!isArray) {
      chr1 = input.charCodeAt(i++);
      chr2 = i < len ? input.charCodeAt(i++) : 0;
      chr3 = i < len ? input.charCodeAt(i++) : 0;
    } else {
      chr1 = input[i++];
      chr2 = i < len ? input[i++] : 0;
      chr3 = i < len ? input[i++] : 0;
    }

    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
    enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
    output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
  }

  return output.join("");
}; // public method for decoding


exports.decode = function (input) {
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0,
      resultIndex = 0;
  var dataUrlPrefix = "data:";

  if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
    // This is a common error: people give a data url
    // (data:image/png;base64,iVBOR...) with a {base64: true} and
    // wonders why things don't work.
    // We can detect that the string input looks like a data url but we
    // *can't* be sure it is one: removing everything up to the comma would
    // be too dangerous.
    throw new Error("Invalid base64 input, it looks like a data url.");
  }

  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var totalLength = input.length * 3 / 4;

  if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
    totalLength--;
  }

  if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
    totalLength--;
  }

  if (totalLength % 1 !== 0) {
    // totalLength is not an integer, the length does not match a valid
    // base64 content. That can happen if:
    // - the input is not a base64 content
    // - the input is *almost* a base64 content, with a extra chars at the
    //   beginning or at the end
    // - the input uses a base64 variant (base64url for example)
    throw new Error("Invalid base64 input, bad content length.");
  }

  var output;

  if (support.uint8array) {
    output = new Uint8Array(totalLength | 0);
  } else {
    output = new Array(totalLength | 0);
  }

  while (i < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i++));
    enc2 = _keyStr.indexOf(input.charAt(i++));
    enc3 = _keyStr.indexOf(input.charAt(i++));
    enc4 = _keyStr.indexOf(input.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output[resultIndex++] = chr1;

    if (enc3 !== 64) {
      output[resultIndex++] = chr2;
    }

    if (enc4 !== 64) {
      output[resultIndex++] = chr3;
    }
  }

  return output;
};

/***/ }),

/***/ "./node_modules/jszip/lib/compressedObject.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/compressedObject.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var external = __webpack_require__(/*! ./external */ "./node_modules/jszip/lib/external.js");

var DataWorker = __webpack_require__(/*! ./stream/DataWorker */ "./node_modules/jszip/lib/stream/DataWorker.js");

var DataLengthProbe = __webpack_require__(/*! ./stream/DataLengthProbe */ "./node_modules/jszip/lib/stream/DataLengthProbe.js");

var Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ "./node_modules/jszip/lib/stream/Crc32Probe.js");

var DataLengthProbe = __webpack_require__(/*! ./stream/DataLengthProbe */ "./node_modules/jszip/lib/stream/DataLengthProbe.js");
/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */


function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
  this.compressedSize = compressedSize;
  this.uncompressedSize = uncompressedSize;
  this.crc32 = crc32;
  this.compression = compression;
  this.compressedContent = data;
}

CompressedObject.prototype = {
  /**
   * Create a worker to get the uncompressed content.
   * @return {GenericWorker} the worker.
   */
  getContentWorker: function getContentWorker() {
    var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
    var that = this;
    worker.on("end", function () {
      if (this.streamInfo['data_length'] !== that.uncompressedSize) {
        throw new Error("Bug : uncompressed data size mismatch");
      }
    });
    return worker;
  },

  /**
   * Create a worker to get the compressed content.
   * @return {GenericWorker} the worker.
   */
  getCompressedWorker: function getCompressedWorker() {
    return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
  }
};
/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */

CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
  return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

/***/ }),

/***/ "./node_modules/jszip/lib/compressions.js":
/*!************************************************!*\
  !*** ./node_modules/jszip/lib/compressions.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

exports.STORE = {
  magic: "\x00\x00",
  compressWorker: function compressWorker(compressionOptions) {
    return new GenericWorker("STORE compression");
  },
  uncompressWorker: function uncompressWorker() {
    return new GenericWorker("STORE decompression");
  }
};
exports.DEFLATE = __webpack_require__(/*! ./flate */ "./node_modules/jszip/lib/flate.js");

/***/ }),

/***/ "./node_modules/jszip/lib/crc32.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/crc32.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");
/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */
// Use ordinary array, since untyped makes no boost here


function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;

    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }

    table[n] = c;
  }

  return table;
} // Create table on load. Just 255 signed longs. Not a problem.


var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;
  crc = crc ^ -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
} // That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */


function crc32str(crc, str, len, pos) {
  var t = crcTable,
      end = pos + len;
  crc = crc ^ -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
  if (typeof input === "undefined" || !input.length) {
    return 0;
  }

  var isArray = utils.getTypeOf(input) !== "string";

  if (isArray) {
    return crc32(crc | 0, input, input.length, 0);
  } else {
    return crc32str(crc | 0, input, input.length, 0);
  }
};

/***/ }),

/***/ "./node_modules/jszip/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

/***/ }),

/***/ "./node_modules/jszip/lib/external.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/external.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global Promise */
 // load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)

var ES6Promise = null;

if (typeof Promise !== "undefined") {
  ES6Promise = Promise;
} else {
  ES6Promise = __webpack_require__(/*! lie */ "./node_modules/lie/lib/browser.js");
}
/**
 * Let the user use/change some implementations.
 */


module.exports = {
  Promise: ES6Promise
};

/***/ }),

/***/ "./node_modules/jszip/lib/flate.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/flate.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var USE_TYPEDARRAY = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';

var pako = __webpack_require__(/*! pako */ "./node_modules/pako/index.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
exports.magic = "\x08\x00";
/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */

function FlateWorker(action, options) {
  GenericWorker.call(this, "FlateWorker/" + action);
  this._pako = null;
  this._pakoAction = action;
  this._pakoOptions = options; // the `meta` object from the last chunk received
  // this allow this worker to pass around metadata

  this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

FlateWorker.prototype.processChunk = function (chunk) {
  this.meta = chunk.meta;

  if (this._pako === null) {
    this._createPako();
  }

  this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};
/**
 * @see GenericWorker.flush
 */


FlateWorker.prototype.flush = function () {
  GenericWorker.prototype.flush.call(this);

  if (this._pako === null) {
    this._createPako();
  }

  this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */


FlateWorker.prototype.cleanUp = function () {
  GenericWorker.prototype.cleanUp.call(this);
  this._pako = null;
};
/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */


FlateWorker.prototype._createPako = function () {
  this._pako = new pako[this._pakoAction]({
    raw: true,
    level: this._pakoOptions.level || -1 // default compression

  });
  var self = this;

  this._pako.onData = function (data) {
    self.push({
      data: data,
      meta: self.meta
    });
  };
};

exports.compressWorker = function (compressionOptions) {
  return new FlateWorker("Deflate", compressionOptions);
};

exports.uncompressWorker = function () {
  return new FlateWorker("Inflate", {});
};

/***/ }),

/***/ "./node_modules/jszip/lib/generate/ZipFileWorker.js":
/*!**********************************************************!*\
  !*** ./node_modules/jszip/lib/generate/ZipFileWorker.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var utf8 = __webpack_require__(/*! ../utf8 */ "./node_modules/jszip/lib/utf8.js");

var crc32 = __webpack_require__(/*! ../crc32 */ "./node_modules/jszip/lib/crc32.js");

var signature = __webpack_require__(/*! ../signature */ "./node_modules/jszip/lib/signature.js");
/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */


var decToHex = function decToHex(dec, bytes) {
  var hex = "",
      i;

  for (i = 0; i < bytes; i++) {
    hex += String.fromCharCode(dec & 0xff);
    dec = dec >>> 8;
  }

  return hex;
};
/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */


var generateUnixExternalFileAttr = function generateUnixExternalFileAttr(unixPermissions, isDir) {
  var result = unixPermissions;

  if (!unixPermissions) {
    // I can't use octal values in strict mode, hence the hexa.
    //  040775 => 0x41fd
    // 0100664 => 0x81b4
    result = isDir ? 0x41fd : 0x81b4;
  }

  return (result & 0xFFFF) << 16;
};
/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */


var generateDosExternalFileAttr = function generateDosExternalFileAttr(dosPermissions, isDir) {
  // the dir flag is already set for compatibility
  return (dosPermissions || 0) & 0x3F;
};
/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */


var generateZipParts = function generateZipParts(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
  var file = streamInfo['file'],
      compression = streamInfo['compression'],
      useCustomEncoding = encodeFileName !== utf8.utf8encode,
      encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
      utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
      comment = file.comment,
      encodedComment = utils.transformTo("string", encodeFileName(comment)),
      utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
      useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
      useUTF8ForComment = utfEncodedComment.length !== comment.length,
      dosTime,
      dosDate,
      extraFields = "",
      unicodePathExtraField = "",
      unicodeCommentExtraField = "",
      dir = file.dir,
      date = file.date;
  var dataInfo = {
    crc32: 0,
    compressedSize: 0,
    uncompressedSize: 0
  }; // if the content is streamed, the sizes/crc32 are only available AFTER
  // the end of the stream.

  if (!streamedContent || streamingEnded) {
    dataInfo.crc32 = streamInfo['crc32'];
    dataInfo.compressedSize = streamInfo['compressedSize'];
    dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
  }

  var bitflag = 0;

  if (streamedContent) {
    // Bit 3: the sizes/crc32 are set to zero in the local header.
    // The correct values are put in the data descriptor immediately
    // following the compressed data.
    bitflag |= 0x0008;
  }

  if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
    // Bit 11: Language encoding flag (EFS).
    bitflag |= 0x0800;
  }

  var extFileAttr = 0;
  var versionMadeBy = 0;

  if (dir) {
    // dos or unix, we set the dos dir flag
    extFileAttr |= 0x00010;
  }

  if (platform === "UNIX") {
    versionMadeBy = 0x031E; // UNIX, version 3.0

    extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
  } else {
    // DOS or other, fallback to DOS
    versionMadeBy = 0x0014; // DOS, version 2.0

    extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
  } // date
  // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
  // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
  // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html


  dosTime = date.getUTCHours();
  dosTime = dosTime << 6;
  dosTime = dosTime | date.getUTCMinutes();
  dosTime = dosTime << 5;
  dosTime = dosTime | date.getUTCSeconds() / 2;
  dosDate = date.getUTCFullYear() - 1980;
  dosDate = dosDate << 4;
  dosDate = dosDate | date.getUTCMonth() + 1;
  dosDate = dosDate << 5;
  dosDate = dosDate | date.getUTCDate();

  if (useUTF8ForFileName) {
    // set the unicode path extra field. unzip needs at least one extra
    // field to correctly handle unicode path, so using the path is as good
    // as any other information. This could improve the situation with
    // other archive managers too.
    // This field is usually used without the utf8 flag, with a non
    // unicode path in the header (winrar, winzip). This helps (a bit)
    // with the messy Windows' default compressed folders feature but
    // breaks on p7zip which doesn't seek the unicode path extra field.
    // So for now, UTF-8 everywhere !
    unicodePathExtraField = // Version
    decToHex(1, 1) + // NameCRC32
    decToHex(crc32(encodedFileName), 4) + // UnicodeName
    utfEncodedFileName;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "\x75\x70" + // size
    decToHex(unicodePathExtraField.length, 2) + // content
    unicodePathExtraField;
  }

  if (useUTF8ForComment) {
    unicodeCommentExtraField = // Version
    decToHex(1, 1) + // CommentCRC32
    decToHex(crc32(encodedComment), 4) + // UnicodeName
    utfEncodedComment;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "\x75\x63" + // size
    decToHex(unicodeCommentExtraField.length, 2) + // content
    unicodeCommentExtraField;
  }

  var header = ""; // version needed to extract

  header += "\x0A\x00"; // general purpose bit flag

  header += decToHex(bitflag, 2); // compression method

  header += compression.magic; // last mod file time

  header += decToHex(dosTime, 2); // last mod file date

  header += decToHex(dosDate, 2); // crc-32

  header += decToHex(dataInfo.crc32, 4); // compressed size

  header += decToHex(dataInfo.compressedSize, 4); // uncompressed size

  header += decToHex(dataInfo.uncompressedSize, 4); // file name length

  header += decToHex(encodedFileName.length, 2); // extra field length

  header += decToHex(extraFields.length, 2);
  var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
  var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
  decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
  header + // file comment length
  decToHex(encodedComment.length, 2) + // disk number start
  "\x00\x00" + // internal file attributes TODO
  "\x00\x00" + // external file attributes
  decToHex(extFileAttr, 4) + // relative offset of local header
  decToHex(offset, 4) + // file name
  encodedFileName + // extra field
  extraFields + // file comment
  encodedComment;
  return {
    fileRecord: fileRecord,
    dirRecord: dirRecord
  };
};
/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */


var generateCentralDirectoryEnd = function generateCentralDirectoryEnd(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
  var dirEnd = "";
  var encodedComment = utils.transformTo("string", encodeFileName(comment)); // end of central dir signature

  dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
  "\x00\x00" + // number of the disk with the start of the central directory
  "\x00\x00" + // total number of entries in the central directory on this disk
  decToHex(entriesCount, 2) + // total number of entries in the central directory
  decToHex(entriesCount, 2) + // size of the central directory   4 bytes
  decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
  decToHex(localDirLength, 4) + // .ZIP file comment length
  decToHex(encodedComment.length, 2) + // .ZIP file comment
  encodedComment;
  return dirEnd;
};
/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */


var generateDataDescriptors = function generateDataDescriptors(streamInfo) {
  var descriptor = "";
  descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
  decToHex(streamInfo['crc32'], 4) + // compressed size                 4 bytes
  decToHex(streamInfo['compressedSize'], 4) + // uncompressed size               4 bytes
  decToHex(streamInfo['uncompressedSize'], 4);
  return descriptor;
};
/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */


function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
  GenericWorker.call(this, "ZipFileWorker"); // The number of bytes written so far. This doesn't count accumulated chunks.

  this.bytesWritten = 0; // The comment of the zip file

  this.zipComment = comment; // The platform "generating" the zip file.

  this.zipPlatform = platform; // the function to encode file names and comments.

  this.encodeFileName = encodeFileName; // Should we stream the content of the files ?

  this.streamFiles = streamFiles; // If `streamFiles` is false, we will need to accumulate the content of the
  // files to calculate sizes / crc32 (and write them *before* the content).
  // This boolean indicates if we are accumulating chunks (it will change a lot
  // during the lifetime of this worker).

  this.accumulate = false; // The buffer receiving chunks when accumulating content.

  this.contentBuffer = []; // The list of generated directory records.

  this.dirRecords = []; // The offset (in bytes) from the beginning of the zip file for the current source.

  this.currentSourceOffset = 0; // The total number of entries in this zip file.

  this.entriesCount = 0; // the name of the file currently being added, null when handling the end of the zip file.
  // Used for the emited metadata.

  this.currentFile = null;
  this._sources = [];
}

utils.inherits(ZipFileWorker, GenericWorker);
/**
 * @see GenericWorker.push
 */

ZipFileWorker.prototype.push = function (chunk) {
  var currentFilePercent = chunk.meta.percent || 0;
  var entriesCount = this.entriesCount;
  var remainingFiles = this._sources.length;

  if (this.accumulate) {
    this.contentBuffer.push(chunk);
  } else {
    this.bytesWritten += chunk.data.length;
    GenericWorker.prototype.push.call(this, {
      data: chunk.data,
      meta: {
        currentFile: this.currentFile,
        percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
      }
    });
  }
};
/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */


ZipFileWorker.prototype.openedSource = function (streamInfo) {
  this.currentSourceOffset = this.bytesWritten;
  this.currentFile = streamInfo['file'].name;
  var streamedContent = this.streamFiles && !streamInfo['file'].dir; // don't stream folders (because they don't have any content)

  if (streamedContent) {
    var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.push({
      data: record.fileRecord,
      meta: {
        percent: 0
      }
    });
  } else {
    // we need to wait for the whole file before pushing anything
    this.accumulate = true;
  }
};
/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */


ZipFileWorker.prototype.closedSource = function (streamInfo) {
  this.accumulate = false;
  var streamedContent = this.streamFiles && !streamInfo['file'].dir;
  var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
  this.dirRecords.push(record.dirRecord);

  if (streamedContent) {
    // after the streamed file, we put data descriptors
    this.push({
      data: generateDataDescriptors(streamInfo),
      meta: {
        percent: 100
      }
    });
  } else {
    // the content wasn't streamed, we need to push everything now
    // first the file record, then the content
    this.push({
      data: record.fileRecord,
      meta: {
        percent: 0
      }
    });

    while (this.contentBuffer.length) {
      this.push(this.contentBuffer.shift());
    }
  }

  this.currentFile = null;
};
/**
 * @see GenericWorker.flush
 */


ZipFileWorker.prototype.flush = function () {
  var localDirLength = this.bytesWritten;

  for (var i = 0; i < this.dirRecords.length; i++) {
    this.push({
      data: this.dirRecords[i],
      meta: {
        percent: 100
      }
    });
  }

  var centralDirLength = this.bytesWritten - localDirLength;
  var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
  this.push({
    data: dirEnd,
    meta: {
      percent: 100
    }
  });
};
/**
 * Prepare the next source to be read.
 */


ZipFileWorker.prototype.prepareNextSource = function () {
  this.previous = this._sources.shift();
  this.openedSource(this.previous.streamInfo);

  if (this.isPaused) {
    this.previous.pause();
  } else {
    this.previous.resume();
  }
};
/**
 * @see GenericWorker.registerPrevious
 */


ZipFileWorker.prototype.registerPrevious = function (previous) {
  this._sources.push(previous);

  var self = this;
  previous.on('data', function (chunk) {
    self.processChunk(chunk);
  });
  previous.on('end', function () {
    self.closedSource(self.previous.streamInfo);

    if (self._sources.length) {
      self.prepareNextSource();
    } else {
      self.end();
    }
  });
  previous.on('error', function (e) {
    self.error(e);
  });
  return this;
};
/**
 * @see GenericWorker.resume
 */


ZipFileWorker.prototype.resume = function () {
  if (!GenericWorker.prototype.resume.call(this)) {
    return false;
  }

  if (!this.previous && this._sources.length) {
    this.prepareNextSource();
    return true;
  }

  if (!this.previous && !this._sources.length && !this.generatedError) {
    this.end();
    return true;
  }
};
/**
 * @see GenericWorker.error
 */


ZipFileWorker.prototype.error = function (e) {
  var sources = this._sources;

  if (!GenericWorker.prototype.error.call(this, e)) {
    return false;
  }

  for (var i = 0; i < sources.length; i++) {
    try {
      sources[i].error(e);
    } catch (e) {// the `error` exploded, nothing to do
    }
  }

  return true;
};
/**
 * @see GenericWorker.lock
 */


ZipFileWorker.prototype.lock = function () {
  GenericWorker.prototype.lock.call(this);
  var sources = this._sources;

  for (var i = 0; i < sources.length; i++) {
    sources[i].lock();
  }
};

module.exports = ZipFileWorker;

/***/ }),

/***/ "./node_modules/jszip/lib/generate/index.js":
/*!**************************************************!*\
  !*** ./node_modules/jszip/lib/generate/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compressions = __webpack_require__(/*! ../compressions */ "./node_modules/jszip/lib/compressions.js");

var ZipFileWorker = __webpack_require__(/*! ./ZipFileWorker */ "./node_modules/jszip/lib/generate/ZipFileWorker.js");
/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */


var getCompression = function getCompression(fileCompression, zipCompression) {
  var compressionName = fileCompression || zipCompression;
  var compression = compressions[compressionName];

  if (!compression) {
    throw new Error(compressionName + " is not a valid compression method !");
  }

  return compression;
};
/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */


exports.generateWorker = function (zip, options, comment) {
  var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
  var entriesCount = 0;

  try {
    zip.forEach(function (relativePath, file) {
      entriesCount++;
      var compression = getCompression(file.options.compression, options.compression);
      var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
      var dir = file.dir,
          date = file.date;

      file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
        name: relativePath,
        dir: dir,
        date: date,
        comment: file.comment || "",
        unixPermissions: file.unixPermissions,
        dosPermissions: file.dosPermissions
      }).pipe(zipFileWorker);
    });
    zipFileWorker.entriesCount = entriesCount;
  } catch (e) {
    zipFileWorker.error(e);
  }

  return zipFileWorker;
};

/***/ }),

/***/ "./node_modules/jszip/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Representation a of zip file in js
 * @constructor
 */

function JSZip() {
  // if this constructor is used without `new`, it adds `new` before itself:
  if (!(this instanceof JSZip)) {
    return new JSZip();
  }

  if (arguments.length) {
    throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
  } // object containing the files :
  // {
  //   "folder/" : {...},
  //   "folder/data.txt" : {...}
  // }


  this.files = {};
  this.comment = null; // Where we are in the hierarchy

  this.root = "";

  this.clone = function () {
    var newObj = new JSZip();

    for (var i in this) {
      if (typeof this[i] !== "function") {
        newObj[i] = this[i];
      }
    }

    return newObj;
  };
}

JSZip.prototype = __webpack_require__(/*! ./object */ "./node_modules/jszip/lib/object.js");
JSZip.prototype.loadAsync = __webpack_require__(/*! ./load */ "./node_modules/jszip/lib/load.js");
JSZip.support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js");
JSZip.defaults = __webpack_require__(/*! ./defaults */ "./node_modules/jszip/lib/defaults.js"); // TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327

JSZip.version = "3.1.5";

JSZip.loadAsync = function (content, options) {
  return new JSZip().loadAsync(content, options);
};

JSZip.external = __webpack_require__(/*! ./external */ "./node_modules/jszip/lib/external.js");
module.exports = JSZip;

/***/ }),

/***/ "./node_modules/jszip/lib/load.js":
/*!****************************************!*\
  !*** ./node_modules/jszip/lib/load.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var external = __webpack_require__(/*! ./external */ "./node_modules/jszip/lib/external.js");

var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/jszip/lib/utf8.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var ZipEntries = __webpack_require__(/*! ./zipEntries */ "./node_modules/jszip/lib/zipEntries.js");

var Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ "./node_modules/jszip/lib/stream/Crc32Probe.js");

var nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ "./node_modules/jszip/lib/nodejsUtils.js");
/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */


function checkEntryCRC32(zipEntry) {
  return new external.Promise(function (resolve, reject) {
    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
    worker.on("error", function (e) {
      reject(e);
    }).on("end", function () {
      if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
        reject(new Error("Corrupted zip : CRC32 mismatch"));
      } else {
        resolve();
      }
    }).resume();
  });
}

module.exports = function (data, options) {
  var zip = this;
  options = utils.extend(options || {}, {
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8.utf8decode
  });

  if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
  }

  return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function (data) {
    var zipEntries = new ZipEntries(options);
    zipEntries.load(data);
    return zipEntries;
  }).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;

    if (options.checkCRC32) {
      for (var i = 0; i < files.length; i++) {
        promises.push(checkEntryCRC32(files[i]));
      }
    }

    return external.Promise.all(promises);
  }).then(function addFiles(results) {
    var zipEntries = results.shift();
    var files = zipEntries.files;

    for (var i = 0; i < files.length; i++) {
      var input = files[i];
      zip.file(input.fileNameStr, input.decompressed, {
        binary: true,
        optimizedBinaryString: true,
        date: input.date,
        dir: input.dir,
        comment: input.fileCommentStr.length ? input.fileCommentStr : null,
        unixPermissions: input.unixPermissions,
        dosPermissions: input.dosPermissions,
        createFolders: options.createFolders
      });
    }

    if (zipEntries.zipComment.length) {
      zip.comment = zipEntries.zipComment;
    }

    return zip;
  });
};

/***/ }),

/***/ "./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");
/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */


function NodejsStreamInputAdapter(filename, stream) {
  GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
  this._upstreamEnded = false;

  this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);
/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */

NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
  var self = this;
  this._stream = stream;
  stream.pause();
  stream.on("data", function (chunk) {
    self.push({
      data: chunk,
      meta: {
        percent: 0
      }
    });
  }).on("error", function (e) {
    if (self.isPaused) {
      this.generatedError = e;
    } else {
      self.error(e);
    }
  }).on("end", function () {
    if (self.isPaused) {
      self._upstreamEnded = true;
    } else {
      self.end();
    }
  });
};

NodejsStreamInputAdapter.prototype.pause = function () {
  if (!GenericWorker.prototype.pause.call(this)) {
    return false;
  }

  this._stream.pause();

  return true;
};

NodejsStreamInputAdapter.prototype.resume = function () {
  if (!GenericWorker.prototype.resume.call(this)) {
    return false;
  }

  if (this._upstreamEnded) {
    this.end();
  } else {
    this._stream.resume();
  }

  return true;
};

module.exports = NodejsStreamInputAdapter;

/***/ }),

/***/ "./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js":
/*!********************************************************************!*\
  !*** ./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Readable = __webpack_require__(/*! readable-stream */ "./node_modules/jszip/lib/readable-stream-browser.js").Readable;

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

utils.inherits(NodejsStreamOutputAdapter, Readable);
/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/

function NodejsStreamOutputAdapter(helper, options, updateCb) {
  Readable.call(this, options);
  this._helper = helper;
  var self = this;
  helper.on("data", function (data, meta) {
    if (!self.push(data)) {
      self._helper.pause();
    }

    if (updateCb) {
      updateCb(meta);
    }
  }).on("error", function (e) {
    self.emit('error', e);
  }).on("end", function () {
    self.push(null);
  });
}

NodejsStreamOutputAdapter.prototype._read = function () {
  this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

/***/ }),

/***/ "./node_modules/jszip/lib/nodejsUtils.js":
/*!***********************************************!*\
  !*** ./node_modules/jszip/lib/nodejsUtils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

module.exports = {
  /**
   * True if this is running in Nodejs, will be undefined in a browser.
   * In a browser, browserify won't include this file and the whole module
   * will be resolved an empty object.
   */
  isNode: typeof Buffer !== "undefined",

  /**
   * Create a new nodejs Buffer from an existing content.
   * @param {Object} data the data to pass to the constructor.
   * @param {String} encoding the encoding to use.
   * @return {Buffer} a new Buffer.
   */
  newBufferFrom: function newBufferFrom(data, encoding) {
    // XXX We can't use `Buffer.from` which comes from `Uint8Array.from`
    // in nodejs v4 (< v.4.5). It's not the expected implementation (and
    // has a different signature).
    // see https://github.com/nodejs/node/issues/8053
    // A condition on nodejs' version won't solve the issue as we don't
    // control the Buffer polyfills that may or may not be used.
    return new Buffer(data, encoding);
  },

  /**
   * Create a new nodejs Buffer with the specified size.
   * @param {Integer} size the size of the buffer.
   * @return {Buffer} a new Buffer.
   */
  allocBuffer: function allocBuffer(size) {
    if (Buffer.alloc) {
      return Buffer.alloc(size);
    } else {
      return new Buffer(size);
    }
  },

  /**
   * Find out if an object is a Buffer.
   * @param {Object} b the object to test.
   * @return {Boolean} true if the object is a Buffer, false otherwise.
   */
  isBuffer: function isBuffer(b) {
    return Buffer.isBuffer(b);
  },
  isStream: function isStream(obj) {
    return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/jszip/lib/object.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/lib/object.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/jszip/lib/utf8.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ "./node_modules/jszip/lib/stream/StreamHelper.js");

var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/jszip/lib/defaults.js");

var CompressedObject = __webpack_require__(/*! ./compressedObject */ "./node_modules/jszip/lib/compressedObject.js");

var ZipObject = __webpack_require__(/*! ./zipObject */ "./node_modules/jszip/lib/zipObject.js");

var generate = __webpack_require__(/*! ./generate */ "./node_modules/jszip/lib/generate/index.js");

var nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ "./node_modules/jszip/lib/nodejsUtils.js");

var NodejsStreamInputAdapter = __webpack_require__(/*! ./nodejs/NodejsStreamInputAdapter */ "./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js");
/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */


var fileAdd = function fileAdd(name, data, originalOptions) {
  // be sure sub folders exist
  var dataType = utils.getTypeOf(data),
      parent;
  /*
   * Correct options.
   */

  var o = utils.extend(originalOptions || {}, defaults);
  o.date = o.date || new Date();

  if (o.compression !== null) {
    o.compression = o.compression.toUpperCase();
  }

  if (typeof o.unixPermissions === "string") {
    o.unixPermissions = parseInt(o.unixPermissions, 8);
  } // UNX_IFDIR  0040000 see zipinfo.c


  if (o.unixPermissions && o.unixPermissions & 0x4000) {
    o.dir = true;
  } // Bit 4    Directory


  if (o.dosPermissions && o.dosPermissions & 0x0010) {
    o.dir = true;
  }

  if (o.dir) {
    name = forceTrailingSlash(name);
  }

  if (o.createFolders && (parent = parentFolder(name))) {
    folderAdd.call(this, parent, true);
  }

  var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;

  if (!originalOptions || typeof originalOptions.binary === "undefined") {
    o.binary = !isUnicodeString;
  }

  var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;

  if (isCompressedEmpty || o.dir || !data || data.length === 0) {
    o.base64 = false;
    o.binary = true;
    data = "";
    o.compression = "STORE";
    dataType = "string";
  }
  /*
   * Convert content to fit.
   */


  var zipObjectContent = null;

  if (data instanceof CompressedObject || data instanceof GenericWorker) {
    zipObjectContent = data;
  } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
    zipObjectContent = new NodejsStreamInputAdapter(name, data);
  } else {
    zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
  }

  var object = new ZipObject(name, zipObjectContent, o);
  this.files[name] = object;
  /*
  TODO: we can't throw an exception because we have async promises
  (we can have a promise of a Date() for example) but returning a
  promise is useless because file(name, data) returns the JSZip
  object for chaining. Should we break that to allow the user
  to catch the error ?
   return external.Promise.resolve(zipObjectContent)
  .then(function () {
      return object;
  });
  */
};
/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */


var parentFolder = function parentFolder(path) {
  if (path.slice(-1) === '/') {
    path = path.substring(0, path.length - 1);
  }

  var lastSlash = path.lastIndexOf('/');
  return lastSlash > 0 ? path.substring(0, lastSlash) : "";
};
/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */


var forceTrailingSlash = function forceTrailingSlash(path) {
  // Check the name ends with a /
  if (path.slice(-1) !== "/") {
    path += "/"; // IE doesn't like substr(-1)
  }

  return path;
};
/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */


var folderAdd = function folderAdd(name, createFolders) {
  createFolders = typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders;
  name = forceTrailingSlash(name); // Does this folder already exist?

  if (!this.files[name]) {
    fileAdd.call(this, name, null, {
      dir: true,
      createFolders: createFolders
    });
  }

  return this.files[name];
};
/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/


function isRegExp(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
} // return the actual prototype of JSZip


var out = {
  /**
   * @see loadAsync
   */
  load: function load() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  },

  /**
   * Call a callback function for each entry at this folder level.
   * @param {Function} cb the callback function:
   * function (relativePath, file) {...}
   * It takes 2 arguments : the relative path and the file.
   */
  forEach: function forEach(cb) {
    var filename, relativePath, file;

    for (filename in this.files) {
      if (!this.files.hasOwnProperty(filename)) {
        continue;
      }

      file = this.files[filename];
      relativePath = filename.slice(this.root.length, filename.length);

      if (relativePath && filename.slice(0, this.root.length) === this.root) {
        // the file is in the current root
        cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
      }
    }
  },

  /**
   * Filter nested files/folders with the specified function.
   * @param {Function} search the predicate to use :
   * function (relativePath, file) {...}
   * It takes 2 arguments : the relative path and the file.
   * @return {Array} An array of matching elements.
   */
  filter: function filter(search) {
    var result = [];
    this.forEach(function (relativePath, entry) {
      if (search(relativePath, entry)) {
        // the file matches the function
        result.push(entry);
      }
    });
    return result;
  },

  /**
   * Add a file to the zip file, or search a file.
   * @param   {string|RegExp} name The name of the file to add (if data is defined),
   * the name of the file to find (if no data) or a regex to match files.
   * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
   * @param   {Object} o     File options
   * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
   * a file (when searching by string) or an array of files (when searching by regex).
   */
  file: function file(name, data, o) {
    if (arguments.length === 1) {
      if (isRegExp(name)) {
        var regexp = name;
        return this.filter(function (relativePath, file) {
          return !file.dir && regexp.test(relativePath);
        });
      } else {
        // text
        var obj = this.files[this.root + name];

        if (obj && !obj.dir) {
          return obj;
        } else {
          return null;
        }
      }
    } else {
      // more than one argument : we have data !
      name = this.root + name;
      fileAdd.call(this, name, data, o);
    }

    return this;
  },

  /**
   * Add a directory to the zip file, or search.
   * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
   * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
   */
  folder: function folder(arg) {
    if (!arg) {
      return this;
    }

    if (isRegExp(arg)) {
      return this.filter(function (relativePath, file) {
        return file.dir && arg.test(relativePath);
      });
    } // else, name is a new folder


    var name = this.root + arg;
    var newFolder = folderAdd.call(this, name); // Allow chaining by returning a new object with this folder as the root

    var ret = this.clone();
    ret.root = newFolder.name;
    return ret;
  },

  /**
   * Delete a file, or a directory and all sub-files, from the zip
   * @param {string} name the name of the file to delete
   * @return {JSZip} this JSZip object
   */
  remove: function remove(name) {
    name = this.root + name;
    var file = this.files[name];

    if (!file) {
      // Look for any folders
      if (name.slice(-1) !== "/") {
        name += "/";
      }

      file = this.files[name];
    }

    if (file && !file.dir) {
      // file
      delete this.files[name];
    } else {
      // maybe a folder, delete recursively
      var kids = this.filter(function (relativePath, file) {
        return file.name.slice(0, name.length) === name;
      });

      for (var i = 0; i < kids.length; i++) {
        delete this.files[kids[i].name];
      }
    }

    return this;
  },

  /**
   * Generate the complete zip file
   * @param {Object} options the options to generate the zip file :
   * - compression, "STORE" by default.
   * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
   * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
   */
  generate: function generate(options) {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  },

  /**
   * Generate the complete zip file as an internal stream.
   * @param {Object} options the options to generate the zip file :
   * - compression, "STORE" by default.
   * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
   * @return {StreamHelper} the streamed zip file.
   */
  generateInternalStream: function generateInternalStream(options) {
    var worker,
        opts = {};

    try {
      opts = utils.extend(options || {}, {
        streamFiles: false,
        compression: "STORE",
        compressionOptions: null,
        type: "",
        platform: "DOS",
        comment: null,
        mimeType: 'application/zip',
        encodeFileName: utf8.utf8encode
      });
      opts.type = opts.type.toLowerCase();
      opts.compression = opts.compression.toUpperCase(); // "binarystring" is prefered but the internals use "string".

      if (opts.type === "binarystring") {
        opts.type = "string";
      }

      if (!opts.type) {
        throw new Error("No output type specified.");
      }

      utils.checkSupport(opts.type); // accept nodejs `process.platform`

      if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {
        opts.platform = "UNIX";
      }

      if (opts.platform === 'win32') {
        opts.platform = "DOS";
      }

      var comment = opts.comment || this.comment || "";
      worker = generate.generateWorker(this, opts, comment);
    } catch (e) {
      worker = new GenericWorker("error");
      worker.error(e);
    }

    return new StreamHelper(worker, opts.type || "string", opts.mimeType);
  },

  /**
   * Generate the complete zip file asynchronously.
   * @see generateInternalStream
   */
  generateAsync: function generateAsync(options, onUpdate) {
    return this.generateInternalStream(options).accumulate(onUpdate);
  },

  /**
   * Generate the complete zip file asynchronously.
   * @see generateInternalStream
   */
  generateNodeStream: function generateNodeStream(options, onUpdate) {
    options = options || {};

    if (!options.type) {
      options.type = "nodebuffer";
    }

    return this.generateInternalStream(options).toNodejsStream(onUpdate);
  }
};
module.exports = out;

/***/ }),

/***/ "./node_modules/jszip/lib/readable-stream-browser.js":
/*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/readable-stream-browser.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js");

/***/ }),

/***/ "./node_modules/jszip/lib/reader/ArrayReader.js":
/*!******************************************************!*\
  !*** ./node_modules/jszip/lib/reader/ArrayReader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataReader = __webpack_require__(/*! ./DataReader */ "./node_modules/jszip/lib/reader/DataReader.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

function ArrayReader(data) {
  DataReader.call(this, data);

  for (var i = 0; i < this.data.length; i++) {
    data[i] = data[i] & 0xFF;
  }
}

utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */

ArrayReader.prototype.byteAt = function (i) {
  return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */


ArrayReader.prototype.lastIndexOfSignature = function (sig) {
  var sig0 = sig.charCodeAt(0),
      sig1 = sig.charCodeAt(1),
      sig2 = sig.charCodeAt(2),
      sig3 = sig.charCodeAt(3);

  for (var i = this.length - 4; i >= 0; --i) {
    if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
      return i - this.zero;
    }
  }

  return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */


ArrayReader.prototype.readAndCheckSignature = function (sig) {
  var sig0 = sig.charCodeAt(0),
      sig1 = sig.charCodeAt(1),
      sig2 = sig.charCodeAt(2),
      sig3 = sig.charCodeAt(3),
      data = this.readData(4);
  return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */


ArrayReader.prototype.readData = function (size) {
  this.checkOffset(size);

  if (size === 0) {
    return [];
  }

  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};

module.exports = ArrayReader;

/***/ }),

/***/ "./node_modules/jszip/lib/reader/DataReader.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/reader/DataReader.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

function DataReader(data) {
  this.data = data; // type : see implementation

  this.length = data.length;
  this.index = 0;
  this.zero = 0;
}

DataReader.prototype = {
  /**
   * Check that the offset will not go too far.
   * @param {string} offset the additional offset to check.
   * @throws {Error} an Error if the offset is out of bounds.
   */
  checkOffset: function checkOffset(offset) {
    this.checkIndex(this.index + offset);
  },

  /**
   * Check that the specified index will not be too far.
   * @param {string} newIndex the index to check.
   * @throws {Error} an Error if the index is out of bounds.
   */
  checkIndex: function checkIndex(newIndex) {
    if (this.length < this.zero + newIndex || newIndex < 0) {
      throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
    }
  },

  /**
   * Change the index.
   * @param {number} newIndex The new index.
   * @throws {Error} if the new index is out of the data.
   */
  setIndex: function setIndex(newIndex) {
    this.checkIndex(newIndex);
    this.index = newIndex;
  },

  /**
   * Skip the next n bytes.
   * @param {number} n the number of bytes to skip.
   * @throws {Error} if the new index is out of the data.
   */
  skip: function skip(n) {
    this.setIndex(this.index + n);
  },

  /**
   * Get the byte at the specified index.
   * @param {number} i the index to use.
   * @return {number} a byte.
   */
  byteAt: function byteAt(i) {// see implementations
  },

  /**
   * Get the next number with a given byte size.
   * @param {number} size the number of bytes to read.
   * @return {number} the corresponding number.
   */
  readInt: function readInt(size) {
    var result = 0,
        i;
    this.checkOffset(size);

    for (i = this.index + size - 1; i >= this.index; i--) {
      result = (result << 8) + this.byteAt(i);
    }

    this.index += size;
    return result;
  },

  /**
   * Get the next string with a given byte size.
   * @param {number} size the number of bytes to read.
   * @return {string} the corresponding string.
   */
  readString: function readString(size) {
    return utils.transformTo("string", this.readData(size));
  },

  /**
   * Get raw data without conversion, <size> bytes.
   * @param {number} size the number of bytes to read.
   * @return {Object} the raw data, implementation specific.
   */
  readData: function readData(size) {// see implementations
  },

  /**
   * Find the last occurence of a zip signature (4 bytes).
   * @param {string} sig the signature to find.
   * @return {number} the index of the last occurence, -1 if not found.
   */
  lastIndexOfSignature: function lastIndexOfSignature(sig) {// see implementations
  },

  /**
   * Read the signature (4 bytes) at the current position and compare it with sig.
   * @param {string} sig the expected signature
   * @return {boolean} true if the signature matches, false otherwise.
   */
  readAndCheckSignature: function readAndCheckSignature(sig) {// see implementations
  },

  /**
   * Get the next date.
   * @return {Date} the date.
   */
  readDate: function readDate() {
    var dostime = this.readInt(4);
    return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, // year
    (dostime >> 21 & 0x0f) - 1, // month
    dostime >> 16 & 0x1f, // day
    dostime >> 11 & 0x1f, // hour
    dostime >> 5 & 0x3f, // minute
    (dostime & 0x1f) << 1)); // second
  }
};
module.exports = DataReader;

/***/ }),

/***/ "./node_modules/jszip/lib/reader/NodeBufferReader.js":
/*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/reader/NodeBufferReader.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ "./node_modules/jszip/lib/reader/Uint8ArrayReader.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

function NodeBufferReader(data) {
  Uint8ArrayReader.call(this, data);
}

utils.inherits(NodeBufferReader, Uint8ArrayReader);
/**
 * @see DataReader.readData
 */

NodeBufferReader.prototype.readData = function (size) {
  this.checkOffset(size);
  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};

module.exports = NodeBufferReader;

/***/ }),

/***/ "./node_modules/jszip/lib/reader/StringReader.js":
/*!*******************************************************!*\
  !*** ./node_modules/jszip/lib/reader/StringReader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataReader = __webpack_require__(/*! ./DataReader */ "./node_modules/jszip/lib/reader/DataReader.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

function StringReader(data) {
  DataReader.call(this, data);
}

utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */

StringReader.prototype.byteAt = function (i) {
  return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */


StringReader.prototype.lastIndexOfSignature = function (sig) {
  return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */


StringReader.prototype.readAndCheckSignature = function (sig) {
  var data = this.readData(4);
  return sig === data;
};
/**
 * @see DataReader.readData
 */


StringReader.prototype.readData = function (size) {
  this.checkOffset(size); // this will work because the constructor applied the "& 0xff" mask.

  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};

module.exports = StringReader;

/***/ }),

/***/ "./node_modules/jszip/lib/reader/Uint8ArrayReader.js":
/*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/reader/Uint8ArrayReader.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArrayReader = __webpack_require__(/*! ./ArrayReader */ "./node_modules/jszip/lib/reader/ArrayReader.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

function Uint8ArrayReader(data) {
  ArrayReader.call(this, data);
}

utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */

Uint8ArrayReader.prototype.readData = function (size) {
  this.checkOffset(size);

  if (size === 0) {
    // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
    return new Uint8Array(0);
  }

  var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};

module.exports = Uint8ArrayReader;

/***/ }),

/***/ "./node_modules/jszip/lib/reader/readerFor.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/reader/readerFor.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var support = __webpack_require__(/*! ../support */ "./node_modules/jszip/lib/support.js");

var ArrayReader = __webpack_require__(/*! ./ArrayReader */ "./node_modules/jszip/lib/reader/ArrayReader.js");

var StringReader = __webpack_require__(/*! ./StringReader */ "./node_modules/jszip/lib/reader/StringReader.js");

var NodeBufferReader = __webpack_require__(/*! ./NodeBufferReader */ "./node_modules/jszip/lib/reader/NodeBufferReader.js");

var Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ "./node_modules/jszip/lib/reader/Uint8ArrayReader.js");
/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */


module.exports = function (data) {
  var type = utils.getTypeOf(data);
  utils.checkSupport(type);

  if (type === "string" && !support.uint8array) {
    return new StringReader(data);
  }

  if (type === "nodebuffer") {
    return new NodeBufferReader(data);
  }

  if (support.uint8array) {
    return new Uint8ArrayReader(utils.transformTo("uint8array", data));
  }

  return new ArrayReader(utils.transformTo("array", data));
};

/***/ }),

/***/ "./node_modules/jszip/lib/signature.js":
/*!*********************************************!*\
  !*** ./node_modules/jszip/lib/signature.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

/***/ }),

/***/ "./node_modules/jszip/lib/stream/ConvertWorker.js":
/*!********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/ConvertWorker.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GenericWorker = __webpack_require__(/*! ./GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");
/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */


function ConvertWorker(destType) {
  GenericWorker.call(this, "ConvertWorker to " + destType);
  this.destType = destType;
}

utils.inherits(ConvertWorker, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

ConvertWorker.prototype.processChunk = function (chunk) {
  this.push({
    data: utils.transformTo(this.destType, chunk.data),
    meta: chunk.meta
  });
};

module.exports = ConvertWorker;

/***/ }),

/***/ "./node_modules/jszip/lib/stream/Crc32Probe.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/stream/Crc32Probe.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GenericWorker = __webpack_require__(/*! ./GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var crc32 = __webpack_require__(/*! ../crc32 */ "./node_modules/jszip/lib/crc32.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");
/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */


function Crc32Probe() {
  GenericWorker.call(this, "Crc32Probe");
  this.withStreamInfo("crc32", 0);
}

utils.inherits(Crc32Probe, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

Crc32Probe.prototype.processChunk = function (chunk) {
  this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
  this.push(chunk);
};

module.exports = Crc32Probe;

/***/ }),

/***/ "./node_modules/jszip/lib/stream/DataLengthProbe.js":
/*!**********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/DataLengthProbe.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ./GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");
/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */


function DataLengthProbe(propName) {
  GenericWorker.call(this, "DataLengthProbe for " + propName);
  this.propName = propName;
  this.withStreamInfo(propName, 0);
}

utils.inherits(DataLengthProbe, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

DataLengthProbe.prototype.processChunk = function (chunk) {
  if (chunk) {
    var length = this.streamInfo[this.propName] || 0;
    this.streamInfo[this.propName] = length + chunk.data.length;
  }

  GenericWorker.prototype.processChunk.call(this, chunk);
};

module.exports = DataLengthProbe;

/***/ }),

/***/ "./node_modules/jszip/lib/stream/DataWorker.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/stream/DataWorker.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var GenericWorker = __webpack_require__(/*! ./GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js"); // the size of the generated chunks
// TODO expose this as a public variable


var DEFAULT_BLOCK_SIZE = 16 * 1024;
/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */

function DataWorker(dataP) {
  GenericWorker.call(this, "DataWorker");
  var self = this;
  this.dataIsReady = false;
  this.index = 0;
  this.max = 0;
  this.data = null;
  this.type = "";
  this._tickScheduled = false;
  dataP.then(function (data) {
    self.dataIsReady = true;
    self.data = data;
    self.max = data && data.length || 0;
    self.type = utils.getTypeOf(data);

    if (!self.isPaused) {
      self._tickAndRepeat();
    }
  }, function (e) {
    self.error(e);
  });
}

utils.inherits(DataWorker, GenericWorker);
/**
 * @see GenericWorker.cleanUp
 */

DataWorker.prototype.cleanUp = function () {
  GenericWorker.prototype.cleanUp.call(this);
  this.data = null;
};
/**
 * @see GenericWorker.resume
 */


DataWorker.prototype.resume = function () {
  if (!GenericWorker.prototype.resume.call(this)) {
    return false;
  }

  if (!this._tickScheduled && this.dataIsReady) {
    this._tickScheduled = true;
    utils.delay(this._tickAndRepeat, [], this);
  }

  return true;
};
/**
 * Trigger a tick a schedule an other call to this function.
 */


DataWorker.prototype._tickAndRepeat = function () {
  this._tickScheduled = false;

  if (this.isPaused || this.isFinished) {
    return;
  }

  this._tick();

  if (!this.isFinished) {
    utils.delay(this._tickAndRepeat, [], this);
    this._tickScheduled = true;
  }
};
/**
 * Read and push a chunk.
 */


DataWorker.prototype._tick = function () {
  if (this.isPaused || this.isFinished) {
    return false;
  }

  var size = DEFAULT_BLOCK_SIZE;
  var data = null,
      nextIndex = Math.min(this.max, this.index + size);

  if (this.index >= this.max) {
    // EOF
    return this.end();
  } else {
    switch (this.type) {
      case "string":
        data = this.data.substring(this.index, nextIndex);
        break;

      case "uint8array":
        data = this.data.subarray(this.index, nextIndex);
        break;

      case "array":
      case "nodebuffer":
        data = this.data.slice(this.index, nextIndex);
        break;
    }

    this.index = nextIndex;
    return this.push({
      data: data,
      meta: {
        percent: this.max ? this.index / this.max * 100 : 0
      }
    });
  }
};

module.exports = DataWorker;

/***/ }),

/***/ "./node_modules/jszip/lib/stream/GenericWorker.js":
/*!********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/GenericWorker.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */

function GenericWorker(name) {
  // the name of the worker
  this.name = name || "default"; // an object containing metadata about the workers chain

  this.streamInfo = {}; // an error which happened when the worker was paused

  this.generatedError = null; // an object containing metadata to be merged by this worker into the general metadata

  this.extraStreamInfo = {}; // true if the stream is paused (and should not do anything), false otherwise

  this.isPaused = true; // true if the stream is finished (and should not do anything), false otherwise

  this.isFinished = false; // true if the stream is locked to prevent further structure updates (pipe), false otherwise

  this.isLocked = false; // the event listeners

  this._listeners = {
    'data': [],
    'end': [],
    'error': []
  }; // the previous worker, if any

  this.previous = null;
}

GenericWorker.prototype = {
  /**
   * Push a chunk to the next workers.
   * @param {Object} chunk the chunk to push
   */
  push: function push(chunk) {
    this.emit("data", chunk);
  },

  /**
   * End the stream.
   * @return {Boolean} true if this call ended the worker, false otherwise.
   */
  end: function end() {
    if (this.isFinished) {
      return false;
    }

    this.flush();

    try {
      this.emit("end");
      this.cleanUp();
      this.isFinished = true;
    } catch (e) {
      this.emit("error", e);
    }

    return true;
  },

  /**
   * End the stream with an error.
   * @param {Error} e the error which caused the premature end.
   * @return {Boolean} true if this call ended the worker with an error, false otherwise.
   */
  error: function error(e) {
    if (this.isFinished) {
      return false;
    }

    if (this.isPaused) {
      this.generatedError = e;
    } else {
      this.isFinished = true;
      this.emit("error", e); // in the workers chain exploded in the middle of the chain,
      // the error event will go downward but we also need to notify
      // workers upward that there has been an error.

      if (this.previous) {
        this.previous.error(e);
      }

      this.cleanUp();
    }

    return true;
  },

  /**
   * Add a callback on an event.
   * @param {String} name the name of the event (data, end, error)
   * @param {Function} listener the function to call when the event is triggered
   * @return {GenericWorker} the current object for chainability
   */
  on: function on(name, listener) {
    this._listeners[name].push(listener);

    return this;
  },

  /**
   * Clean any references when a worker is ending.
   */
  cleanUp: function cleanUp() {
    this.streamInfo = this.generatedError = this.extraStreamInfo = null;
    this._listeners = [];
  },

  /**
   * Trigger an event. This will call registered callback with the provided arg.
   * @param {String} name the name of the event (data, end, error)
   * @param {Object} arg the argument to call the callback with.
   */
  emit: function emit(name, arg) {
    if (this._listeners[name]) {
      for (var i = 0; i < this._listeners[name].length; i++) {
        this._listeners[name][i].call(this, arg);
      }
    }
  },

  /**
   * Chain a worker with an other.
   * @param {Worker} next the worker receiving events from the current one.
   * @return {worker} the next worker for chainability
   */
  pipe: function pipe(next) {
    return next.registerPrevious(this);
  },

  /**
   * Same as `pipe` in the other direction.
   * Using an API with `pipe(next)` is very easy.
   * Implementing the API with the point of view of the next one registering
   * a source is easier, see the ZipFileWorker.
   * @param {Worker} previous the previous worker, sending events to this one
   * @return {Worker} the current worker for chainability
   */
  registerPrevious: function registerPrevious(previous) {
    if (this.isLocked) {
      throw new Error("The stream '" + this + "' has already been used.");
    } // sharing the streamInfo...


    this.streamInfo = previous.streamInfo; // ... and adding our own bits

    this.mergeStreamInfo();
    this.previous = previous;
    var self = this;
    previous.on('data', function (chunk) {
      self.processChunk(chunk);
    });
    previous.on('end', function () {
      self.end();
    });
    previous.on('error', function (e) {
      self.error(e);
    });
    return this;
  },

  /**
   * Pause the stream so it doesn't send events anymore.
   * @return {Boolean} true if this call paused the worker, false otherwise.
   */
  pause: function pause() {
    if (this.isPaused || this.isFinished) {
      return false;
    }

    this.isPaused = true;

    if (this.previous) {
      this.previous.pause();
    }

    return true;
  },

  /**
   * Resume a paused stream.
   * @return {Boolean} true if this call resumed the worker, false otherwise.
   */
  resume: function resume() {
    if (!this.isPaused || this.isFinished) {
      return false;
    }

    this.isPaused = false; // if true, the worker tried to resume but failed

    var withError = false;

    if (this.generatedError) {
      this.error(this.generatedError);
      withError = true;
    }

    if (this.previous) {
      this.previous.resume();
    }

    return !withError;
  },

  /**
   * Flush any remaining bytes as the stream is ending.
   */
  flush: function flush() {},

  /**
   * Process a chunk. This is usually the method overridden.
   * @param {Object} chunk the chunk to process.
   */
  processChunk: function processChunk(chunk) {
    this.push(chunk);
  },

  /**
   * Add a key/value to be added in the workers chain streamInfo once activated.
   * @param {String} key the key to use
   * @param {Object} value the associated value
   * @return {Worker} the current worker for chainability
   */
  withStreamInfo: function withStreamInfo(key, value) {
    this.extraStreamInfo[key] = value;
    this.mergeStreamInfo();
    return this;
  },

  /**
   * Merge this worker's streamInfo into the chain's streamInfo.
   */
  mergeStreamInfo: function mergeStreamInfo() {
    for (var key in this.extraStreamInfo) {
      if (!this.extraStreamInfo.hasOwnProperty(key)) {
        continue;
      }

      this.streamInfo[key] = this.extraStreamInfo[key];
    }
  },

  /**
   * Lock the stream to prevent further updates on the workers chain.
   * After calling this method, all calls to pipe will fail.
   */
  lock: function lock() {
    if (this.isLocked) {
      throw new Error("The stream '" + this + "' has already been used.");
    }

    this.isLocked = true;

    if (this.previous) {
      this.previous.lock();
    }
  },

  /**
   *
   * Pretty print the workers chain.
   */
  toString: function toString() {
    var me = "Worker " + this.name;

    if (this.previous) {
      return this.previous + " -> " + me;
    } else {
      return me;
    }
  }
};
module.exports = GenericWorker;

/***/ }),

/***/ "./node_modules/jszip/lib/stream/StreamHelper.js":
/*!*******************************************************!*\
  !*** ./node_modules/jszip/lib/stream/StreamHelper.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var utils = __webpack_require__(/*! ../utils */ "./node_modules/jszip/lib/utils.js");

var ConvertWorker = __webpack_require__(/*! ./ConvertWorker */ "./node_modules/jszip/lib/stream/ConvertWorker.js");

var GenericWorker = __webpack_require__(/*! ./GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");

var base64 = __webpack_require__(/*! ../base64 */ "./node_modules/jszip/lib/base64.js");

var support = __webpack_require__(/*! ../support */ "./node_modules/jszip/lib/support.js");

var external = __webpack_require__(/*! ../external */ "./node_modules/jszip/lib/external.js");

var NodejsStreamOutputAdapter = null;

if (support.nodestream) {
  try {
    NodejsStreamOutputAdapter = __webpack_require__(/*! ../nodejs/NodejsStreamOutputAdapter */ "./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js");
  } catch (e) {}
}
/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */


function transformZipOutput(type, content, mimeType) {
  switch (type) {
    case "blob":
      return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);

    case "base64":
      return base64.encode(content);

    default:
      return utils.transformTo(type, content);
  }
}
/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */


function concat(type, dataArray) {
  var i,
      index = 0,
      res = null,
      totalLength = 0;

  for (i = 0; i < dataArray.length; i++) {
    totalLength += dataArray[i].length;
  }

  switch (type) {
    case "string":
      return dataArray.join("");

    case "array":
      return Array.prototype.concat.apply([], dataArray);

    case "uint8array":
      res = new Uint8Array(totalLength);

      for (i = 0; i < dataArray.length; i++) {
        res.set(dataArray[i], index);
        index += dataArray[i].length;
      }

      return res;

    case "nodebuffer":
      return Buffer.concat(dataArray);

    default:
      throw new Error("concat : unsupported type '" + type + "'");
  }
}
/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */


function _accumulate(helper, updateCallback) {
  return new external.Promise(function (resolve, reject) {
    var dataArray = [];
    var chunkType = helper._internalType,
        resultType = helper._outputType,
        mimeType = helper._mimeType;
    helper.on('data', function (data, meta) {
      dataArray.push(data);

      if (updateCallback) {
        updateCallback(meta);
      }
    }).on('error', function (err) {
      dataArray = [];
      reject(err);
    }).on('end', function () {
      try {
        var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
        resolve(result);
      } catch (e) {
        reject(e);
      }

      dataArray = [];
    }).resume();
  });
}
/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */


function StreamHelper(worker, outputType, mimeType) {
  var internalType = outputType;

  switch (outputType) {
    case "blob":
    case "arraybuffer":
      internalType = "uint8array";
      break;

    case "base64":
      internalType = "string";
      break;
  }

  try {
    // the type used internally
    this._internalType = internalType; // the type used to output results

    this._outputType = outputType; // the mime type

    this._mimeType = mimeType;
    utils.checkSupport(internalType);
    this._worker = worker.pipe(new ConvertWorker(internalType)); // the last workers can be rewired without issues but we need to
    // prevent any updates on previous workers.

    worker.lock();
  } catch (e) {
    this._worker = new GenericWorker("error");

    this._worker.error(e);
  }
}

StreamHelper.prototype = {
  /**
   * Listen a StreamHelper, accumulate its content and concatenate it into a
   * complete block.
   * @param {Function} updateCb the update callback.
   * @return Promise the promise for the accumulation.
   */
  accumulate: function accumulate(updateCb) {
    return _accumulate(this, updateCb);
  },

  /**
   * Add a listener on an event triggered on a stream.
   * @param {String} evt the name of the event
   * @param {Function} fn the listener
   * @return {StreamHelper} the current helper.
   */
  on: function on(evt, fn) {
    var self = this;

    if (evt === "data") {
      this._worker.on(evt, function (chunk) {
        fn.call(self, chunk.data, chunk.meta);
      });
    } else {
      this._worker.on(evt, function () {
        utils.delay(fn, arguments, self);
      });
    }

    return this;
  },

  /**
   * Resume the flow of chunks.
   * @return {StreamHelper} the current helper.
   */
  resume: function resume() {
    utils.delay(this._worker.resume, [], this._worker);
    return this;
  },

  /**
   * Pause the flow of chunks.
   * @return {StreamHelper} the current helper.
   */
  pause: function pause() {
    this._worker.pause();

    return this;
  },

  /**
   * Return a nodejs stream for this helper.
   * @param {Function} updateCb the update callback.
   * @return {NodejsStreamOutputAdapter} the nodejs stream.
   */
  toNodejsStream: function toNodejsStream(updateCb) {
    utils.checkSupport("nodestream");

    if (this._outputType !== "nodebuffer") {
      // an object stream containing blob/arraybuffer/uint8array/string
      // is strange and I don't know if it would be useful.
      // I you find this comment and have a good usecase, please open a
      // bug report !
      throw new Error(this._outputType + " is not supported by this method");
    }

    return new NodejsStreamOutputAdapter(this, {
      objectMode: this._outputType !== "nodebuffer"
    }, updateCb);
  }
};
module.exports = StreamHelper;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/jszip/lib/support.js":
/*!*******************************************!*\
  !*** ./node_modules/jszip/lib/support.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined"; // contains true if JSZip can read/generate Uint8Array, false otherwise.

exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
  exports.blob = false;
} else {
  var buffer = new ArrayBuffer(0);

  try {
    exports.blob = new Blob([buffer], {
      type: "application/zip"
    }).size === 0;
  } catch (e) {
    try {
      var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
      var builder = new Builder();
      builder.append(buffer);
      exports.blob = builder.getBlob('application/zip').size === 0;
    } catch (e) {
      exports.blob = false;
    }
  }
}

try {
  exports.nodestream = !!__webpack_require__(/*! readable-stream */ "./node_modules/jszip/lib/readable-stream-browser.js").Readable;
} catch (e) {
  exports.nodestream = false;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/jszip/lib/utf8.js":
/*!****************************************!*\
  !*** ./node_modules/jszip/lib/utf8.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js");

var nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ "./node_modules/jszip/lib/nodejsUtils.js");

var GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");
/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */
// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff


var _utf8len = new Array(256);

for (var i = 0; i < 256; i++) {
  _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
}

_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
// convert string to array (typed, when possible)

var string2buf = function string2buf(str) {
  var buf,
      c,
      c2,
      m_pos,
      i,
      str_len = str.length,
      buf_len = 0; // count binary size

  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);

    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);

      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }

    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  } // allocate buffer


  if (support.uint8array) {
    buf = new Uint8Array(buf_len);
  } else {
    buf = new Array(buf_len);
  } // convert


  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);

    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);

      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }

    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }

  return buf;
}; // Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);


var utf8border = function utf8border(buf, max) {
  var pos;
  max = max || buf.length;

  if (max > buf.length) {
    max = buf.length;
  } // go back from last position, until start of sequence found


  pos = max - 1;

  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  } // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.


  if (pos < 0) {
    return max;
  } // If we came to start of buffer - that means vuffer is too small,
  // return max too.


  if (pos === 0) {
    return max;
  }

  return pos + _utf8len[buf[pos]] > max ? pos : max;
}; // convert array to string


var buf2string = function buf2string(buf) {
  var str, i, out, c, c_len;
  var len = buf.length; // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.

  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++]; // quick process ascii

    if (c < 0x80) {
      utf16buf[out++] = c;
      continue;
    }

    c_len = _utf8len[c]; // skip 5 & 6 byte codes

    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;
      i += c_len - 1;
      continue;
    } // apply mask on first byte


    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest

    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    } // terminated by end of string?


    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;
      continue;
    }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  } // shrinkBuf(utf16buf, out)


  if (utf16buf.length !== out) {
    if (utf16buf.subarray) {
      utf16buf = utf16buf.subarray(0, out);
    } else {
      utf16buf.length = out;
    }
  } // return String.fromCharCode.apply(null, utf16buf);


  return utils.applyFromCharCode(utf16buf);
}; // That's all for the pako functions.

/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */


exports.utf8encode = function utf8encode(str) {
  if (support.nodebuffer) {
    return nodejsUtils.newBufferFrom(str, "utf-8");
  }

  return string2buf(str);
};
/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */


exports.utf8decode = function utf8decode(buf) {
  if (support.nodebuffer) {
    return utils.transformTo("nodebuffer", buf).toString("utf-8");
  }

  buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
  return buf2string(buf);
};
/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */


function Utf8DecodeWorker() {
  GenericWorker.call(this, "utf-8 decode"); // the last bytes if a chunk didn't end with a complete codepoint.

  this.leftOver = null;
}

utils.inherits(Utf8DecodeWorker, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

Utf8DecodeWorker.prototype.processChunk = function (chunk) {
  var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data); // 1st step, re-use what's left of the previous chunk

  if (this.leftOver && this.leftOver.length) {
    if (support.uint8array) {
      var previousData = data;
      data = new Uint8Array(previousData.length + this.leftOver.length);
      data.set(this.leftOver, 0);
      data.set(previousData, this.leftOver.length);
    } else {
      data = this.leftOver.concat(data);
    }

    this.leftOver = null;
  }

  var nextBoundary = utf8border(data);
  var usableData = data;

  if (nextBoundary !== data.length) {
    if (support.uint8array) {
      usableData = data.subarray(0, nextBoundary);
      this.leftOver = data.subarray(nextBoundary, data.length);
    } else {
      usableData = data.slice(0, nextBoundary);
      this.leftOver = data.slice(nextBoundary, data.length);
    }
  }

  this.push({
    data: exports.utf8decode(usableData),
    meta: chunk.meta
  });
};
/**
 * @see GenericWorker.flush
 */


Utf8DecodeWorker.prototype.flush = function () {
  if (this.leftOver && this.leftOver.length) {
    this.push({
      data: exports.utf8decode(this.leftOver),
      meta: {}
    });
    this.leftOver = null;
  }
};

exports.Utf8DecodeWorker = Utf8DecodeWorker;
/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */

function Utf8EncodeWorker() {
  GenericWorker.call(this, "utf-8 encode");
}

utils.inherits(Utf8EncodeWorker, GenericWorker);
/**
 * @see GenericWorker.processChunk
 */

Utf8EncodeWorker.prototype.processChunk = function (chunk) {
  this.push({
    data: exports.utf8encode(chunk.data),
    meta: chunk.meta
  });
};

exports.Utf8EncodeWorker = Utf8EncodeWorker;

/***/ }),

/***/ "./node_modules/jszip/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js");

var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/jszip/lib/base64.js");

var nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ "./node_modules/jszip/lib/nodejsUtils.js");

var setImmediate = __webpack_require__(/*! core-js/library/fn/set-immediate */ "./node_modules/jszip/node_modules/core-js/library/fn/set-immediate.js");

var external = __webpack_require__(/*! ./external */ "./node_modules/jszip/lib/external.js");
/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */


function string2binary(str) {
  var result = null;

  if (support.uint8array) {
    result = new Uint8Array(str.length);
  } else {
    result = new Array(str.length);
  }

  return stringToArrayLike(str, result);
}
/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */


exports.newBlob = function (part, type) {
  exports.checkSupport("blob");

  try {
    // Blob constructor
    return new Blob([part], {
      type: type
    });
  } catch (e) {
    try {
      // deprecated, browser only, old way
      var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
      var builder = new Builder();
      builder.append(part);
      return builder.getBlob(type);
    } catch (e) {
      // well, fuck ?!
      throw new Error("Bug : can't construct the Blob.");
    }
  }
};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */


function identity(input) {
  return input;
}
/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */


function stringToArrayLike(str, array) {
  for (var i = 0; i < str.length; ++i) {
    array[i] = str.charCodeAt(i) & 0xFF;
  }

  return array;
}
/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */


var arrayToStringHelper = {
  /**
   * Transform an array of int into a string, chunk by chunk.
   * See the performances notes on arrayLikeToString.
   * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
   * @param {String} type the type of the array.
   * @param {Integer} chunk the chunk size.
   * @return {String} the resulting string.
   * @throws Error if the chunk is too big for the stack.
   */
  stringifyByChunk: function stringifyByChunk(array, type, chunk) {
    var result = [],
        k = 0,
        len = array.length; // shortcut

    if (len <= chunk) {
      return String.fromCharCode.apply(null, array);
    }

    while (k < len) {
      if (type === "array" || type === "nodebuffer") {
        result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
      } else {
        result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
      }

      k += chunk;
    }

    return result.join("");
  },

  /**
   * Call String.fromCharCode on every item in the array.
   * This is the naive implementation, which generate A LOT of intermediate string.
   * This should be used when everything else fail.
   * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
   * @return {String} the result.
   */
  stringifyByChar: function stringifyByChar(array) {
    var resultStr = "";

    for (var i = 0; i < array.length; i++) {
      resultStr += String.fromCharCode(array[i]);
    }

    return resultStr;
  },
  applyCanBeUsed: {
    /**
     * true if the browser accepts to use String.fromCharCode on Uint8Array
     */
    uint8array: function () {
      try {
        return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
      } catch (e) {
        return false;
      }
    }(),

    /**
     * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
     */
    nodebuffer: function () {
      try {
        return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
      } catch (e) {
        return false;
      }
    }()
  }
};
/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */

function arrayLikeToString(array) {
  // Performances notes :
  // --------------------
  // String.fromCharCode.apply(null, array) is the fastest, see
  // see http://jsperf.com/converting-a-uint8array-to-a-string/2
  // but the stack is limited (and we can get huge arrays !).
  //
  // result += String.fromCharCode(array[i]); generate too many strings !
  //
  // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
  // TODO : we now have workers that split the work. Do we still need that ?
  var chunk = 65536,
      type = exports.getTypeOf(array),
      canUseApply = true;

  if (type === "uint8array") {
    canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
  } else if (type === "nodebuffer") {
    canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
  }

  if (canUseApply) {
    while (chunk > 1) {
      try {
        return arrayToStringHelper.stringifyByChunk(array, type, chunk);
      } catch (e) {
        chunk = Math.floor(chunk / 2);
      }
    }
  } // no apply or chunk error : slow and painful algorithm
  // default browser on android 4.*


  return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;
/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */

function arrayLikeToArrayLike(arrayFrom, arrayTo) {
  for (var i = 0; i < arrayFrom.length; i++) {
    arrayTo[i] = arrayFrom[i];
  }

  return arrayTo;
} // a matrix containing functions to transform everything into everything.


var transform = {}; // string to ?

transform["string"] = {
  "string": identity,
  "array": function array(input) {
    return stringToArrayLike(input, new Array(input.length));
  },
  "arraybuffer": function arraybuffer(input) {
    return transform["string"]["uint8array"](input).buffer;
  },
  "uint8array": function uint8array(input) {
    return stringToArrayLike(input, new Uint8Array(input.length));
  },
  "nodebuffer": function nodebuffer(input) {
    return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
  }
}; // array to ?

transform["array"] = {
  "string": arrayLikeToString,
  "array": identity,
  "arraybuffer": function arraybuffer(input) {
    return new Uint8Array(input).buffer;
  },
  "uint8array": function uint8array(input) {
    return new Uint8Array(input);
  },
  "nodebuffer": function nodebuffer(input) {
    return nodejsUtils.newBufferFrom(input);
  }
}; // arraybuffer to ?

transform["arraybuffer"] = {
  "string": function string(input) {
    return arrayLikeToString(new Uint8Array(input));
  },
  "array": function array(input) {
    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
  },
  "arraybuffer": identity,
  "uint8array": function uint8array(input) {
    return new Uint8Array(input);
  },
  "nodebuffer": function nodebuffer(input) {
    return nodejsUtils.newBufferFrom(new Uint8Array(input));
  }
}; // uint8array to ?

transform["uint8array"] = {
  "string": arrayLikeToString,
  "array": function array(input) {
    return arrayLikeToArrayLike(input, new Array(input.length));
  },
  "arraybuffer": function arraybuffer(input) {
    return input.buffer;
  },
  "uint8array": identity,
  "nodebuffer": function nodebuffer(input) {
    return nodejsUtils.newBufferFrom(input);
  }
}; // nodebuffer to ?

transform["nodebuffer"] = {
  "string": arrayLikeToString,
  "array": function array(input) {
    return arrayLikeToArrayLike(input, new Array(input.length));
  },
  "arraybuffer": function arraybuffer(input) {
    return transform["nodebuffer"]["uint8array"](input).buffer;
  },
  "uint8array": function uint8array(input) {
    return arrayLikeToArrayLike(input, new Uint8Array(input.length));
  },
  "nodebuffer": identity
};
/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */

exports.transformTo = function (outputType, input) {
  if (!input) {
    // undefined, null, etc
    // an empty string won't harm.
    input = "";
  }

  if (!outputType) {
    return input;
  }

  exports.checkSupport(outputType);
  var inputType = exports.getTypeOf(input);
  var result = transform[inputType][outputType](input);
  return result;
};
/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */


exports.getTypeOf = function (input) {
  if (typeof input === "string") {
    return "string";
  }

  if (Object.prototype.toString.call(input) === "[object Array]") {
    return "array";
  }

  if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
    return "nodebuffer";
  }

  if (support.uint8array && input instanceof Uint8Array) {
    return "uint8array";
  }

  if (support.arraybuffer && input instanceof ArrayBuffer) {
    return "arraybuffer";
  }
};
/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */


exports.checkSupport = function (type) {
  var supported = support[type.toLowerCase()];

  if (!supported) {
    throw new Error(type + " is not supported by this platform");
  }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */

exports.pretty = function (str) {
  var res = '',
      code,
      i;

  for (i = 0; i < (str || "").length; i++) {
    code = str.charCodeAt(i);
    res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
  }

  return res;
};
/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */


exports.delay = function (callback, args, self) {
  setImmediate(function () {
    callback.apply(self || null, args || []);
  });
};
/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */


exports.inherits = function (ctor, superCtor) {
  var Obj = function Obj() {};

  Obj.prototype = superCtor.prototype;
  ctor.prototype = new Obj();
};
/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */


exports.extend = function () {
  var result = {},
      i,
      attr;

  for (i = 0; i < arguments.length; i++) {
    // arguments is not enumerable in some browsers
    for (attr in arguments[i]) {
      if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
        result[attr] = arguments[i][attr];
      }
    }
  }

  return result;
};
/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */


exports.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
  // if inputData is already a promise, this flatten it.
  var promise = external.Promise.resolve(inputData).then(function (data) {
    var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

    if (isBlob && typeof FileReader !== "undefined") {
      return new external.Promise(function (resolve, reject) {
        var reader = new FileReader();

        reader.onload = function (e) {
          resolve(e.target.result);
        };

        reader.onerror = function (e) {
          reject(e.target.error);
        };

        reader.readAsArrayBuffer(data);
      });
    } else {
      return data;
    }
  });
  return promise.then(function (data) {
    var dataType = exports.getTypeOf(data);

    if (!dataType) {
      return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
    } // special case : it's way easier to work with Uint8Array than with ArrayBuffer


    if (dataType === "arraybuffer") {
      data = exports.transformTo("uint8array", data);
    } else if (dataType === "string") {
      if (isBase64) {
        data = base64.decode(data);
      } else if (isBinary) {
        // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
        if (isOptimizedBinaryString !== true) {
          // this is a string, not in a base64 format.
          // Be sure that this is a correct "binary string"
          data = string2binary(data);
        }
      }
    }

    return data;
  });
};

/***/ }),

/***/ "./node_modules/jszip/lib/zipEntries.js":
/*!**********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntries.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var readerFor = __webpack_require__(/*! ./reader/readerFor */ "./node_modules/jszip/lib/reader/readerFor.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var sig = __webpack_require__(/*! ./signature */ "./node_modules/jszip/lib/signature.js");

var ZipEntry = __webpack_require__(/*! ./zipEntry */ "./node_modules/jszip/lib/zipEntry.js");

var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/jszip/lib/utf8.js");

var support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js"); //  class ZipEntries {{{

/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */


function ZipEntries(loadOptions) {
  this.files = [];
  this.loadOptions = loadOptions;
}

ZipEntries.prototype = {
  /**
   * Check that the reader is on the specified signature.
   * @param {string} expectedSignature the expected signature.
   * @throws {Error} if it is an other signature.
   */
  checkSignature: function checkSignature(expectedSignature) {
    if (!this.reader.readAndCheckSignature(expectedSignature)) {
      this.reader.index -= 4;
      var signature = this.reader.readString(4);
      throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
    }
  },

  /**
   * Check if the given signature is at the given index.
   * @param {number} askedIndex the index to check.
   * @param {string} expectedSignature the signature to expect.
   * @return {boolean} true if the signature is here, false otherwise.
   */
  isSignature: function isSignature(askedIndex, expectedSignature) {
    var currentIndex = this.reader.index;
    this.reader.setIndex(askedIndex);
    var signature = this.reader.readString(4);
    var result = signature === expectedSignature;
    this.reader.setIndex(currentIndex);
    return result;
  },

  /**
   * Read the end of the central directory.
   */
  readBlockEndOfCentral: function readBlockEndOfCentral() {
    this.diskNumber = this.reader.readInt(2);
    this.diskWithCentralDirStart = this.reader.readInt(2);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
    this.centralDirRecords = this.reader.readInt(2);
    this.centralDirSize = this.reader.readInt(4);
    this.centralDirOffset = this.reader.readInt(4);
    this.zipCommentLength = this.reader.readInt(2); // warning : the encoding depends of the system locale
    // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
    // On a windows machine, this field is encoded with the localized windows code page.

    var zipComment = this.reader.readData(this.zipCommentLength);
    var decodeParamType = support.uint8array ? "uint8array" : "array"; // To get consistent behavior with the generation part, we will assume that
    // this is utf8 encoded unless specified otherwise.

    var decodeContent = utils.transformTo(decodeParamType, zipComment);
    this.zipComment = this.loadOptions.decodeFileName(decodeContent);
  },

  /**
   * Read the end of the Zip 64 central directory.
   * Not merged with the method readEndOfCentral :
   * The end of central can coexist with its Zip64 brother,
   * I don't want to read the wrong number of bytes !
   */
  readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
    this.zip64EndOfCentralSize = this.reader.readInt(8);
    this.reader.skip(4); // this.versionMadeBy = this.reader.readString(2);
    // this.versionNeeded = this.reader.readInt(2);

    this.diskNumber = this.reader.readInt(4);
    this.diskWithCentralDirStart = this.reader.readInt(4);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
    this.centralDirRecords = this.reader.readInt(8);
    this.centralDirSize = this.reader.readInt(8);
    this.centralDirOffset = this.reader.readInt(8);
    this.zip64ExtensibleData = {};
    var extraDataSize = this.zip64EndOfCentralSize - 44,
        index = 0,
        extraFieldId,
        extraFieldLength,
        extraFieldValue;

    while (index < extraDataSize) {
      extraFieldId = this.reader.readInt(2);
      extraFieldLength = this.reader.readInt(4);
      extraFieldValue = this.reader.readData(extraFieldLength);
      this.zip64ExtensibleData[extraFieldId] = {
        id: extraFieldId,
        length: extraFieldLength,
        value: extraFieldValue
      };
    }
  },

  /**
   * Read the end of the Zip 64 central directory locator.
   */
  readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
    this.diskWithZip64CentralDirStart = this.reader.readInt(4);
    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
    this.disksCount = this.reader.readInt(4);

    if (this.disksCount > 1) {
      throw new Error("Multi-volumes zip are not supported");
    }
  },

  /**
   * Read the local files, based on the offset read in the central part.
   */
  readLocalFiles: function readLocalFiles() {
    var i, file;

    for (i = 0; i < this.files.length; i++) {
      file = this.files[i];
      this.reader.setIndex(file.localHeaderOffset);
      this.checkSignature(sig.LOCAL_FILE_HEADER);
      file.readLocalPart(this.reader);
      file.handleUTF8();
      file.processAttributes();
    }
  },

  /**
   * Read the central directory.
   */
  readCentralDir: function readCentralDir() {
    var file;
    this.reader.setIndex(this.centralDirOffset);

    while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
      file = new ZipEntry({
        zip64: this.zip64
      }, this.loadOptions);
      file.readCentralPart(this.reader);
      this.files.push(file);
    }

    if (this.centralDirRecords !== this.files.length) {
      if (this.centralDirRecords !== 0 && this.files.length === 0) {
        // We expected some records but couldn't find ANY.
        // This is really suspicious, as if something went wrong.
        throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      } else {// We found some records but not all.
        // Something is wrong but we got something for the user: no error here.
        // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
      }
    }
  },

  /**
   * Read the end of central directory.
   */
  readEndOfCentral: function readEndOfCentral() {
    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);

    if (offset < 0) {
      // Check if the content is a truncated zip or complete garbage.
      // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
      // extractible zip for example) but it can give a good hint.
      // If an ajax request was used without responseType, we will also
      // get unreadable data.
      var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

      if (isGarbage) {
        throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
      } else {
        throw new Error("Corrupted zip: can't find end of central directory");
      }
    }

    this.reader.setIndex(offset);
    var endOfCentralDirOffset = offset;
    this.checkSignature(sig.CENTRAL_DIRECTORY_END);
    this.readBlockEndOfCentral();
    /* extract from the zip spec :
        4)  If one of the fields in the end of central directory
            record is too small to hold required data, the field
            should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
            ZIP64 format record should be created.
        5)  The end of central directory record and the
            Zip64 end of central directory locator record must
            reside on the same disk when splitting or spanning
            an archive.
     */

    if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
      this.zip64 = true;
      /*
      Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
      the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
      all numbers as 64-bit double precision IEEE 754 floating point numbers.
      So, we have 53bits for integers and bitwise operations treat everything as 32bits.
      see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
      and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
      */
      // should look for a zip64 EOCD locator

      offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);

      if (offset < 0) {
        throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
      }

      this.reader.setIndex(offset);
      this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
      this.readBlockZip64EndOfCentralLocator(); // now the zip64 EOCD record

      if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
        // console.warn("ZIP64 end of central directory not where expected.");
        this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);

        if (this.relativeOffsetEndOfZip64CentralDir < 0) {
          throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
        }
      }

      this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
      this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
      this.readBlockZip64EndOfCentral();
    }

    var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;

    if (this.zip64) {
      expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator

      expectedEndOfCentralDirOffset += 12
      /* should not include the leading 12 bytes */
      + this.zip64EndOfCentralSize;
    }

    var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

    if (extraBytes > 0) {
      // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
      if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {// The offsets seem wrong, but we have something at the specified offset.
        // So… we keep it.
      } else {
        // the offset is wrong, update the "zero" of the reader
        // this happens if data has been prepended (crx files for example)
        this.reader.zero = extraBytes;
      }
    } else if (extraBytes < 0) {
      throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
    }
  },
  prepareReader: function prepareReader(data) {
    this.reader = readerFor(data);
  },

  /**
   * Read a zip file and create ZipEntries.
   * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
   */
  load: function load(data) {
    this.prepareReader(data);
    this.readEndOfCentral();
    this.readCentralDir();
    this.readLocalFiles();
  }
}; // }}} end of ZipEntries

module.exports = ZipEntries;

/***/ }),

/***/ "./node_modules/jszip/lib/zipEntry.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var readerFor = __webpack_require__(/*! ./reader/readerFor */ "./node_modules/jszip/lib/reader/readerFor.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jszip/lib/utils.js");

var CompressedObject = __webpack_require__(/*! ./compressedObject */ "./node_modules/jszip/lib/compressedObject.js");

var crc32fn = __webpack_require__(/*! ./crc32 */ "./node_modules/jszip/lib/crc32.js");

var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/jszip/lib/utf8.js");

var compressions = __webpack_require__(/*! ./compressions */ "./node_modules/jszip/lib/compressions.js");

var support = __webpack_require__(/*! ./support */ "./node_modules/jszip/lib/support.js");

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;
/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */

var findCompression = function findCompression(compressionMethod) {
  for (var method in compressions) {
    if (!compressions.hasOwnProperty(method)) {
      continue;
    }

    if (compressions[method].magic === compressionMethod) {
      return compressions[method];
    }
  }

  return null;
}; // class ZipEntry {{{

/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */


function ZipEntry(options, loadOptions) {
  this.options = options;
  this.loadOptions = loadOptions;
}

ZipEntry.prototype = {
  /**
   * say if the file is encrypted.
   * @return {boolean} true if the file is encrypted, false otherwise.
   */
  isEncrypted: function isEncrypted() {
    // bit 1 is set
    return (this.bitFlag & 0x0001) === 0x0001;
  },

  /**
   * say if the file has utf-8 filename/comment.
   * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
   */
  useUTF8: function useUTF8() {
    // bit 11 is set
    return (this.bitFlag & 0x0800) === 0x0800;
  },

  /**
   * Read the local part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readLocalPart: function readLocalPart(reader) {
    var compression, localExtraFieldsLength; // we already know everything from the central dir !
    // If the central dir data are false, we are doomed.
    // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
    // The less data we get here, the more reliable this should be.
    // Let's skip the whole header and dash to the data !

    reader.skip(22); // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
    // Strangely, the filename here is OK.
    // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
    // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
    // Search "unzip mismatching "local" filename continuing with "central" filename version" on
    // the internet.
    //
    // I think I see the logic here : the central directory is used to display
    // content and the local directory is used to extract the files. Mixing / and \
    // may be used to display \ to windows users and use / when extracting the files.
    // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394

    this.fileNameLength = reader.readInt(2);
    localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
    // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.

    this.fileName = reader.readData(this.fileNameLength);
    reader.skip(localExtraFieldsLength);

    if (this.compressedSize === -1 || this.uncompressedSize === -1) {
      throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
    }

    compression = findCompression(this.compressionMethod);

    if (compression === null) {
      // no compression found
      throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
    }

    this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
  },

  /**
   * Read the central part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readCentralPart: function readCentralPart(reader) {
    this.versionMadeBy = reader.readInt(2);
    reader.skip(2); // this.versionNeeded = reader.readInt(2);

    this.bitFlag = reader.readInt(2);
    this.compressionMethod = reader.readString(2);
    this.date = reader.readDate();
    this.crc32 = reader.readInt(4);
    this.compressedSize = reader.readInt(4);
    this.uncompressedSize = reader.readInt(4);
    var fileNameLength = reader.readInt(2);
    this.extraFieldsLength = reader.readInt(2);
    this.fileCommentLength = reader.readInt(2);
    this.diskNumberStart = reader.readInt(2);
    this.internalFileAttributes = reader.readInt(2);
    this.externalFileAttributes = reader.readInt(4);
    this.localHeaderOffset = reader.readInt(4);

    if (this.isEncrypted()) {
      throw new Error("Encrypted zip are not supported");
    } // will be read in the local part, see the comments there


    reader.skip(fileNameLength);
    this.readExtraFields(reader);
    this.parseZIP64ExtraField(reader);
    this.fileComment = reader.readData(this.fileCommentLength);
  },

  /**
   * Parse the external file attributes and get the unix/dos permissions.
   */
  processAttributes: function processAttributes() {
    this.unixPermissions = null;
    this.dosPermissions = null;
    var madeBy = this.versionMadeBy >> 8; // Check if we have the DOS directory flag set.
    // We look for it in the DOS and UNIX permissions
    // but some unknown platform could set it as a compatibility flag.

    this.dir = this.externalFileAttributes & 0x0010 ? true : false;

    if (madeBy === MADE_BY_DOS) {
      // first 6 bits (0 to 5)
      this.dosPermissions = this.externalFileAttributes & 0x3F;
    }

    if (madeBy === MADE_BY_UNIX) {
      this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF; // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
    } // fail safe : if the name ends with a / it probably means a folder


    if (!this.dir && this.fileNameStr.slice(-1) === '/') {
      this.dir = true;
    }
  },

  /**
   * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
   * @param {DataReader} reader the reader to use.
   */
  parseZIP64ExtraField: function parseZIP64ExtraField(reader) {
    if (!this.extraFields[0x0001]) {
      return;
    } // should be something, preparing the extra reader


    var extraReader = readerFor(this.extraFields[0x0001].value); // I really hope that these 64bits integer can fit in 32 bits integer, because js
    // won't let us have more.

    if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
      this.uncompressedSize = extraReader.readInt(8);
    }

    if (this.compressedSize === utils.MAX_VALUE_32BITS) {
      this.compressedSize = extraReader.readInt(8);
    }

    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
      this.localHeaderOffset = extraReader.readInt(8);
    }

    if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
      this.diskNumberStart = extraReader.readInt(4);
    }
  },

  /**
   * Read the central part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readExtraFields: function readExtraFields(reader) {
    var end = reader.index + this.extraFieldsLength,
        extraFieldId,
        extraFieldLength,
        extraFieldValue;

    if (!this.extraFields) {
      this.extraFields = {};
    }

    while (reader.index < end) {
      extraFieldId = reader.readInt(2);
      extraFieldLength = reader.readInt(2);
      extraFieldValue = reader.readData(extraFieldLength);
      this.extraFields[extraFieldId] = {
        id: extraFieldId,
        length: extraFieldLength,
        value: extraFieldValue
      };
    }
  },

  /**
   * Apply an UTF8 transformation if needed.
   */
  handleUTF8: function handleUTF8() {
    var decodeParamType = support.uint8array ? "uint8array" : "array";

    if (this.useUTF8()) {
      this.fileNameStr = utf8.utf8decode(this.fileName);
      this.fileCommentStr = utf8.utf8decode(this.fileComment);
    } else {
      var upath = this.findExtraFieldUnicodePath();

      if (upath !== null) {
        this.fileNameStr = upath;
      } else {
        // ASCII text or unsupported code page
        var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
        this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
      }

      var ucomment = this.findExtraFieldUnicodeComment();

      if (ucomment !== null) {
        this.fileCommentStr = ucomment;
      } else {
        // ASCII text or unsupported code page
        var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
        this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
      }
    }
  },

  /**
   * Find the unicode path declared in the extra field, if any.
   * @return {String} the unicode path, null otherwise.
   */
  findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
    var upathField = this.extraFields[0x7075];

    if (upathField) {
      var extraReader = readerFor(upathField.value); // wrong version

      if (extraReader.readInt(1) !== 1) {
        return null;
      } // the crc of the filename changed, this field is out of date.


      if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
        return null;
      }

      return utf8.utf8decode(extraReader.readData(upathField.length - 5));
    }

    return null;
  },

  /**
   * Find the unicode comment declared in the extra field, if any.
   * @return {String} the unicode comment, null otherwise.
   */
  findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
    var ucommentField = this.extraFields[0x6375];

    if (ucommentField) {
      var extraReader = readerFor(ucommentField.value); // wrong version

      if (extraReader.readInt(1) !== 1) {
        return null;
      } // the crc of the comment changed, this field is out of date.


      if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
        return null;
      }

      return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
    }

    return null;
  }
};
module.exports = ZipEntry;

/***/ }),

/***/ "./node_modules/jszip/lib/zipObject.js":
/*!*********************************************!*\
  !*** ./node_modules/jszip/lib/zipObject.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ "./node_modules/jszip/lib/stream/StreamHelper.js");

var DataWorker = __webpack_require__(/*! ./stream/DataWorker */ "./node_modules/jszip/lib/stream/DataWorker.js");

var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/jszip/lib/utf8.js");

var CompressedObject = __webpack_require__(/*! ./compressedObject */ "./node_modules/jszip/lib/compressedObject.js");

var GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ "./node_modules/jszip/lib/stream/GenericWorker.js");
/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */


var ZipObject = function ZipObject(name, data, options) {
  this.name = name;
  this.dir = options.dir;
  this.date = options.date;
  this.comment = options.comment;
  this.unixPermissions = options.unixPermissions;
  this.dosPermissions = options.dosPermissions;
  this._data = data;
  this._dataBinary = options.binary; // keep only the compression

  this.options = {
    compression: options.compression,
    compressionOptions: options.compressionOptions
  };
};

ZipObject.prototype = {
  /**
   * Create an internal stream for the content of this object.
   * @param {String} type the type of each chunk.
   * @return StreamHelper the stream.
   */
  internalStream: function internalStream(type) {
    var result = null,
        outputType = "string";

    try {
      if (!type) {
        throw new Error("No output type specified.");
      }

      outputType = type.toLowerCase();
      var askUnicodeString = outputType === "string" || outputType === "text";

      if (outputType === "binarystring" || outputType === "text") {
        outputType = "string";
      }

      result = this._decompressWorker();
      var isUnicodeString = !this._dataBinary;

      if (isUnicodeString && !askUnicodeString) {
        result = result.pipe(new utf8.Utf8EncodeWorker());
      }

      if (!isUnicodeString && askUnicodeString) {
        result = result.pipe(new utf8.Utf8DecodeWorker());
      }
    } catch (e) {
      result = new GenericWorker("error");
      result.error(e);
    }

    return new StreamHelper(result, outputType, "");
  },

  /**
   * Prepare the content in the asked type.
   * @param {String} type the type of the result.
   * @param {Function} onUpdate a function to call on each internal update.
   * @return Promise the promise of the result.
   */
  async: function async(type, onUpdate) {
    return this.internalStream(type).accumulate(onUpdate);
  },

  /**
   * Prepare the content as a nodejs stream.
   * @param {String} type the type of each chunk.
   * @param {Function} onUpdate a function to call on each internal update.
   * @return Stream the stream.
   */
  nodeStream: function nodeStream(type, onUpdate) {
    return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
  },

  /**
   * Return a worker for the compressed content.
   * @private
   * @param {Object} compression the compression object to use.
   * @param {Object} compressionOptions the options to use when compressing.
   * @return Worker the worker.
   */
  _compressWorker: function _compressWorker(compression, compressionOptions) {
    if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
      return this._data.getCompressedWorker();
    } else {
      var result = this._decompressWorker();

      if (!this._dataBinary) {
        result = result.pipe(new utf8.Utf8EncodeWorker());
      }

      return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
    }
  },

  /**
   * Return a worker for the decompressed content.
   * @private
   * @return Worker the worker.
   */
  _decompressWorker: function _decompressWorker() {
    if (this._data instanceof CompressedObject) {
      return this._data.getContentWorker();
    } else if (this._data instanceof GenericWorker) {
      return this._data;
    } else {
      return new DataWorker(this._data);
    }
  }
};
var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];

var removedFn = function removedFn() {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for (var i = 0; i < removedMethods.length; i++) {
  ZipObject.prototype[removedMethods[i]] = removedFn;
}

module.exports = ZipObject;

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/fn/set-immediate.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/fn/set-immediate.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/web.immediate */ "./node_modules/jszip/node_modules/core-js/library/modules/web.immediate.js");

module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/jszip/node_modules/core-js/library/modules/_core.js").setImmediate;

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_a-function.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_a-function.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_an-object.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_an-object.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/jszip/node_modules/core-js/library/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_cof.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_cof.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_core.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_core.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.3.0'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_ctx.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_ctx.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/jszip/node_modules/core-js/library/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/jszip/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/jszip/node_modules/core-js/library/modules/_is-object.js"),
    document = __webpack_require__(/*! ./_global */ "./node_modules/jszip/node_modules/core-js/library/modules/_global.js").document // in old IE typeof document.createElement is 'object'
,
    is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_export.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_export.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/jszip/node_modules/core-js/library/modules/_global.js"),
    core = __webpack_require__(/*! ./_core */ "./node_modules/jszip/node_modules/core-js/library/modules/_core.js"),
    ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/jszip/node_modules/core-js/library/modules/_ctx.js"),
    hide = __webpack_require__(/*! ./_hide */ "./node_modules/jszip/node_modules/core-js/library/modules/_hide.js"),
    PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F,
      IS_GLOBAL = type & $export.G,
      IS_STATIC = type & $export.S,
      IS_PROTO = type & $export.P,
      IS_BIND = type & $export.B,
      IS_WRAP = type & $export.W,
      exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
      expProto = exports[PROTOTYPE],
      target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
      key,
      own,
      out;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue; // export native or passed

    out = own ? target[key] : source[key]; // prevent global pollution for namespaces

    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function F(a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();

            case 1:
              return new C(a);

            case 2:
              return new C(a, b);
          }

          return new C(a, b, c);
        }

        return C.apply(this, arguments);
      };

      F[PROTOTYPE] = C[PROTOTYPE];
      return F; // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
}; // type bitmap


$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library` 

module.exports = $export;

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_fails.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_fails.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_global.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_global.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_hide.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_hide.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/jszip/node_modules/core-js/library/modules/_object-dp.js"),
    createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/jszip/node_modules/core-js/library/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_html.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_html.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_global */ "./node_modules/jszip/node_modules/core-js/library/modules/_global.js").document && document.documentElement;

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!************************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/jszip/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_invoke.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_invoke.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_is-object.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_is-object.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (it) {
  return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_object-dp.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_object-dp.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/jszip/node_modules/core-js/library/modules/_an-object.js"),
    IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/jszip/node_modules/core-js/library/modules/_ie8-dom-define.js"),
    toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/jszip/node_modules/core-js/library/modules/_to-primitive.js"),
    dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_property-desc.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_property-desc.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_task.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_task.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/jszip/node_modules/core-js/library/modules/_ctx.js"),
    invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/jszip/node_modules/core-js/library/modules/_invoke.js"),
    html = __webpack_require__(/*! ./_html */ "./node_modules/jszip/node_modules/core-js/library/modules/_html.js"),
    cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js"),
    global = __webpack_require__(/*! ./_global */ "./node_modules/jszip/node_modules/core-js/library/modules/_global.js"),
    process = global.process,
    setTask = global.setImmediate,
    clearTask = global.clearImmediate,
    MessageChannel = global.MessageChannel,
    counter = 0,
    queue = {},
    ONREADYSTATECHANGE = 'onreadystatechange',
    defer,
    channel,
    port;

var run = function run() {
  var id = +this;

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function listener(event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [],
        i = 1;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    queue[++counter] = function () {
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__(/*! ./_cof */ "./node_modules/jszip/node_modules/core-js/library/modules/_cof.js")(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/_to-primitive.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/_to-primitive.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/jszip/node_modules/core-js/library/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/jszip/node_modules/core-js/library/modules/web.immediate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jszip/node_modules/core-js/library/modules/web.immediate.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/jszip/node_modules/core-js/library/modules/_export.js"),
    $task = __webpack_require__(/*! ./_task */ "./node_modules/jszip/node_modules/core-js/library/modules/_task.js");

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "./node_modules/lie/lib/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/lie/lib/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var immediate = __webpack_require__(/*! immediate */ "./node_modules/immediate/lib/browser.js");
/* istanbul ignore next */


function INTERNAL() {}

var handlers = {};
var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];
module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }

  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;

  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }

  var promise = new this.constructor(INTERNAL);

  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};

function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;

  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }

  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}

QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};

QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};

QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};

QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;

    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }

    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);

  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }

  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;

    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }

  return self;
};

handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;

  while (++i < len) {
    self.queue[i].callRejected(error);
  }

  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;

  if (obj && (_typeof(obj) === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;

  function onError(value) {
    if (called) {
      return;
    }

    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }

    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);

  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};

  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }

  return out;
}

Promise.resolve = resolve;

function resolve(value) {
  if (value instanceof this) {
    return value;
  }

  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;

function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;

function all(iterable) {
  var self = this;

  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;

  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }

  return promise;

  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });

    function resolveFromAll(outValue) {
      values[i] = outValue;

      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;

function race(iterable) {
  var self = this;

  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;

  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }

  return promise;

  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return "\uFFFD";
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return "\uFFFD";
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + "\uFFFD";
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Top level file is just a mixin of submodules & constants


var assign = __webpack_require__(/*! ./lib/utils/common */ "./node_modules/pako/lib/utils/common.js").assign;

var deflate = __webpack_require__(/*! ./lib/deflate */ "./node_modules/pako/lib/deflate.js");

var inflate = __webpack_require__(/*! ./lib/inflate */ "./node_modules/pako/lib/inflate.js");

var constants = __webpack_require__(/*! ./lib/zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

var pako = {};
assign(pako, deflate, inflate, constants);
module.exports = pako;

/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "./node_modules/pako/lib/zlib/deflate.js");

var utils = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");

var strings = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");

var msg = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");

var ZStream = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

var toString = Object.prototype.toString;
/* Public constants ==========================================================*/

/* ===========================================================================*/

var Z_NO_FLUSH = 0;
var Z_FINISH = 4;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_SYNC_FLUSH = 2;
var Z_DEFAULT_COMPRESSION = -1;
var Z_DEFAULT_STRATEGY = 0;
var Z_DEFLATED = 8;
/* ===========================================================================*/

/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/

/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/

function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);
  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});
  var opt = this.options;

  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }

  this.err = 0; // error code, if happens (0 = Z_OK)

  this.msg = ''; // error message

  this.ended = false; // used to avoid multiple onEnd() calls

  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict; // Convert data if needed

    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}
/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/


Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;

  var status, _mode;

  if (this.ended) {
    return false;
  }

  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH; // Convert data if needed

  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_deflate.deflate(strm, _mode);
    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END); // Finalize on the last chunk.


  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  } // callback interim results if Z_SYNC_FLUSH.


  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};
/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/


Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};
/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/


Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }

  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/


function deflate(input, options) {
  var deflator = new Deflate(options);
  deflator.push(input, true); // That will never happens, if you don't cheat with options :)

  if (deflator.err) {
    throw deflator.msg || msg[deflator.err];
  }

  return deflator.result;
}
/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/


function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}
/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/


function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}

exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "./node_modules/pako/lib/zlib/inflate.js");

var utils = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");

var strings = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");

var c = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

var msg = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");

var ZStream = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

var GZheader = __webpack_require__(/*! ./zlib/gzheader */ "./node_modules/pako/lib/zlib/gzheader.js");

var toString = Object.prototype.toString;
/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/

/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/

function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);
  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});
  var opt = this.options; // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.

  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;

    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  } // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate


  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  } // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible


  if (opt.windowBits > 15 && opt.windowBits < 48) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err = 0; // error code, if happens (0 = Z_OK)

  this.msg = ''; // error message

  this.ended = false; // used to avoid multiple onEnd() calls

  this.chunks = []; // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();
  zlib_inflate.inflateGetHeader(this.strm, this.header);
}
/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/


Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;

  var status, _mode;

  var next_out_utf8, tail, utf8str;
  var dict; // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.

  var allowBufError = false;

  if (this.ended) {
    return false;
  }

  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH; // Convert data if needed

  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
        if (this.options.to === 'string') {
          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8); // move tail

          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;

          if (tail) {
            utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }

          this.onData(utf8str);
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.


    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  } // Finalize on the last chunk.


  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  } // callback interim results if Z_SYNC_FLUSH.


  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};
/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/


Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};
/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/


Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }

  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/


function inflate(input, options) {
  var inflator = new Inflate(options);
  inflator.push(input, true); // That will never happens, if you don't cheat with options :)

  if (inflator.err) {
    throw inflator.msg || msg[inflator.err];
  }

  return inflator.result;
}
/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/


function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}
/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip = inflate;

/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj
/*from1, from2, from3, ...*/
) {
  var sources = Array.prototype.slice.call(arguments, 1);

  while (sources.length) {
    var source = sources.shift();

    if (!source) {
      continue;
    }

    if (_typeof(source) !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
}; // reduce buffer size, avoiding mem copy


exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }

  if (buf.subarray) {
    return buf.subarray(0, size);
  }

  buf.length = size;
  return buf;
};

var fnTyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    } // Fallback to ordinary array


    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    var i, l, len, pos, chunk, result; // calculate data length

    len = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    } // join chunks


    result = new Uint8Array(len);
    pos = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};
var fnUntyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    return [].concat.apply([], chunks);
  }
}; // Enable/Disable typed arrays use, for testing
//

exports.setTyped = function (on) {
  if (on) {
    exports.Buf8 = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8 = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// String encode/decode helpers


var utils = __webpack_require__(/*! ./common */ "./node_modules/pako/lib/utils/common.js"); // Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//


var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}

try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
} // Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff


var _utf8len = new utils.Buf8(256);

for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}

_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
// convert string to array (typed, when possible)

exports.string2buf = function (str) {
  var buf,
      c,
      c2,
      m_pos,
      i,
      str_len = str.length,
      buf_len = 0; // count binary size

  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);

    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);

      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }

    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  } // allocate buffer


  buf = new utils.Buf8(buf_len); // convert

  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);

    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);

      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }

    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }

  return buf;
}; // Helper (used in 2 places)


function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';

  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }

  return result;
} // Convert byte array to binary string


exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
}; // Convert binary string (typed, when possible)


exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);

  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }

  return buf;
}; // convert array to string


exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length; // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.

  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++]; // quick process ascii

    if (c < 0x80) {
      utf16buf[out++] = c;
      continue;
    }

    c_len = _utf8len[c]; // skip 5 & 6 byte codes

    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;
      i += c_len - 1;
      continue;
    } // apply mask on first byte


    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest

    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    } // terminated by end of string?


    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;
      continue;
    }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  }

  return buf2binstring(utf16buf, out);
}; // Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);


exports.utf8border = function (buf, max) {
  var pos;
  max = max || buf.length;

  if (max > buf.length) {
    max = buf.length;
  } // go back from last position, until start of sequence found


  pos = max - 1;

  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  } // Very small and broken sequence,
  // return max, because we should return something anyway.


  if (pos < 0) {
    return max;
  } // If we came to start of buffer - that means buffer is too small,
  // return max too.


  if (pos === 0) {
    return max;
  }

  return pos + _utf8len[buf[pos]] > max ? pos : max;
};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

module.exports = adler32;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8 //Z_NULL:                 null // Use -1 or null inline, depending on var type

};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// Use ordinary array, since untyped makes no boost here

function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;

    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }

    table[n] = c;
  }

  return table;
} // Create table on load. Just 255 signed longs. Not a problem.


var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;
  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = crc32;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var trees = __webpack_require__(/*! ./trees */ "./node_modules/pako/lib/zlib/trees.js");

var adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");

var crc32 = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");

var msg = __webpack_require__(/*! ./messages */ "./node_modules/pako/lib/zlib/messages.js");
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */


var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1; //var Z_SYNC_FLUSH    = 2;

var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5; //var Z_TREES         = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

var Z_OK = 0;
var Z_STREAM_END = 1; //var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;

var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3; //var Z_MEM_ERROR     = -4;

var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;

var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT

var Z_UNKNOWN = 2;
/* The deflate compression method */

var Z_DEFLATED = 8;
/*============================================================================*/

var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */

var MAX_WBITS = 15;
/* 32K LZ77 window */

var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 0x20;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
/* block not completed, need more input or more output */

var BS_BLOCK_DONE = 2;
/* block flush performed */

var BS_FINISH_STARTED = 3;
/* finish started, need only more output at next deflate */

var BS_FINISH_DONE = 4;
/* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
}
/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */


function flush_pending(strm) {
  var s = strm.state; //_tr_flush_bits(s);

  var len = s.pending;

  if (len > strm.avail_out) {
    len = strm.avail_out;
  }

  if (len === 0) {
    return;
  }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;

  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);

  s.block_start = s.strstart;
  flush_pending(s.strm);
}

function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */


function putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}
/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */


function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }

  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);

  utils.arraySet(buf, strm.input, strm.next_in, len, start);

  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;
  return len;
}
/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */


function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  /* max hash chain length */

  var scan = s.strstart;
  /* current string */

  var match;
  /* matched string */

  var len;
  /* length of current match */

  var best_len = s.prev_length;
  /* best match length so far */

  var nice_match = s.nice_match;
  /* stop if match long enough */

  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0
  /*NIL*/
  ;
  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev = s.prev;
  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */

  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */


  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");


  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;
    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */


    scan += 2;
    match++; // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */

    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");


    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;

      if (len >= nice_match) {
        break;
      }

      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }

  return s.lookahead;
}
/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */


function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed

    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */

    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */

      s.block_start -= _w_size;
      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }

    if (s.strm.avail_in === 0) {
      break;
    }
    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");


    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    /* Initialize the hash value now that we have some input: */

    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */

      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif

      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;

        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");

}
/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */


function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  /* Copy as much as possible from input to output: */


  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {
      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }
      fill_window(s);

      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    } //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");


    s.strstart += s.lookahead;
    s.lookahead = 0;
    /* Emit a stored block if pending_buf will be full: */

    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/

      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */


    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_NEED_MORE;
}
/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */


function deflate_fast(s, flush) {
  var hash_head;
  /* head of the hash chain */

  var bflush;
  /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);

      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
        /* flush the current block */
      }
    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */


    if (hash_head !== 0
    /*NIL*/
    && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }

    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */

      if (s.match_length <= s.max_lazy_match
      /*max_insert_length*/
      && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        /* string at strstart already in table */

        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/

          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/

          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);

        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */

        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif

        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */


function deflate_slow(s, flush) {
  var hash_head;
  /* head of hash chain */

  var bflush;
  /* set if current block must be flushed */

  var max_insert;
  /* Process the input block. */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);

      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     */


    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0
    /*NIL*/
    && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
    /*MAX_DIST(s)*/
    ) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096
        /*TOO_FAR*/
        )) {
          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */


    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */
      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/

      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */

      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;

      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);

      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/

      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));

      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }

      s.strstart++;
      s.lookahead--;

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  } //Assert (flush != Z_NO_FLUSH, "no flush?");


  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));

    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }

  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */


function deflate_rle(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  var prev;
  /* byte at distance one to match */

  var scan, strend;
  /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);

      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* See how many times the previous byte repeats */


    s.match_length = 0;

    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];

      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;

        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);

        s.match_length = MAX_MATCH - (strend - scan);

        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      } //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");

    }
    /* Emit match if have run of MIN_MATCH or longer, else emit literal */


    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */


function deflate_huff(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);

      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        break;
        /* flush the current block */
      }
    }
    /* Output a literal byte */


    s.match_length = 0; //Tracevv((stderr,"%c", s->window[s->strstart]));

    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/

    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */


function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;
configuration_table = [
/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored),
/* 0 store only */
new Config(4, 4, 8, 4, deflate_fast),
/* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast),
/* 2 */
new Config(4, 6, 32, 32, deflate_fast),
/* 3 */
new Config(4, 4, 16, 16, deflate_slow),
/* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow),
/* 5 */
new Config(8, 16, 128, 128, deflate_slow),
/* 6 */
new Config(8, 32, 128, 256, deflate_slow),
/* 7 */
new Config(32, 128, 258, 1024, deflate_slow),
/* 8 */
new Config(32, 258, 258, 4096, deflate_slow)
/* 9 max compression */
];
/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */

function lm_init(s) {
  s.window_size = 2 * s.w_size;
  /*** CLEAR_HASH(s); ***/

  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */

  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function DeflateState() {
  this.strm = null;
  /* pointer back to this zlib stream */

  this.status = 0;
  /* as the name implies */

  this.pending_buf = null;
  /* output still pending */

  this.pending_buf_size = 0;
  /* size of pending_buf */

  this.pending_out = 0;
  /* next pending byte to output to the stream */

  this.pending = 0;
  /* nb of bytes in the pending buffer */

  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  this.gzhead = null;
  /* gzip header information to write */

  this.gzindex = 0;
  /* where in extra, name, or comment */

  this.method = Z_DEFLATED;
  /* can only be DEFLATED */

  this.last_flush = -1;
  /* value of flush param for previous deflate call */

  this.w_size = 0;
  /* LZ77 window size (32K by default) */

  this.w_bits = 0;
  /* log2(w_size)  (8..16) */

  this.w_mask = 0;
  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;
  /* Heads of the hash chains or NIL. */

  this.ins_h = 0;
  /* hash index of string to be inserted */

  this.hash_size = 0;
  /* number of elements in hash table */

  this.hash_bits = 0;
  /* log2(hash_size) */

  this.hash_mask = 0;
  /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;
  /* length of best match */

  this.prev_match = 0;
  /* previous match */

  this.match_available = 0;
  /* set if previous match exists */

  this.strstart = 0;
  /* start of string to insert */

  this.match_start = 0;
  /* start of matching string */

  this.lookahead = 0;
  /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;

  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;
  /* compression level (1..9) */

  this.strategy = 0;
  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0;
  /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */
  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective

  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  /* desc. for literal tree */

  this.d_desc = null;
  /* desc. for distance tree */

  this.bl_desc = null;
  /* desc. for bit length tree */
  //ush bl_count[MAX_BITS+1];

  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */

  this.heap = new utils.Buf16(2 * L_CODES + 1);
  /* heap used to build the Huffman trees */

  zero(this.heap);
  this.heap_len = 0;
  /* number of elements in the heap */

  this.heap_max = 0;
  /* element of largest frequency */

  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];

  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;
  /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;
  /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;
  /* bit length of current block with optimal trees */

  this.static_len = 0;
  /* bit length of current block with static trees */

  this.matches = 0;
  /* number of string matches in current block */

  this.insert = 0;
  /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */

  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */
  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;

  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }

  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)

  s.last_flush = Z_NO_FLUSH;

  trees._tr_init(s);

  return Z_OK;
}

function deflateReset(strm) {
  var ret = deflateResetKeep(strm);

  if (ret === Z_OK) {
    lm_init(strm.state);
  }

  return ret;
}

function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }

  strm.state.gzhead = head;
  return Z_OK;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR;
  }

  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    /* write gzip wrapper instead */

    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */


  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size); // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6;
  /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;

  s.pending_buf = new utils.Buf8(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}

function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm;
  /* just in case */

  old_flush = s.last_flush;
  s.last_flush = flush;
  /* Write the header */

  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);

      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);

      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, s.gzhead.time >> 8 & 0xff);
        put_byte(s, s.gzhead.time >> 16 & 0xff);
        put_byte(s, s.gzhead.time >> 24 & 0xff);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 0xff);

        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }

        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }

        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }

        header |= level_flags << 6;

        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }

        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        /* Save the adler32 of the preset dictionary: */

        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }

        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  } //#ifdef GZIP


  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */

        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              break;
            }
          }

          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
      s.status = NAME_STATE;
    }
  }

  if (s.status === NAME_STATE) {
    if (s.gzhead.name
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
      s.status = COMMENT_STATE;
    }
  }

  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
      s.status = HCRC_STATE;
    }
  }

  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }

      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);

        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  } //#endif

  /* Flush as much pending output as possible */


  if (s.pending !== 0) {
    flush_pending(strm);

    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }
    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */

  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  /* User must not provide more input after the first FINISH: */


  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  /* Start a new block or continue the current one.
   */


  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }

    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }

      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }

    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */
        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */


        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/

          /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }

      flush_pending(strm);

      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR at next call, see above */

        return Z_OK;
      }
    }
  } //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}


  if (flush !== Z_FINISH) {
    return Z_OK;
  }

  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }
  /* Write the trailer */


  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */

  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */


  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm
  /*== Z_NULL*/
  || !strm.state
  /*== Z_NULL*/
  ) {
      return Z_STREAM_ERROR;
    }

  status = strm.state.status;

  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}
/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */


function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm
  /*== Z_NULL*/
  || !strm.state
  /*== Z_NULL*/
  ) {
      return Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }
  /* when using zlib wrappers, compute Adler-32 for provided dictionary */


  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;
  /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */

  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */

      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);

      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);


    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */


  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);

  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);

    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);

    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }

  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';
/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text = 0;
  /* modification time */

  this.time = 0;
  /* extra flags (not used when writing a gzip file) */

  this.xflags = 0;
  /* operating system */

  this.os = 0;
  /* pointer to extra field or Z_NULL if none */

  this.extra = null;
  /* extra field length (valid if extra != Z_NULL) */

  this.extra_len = 0; // Actually, we don't need it in JS,
  // but leave for few code modifications
  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;

  /* pointer to zero-terminated file name or Z_NULL */

  this.name = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;

  /* pointer to zero-terminated comment or Z_NULL */

  this.comment = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;

  /* true if there was or will be a header crc */

  this.hcrc = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */

  this.done = false;
}

module.exports = GZheader;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// See state defs from inflate.js

var BAD = 30;
/* got a data error -- remain here until reset */

var TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */

module.exports = function inflate_fast(strm, start) {
  var state;

  var _in;
  /* local strm.input */


  var last;
  /* have enough input while in < last */

  var _out;
  /* local strm.output */


  var beg;
  /* inflate()'s initial strm.output */

  var end;
  /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT

  var dmax;
  /* maximum distance from zlib header */
  //#endif

  var wsize;
  /* window size or zero if not using window */

  var whave;
  /* valid bytes in the window */

  var wnext;
  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools

  var s_window;
  /* allocated sliding window, if wsize != 0 */

  var hold;
  /* local strm.hold */

  var bits;
  /* local strm.bits */

  var lcode;
  /* local strm.lencode */

  var dcode;
  /* local strm.distcode */

  var lmask;
  /* mask for first level of length codes */

  var dmask;
  /* mask for first level of distance codes */

  var here;
  /* retrieved table entry */

  var op;
  /* code bits, operation, extra bits, or */

  /*  window position, window bytes to copy */

  var len;
  /* match length, unused bytes */

  var dist;
  /* match distance */

  var from;
  /* where to copy match from */

  var from_source;
  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */

  state = strm.state; //here = state.here;

  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257); //#ifdef INFLATE_STRICT

  dmax = state.dmax; //#endif

  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24
      /*here.bits*/
      ;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff
      /*here.op*/
      ;

      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff
        /*here.val*/
        ;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff
        /*here.val*/
        ;
        op &= 15;
        /* number of extra bits */

        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }

          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        } //Tracevv((stderr, "inflate:         length %u\n", len));


        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }

        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24
          /*here.bits*/
          ;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff
          /*here.op*/
          ;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff
            /*here.val*/
            ;
            op &= 15;
            /* number of extra bits */

            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;

              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }

            dist += hold & (1 << op) - 1; //#ifdef INFLATE_STRICT

            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            } //#endif


            hold >>>= op;
            bits -= op; //Tracevv((stderr, "inflate:         distance %u\n", dist));

            op = _out - beg;
            /* max distance in output */

            if (dist > op) {
              /* see if copy from window */
              op = dist - op;
              /* distance back in window */

              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                } // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif

              }

              from = 0; // window index

              from_source = s_window;

              if (wnext === 0) {
                /* very common case */
                from += wsize - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;

                if (op < len) {
                  /* some from end of window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = 0;

                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = _out - dist;
                    /* rest from output */

                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  from_source = output;
                }
              }

              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }

              if (len) {
                output[_out++] = from_source[from++];

                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist;
              /* copy direct from output */

              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);

              if (len) {
                output[_out++] = output[from++];

                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + (
            /*here.val*/
            hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + (
        /*here.val*/
        hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);
  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */


  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  /* update state and return */

  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");

var crc32 = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");

var inflate_fast = __webpack_require__(/*! ./inffast */ "./node_modules/pako/lib/zlib/inffast.js");

var inflate_table = __webpack_require__(/*! ./inftrees */ "./node_modules/pako/lib/zlib/inftrees.js");

var CODES = 0;
var LENS = 1;
var DISTS = 2;
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;

var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2; //var Z_ERRNO         = -1;

var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* The deflate compression method */

var Z_DEFLATED = 8;
/* STATES ====================================================================*/

/* ===========================================================================*/

var HEAD = 1;
/* i: waiting for magic header */

var FLAGS = 2;
/* i: waiting for method and flags (gzip) */

var TIME = 3;
/* i: waiting for modification time (gzip) */

var OS = 4;
/* i: waiting for extra flags and operating system (gzip) */

var EXLEN = 5;
/* i: waiting for extra length (gzip) */

var EXTRA = 6;
/* i: waiting for extra bytes (gzip) */

var NAME = 7;
/* i: waiting for end of file name (gzip) */

var COMMENT = 8;
/* i: waiting for end of comment (gzip) */

var HCRC = 9;
/* i: waiting for header crc (gzip) */

var DICTID = 10;
/* i: waiting for dictionary check value */

var DICT = 11;
/* waiting for inflateSetDictionary() call */

var TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

var TYPEDO = 13;
/* i: same, but skip check to exit inflate on new block */

var STORED = 14;
/* i: waiting for stored size (length and complement) */

var COPY_ = 15;
/* i/o: same as COPY below, but only first time in */

var COPY = 16;
/* i/o: waiting for input or output to copy stored block */

var TABLE = 17;
/* i: waiting for dynamic block table lengths */

var LENLENS = 18;
/* i: waiting for code length code lengths */

var CODELENS = 19;
/* i: waiting for length/lit and distance code lengths */

var LEN_ = 20;
/* i: same as LEN below, but only first time in */

var LEN = 21;
/* i: waiting for length/lit/eob code */

var LENEXT = 22;
/* i: waiting for length extra bits */

var DIST = 23;
/* i: waiting for distance code */

var DISTEXT = 24;
/* i: waiting for distance extra bits */

var MATCH = 25;
/* o: waiting for output space to copy string */

var LIT = 26;
/* o: waiting for output space to write literal */

var CHECK = 27;
/* i: waiting for 32-bit check value */

var LENGTH = 28;
/* i: waiting for 32-bit length (gzip) */

var DONE = 29;
/* finished check, done -- remain here until reset */

var BAD = 30;
/* got a data error -- remain here until reset */

var MEM = 31;
/* got an inflate() memory error -- remain here until reset */

var SYNC = 32;
/* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592; //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */

var DEF_WBITS = MAX_WBITS;

function zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function InflateState() {
  this.mode = 0;
  /* current inflate mode */

  this.last = false;
  /* true if processing last block */

  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  this.havedict = false;
  /* true if dictionary provided */

  this.flags = 0;
  /* gzip header method and flags (0 if zlib) */

  this.dmax = 0;
  /* zlib header max distance (INFLATE_STRICT) */

  this.check = 0;
  /* protected copy of check value */

  this.total = 0;
  /* protected copy of output count */
  // TODO: may be {}

  this.head = null;
  /* where to save gzip header information */

  /* sliding window */

  this.wbits = 0;
  /* log base 2 of requested window size */

  this.wsize = 0;
  /* window size or zero if not using window */

  this.whave = 0;
  /* valid bytes in the window */

  this.wnext = 0;
  /* window write index */

  this.window = null;
  /* allocated sliding window, if needed */

  /* bit accumulator */

  this.hold = 0;
  /* input bit accumulator */

  this.bits = 0;
  /* number of bits in "in" */

  /* for string and stored block copying */

  this.length = 0;
  /* literal or length of data to copy */

  this.offset = 0;
  /* distance back to copy string from */

  /* for table and code decoding */

  this.extra = 0;
  /* extra bits needed */

  /* fixed and dynamic code tables */

  this.lencode = null;
  /* starting table for length/literal codes */

  this.distcode = null;
  /* starting table for distance codes */

  this.lenbits = 0;
  /* index bits for lencode */

  this.distbits = 0;
  /* index bits for distcode */

  /* dynamic table building */

  this.ncode = 0;
  /* number of code length code lengths */

  this.nlen = 0;
  /* number of length code lengths */

  this.ndist = 0;
  /* number of distance code lengths */

  this.have = 0;
  /* number of code lengths in lens[] */

  this.next = null;
  /* next available space in codes[] */

  this.lens = new utils.Buf16(320);
  /* temporary storage for code lengths */

  this.work = new utils.Buf16(288);
  /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */

  this.lendyn = null;
  /* dynamic table for length/literal codes (JS specific) */

  this.distdyn = null;
  /* dynamic table for distance codes (JS specific) */

  this.sane = 0;
  /* if false, allow invalid distance too far */

  this.back = 0;
  /* bits back of last unprocessed length/lit */

  this.was = 0;
  /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = '';
  /*Z_NULL*/

  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }

  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null
  /*Z_NULL*/
  ;
  state.hold = 0;
  state.bits = 0; //state.lencode = state.distcode = state.next = state.codes;

  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1; //Tracev((stderr, "inflate: reset\n"));

  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;
  /* get the state */

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  /* extract wrap request from windowBits parameter */

  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;

    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  /* set number of window bits, free window if different */


  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }

  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  /* update state and reset the rest of it */


  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return Z_STREAM_ERROR;
  } //strm.msg = Z_NULL;                 /* in case we return an error */


  state = new InflateState(); //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));

  strm.state = state;
  state.window = null
  /*Z_NULL*/
  ;
  ret = inflateReset2(strm, windowBits);

  if (ret !== Z_OK) {
    strm.state = null
    /*Z_NULL*/
    ;
  }

  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */


var virgin = true;
var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    /* literal/length table */

    sym = 0;

    while (sym < 144) {
      state.lens[sym++] = 8;
    }

    while (sym < 256) {
      state.lens[sym++] = 9;
    }

    while (sym < 280) {
      state.lens[sym++] = 7;
    }

    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
      bits: 9
    });
    /* distance table */

    sym = 0;

    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
      bits: 5
    });
    /* do this just once */

    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */


function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;
  /* if it hasn't been done already, allocate space for the window */

  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new utils.Buf8(state.wsize);
  }
  /* copy state->wsize or less output bytes into the circular window */


  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;

    if (dist > copy) {
      dist = copy;
    } //zmemcpy(state->window + state->wnext, end - copy, dist);


    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;

    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;

      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }

      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }

  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers

  var next;
  /* next input INDEX */

  var put;
  /* next output INDEX */

  var have, left;
  /* available input and output */

  var hold;
  /* bit buffer */

  var bits;
  /* bits in bit buffer */

  var _in, _out;
  /* save starting available input and output */


  var copy;
  /* number of stored or match bytes to copy */

  var from;
  /* where to copy match bytes from */

  var from_source;
  var here = 0;
  /* current decoding table entry */

  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */

  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)

  var len;
  /* length to copy for repeats, bits to drop */

  var ret;
  /* return code */

  var hbuf = new utils.Buf8(4);
  /* buffer for gzip header crc calculation */

  var opts;
  var n; // temporary var for NEED_BITS

  var order =
  /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;

  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  /* skip check */
  //--- LOAD() ---


  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits; //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        } //=== NEEDBITS(16);


        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0
          /*crc32(0L, Z_NULL, 0)*/
          ; //=== CRC2(state.check, hold);

          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
          //=== INITBITS();

          hold = 0;
          bits = 0; //===//

          state.mode = FLAGS;
          break;
        }

        state.flags = 0;
        /* expect zlib header */

        if (state.head) {
          state.head.done = false;
        }

        if (!(state.wrap & 1) ||
        /* check if zlib header allowed */
        (((hold & 0xff) <<
        /*BITS(8)*/
        8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }

        if ((hold & 0x0f) !==
        /*BITS(4)*/
        Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        } //--- DROPBITS(4) ---//


        hold >>>= 4;
        bits -= 4; //---//

        len = (hold & 0x0f) +
        /*BITS(4)*/
        8;

        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        state.dmax = 1 << len; //Tracev((stderr, "inflate:   zlib header ok\n"));

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = hold & 0x200 ? DICTID : TYPE; //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        break;

      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.flags = hold;

        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }

        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }

        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = TIME;

      /* falls through */

      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.head) {
          state.head.time = hold;
        }

        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0); //===
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = OS;

      /* falls through */

      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = EXLEN;

      /* falls through */

      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.length = hold;

          if (state.head) {
            state.head.extra_len = hold;
          }

          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0); //===//
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
        } else if (state.head) {
          state.head.extra = null
          /*Z_NULL*/
          ;
        }

        state.mode = EXTRA;

      /* falls through */

      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;

          if (copy > have) {
            copy = have;
          }

          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;

              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }

              utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len); //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }

            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }

            have -= copy;
            next += copy;
            state.length -= copy;
          }

          if (state.length) {
            break inf_leave;
          }
        }

        state.length = 0;
        state.mode = NAME;

      /* falls through */

      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            if (state.head && len && state.length < 65536
            /*state.head.name_max*/
            ) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }

        state.length = 0;
        state.mode = COMMENT;

      /* falls through */

      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            if (state.head && len && state.length < 65536
            /*state.head.comm_max*/
            ) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }

        state.mode = HCRC;

      /* falls through */

      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
        }

        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }

        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;

      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        strm.adler = state.check = zswap32(hold); //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        state.mode = DICT;

      /* falls through */

      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          return Z_NEED_DICT;
        }

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = TYPE;

      /* falls through */

      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7; //---//

          state.mode = CHECK;
          break;
        } //=== NEEDBITS(3); */


        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.last = hold & 0x01
        /*BITS(1)*/
        ; //--- DROPBITS(1) ---//

        hold >>>= 1;
        bits -= 1; //---//

        switch (hold & 0x03) {
          /*BITS(2)*/
          case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;

          case 1:
            /* fixed block */
            fixedtables(state); //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));

            state.mode = LEN_;
            /* decode codes */

            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2; //---//

              break inf_leave;
            }

            break;

          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;

          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        } //--- DROPBITS(2) ---//


        hold >>>= 2;
        bits -= 2; //---//

        break;

      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7; //---//
        //=== NEEDBITS(32); */

        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }

        state.length = hold & 0xffff; //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        state.mode = COPY_;

        if (flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case COPY_:
        state.mode = COPY;

      /* falls through */

      case COPY:
        copy = state.length;

        if (copy) {
          if (copy > have) {
            copy = have;
          }

          if (copy > left) {
            copy = left;
          }

          if (copy === 0) {
            break inf_leave;
          } //--- zmemcpy(put, next, copy); ---


          utils.arraySet(output, input, next, copy, put); //---//

          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        } //Tracev((stderr, "inflate:       stored end\n"));


        state.mode = TYPE;
        break;

      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.nlen = (hold & 0x1f) +
        /*BITS(5)*/
        257; //--- DROPBITS(5) ---//

        hold >>>= 5;
        bits -= 5; //---//

        state.ndist = (hold & 0x1f) +
        /*BITS(5)*/
        1; //--- DROPBITS(5) ---//

        hold >>>= 5;
        bits -= 5; //---//

        state.ncode = (hold & 0x0f) +
        /*BITS(4)*/
        4; //--- DROPBITS(4) ---//

        hold >>>= 4;
        bits -= 4; //---//
        //#ifndef PKZIP_BUG_WORKAROUND

        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        } //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));


        state.have = 0;
        state.mode = LENLENS;

      /* falls through */

      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//

          hold >>>= 3;
          bits -= 3; //---//
        }

        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        } // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table


        state.lencode = state.lendyn;
        state.lenbits = 7;
        opts = {
          bits: state.lenbits
        };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        } //Tracev((stderr, "inflate:       code lengths ok\n"));


        state.have = 0;
        state.mode = CODELENS;

      /* falls through */

      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            /*BITS(state.lenbits)*/

            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          }

          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits; //---//

            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }

              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//

              hold >>>= 2;
              bits -= 2; //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//

              hold >>>= 3;
              bits -= 3; //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//

              hold >>>= 7;
              bits -= 7; //---//
            }

            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }

            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }
        /* handle error breaks in while */


        if (state.mode === BAD) {
          break;
        }
        /* check for end-of-block code (better have one) */


        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }
        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */


        state.lenbits = 9;
        opts = {
          bits: state.lenbits
        };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        state.lenbits = opts.bits; // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6; //state.distcode.copy(state.codes);
        // Switch to use dynamic table

        state.distcode = state.distdyn;
        opts = {
          bits: state.distbits
        };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        state.distbits = opts.bits; // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        } //Tracev((stderr, 'inflate:       codes ok\n'));


        state.mode = LEN_;

        if (flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case LEN_:
        state.mode = LEN;

      /* falls through */

      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          inflate_fast(strm, _out); //--- LOAD() ---

          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits; //---

          if (state.mode === TYPE) {
            state.back = -1;
          }

          break;
        }

        state.back = 0;

        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1];
          /*BITS(state.lenbits)*/

          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          hold >>>= last_bits;
          bits -= last_bits; //---//

          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        hold >>>= here_bits;
        bits -= here_bits; //---//

        state.back += here_bits;
        state.length = here_val;

        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }

        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }

        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }

        state.extra = here_op & 15;
        state.mode = LENEXT;

      /* falls through */

      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.length += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          hold >>>= state.extra;
          bits -= state.extra; //---//

          state.back += state.extra;
        } //Tracevv((stderr, "inflate:         length %u\n", state.length));


        state.was = state.length;
        state.mode = DIST;

      /* falls through */

      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1];
          /*BITS(state.distbits)*/

          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          hold >>>= last_bits;
          bits -= last_bits; //---//

          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        hold >>>= here_bits;
        bits -= here_bits; //---//

        state.back += here_bits;

        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }

        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;

      /* falls through */

      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.offset += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          hold >>>= state.extra;
          bits -= state.extra; //---//

          state.back += state.extra;
        } //#ifdef INFLATE_STRICT


        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        } //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));


        state.mode = MATCH;

      /* falls through */

      case MATCH:
        if (left === 0) {
          break inf_leave;
        }

        copy = _out - left;

        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;

          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            } // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif

          }

          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }

          if (copy > state.length) {
            copy = state.length;
          }

          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }

        if (copy > left) {
          copy = left;
        }

        left -= copy;
        state.length -= copy;

        do {
          output[put++] = from_source[from++];
        } while (--copy);

        if (state.length === 0) {
          state.mode = LEN;
        }

        break;

      case LIT:
        if (left === 0) {
          break inf_leave;
        }

        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;

      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--; // Use '|' instead of '+' to make sure that result is signed

            hold |= input[next++] << bits;
            bits += 8;
          } //===//


          _out -= left;
          strm.total_out += _out;
          state.total += _out;

          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
          }

          _out = left; // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too

          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }

        state.mode = LENGTH;

      /* falls through */

      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }

        state.mode = DONE;

      /* falls through */

      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;

      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;

      case MEM:
        return Z_MEM_ERROR;

      case SYNC:
      /* falls through */

      default:
        return Z_STREAM_ERROR;
    }
  } // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */
  //--- RESTORE() ---


  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits; //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }

  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;

  if (state.wrap && _out) {
    strm.adler = state.check =
    /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }

  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);

  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }

  return ret;
}

function inflateEnd(strm) {
  if (!strm || !strm.state
  /*|| strm->zfree == (free_func)0*/
  ) {
      return Z_STREAM_ERROR;
    }

  var state = strm.state;

  if (state.window) {
    state.window = null;
  }

  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;
  /* check state */

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;

  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  /* save header structure */


  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state;
  var dictid;
  var ret;
  /* check state */

  if (!strm
  /* == Z_NULL */
  || !strm.state
  /* == Z_NULL */
  ) {
      return Z_STREAM_ERROR;
    }

  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  /* check for correct dictionary identifier */


  if (state.mode === DICT) {
    dictid = 1;
    /* adler32(0, null, 0)*/

    /* dictid = adler32(dictid, dictionary, dictLength); */

    dictid = adler32(dictid, dictionary, dictLength, 0);

    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */


  ret = updatewindow(strm, dictionary, dictLength, dictLength);

  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }

  state.havedict = 1; // Tracev((stderr, "inflate:   dictionary set\n"));

  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';
/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592; //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;
var lbase = [
/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
var lext = [
/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
var dbase = [
/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
var dext = [
/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits; //here = opts.here; /* table entry for duplication */

  var len = 0;
  /* a code's length in bits */

  var sym = 0;
  /* index of code symbols */

  var min = 0,
      max = 0;
  /* minimum and maximum code lengths */

  var root = 0;
  /* number of index bits for root table */

  var curr = 0;
  /* number of index bits for current table */

  var drop = 0;
  /* code bits to drop for sub-table */

  var left = 0;
  /* number of prefix codes available */

  var used = 0;
  /* code entries in table used */

  var huff = 0;
  /* Huffman code */

  var incr;
  /* for incrementing code, index */

  var fill;
  /* index for replicating entries */

  var low;
  /* low bits for current root entry */

  var mask;
  /* mask for low root bits */

  var next;
  /* next available space in table */

  var base = null;
  /* base value table to use */

  var base_index = 0; //  var shoextra;    /* extra bits table to use */

  var end;
  /* use base and extra for symbol > end */

  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */

  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */

  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */

  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }

  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  /* bound code lengths, force root to be within code lengths */


  root = bits;

  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }

  if (root > max) {
    root = max;
  }

  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0; //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;

    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
    /* no symbols, but wait for decoding to report error */
  }

  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }

  if (root < min) {
    root = min;
  }
  /* check for an over-subscribed or incomplete set of lengths */


  left = 1;

  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];

    if (left < 0) {
      return -1;
    }
    /* over-subscribed */

  }

  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;
    /* incomplete set */
  }
  /* generate offsets into symbol table for each length for sorting */


  offs[1] = 0;

  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  /* sort symbols by length, by symbol order within each length */


  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8


  if (type === CODES) {
    base = extra = work;
    /* dummy value--not used */

    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }
  /* initialize opts for loop */


  huff = 0;
  /* starting code */

  sym = 0;
  /* starting code symbol */

  len = min;
  /* starting code length */

  next = table_index;
  /* current table to fill in */

  curr = root;
  /* current table index bits */

  drop = 0;
  /* current bits to drop from code for index */

  low = -1;
  /* trigger new sub-table when len > root */

  used = 1 << root;
  /* use root table entries */

  mask = used - 1;
  /* mask for comparing low */

  /* check available table space */

  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  /* process all codes and make table entries */


  for (;;) {
    /* create table entry */
    here_bits = len - drop;

    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      /* end of block */

      here_val = 0;
    }
    /* replicate for those indices with low len bits equal to huff */


    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    /* save offset to next table */

    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    /* backwards increment the len-bit code huff */


    incr = 1 << len - 1;

    while (huff & incr) {
      incr >>= 1;
    }

    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    /* go to next symbol, update count, len */


    sym++;

    if (--count[len] === 0) {
      if (len === max) {
        break;
      }

      len = lens[lens_index + work[sym]];
    }
    /* create new sub-table if needed */


    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }
      /* increment past last table */


      next += min;
      /* here min is 1 << curr */

      /* determine length of next table */

      curr = len - drop;
      left = 1 << curr;

      while (curr + drop < max) {
        left -= count[curr + drop];

        if (left <= 0) {
          break;
        }

        curr++;
        left <<= 1;
      }
      /* check for enough space */


      used += 1 << curr;

      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      /* point entry in root table to sub-table */


      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/

      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */


  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  /* set return parameters */
  //opts.table_index += used;


  opts.bits = root;
  return 0;
};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2: 'need dictionary',

  /* Z_NEED_DICT       2  */
  1: 'stream end',

  /* Z_STREAM_END      1  */
  0: '',

  /* Z_OK              0  */
  '-1': 'file error',

  /* Z_ERRNO         (-1) */
  '-2': 'stream error',

  /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error',

  /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory',

  /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error',

  /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version'
  /* Z_VERSION_ERROR (-6) */

};

/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");
/* Public constants ==========================================================*/

/* ===========================================================================*/
//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;


var Z_FIXED = 4; //var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */

var Z_BINARY = 0;
var Z_TEXT = 1; //var Z_ASCII             = 1; // = Z_TEXT

var Z_UNKNOWN = 2;
/*============================================================================*/

function zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
} // From zutil.h


var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */
// From deflate.h

/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK = 256;
/* end of block literal code */

var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */

var extra_lbits =
/* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
var extra_dbits =
/* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
var extra_blbits =
/* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */
// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512;
/* see definition of array dist_code below */
// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1

var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code = new Array(DIST_CODE_LEN);

zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);

zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  /* static tree or NULL */

  this.extra_bits = extra_bits;
  /* extra bits for each code or NULL */

  this.extra_base = extra_base;
  /* base index for extra_bits */

  this.elems = elems;
  /* max number of elements in the tree */

  this.max_length = max_length;
  /* max bit length for the codes */
  // show if `static_tree` has data or dummy - needed for monomorphic objects

  this.has_stree = static_tree && static_tree.length;
}

var static_l_desc;
var static_d_desc;
var static_bl_desc;

function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  /* the dynamic tree */

  this.max_code = 0;
  /* largest code with non zero frequency */

  this.stat_desc = stat_desc;
  /* the corresponding static tree */
}

function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */


function put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}
/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */


function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]
  /*.Code*/
  , tree[c * 2 + 1]
  /*.Len*/
  );
}
/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */


function bi_reverse(code, len) {
  var res = 0;

  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);

  return res >>> 1;
}
/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */


function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */


function gen_bitlen(s, desc) //    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  /* heap index */

  var n, m;
  /* iterate over the tree elements */

  var bits;
  /* bit length */

  var xbits;
  /* extra bits */

  var f;
  /* frequency */

  var overflow = 0;
  /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */


  tree[s.heap[s.heap_max] * 2 + 1]
  /*.Len*/
  = 0;
  /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]
    /*.Dad*/
    * 2 + 1]
    /*.Len*/
    + 1;

    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }

    tree[n * 2 + 1]
    /*.Len*/
    = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    }
    /* not a leaf node */


    s.bl_count[bits]++;
    xbits = 0;

    if (n >= base) {
      xbits = extra[n - base];
    }

    f = tree[n * 2]
    /*.Freq*/
    ;
    s.opt_len += f * (bits + xbits);

    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]
      /*.Len*/
      + xbits);
    }
  }

  if (overflow === 0) {
    return;
  } // Trace((stderr,"\nbit length overflow\n"));

  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */


  do {
    bits = max_length - 1;

    while (s.bl_count[bits] === 0) {
      bits--;
    }

    s.bl_count[bits]--;
    /* move one leaf down the tree */

    s.bl_count[bits + 1] += 2;
    /* move one overflow item as its brother */

    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */

    overflow -= 2;
  } while (overflow > 0);
  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */


  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];

    while (n !== 0) {
      m = s.heap[--h];

      if (m > max_code) {
        continue;
      }

      if (tree[m * 2 + 1]
      /*.Len*/
      !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]
        /*.Len*/
        ) * tree[m * 2]
        /*.Freq*/
        ;
        tree[m * 2 + 1]
        /*.Len*/
        = bits;
      }

      n--;
    }
  }
}
/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */


function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1);
  /* next code value for each bit length */

  var code = 0;
  /* running code value */

  var bits;
  /* bit index */

  var n;
  /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */

  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));


  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1]
    /*.Len*/
    ;

    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */


    tree[n * 2]
    /*.Code*/
    = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}
/* ===========================================================================
 * Initialize the various 'constant' tables.
 */


function tr_static_init() {
  var n;
  /* iterates over tree elements */

  var bits;
  /* bit counter */

  var length;
  /* length value */

  var code;
  /* code value */

  var dist;
  /* distance index */

  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */

  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */

  length = 0;

  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;

    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  } //Assert (length == 256, "tr_static_init: length != 256");

  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */


  _length_code[length - 1] = code;
  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */

  dist = 0;

  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;

    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: dist != 256");


  dist >>= 7;
  /* from now on, all distances are divided by 128 */

  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;

    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */


  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;

  while (n <= 143) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 8;
    n++;
    bl_count[8]++;
  }

  while (n <= 255) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 9;
    n++;
    bl_count[9]++;
  }

  while (n <= 279) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 7;
    n++;
    bl_count[7]++;
  }

  while (n <= 287) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */


  gen_codes(static_ltree, L_CODES + 1, bl_count);
  /* The static distance tree is trivial: */

  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]
    /*.Len*/
    = 5;
    static_dtree[n * 2]
    /*.Code*/
    = bi_reverse(n, 5);
  } // Now data ready and we can init static trees


  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;
}
/* ===========================================================================
 * Initialize a new block.
 */


function init_block(s) {
  var n;
  /* iterates over tree elements */

  /* Initialize the trees. */

  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2]
    /*.Freq*/
    = 0;
  }

  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2]
    /*.Freq*/
    = 0;
  }

  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2]
    /*.Freq*/
    = 0;
  }

  s.dyn_ltree[END_BLOCK * 2]
  /*.Freq*/
  = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */


function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }

  s.bi_buf = 0;
  s.bi_valid = 0;
}
/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */


function copy_block(s, buf, len, header) //DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);
  /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  } //  while (len--) {
  //    put_byte(s, *buf++);
  //  }


  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */


function smaller(tree, n, m, depth) {
  var _n2 = n * 2;

  var _m2 = m * 2;

  return tree[_n2]
  /*.Freq*/
  < tree[_m2]
  /*.Freq*/
  || tree[_n2]
  /*.Freq*/
  === tree[_m2]
  /*.Freq*/
  && depth[n] <= depth[m];
}
/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */


function pqdownheap(s, tree, k) //    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;
  /* left son of k */

  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */


    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    /* Exchange v with the smallest son */


    s.heap[k] = s.heap[j];
    k = j;
    /* And continue down the tree, setting j to the left son of k */

    j <<= 1;
  }

  s.heap[k] = v;
} // inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */


function compress_block(s, ltree, dtree) //    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;
  /* distance of matched string */

  var lc;
  /* match length or unmatched char (if dist == 0) */

  var lx = 0;
  /* running index in l_buf */

  var code;
  /* the code to send */

  var extra;
  /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree);
        /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree);
        /* send the length code */

        extra = extra_lbits[code];

        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
          /* send the extra length bits */
        }

        dist--;
        /* dist is now the match distance - 1 */

        code = d_code(dist); //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);
        /* send the distance code */

        extra = extra_dbits[code];

        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
          /* send the extra distance bits */
        }
      }
      /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}
/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */


function build_tree(s, desc) //    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  /* iterate over heap elements */

  var max_code = -1;
  /* largest code with non zero frequency */

  var node;
  /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */

  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]
    /*.Freq*/
    !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1]
      /*.Len*/
      = 0;
    }
  }
  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */


  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2]
    /*.Freq*/
    = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]
      /*.Len*/
      ;
    }
    /* node is 0 or 1 so it does not have extra bits */

  }

  desc.max_code = max_code;
  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */

  for (n = s.heap_len >> 1
  /*int /2*/
  ; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */


  node = elems;
  /* next internal node of the tree */

  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */

    /*** pqremove ***/
    n = s.heap[1
    /*SMALLEST*/
    ];
    s.heap[1
    /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
    /***/

    m = s.heap[1
    /*SMALLEST*/
    ];
    /* m = node of next least frequency */

    s.heap[--s.heap_max] = n;
    /* keep the nodes sorted by frequency */

    s.heap[--s.heap_max] = m;
    /* Create a new node father of n and m */

    tree[node * 2]
    /*.Freq*/
    = tree[n * 2]
    /*.Freq*/
    + tree[m * 2]
    /*.Freq*/
    ;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]
    /*.Dad*/
    = tree[m * 2 + 1]
    /*.Dad*/
    = node;
    /* and insert the new node in the heap */

    s.heap[1
    /*SMALLEST*/
    ] = node++;
    pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1
  /*SMALLEST*/
  ];
  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */

  gen_bitlen(s, desc);
  /* The field len is now set, we can generate the bit codes */

  gen_codes(tree, max_code, s.bl_count);
}
/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */


function scan_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  var prevlen = -1;
  /* last emitted length */

  var curlen;
  /* length of current code */

  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  var count = 0;
  /* repeat count of the current code */

  var max_count = 7;
  /* max repeat count */

  var min_count = 4;
  /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  tree[(max_code + 1) * 2 + 1]
  /*.Len*/
  = 0xffff;
  /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2]
      /*.Freq*/
      += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }

      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */


function send_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  var prevlen = -1;
  /* last emitted length */

  var curlen;
  /* length of current code */

  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  var count = 0;
  /* repeat count of the current code */

  var max_count = 7;
  /* max repeat count */

  var min_count = 4;
  /* min repeat count */

  /* tree[max_code+1].Len = -1; */

  /* guard already set */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      } //Assert(count >= 3 && count <= 6, " 3_6?");


      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */


function build_bl_tree(s) {
  var max_blindex;
  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */

  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  /* Build the bit length tree: */

  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */

  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]
    /*.Len*/
    !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */


  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}
/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */


function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;
  /* index in bl_order */
  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));

  send_bits(s, lcodes - 257, 5);
  /* not +255 as stated in appnote.txt */

  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  /* not -3 as stated in appnote.txt */

  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]
    /*.Len*/
    , 3);
  } //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));


  send_tree(s, s.dyn_ltree, lcodes - 1);
  /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1);
  /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}
/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */


function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;
  /* Check for non-textual ("black-listed") bytes. */

  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2]
    /*.Freq*/
    !== 0) {
      return Z_BINARY;
    }
  }
  /* Check for textual ("white-listed") bytes. */


  if (s.dyn_ltree[9 * 2]
  /*.Freq*/
  !== 0 || s.dyn_ltree[10 * 2]
  /*.Freq*/
  !== 0 || s.dyn_ltree[13 * 2]
  /*.Freq*/
  !== 0) {
    return Z_TEXT;
  }

  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]
    /*.Freq*/
    !== 0) {
      return Z_TEXT;
    }
  }
  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */


  return Z_BINARY;
}

var static_init_done = false;
/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */

function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  /* Initialize the first block of the first file: */

  init_block(s);
}
/* ===========================================================================
 * Send a stored block
 */


function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  /* send block type */

  copy_block(s, buf, stored_len, true);
  /* with header */
}
/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */


function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */


function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;
  /* opt_len and static_len in bytes */

  var max_blindex = 0;
  /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */

  if (s.level > 0) {
    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }
    /* Construct the literal and distance trees */


    build_tree(s, s.l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */

    max_blindex = build_bl_tree(s);
    /* Determine the best encoding. Compute the block lengths in bytes. */

    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5;
    /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  } // Assert (s->compressed_len == s->bits_sent, "bad compressed size");

  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */


  init_block(s);

  if (last) {
    bi_windup(s);
  } // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));

}
/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */


function _tr_tally(s, dist, lc) //    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */

    dist--;
    /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  } // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif


  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers

  this.next_in = 0;
  /* number of bytes available at input */

  this.avail_in = 0;
  /* total number of input bytes read so far */

  this.total_in = 0;
  /* next output byte should be put there */

  this.output = null; // JS specific, because we have no pointers

  this.next_out = 0;
  /* remaining free space at output */

  this.avail_out = 0;
  /* total number of bytes output so far */

  this.total_out = 0;
  /* last error message, NULL if no error */

  this.msg = ''
  /*Z_NULL*/
  ;
  /* not visible by applications */

  this.state = null;
  /* best guess about the data type: binary or text */

  this.data_type = 2
  /*Z_UNKNOWN*/
  ;
  /* adler32 value of the uncompressed data */

  this.adler = 0;
}

module.exports = ZStream;

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = {
    nextTick: nextTick
  };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args, i;

  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);

    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });

    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });

    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });

    default:
      args = new Array(len - 1);
      i = 0;

      while (i < args.length) {
        args[i++] = arguments[i];
      }

      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/


var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;
/*<replacement>*/

var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");

var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);
{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // the no-half-open enforcer

function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();
  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");
/*<replacement>*/


var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/


module.exports = Readable;
/*<replacement>*/

var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/


var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/


var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/

var debugUtil = __webpack_require__(/*! util */ 0);

var debug = void 0;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "./node_modules/readable-stream/lib/internal/streams/BufferList.js");

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/node-libs-browser/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  } // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.


  var increasedAwaitDrain = false;
  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);

    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;

    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;

      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {}
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
} // Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function fromListPartial(n, list, hasStrings) {
  var ret;

  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }

  return ret;
} // Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;

  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;

    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
} // Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;

  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;

    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
/*<replacement>*/


var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);

    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");

util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js"); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;

var util = __webpack_require__(/*! util */ 1);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({
      length: this.length
    });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/
// undocumented cb() API, needed for core, not for public API


function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").PassThrough;

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").Transform;

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
} // Copy static methods from Buffer


copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ "./node_modules/readable-stream/readable-browser.js");
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ "./node_modules/readable-stream/writable-browser.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ "./node_modules/readable-stream/duplex-browser.js");
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ "./node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ "./node_modules/readable-stream/passthrough.js"); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  } // blank or null?


  if (!css || typeof css !== "string") {
    return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

  /*
  This regular expression is just a way to recursively match brackets within
  a string.
  	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
     (  = Start a capturing group
       (?:  = Start a non-capturing group
           [^)(]  = Match anything that isn't a parentheses
           |  = OR
           \(  = Match a start parentheses
               (?:  = Start another non-capturing groups
                   [^)(]+  = Match anything that isn't a parentheses
                   |  = OR
                   \(  = Match a start parentheses
                       [^)(]*  = Match anything that isn't a parentheses
                   \)  = Match a end parentheses
               )  = End Group
               *\) = Match anything and then a close parens
           )  = Close non-capturing group
           *  = Match anything
        )  = Close capturing group
   \)  = Match a close parens
  	 /gi  = Get all matches, not the first.  Be case insensitive.
   */

  var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
    // strip quotes (if they exist)
    var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
      return $1;
    }).replace(/^'(.*)'$/, function (o, $1) {
      return $1;
    }); // already a full url? no change

    if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
      return fullMatch;
    } // convert the url to a full url


    var newUrl;

    if (unquotedOrigUrl.indexOf("//") === 0) {
      //TODO: should we add protocol?
      newUrl = unquotedOrigUrl;
    } else if (unquotedOrigUrl.indexOf("/") === 0) {
      // path should be relative to the base url
      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
    } else {
      // path should be relative to current directory
      newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
    } // send back the fixed url(...)


    return "url(" + JSON.stringify(newUrl) + ")";
  }); // send back the fixed css

  return fixedCss;
};

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/automaton.json":
/*!****************************!*\
  !*** ./src/automaton.json ***!
  \****************************/
/*! exports provided: v, length, resolution, params, guiSettings, default */
/***/ (function(module) {

module.exports = {"v":"2.0.1","length":3,"resolution":1000,"params":{"camera-rotY":{"nodes":[{"time":0,"value":0,"out":{"time":0,"value":0}},{"time":0.30000000000000004,"value":0.1,"in":{"time":0,"value":0},"out":{"time":0.10095693779904313,"value":0}},{"time":0.4,"value":0.2,"in":{"time":-0.11531100478468903,"value":0},"out":{"time":0,"value":0}},{"time":0.9,"value":0.4,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1,"value":1,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":2.4401913875598082,"value":1.9000000000000001,"in":{"time":-0.08086124401913874,"value":-0.07902169906381928},"out":{"time":0.08086124401913874,"value":0.07902169906381928}},{"time":3,"value":2.7,"in":{"time":-0.0693779904306222,"value":-0.04451536234671494}}],"fxs":[{"time":0,"length":3,"row":0,"def":"noise","params":{"recursion":2,"freq":1,"reso":4,"seed":1,"amp":0.1}},{"time":0.9,"length":0.09999999999999998,"row":1,"def":"lofi","params":{"rate":40,"relative":false,"reso":0,"round":false}}]},"camera-rotX":{"nodes":[{"time":0,"value":0.4,"out":{"time":0,"value":0}},{"time":3,"value":0.4,"in":{"time":0,"value":0}}],"fxs":[{"time":0,"length":3,"row":0,"def":"noise","params":{"recursion":2,"freq":1,"reso":4,"seed":4,"amp":0.05}},{"time":0,"length":3,"row":1,"def":"sine","params":{"amp":0.1,"freq":1,"phase":0.25}}]},"particles-genRate":{"nodes":[{"time":0,"value":1,"out":{"time":0,"value":0}},{"time":3,"value":1,"in":{"time":0,"value":0}}],"fxs":[]},"particles-colorVar":{"nodes":[{"time":0,"value":0.2,"out":{"time":0,"value":0}},{"time":3,"value":0.2,"in":{"time":0,"value":0}}],"fxs":[]},"particles-colorOffset":{"nodes":[{"time":0,"value":0,"out":{"time":0,"value":0}},{"time":3,"value":0,"in":{"time":0,"value":0}}],"fxs":[]},"post-barrelAmp":{"nodes":[{"time":0,"value":0.1,"out":{"time":0,"value":0}},{"time":3,"value":0.1,"in":{"time":0,"value":0}}],"fxs":[]},"post-barrelOffset":{"nodes":[{"time":0,"value":0,"out":{"time":0,"value":0}},{"time":3,"value":0,"in":{"time":0,"value":0}}],"fxs":[]},"particles-noisePhase":{"nodes":[{"time":0,"value":0,"out":{"time":0,"value":0}},{"time":3,"value":0,"in":{"time":0,"value":0}}],"fxs":[{"time":0,"length":3,"row":0,"def":"sine","params":{"amp":2.74,"freq":1,"phase":0.39}}]},"camera-Radius":{"nodes":[{"time":0,"value":6.5,"out":{"time":0,"value":0}},{"time":0.3,"value":6.5,"in":{"time":0,"value":0},"out":{"time":0.10956937799043076,"value":0}},{"time":0.4,"value":7,"in":{"time":-0.1267942583732058,"value":0},"out":{"time":0,"value":0}},{"time":0.9,"value":7,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1,"value":6,"in":{"time":0,"value":0},"out":{"time":1.2980861244019146,"value":0}},{"time":2.943062200956938,"value":3.4000000000000004,"in":{"time":-0.11244019138755945,"value":0},"out":{"time":0.05215311004784651,"value":0}},{"time":3,"value":6.5,"in":{"time":0,"value":0}}],"fxs":[{"time":0.9,"length":0.09999999999999998,"row":0,"def":"lofi","params":{"rate":40,"relative":false,"reso":0,"round":false}}]},"box-phase":{"nodes":[{"time":0,"value":1,"out":{"time":0,"value":0}},{"time":3,"value":1,"in":{"time":0,"value":0}}],"fxs":[]},"particles-noiseAmp":{"nodes":[{"time":0,"value":1,"out":{"time":0,"value":0}},{"time":3,"value":1,"in":{"time":0,"value":0}}],"fxs":[]},"particles-fluidAmp":{"nodes":[{"time":0,"value":1,"out":{"time":0,"value":0}},{"time":3,"value":1,"in":{"time":0,"value":0}}],"fxs":[]},"pixelsort-threshold":{"nodes":[{"time":0,"value":1,"out":{"time":0.07511961722488025,"value":0}},{"time":0.30000000000000004,"value":0.4,"in":{"time":-0.24091856659081845,"value":0.050985676884311916},"out":{"time":0.0790075075836925,"value":-0.016720385274160466}},{"time":0.4,"value":0,"in":{"time":-0.0923444976076554,"value":0},"out":{"time":0,"value":0}},{"time":1.3,"value":0,"in":{"time":0,"value":0},"out":{"time":0.1267942583732058,"value":0}},{"time":1.5,"value":0.97,"in":{"time":-0.05215311004784695,"value":0},"out":{"time":0.37368421052631584,"value":0}},{"time":1.9000000000000001,"value":0,"in":{"time":-0.07511961722488025,"value":0},"out":{"time":0,"value":0}},{"time":2,"value":0,"in":{"time":0,"value":0},"out":{"time":0.07,"value":0}},{"time":2.0727272727272728,"value":0.30000000000000004,"in":{"time":-0.05,"value":0},"out":{"time":0.08660287081339701,"value":0}},{"time":2.477511961722488,"value":0,"in":{"time":-0.3076555023923446,"value":0},"out":{"time":0.11244019138756034,"value":0}},{"time":2.7794258373205754,"value":0.23981549346564557,"in":{"time":-0.05502392344497542,"value":-0.07854478730923464},"out":{"time":0.05502392344497542,"value":0.07854478730923464}},{"time":2.8253588516746415,"value":0.4,"in":{"time":-0.03193419667958931,"value":-0.0010328881018948786},"out":{"time":0,"value":0.004541941784246467}},{"time":2.9000000000000004,"value":0.4,"in":{"time":0,"value":0},"out":{"time":0.07138755980861282,"value":0}},{"time":3,"value":1,"in":{"time":-0.02631578947368407,"value":0}}],"fxs":[]},"deltaTime-multiplier":{"nodes":[{"time":0,"value":1,"out":{"time":0.049282296650717705,"value":0.6911764705882355}},{"time":0.30000000000000004,"value":2,"in":{"time":-0.07224880382775123,"value":0},"out":{"time":0.08947368421052615,"value":0}},{"time":0.5,"value":2,"in":{"time":0,"value":0},"out":{"time":0.06363636363636371,"value":0}},{"time":0.6000000000000001,"value":1,"in":{"time":-0.08947368421052626,"value":0},"out":{"time":1.5449760765550238,"value":0}},{"time":3,"value":0,"in":{"time":-0.5,"value":0}}],"fxs":[]},"pixelsort-shadow":{"nodes":[{"time":0,"value":1,"out":{"time":0,"value":0}},{"time":1,"value":1,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":1,"value":0,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":2,"value":0,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":2,"value":1,"in":{"time":0,"value":0},"out":{"time":0,"value":0}},{"time":3,"value":1,"in":{"time":0,"value":0}}],"fxs":[]}},"guiSettings":{"snapActive":true,"snapTime":0.1,"snapValue":0.1}};

/***/ }),

/***/ "./src/config.json":
/*!*************************!*\
  !*** ./src/config.json ***!
  \*************************/
/*! exports provided: resolution, shadowReso, default */
/***/ (function(module) {

module.exports = {"resolution":[640,640],"shadowReso":512};

/***/ }),

/***/ "./src/geoms/cube.js":
/*!***************************!*\
  !*** ./src/geoms/cube.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var genCube = function genCube(_props) {
  var props = Object.assign({
    size: 1.0
  }, _props);
  var pos = [];
  var nor = [];
  var ind = [];
  var S = props.size;

  var _loop = function _loop(i) {
    var p = [[-S, -S, S], [S, -S, S], [-S, S, S], [S, S, S]];
    var n = [[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]];
    var id = [0, 1, 3, 0, 3, 2].map(function (v) {
      return v + i * 4;
    });

    if (i !== 0) {
      var func = function func(v) {
        if (i < 4) {
          var t = i * Math.PI / 2.0;
          var x = v[0];
          var z = v[2];
          v[0] = Math.cos(t) * x - Math.sin(t) * z;
          v[2] = Math.sin(t) * x + Math.cos(t) * z;
        } else {
          var _t = (i - 0.5) * Math.PI;

          var y = v[1];
          var _z = v[2];
          v[1] = Math.cos(_t) * y - Math.sin(_t) * _z;
          v[2] = Math.sin(_t) * y + Math.cos(_t) * _z;
        }
      };

      p.map(func);
      n.map(func);
    }

    p.map(function (v) {
      return pos.push.apply(pos, _toConsumableArray(v));
    });
    n.map(function (v) {
      return nor.push.apply(nor, _toConsumableArray(v));
    });
    ind.push.apply(ind, _toConsumableArray(id));
  };

  for (var i = 0; i < 6; i++) {
    _loop(i);
  }

  return {
    position: pos,
    normal: nor,
    index: ind
  };
};

module.exports = genCube;

/***/ }),

/***/ "./src/geoms/octahedron.js":
/*!*********************************!*\
  !*** ./src/geoms/octahedron.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var genOctahedron = function genOctahedron(_props) {
  var props = Object.assign({
    div: 1.0
  }, _props);
  var div = parseInt(Math.max(0, props.div));
  var pos = [];
  var nor = [];
  var ind = [];

  for (var ii = 0; ii < 2; ii++) {
    for (var iq = 0; iq < 4; iq++) {
      for (var iy = 0; iy < div + 1; iy++) {
        for (var ix = 0; ix < iy + 1; ix++) {
          var lat0 = (ii * 2.0 + iy / (div + 1)) * Math.PI / 2.0;
          var lat1 = (ii * 2.0 + (iy + 1) / (div + 1)) * Math.PI / 2.0;
          var lon0 = (ii * 2.0 - 1.0) * ((ix - 1) / Math.max(1, iy) + iq) * Math.PI / 2.0;
          var lon1 = (ii * 2.0 - 1.0) * (ix / (iy + 1) + iq) * Math.PI / 2.0;
          var lon2 = (ii * 2.0 - 1.0) * (ix / Math.max(1, iy) + iq) * Math.PI / 2.0;
          var lon3 = (ii * 2.0 - 1.0) * ((ix + 1) / (iy + 1) + iq) * Math.PI / 2.0;

          if (ix !== 0) {
            ind.push(pos.length / 3, pos.length / 3 + 1, pos.length / 3 + 2);
            var x1 = Math.sin(lat0) * Math.cos(lon0);
            var y1 = Math.cos(lat0);
            var z1 = Math.sin(lat0) * Math.sin(lon0);
            var x2 = Math.sin(lat1) * Math.cos(lon1);
            var y2 = Math.cos(lat1);
            var z2 = Math.sin(lat1) * Math.sin(lon1);
            var x3 = Math.sin(lat0) * Math.cos(lon2);
            var y3 = Math.cos(lat0);
            var z3 = Math.sin(lat0) * Math.sin(lon2);
            pos.push(x1, y1, z1, x2, y2, z2, x3, y3, z3);
            {
              var x = x1 + x2 + x3;
              var y = y1 + y2 + y3;
              var z = z1 + z2 + z3;
              var l = Math.sqrt(x * x + y * y + z * z);

              for (var i = 0; i < 3; i++) {
                nor.push(x / l, y / l, z / l);
              }
            }
          }

          {
            ind.push(pos.length / 3, pos.length / 3 + 1, pos.length / 3 + 2);

            var _x = Math.sin(lat0) * Math.cos(lon2);

            var _y = Math.cos(lat0);

            var _z = Math.sin(lat0) * Math.sin(lon2);

            var _x2 = Math.sin(lat1) * Math.cos(lon1);

            var _y2 = Math.cos(lat1);

            var _z2 = Math.sin(lat1) * Math.sin(lon1);

            var _x3 = Math.sin(lat1) * Math.cos(lon3);

            var _y3 = Math.cos(lat1);

            var _z3 = Math.sin(lat1) * Math.sin(lon3);

            pos.push(_x, _y, _z, _x2, _y2, _z2, _x3, _y3, _z3);
            {
              var _x4 = _x + _x2 + _x3;

              var _y4 = _y + _y2 + _y3;

              var _z4 = _z + _z2 + _z3;

              var _l = Math.sqrt(_x4 * _x4 + _y4 * _y4 + _z4 * _z4);

              for (var _i = 0; _i < 3; _i++) {
                nor.push(_x4 / _l, _y4 / _l, _z4 / _l);
              }
            }
          }
        }
      }
    }
  }

  return {
    position: pos,
    normal: nor,
    index: ind
  };
};

module.exports = genOctahedron;

/***/ }),

/***/ "./src/libs/canvas-saver.js":
/*!**********************************!*\
  !*** ./src/libs/canvas-saver.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var JSZip = __webpack_require__(/*! jszip */ "./node_modules/jszip/lib/index.js");

var CanvasSaver =
/*#__PURE__*/
function () {
  function CanvasSaver(canvas) {
    _classCallCheck(this, CanvasSaver);

    this.canvas = canvas;
    this.queueSave = false;
    this.zip = new JSZip();
    this.anchor = document.createElement('a');
    this.frameCount = 0;
    this.inProgress = 0;
  }

  _createClass(CanvasSaver, [{
    key: "capture",
    value: function capture() {
      var _this = this;

      if (this.queueSave) {
        console.error('You already queued save command! Further captures are ignored.');
        return;
      }

      var filename = ('0000' + this.frameCount).slice(-5) + '.png';
      this.frameCount++;
      this.inProgress++;
      this.canvas.toBlob(function (blob) {
        _this.zip.file(filename, blob);

        _this.inProgress--;

        _this.__done();
      });
    }
  }, {
    key: "save",
    value: function save() {
      this.queueSave = true;

      this.__done();
    }
  }, {
    key: "__done",
    value: function __done() {
      var _this2 = this;

      if (this.queueSave && this.inProgress === 0) {
        this.zip.generateAsync({
          type: 'blob'
        }).then(function (blob) {
          _this2.anchor.href = window.URL.createObjectURL(blob);
          _this2.anchor.download = 'canvasSaver-' + Date.now();

          _this2.anchor.click();

          _this2.frameCount = 0;
          _this2.queueSave = false;
        });
      }
    }
  }]);

  return CanvasSaver;
}();

module.exports = CanvasSaver;

/***/ }),

/***/ "./src/libs/glcat-path-gui.js":
/*!************************************!*\
  !*** ./src/libs/glcat-path-gui.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _glcat_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glcat-path */ "./src/libs/glcat-path.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }



var requiredFields = function requiredFields(object, nanithefuck, fields) {
  fields.map(function (field) {
    if (typeof object[field] === 'undefined') {
      throw 'GLCat-Path: ' + field + ' is required for ' + nanithefuck;
    }
  });
};

var PathGUI =
/*#__PURE__*/
function (_Path) {
  _inherits(PathGUI, _Path);

  function PathGUI(glCat, params) {
    var _this;

    _classCallCheck(this, PathGUI);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PathGUI).call(this, glCat, params));

    var it = _assertThisInitialized(_assertThisInitialized(_this));

    requiredFields(params, 'params', ['canvas', 'el']);
    it.gui = {
      parent: it.params.el
    };
    it.gui.info = document.createElement('span');
    it.gui.parent.appendChild(it.gui.info);
    it.gui.range = document.createElement('input');
    it.gui.range.type = 'range';
    it.gui.range.min = 0;
    it.gui.range.max = 0;
    it.gui.range.step = 1;
    it.gui.parent.appendChild(it.gui.range);
    it.dateList = new Array(30).fill(0);
    it.dateListIndex = 0;
    it.totalFrames = 0;
    it.fps = 0;
    it.currentIndex = 0;
    it.viewName = '';
    it.viewIndex = 0;
    var gl = glCat.gl;
    var vboQuad = glCat.createVertexbuffer(new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]));
    it.add({
      __PathGuiReturn: {
        width: it.params.canvas.width,
        height: it.params.canvas.height,
        vert: 'attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}',
        frag: 'precision highp float;uniform vec2 r;uniform sampler2D s;void main(){gl_FragColor=texture2D(s,gl_FragCoord.xy/r);}',
        blend: [gl.ONE, gl.ONE],
        clear: [0.0, 0.0, 0.0, 1.0],
        func: function func(_p, params) {
          gl.viewport(0, 0, it.params.canvas.width, it.params.canvas.height);
          glCat.uniform2fv('r', [it.params.canvas.width, it.params.canvas.height]);
          glCat.attribute('p', vboQuad, 2);
          glCat.uniformTexture('s', params.input, 0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
      }
    });
    return _this;
  }

  _createClass(PathGUI, [{
    key: "begin",
    value: function begin() {
      var it = this;
      it.currentIndex = 0;
    }
  }, {
    key: "end",
    value: function end() {
      var it = this;
      it.gui.range.max = Math.max(it.gui.range.max, it.currentIndex);
      it.currentIndex = 0;
      var now = +new Date() * 1E-3;
      it.dateList[it.dateListIndex] = now;
      it.dateListIndex = (it.dateListIndex + 1) % it.dateList.length;
      it.fps = ((it.dateList.length - 1) / (now - it.dateList[it.dateListIndex])).toFixed(1);
      it.totalFrames++;
      it.gui.info.innerText = 'Path: ' + it.viewName + ' (' + it.viewIndex + ')\n' + it.fps + ' FPS\n' + it.totalFrames + ' frames\n';
    }
  }, {
    key: "render",
    value: function render(name, params) {
      var it = this;
      it.currentIndex++;
      var view = parseInt(it.gui.range.value);

      if (it.currentIndex <= view || view === 0) {
        it.viewName = view === 0 ? '*Full*' : name;
        it.viewIndex = it.currentIndex;

        _get(_getPrototypeOf(PathGUI.prototype), "render", this).call(this, name, params);

        if (it.currentIndex === view) {
          var t = params && params.target ? params.target : it.paths[name].framebuffer;

          if (t && t.framebuffer) {
            var i = t.textures ? t.textures[0] : t.texture;

            if (it.params.stretch) {
              _get(_getPrototypeOf(PathGUI.prototype), "render", this).call(this, '__PathGuiReturn', {
                target: PathGUI.nullFb,
                input: i,
                width: it.params.canvas.width,
                height: it.params.canvas.height
              });
            } else {
              it.params.canvas.width = (params ? params.width : 0) || it.paths[name].width || it.params.width;
              it.params.canvas.height = (params ? params.height : 0) || it.paths[name].height || it.params.height;

              _get(_getPrototypeOf(PathGUI.prototype), "render", this).call(this, '__PathGuiReturn', {
                target: PathGUI.nullFb,
                input: i
              });
            }
          }
        }
      }
    }
  }]);

  return PathGUI;
}(_glcat_path__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (PathGUI);

/***/ }),

/***/ "./src/libs/glcat-path.js":
/*!********************************!*\
  !*** ./src/libs/glcat-path.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var requiredFields = function requiredFields(object, nanithefuck, fields) {
  fields.map(function (field) {
    if (typeof object[field] === 'undefined') {
      throw 'GLCat-Path: ' + field + ' is required for ' + nanithefuck;
    }
  });
};

var Path =
/*#__PURE__*/
function () {
  function Path(glCat, params) {
    _classCallCheck(this, Path);

    var it = this;
    it.glCat = glCat;
    it.gl = glCat.gl;
    it.paths = {};

    it.globalFunc = function () {};

    it.params = params || {};
  }

  _createClass(Path, [{
    key: "add",
    value: function add(paths) {
      var it = this;

      for (var name in paths) {
        var path = paths[name];
        requiredFields(path, 'path object', ['vert', 'frag']);
        it.paths[name] = path;

        if (typeof path.depthTest === 'undefined') {
          path.depthTest = true;
        }

        if (typeof path.depthWrite === 'undefined') {
          path.depthWrite = true;
        }

        if (typeof path.blend === 'undefined') {
          path.blend = [it.gl.SRC_ALPHA, it.gl.ONE_MINUS_SRC_ALPHA];
        }

        if (typeof path.cull === 'undefined') {
          path.cull = true;
        }

        if (path.framebuffer) {
          if (path.drawbuffers) {
            path.framebuffer = it.glCat.createDrawBuffers(path.width, path.height, path.drawbuffers);
          } else if (path.float) {
            path.framebuffer = it.glCat.createFloatFramebuffer(path.width, path.height);
          } else {
            path.framebuffer = it.glCat.createFramebuffer(path.width, path.height);
          }

          if (path.filter) {
            it.glCat.textureFilter(path.framebuffer.texture, path.filter);
          }

          if (path.wrap) {
            it.glCat.textureWrap(path.framebuffer.texture, path.wrap);
          }
        }

        path.program = it.glCat.createProgram(path.vert, path.frag);
      }
    }
  }, {
    key: "render",
    value: function render(name, params) {
      var _it$gl;

      var it = this;
      var path = it.paths[name];

      if (!path) {
        throw 'GLCat-Path: The path called ' + name + ' is not defined!';
      }

      if (!params) {
        params = {};
      }

      params.framebuffer = typeof params.target !== 'undefined' ? params.target.framebuffer : path.framebuffer ? path.framebuffer.framebuffer : null;
      var width = params.width || path.width;
      var height = params.height || path.height;

      if (!width || !height) {
        throw 'GLCat-Path: width or height is invalid';
      }

      it.gl.viewport(0, 0, width, height);
      it.glCat.useProgram(path.program);
      path.cull ? it.gl.enable(it.gl.CULL_FACE) : it.gl.disable(it.gl.CULL_FACE);
      it.gl.bindFramebuffer(it.gl.FRAMEBUFFER, params.framebuffer);

      if (it.params.drawbuffers) {
        it.glCat.drawBuffers(path.drawbuffers ? path.drawbuffers : params.framebuffer === null ? [it.gl.BACK] : [it.gl.COLOR_ATTACHMENT0]);
      }

      (_it$gl = it.gl).blendFunc.apply(_it$gl, _toConsumableArray(path.blend));

      if (path.clear) {
        var _it$glCat;

        (_it$glCat = it.glCat).clear.apply(_it$glCat, _toConsumableArray(path.clear));
      }

      path.depthTest ? it.gl.enable(it.gl.DEPTH_TEST) : it.gl.disable(it.gl.DEPTH_TEST);
      path.depthWrite ? it.gl.depthMask(true) : it.gl.depthMask(false);
      it.glCat.uniform2fv('resolution', [width, height]);
      it.globalFunc(path, params);

      if (path.func) {
        path.func(path, params);
      }
    }
  }, {
    key: "replaceProgram",
    value: function replaceProgram(name, vert, frag) {
      var path = this.paths[name];

      if (!path) {
        throw 'GLCat-Path: The path called ' + name + ' is not defined!';
      }

      try {
        var prevProgram = path.program;
        var newProgram = this.glCat.createProgram(vert, frag);

        if (newProgram) {
          path.program = newProgram;
          this.gl.deleteProgram(prevProgram.program);
          this.gl.deleteShader(prevProgram.vert);
          this.gl.deleteShader(prevProgram.frag);
        }
      } catch (e) {
        console.error(e);
      }
    }
  }, {
    key: "resize",
    value: function resize(name, width, height) {
      var it = this;
      var path = it.paths[name];
      path.width = width;
      path.height = height;

      if (path.framebuffer) {
        if (it.params.drawbuffers && path.drawbuffers) {
          path.framebuffer = it.glCat.createDrawBuffers(path.width, path.height, path.drawbuffers);
        } else if (path.float) {
          it.glCat.resizeFloatFramebuffer(path.framebuffer, path.width, path.height);
        } else {
          it.glCat.resizeFramebuffer(path.framebuffer, path.width, path.height);
        }
      }

      if (typeof path.onresize === 'function') {
        path.onresize(path, width, height);
      }
    }
  }, {
    key: "setGlobalFunc",
    value: function setGlobalFunc(func) {
      this.globalFunc = func;
    }
  }, {
    key: "fb",
    value: function fb(name) {
      if (!this.paths[name]) {
        throw 'glcat-path.fb: path called ' + name + ' is not defined';
      }

      if (!this.paths[name].framebuffer) {
        throw 'glcat-path.fb: there is no framebuffer for the path ' + name;
      }

      return this.paths[name].framebuffer;
    }
  }]);

  return Path;
}();

Path.nullFb = {
  framebuffer: null
};
/* harmony default export */ __webpack_exports__["default"] = (Path);

/***/ }),

/***/ "./src/libs/glcat.js":
/*!***************************!*\
  !*** ./src/libs/glcat.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @typedef {Object} GLCatProgram
 * @property {WebGLProgram} program
 * @property {Object<string,GLint|WebGLUniformLocation>} locations
 */

/**
 * @typedef {Object} GLCatFramebuffer
 * @property {WebGLFramebuffer} framebuffer
 * @property {WebGLRenderbuffer} depth
 * @property {WebGLTexture} texture
 */

/**
 * @typedef {Object} GLCatDrawBuffers
 * @property {WebGLFramebuffer} framebuffer
 * @property {WebGLRenderbuffer} depth
 * @property {WebGLTexture[]} textures
 */

/**
 * @typedef {ImageBitmap|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} Pixelable
 */

/**
 * WebGL wrapper with lots of respect to the original API, starring FMS_Cat.
 */
var GLCat =
/*#__PURE__*/
function () {
  /**
   * Create a new GLCat instance.
   * @param {WebGLRenderingContext} _gl Original WebGL context
   */
  function GLCat(_gl) {
    _classCallCheck(this, GLCat);

    this.gl = _gl;
    var gl = this.gl;
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    /**
     * Contain extensions.  
     * Keys are extension name, and values are extension object.
     * @type {Object<string,WebGLExtension>}
     * @protected
     */

    this.__extensions = {};
    /**
     * Currently using program.
     * @type {WebGLProgram}
     * @protected
     */

    this.__currentProgram = null;
  }
  /**
   * Get a new or existing extension object.
   * @param {string} _name Name of the extension
   * @param {boolean} [_throw=false] If this is true, exception will be throwed when it is failed to get extension
   * @returns {WebGLExtension} Extension object
   */


  _createClass(GLCat, [{
    key: "getExtension",
    value: function getExtension(_name, _throw) {
      var _this = this;

      var gl = this.gl;

      if (_typeof(_name) === 'object' && _name.isArray()) {
        return _name.every(function (name) {
          return _this.getExtension(name, _throw);
        });
      } else if (typeof _name === 'string') {
        if (this.__extensions[_name]) {
          return this.__extensions[_name];
        } else {
          this.__extensions[_name] = gl.getExtension(_name);

          if (this.__extensions[_name]) {
            return this.__extensions[_name];
          } else {
            if (_throw) {
              throw new Error('The extension "' + _name + '" is not supported');
            }

            return null;
          }
        }
      } else {
        throw new Error('GLCat.getExtension: _name must be string or array');
      }
    }
    /**
     * Create a new GLCat program object.
     * @param {string} _vert GLSL source of the vertex shader
     * @param {string} _frag GLSL source of the fragment shader
     * @param {Function} [_onError] Will be called if compile/link error is occurred
     * @returns {GLCatProgram} Created program
     */

  }, {
    key: "createProgram",
    value: function createProgram(_vert, _frag, _onError) {
      var gl = this.gl;
      var error;

      if (typeof _onError === 'function') {
        error = _onError;
      } else {
        error = function error(_str) {
          throw new Error(_str);
        };
      }

      var vert = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vert, _vert);
      gl.compileShader(vert);

      if (!gl.getShaderParameter(vert, gl.COMPILE_STATUS)) {
        error(gl.getShaderInfoLog(vert));
        gl.deleteShader(vert);
        return null;
      }

      var frag = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(frag, _frag);
      gl.compileShader(frag);

      if (!gl.getShaderParameter(frag, gl.COMPILE_STATUS)) {
        error(gl.getShaderInfoLog(frag));
        gl.deleteShader(vert);
        gl.deleteShader(frag);
        return null;
      }

      var program = gl.createProgram();
      gl.attachShader(program, vert);
      gl.attachShader(program, frag);
      gl.linkProgram(program);

      if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
        return {
          vert: vert,
          frag: frag,
          program: program,
          locations: {}
        };
      } else {
        error(gl.getProgramInfoLog(program));
        gl.deleteShader(vert);
        gl.deleteShader(frag);
        gl.deleteProgram(program);
        return null;
      }
    }
    /**
     * Specity a program to use.
     * @param {GLCatProgram} _program Program you want to use
     * @returns {void} void
     */

  }, {
    key: "useProgram",
    value: function useProgram(_program) {
      var gl = this.gl;
      gl.useProgram(_program.program);
      this.__currentProgram = _program;
    }
    /**
     * Create a new vertex buffer.
     * @param {ArrayBuffer|ArrayBufferView} _source Source of the data
     * @returns {WebGLBuffer} Generated vertex buffer
     */

  }, {
    key: "createVertexbuffer",
    value: function createVertexbuffer(_source) {
      var gl = this.gl;
      var buffer = gl.createBuffer();

      if (_source) {
        this.setVertexbuffer(buffer, _source);
      }

      return buffer;
    }
    /**
     * Set new data into a vertex buffer.
     * @param {WebGLBuffer} _target Target vertex buffer
     * @param {ArrayBuffer|ArrayBufferView} _source Source of the data
     * @param {GLenum} [_usage=gl.STATIC_DRAW] Usage of the buffer
     * @returns {void} void
     */

  }, {
    key: "setVertexbuffer",
    value: function setVertexbuffer(_target, _source, _usage) {
      var gl = this.gl;
      var usage = _usage || gl.STATIC_DRAW;
      gl.bindBuffer(gl.ARRAY_BUFFER, _target);
      gl.bufferData(gl.ARRAY_BUFFER, _source, usage);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    /**
     * Create a new index buffer.
     * @param {ArrayBuffer|ArrayBufferView} _source Source of the data
     * @returns {WebGLBuffer} Generated index buffer
     */

  }, {
    key: "createIndexbuffer",
    value: function createIndexbuffer(_source) {
      var gl = this.gl;
      var buffer = gl.createBuffer();

      if (_source) {
        this.setIndexbuffer(buffer, _source);
      }

      return buffer;
    }
    /**
     * Set new data into a index buffer.
     * @param {WebGLBuffer} _target Target index buffer
     * @param {ArrayBuffer|ArrayBufferView} _source Source of the data
     * @param {GLenum} [_usage=gl.STATIC_DRAW] Usage of the buffer
     * @returns {void} void
     */

  }, {
    key: "setIndexbuffer",
    value: function setIndexbuffer(_target, _source, _usage) {
      var gl = this.gl;
      var usage = _usage || gl.STATIC_DRAW;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _target);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, _source, usage);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }
    /**
     * Get location for given attribute variable name for current program.
     * @param {string} _name Name of the attribute variable
     * @returns {GLint} Location of the attribute variable
     */

  }, {
    key: "getAttribLocation",
    value: function getAttribLocation(_name) {
      var gl = this.gl;
      var location;

      if (this.__currentProgram.locations[_name]) {
        location = this.__currentProgram.locations[_name];
      } else {
        location = gl.getAttribLocation(this.__currentProgram.program, _name);
        this.__currentProgram.locations[_name] = location;
      }

      return location;
    }
    /**
     * Attach an vertex buffer as attribute variable to the current program.
     * @param {string} _name Name of the attribute variable
     * @param {WebGLBuffer} _buffer Vertex buffer
     * @param {GLint} _size Number of components per vertex. Must be 1, 2, 3 or 4
     * @param {GLenum} [_type=gl.FLOAT] Data type of each component
     * @param {GLsizei} [_stride=0] Stride in bytes
     * @param {GLintptr} [_offset=0] Offset in bytes
     * @returns {void} void
     */

  }, {
    key: "attribute",
    value: function attribute(_name, _buffer, _size, _type, _stride, _offset) {
      var gl = this.gl;
      var location = this.getAttribLocation(_name);

      if (location === -1) {
        return;
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);
      gl.enableVertexAttribArray(location);
      gl.vertexAttribPointer(location, _size, _type || gl.FLOAT, false, _stride || 0, _offset || 0);
      var ext = this.getExtension('ANGLE_instanced_arrays');

      if (ext) {
        ext.vertexAttribDivisorANGLE(location, 0);
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    /**
     * Attach an vertex buffer as attribute variable to the current program.  
     * Can set divisor at 4th argument for use of instancing.
     * @param {string} _name Name of the attribute variable
     * @param {WebGLBuffer} _buffer Vertex buffer
     * @param {GLint} _size Number of components per vertex. Must be 1, 2, 3 or 4
     * @param {GLuint} _div Divisor of the attribute
     * @param {GLenum} [_type=gl.FLOAT] Data type of each component
     * @param {GLsizei} [_stride=0] Stride in bytes
     * @param {GLintptr} [_offset=0] Offset in bytes
     * @returns {void} void
     */

  }, {
    key: "attributeDivisor",
    value: function attributeDivisor(_name, _buffer, _size, _div, _type, _stride, _offset) {
      var gl = this.gl;
      this.getExtension('ANGLE_instanced_arrays', true);
      var location = this.getAttribLocation(_name);

      if (location === -1) {
        return;
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);
      gl.enableVertexAttribArray(location);
      gl.vertexAttribPointer(location, _size, _type || gl.FLOAT, false, _stride || 0, _offset || 0);
      var ext = this.getExtension('ANGLE_instanced_arrays');

      if (ext) {
        ext.vertexAttribDivisorANGLE(location, _div);
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    /**
     * Get location for given uniform variable name for current program.
     * @param {string} _name Name of the uniform variable
     * @returns {WebGLUniformLocation} Location of the uniform variable
     */

  }, {
    key: "getUniformLocation",
    value: function getUniformLocation(_name) {
      var gl = this.gl;
      var location;

      if (typeof this.__currentProgram.locations[_name] !== 'undefined') {
        location = this.__currentProgram.locations[_name];
      } else {
        location = gl.getUniformLocation(this.__currentProgram.program, _name);
        this.__currentProgram.locations[_name] = location;
      }

      return location;
    }
    /**
     * Attach an uniform variable.  
     * Finally, laziness won.
     * @param {string} _type Type of the uniform variable
     * @param {string} _name Name of the uniform variable
     * @param {number} _value Value
     * @returns {void} void
     */

  }, {
    key: "uniform",
    value: function uniform(_type, _name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);

      gl['uniform' + _type](location, _value);
    }
    /**
     * Attach an `int` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {number} _value `int` value
     * @returns {void} void
     */

  }, {
    key: "uniform1i",
    value: function uniform1i(_name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniform1i(location, _value);
    }
    /**
     * Attach a `float` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {number} _value `float` value
     * @returns {void} void
     */

  }, {
    key: "uniform1f",
    value: function uniform1f(_name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniform1f(location, _value);
    }
    /**
     * Attach an array of `vec2` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {Float32Array|number[]} _value Array of `vec2` value
     * @returns {void} void
     */

  }, {
    key: "uniform2fv",
    value: function uniform2fv(_name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniform2fv(location, _value);
    }
    /**
     * Attach an array of `vec3` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {Float32Array|number[]} _value Array of `vec3` value
     * @returns {void} void
     */

  }, {
    key: "uniform3fv",
    value: function uniform3fv(_name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniform3fv(location, _value);
    }
    /**
     * Attach an array of `vec4` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {Float32Array|number[]} _value Array of `vec4` value
     * @returns {void} void
     */

  }, {
    key: "uniform4fv",
    value: function uniform4fv(_name, _value) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniform4fv(location, _value);
    }
    /**
     * Attach an array of `mat4` type uniform variable.
     * @param {string} _name Name of the uniform variable
     * @param {Float32Array|number[]} _value Array of `mat4` value
     * @param {GLboolean} [_transpose=false] Specify whether to transpose the matrix
     * @returns {void} void
     */

  }, {
    key: "uniformMatrix4fv",
    value: function uniformMatrix4fv(_name, _value, _transpose) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.uniformMatrix4fv(location, _transpose || false, _value);
    }
    /**
     * Attach a `sampler2D` type uniform texture.
     * @param {string} _name Name of the uniform texture
     * @param {WebGLTexture} _texture Texture object
     * @param {number} _number Specify a texture unit, in integer
     * @returns {void} void
     */

  }, {
    key: "uniformTexture",
    value: function uniformTexture(_name, _texture, _number) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.activeTexture(gl.TEXTURE0 + _number);
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.uniform1i(location, _number);
    }
    /**
     * Attach a `samplerCube` type uniform texture.
     * @param {string} _name Name of the uniform texture
     * @param {WebGLTexture} _texture Texture object
     * @param {number} _number Specify a texture unit, in integer
     * @returns {void} void
     */

  }, {
    key: "uniformCubemap",
    value: function uniformCubemap(_name, _texture, _number) {
      var gl = this.gl;
      var location = this.getUniformLocation(_name);
      gl.activeTexture(gl.TEXTURE0 + _number);
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, _texture);
      gl.uniform1i(location, _number);
    }
    /**
     * Create a texture object.
     * @returns {WebGLTexture} Texture object
     */

  }, {
    key: "createTexture",
    value: function createTexture() {
      var gl = this.gl;
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Specify how to filter the texture.
     * @param {WebGLTexture} _texture Texture object
     * @param {GLenum} _filter Texture filter
     * @returns {void} void
     */

  }, {
    key: "textureFilter",
    value: function textureFilter(_texture, _filter) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, _filter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, _filter);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Specify how to wrap the texture.
     * @param {WebGLTexture} _texture Texture object
     * @param {GLenum} _filter Wrapping function for the texture
     * @returns {void} void
     */

  }, {
    key: "textureWrap",
    value: function textureWrap(_texture, _wrap) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, _wrap);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, _wrap);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Set new data into a texture object.  
     * This function uses image data. If you want to source `Uint8Array`, use `GLCat.setTextureFromArray()` instead.
     * @param {WebGLTexture} _texture Texture object
     * @param {Pixelable} _source Source image of the pixel data
     * @returns {void} void
     */

  }, {
    key: "setTexture",
    value: function setTexture(_texture, _source) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _source);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Set new data into a texture object.  
     * This function uses `Uint8Array`. If you want to source image data, use `GLCat.setTexture()` instead.  
     * Or you want to use float texture? Try this: `GLCat.setTextureFromFloatArray()`
     * @param {WebGLTexture} _texture Texture object
     * @param {GLsizei} _width Width of the texture
     * @param {GLsizei} _height Height of the texture
     * @param {Uint8Array} _source Source buffer of the pixel data
     * @returns {void} void
     */

  }, {
    key: "setTextureFromArray",
    value: function setTextureFromArray(_texture, _width, _height, _source) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(_source));
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Set new data into a texture object.  
     * This function uses `Float32Array`.  
     * If you can't grab `OES_texture_float` extension here, you will die at this point.
     * @param {WebGLTexture} _texture Texture object
     * @param {GLsizei} _width Width of the texture
     * @param {GLsizei} _height Height of the texture
     * @param {Float32Array} _source Source buffer of the pixel data
     * @returns {void} void
     */

  }, {
    key: "setTextureFromFloatArray",
    value: function setTextureFromFloatArray(_texture, _width, _height, _source) {
      var gl = this.gl;
      this.getExtension('OES_texture_float', true);
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, new Float32Array(_source));

      if (!this.getExtension('OES_texture_float_linear')) {
        this.textureFilter(_texture, gl.NEAREST);
      }

      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Copy pixels from current framebuffer to given texture.
     * @param {WebGLTexture} _texture Target texture object
     * @param {GLsizei} _width Width of the texture
     * @param {GLsizei} _height Height of the texture
     * @returns {void} void
     */

  }, {
    key: "copyTexture",
    value: function copyTexture(_texture, _width, _height) {
      var gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, _texture);
      gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, _width, _height, 0);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * Create a cubemap texture object.
     * @param {Pixelable[]} _arrayOfImage Array of iamges. Order: `X+`, `X-`, `Y+`, `Y-`, `Z+`, `Z-`
     * @returns {WebGLTexture} Texture object
     */

  }, {
    key: "createCubemap",
    value: function createCubemap(_arrayOfImage) {
      var gl = this.gl;
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);

      for (var i = 0; i < 6; i++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _arrayOfImage[i]);
      }

      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
      return texture;
    }
    /**
     * Create a framebuffer object.
     * @param {GLsizei} _width Width of the framebuffer
     * @param {GLsizei} _height Height of the framebuffer
     * @returns {GLCatFramebuffer} Framebuffer object
     */

  }, {
    key: "createFramebuffer",
    value: function createFramebuffer(_width, _height) {
      var gl = this.gl;
      var framebuffer = {};
      framebuffer.framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);
      framebuffer.depth = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, framebuffer.depth);
      framebuffer.texture = this.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, framebuffer.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, framebuffer.texture, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return framebuffer;
    }
    /**
     * Resize a framebuffer object.
     * @param {GLCatFramebuffer} Framebuffer object
     * @param {GLsizei} _width Width of the framebuffer
     * @param {GLsizei} _height Height of the framebuffer
     * @returns {void} void
     */

  }, {
    key: "resizeFramebuffer",
    value: function resizeFramebuffer(_framebuffer, _width, _height) {
      var it = this;
      var gl = it.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, _framebuffer.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Create a framebuffer object, but Float32 one.
     * @param {GLsizei} _width Width of the framebuffer
     * @param {GLsizei} _height Height of the framebuffer
     * @returns {GLCatFramebuffer} Framebuffer object
     */

  }, {
    key: "createFloatFramebuffer",
    value: function createFloatFramebuffer(_width, _height) {
      var it = this;
      var gl = it.gl;
      it.getExtension('OES_texture_float', true);
      var framebuffer = {};
      framebuffer.framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);
      framebuffer.depth = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, framebuffer.depth);
      framebuffer.texture = it.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, framebuffer.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);

      if (!it.getExtension('OES_texture_float_linear')) {
        it.textureFilter(framebuffer.texture, gl.NEAREST);
      }

      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, framebuffer.texture, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return framebuffer;
    }
    /**
     * Resize a float framebuffer object.
     * @param {GLCatFramebuffer} Framebuffer object
     * @param {GLsizei} _width Width of the framebuffer
     * @param {GLsizei} _height Height of the framebuffer
     * @returns {void} void
     */

  }, {
    key: "resizeFloatFramebuffer",
    value: function resizeFloatFramebuffer(_framebuffer, _width, _height) {
      var it = this;
      var gl = it.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, _framebuffer.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Create a draw buffers object.  
     * If you can't grab `WEBGL_draw_buffers` extension, you will die instantly.  
     * Format of its textures will be Float32.
     * @param {GLsizei} _width Width of the draw buffers
     * @param {GLsizei} _height Height of the draw buffers
     * @param {number} Specify how many textures it has
     * @returns {GLCatDrawBuffers} Draw buffers object
     */

  }, {
    key: "createDrawBuffers",
    value: function createDrawBuffers(_width, _height, _numDrawBuffers) {
      var it = this;
      var gl = it.gl;
      it.getExtension('OES_texture_float', true);
      var ext = it.getExtension('WEBGL_draw_buffers', true);

      if (ext.MAX_DRAW_BUFFERS_WEBGL < _numDrawBuffers) {
        throw 'createDrawBuffers: MAX_DRAW_BUFFERS_WEBGL is ' + ext.MAX_DRAW_BUFFERS_WEBGL;
      }

      var drawbuffers = {};
      drawbuffers.framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, drawbuffers.framebuffer);
      drawbuffers.depth = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, drawbuffers.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, drawbuffers.depth);
      drawbuffers.textures = [];

      for (var i = 0; i < _numDrawBuffers; i++) {
        drawbuffers.textures[i] = it.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, drawbuffers.textures[i]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);

        if (!it.getExtension('OES_texture_float_linear')) {
          it.textureFilter(drawbuffers.textures[i], gl.NEAREST);
        }

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT0_WEBGL + i, gl.TEXTURE_2D, drawbuffers.textures[i], 0);
      }

      var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

      if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw 'createDrawBuffers: gl.checkFramebufferStatus( gl.FRAMEBUFFER ) returns ' + status;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return drawbuffers;
    }
    /**
     * Resize a draw buffers object.
     * @param {GLCatDrawBuffers} Draw buffers object
     * @param {GLsizei} _width Width of the draw buffers
     * @param {GLsizei} _height Height of the draw buffers
     * @returns {void} void
     */

  }, {
    key: "resizeDrawBuffers",
    value: function resizeDrawBuffers(_framebuffer, _width, _height) {
      var it = this;
      var gl = it.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);

      for (var i = 0; i < _framebuffer.textures.length; i++) {
        gl.bindTexture(gl.TEXTURE_2D, _framebuffer.textures[i]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * Call this before you are going to use draw buffers.
     * @param {number} Specify how many draw buffers you are going to use
     * @returns {void} void
     */

  }, {
    key: "drawBuffers",
    value: function drawBuffers(_numDrawBuffers) {
      var it = this;
      var gl = it.gl;
      var ext = it.getExtension('WEBGL_draw_buffers', true);
      var array = [];

      if (typeof _numDrawBuffers === 'number') {
        for (var i = 0; i < _numDrawBuffers; i++) {
          array.push(ext.COLOR_ATTACHMENT0_WEBGL + i);
        }
      } else {
        array = array.concat(_numDrawBuffers);
      }

      ext.drawBuffersWEBGL(array);
    }
    /**
     * Clear current framebuffer.
     * @param {GLclampf} [_r=0.0] Red amount of clearing color
     * @param {GLclampf} [_g=0.0] Green amount of clearing color
     * @param {GLclampf} [_b=0.0] Blue amount of clearing color
     * @param {GLclampf} [_a=1.0] Alpha amount of clearing color
     * @param {GLclampf} [_depth=1.0] Clearing depth
     * @returns {void} void
     */

  }, {
    key: "clear",
    value: function clear(_r, _g, _b, _a, _depth) {
      var it = this;
      var gl = it.gl;
      var r = _r || 0.0;
      var g = _g || 0.0;
      var b = _b || 0.0;
      var a = typeof _a === 'number' ? _a : 1.0;
      var depth = typeof _depth === 'number' ? _depth : 1.0;
      gl.clearColor(r, g, b, a);
      gl.clearDepth(depth);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
  }]);

  return GLCat;
}();

/* harmony default export */ __webpack_exports__["default"] = (GLCat);

/***/ }),

/***/ "./src/libs/mathcat.js":
/*!*****************************!*\
  !*** ./src/libs/mathcat.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// にゃーん
var MathCat = {};
/**
 * Add two vecs.
 * @param {number[]} a vecN
 * @param {number[]} b vecN
 * @returns {number[]} vecN, `a + b`
 * @static
 */

MathCat.vecAdd = function (a, b) {
  return a.map(function (e, i) {
    return e + b[i];
  });
};
/**
 * Substract a vec from an another vec.
 * @param {number[]} a vecN
 * @param {number[]} b vecN
 * @returns {number[]} vecN, `a - b`
 * @static
 */


MathCat.vecSub = function (a, b) {
  return a.map(function (e, i) {
    return e - b[i];
  });
};
/**
 * Multiply two vecs.
 * @param {number[]} a vecN
 * @param {number[]} b vecN
 * @returns {number[]} vecN, `a * b`
 * @static
 */


MathCat.vecMul = function (a, b) {
  return a.map(function (e, i) {
    return e - b[i];
  });
};
/**
 * Return a cross of two vec3s.
 * @param {number[]} a vec3
 * @param {number[]} b vec3
 * @returns {number[]} vec3, cross product of `a` and `b`
 * @static
 */


MathCat.vec3Cross = function (a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
};
/**
 * Scale a vec by scalar.
 * @param {number} s scalar
 * @param {number[]} v vecN
 * @returns {number[]} vecN, `s * v`
 * @static
 */


MathCat.vecScale = function (s, v) {
  return v.map(function (e) {
    return e * s;
  });
};
/**
 * Dot two vectors.
 * @param {number[]} a vecN
 * @param {number[]} b vecN
 * @returns {number[]} vecN, Dot of `a` and `b`
 * @static
 */


MathCat.vecDot = function (a, b) {
  return a.reduce(function (p, e, i) {
    return p + e * b[i];
  }, 0.0);
};
/**
 * Return length of a vec.
 * @param {number[]} v vecN
 * @returns {number} scalar, length of `v`
 * @static
 */


MathCat.vecLength = function (v) {
  return Math.sqrt(v.reduce(function (p, c) {
    return p + c * c;
  }, 0.0));
};
/**
 * Normalize a vec.
 * @param {number[]} v vecN
 * @returns {number[]} vec, normalized `v`
 * @static
 */


MathCat.vecNormalize = function (v) {
  return MathCat.vecScale(1.0 / MathCat.vecLength(v), v);
};
/**
 * Multiply two quats.
 * @param {number[]} q quat
 * @param {number[]} r quat
 * @returns {number[]} quat, product of `a` and `b`
 * @static
 */


MathCat.quatMul = function (q, r) {
  return [q[3] * r[0] + q[0] * r[3] + q[1] * r[2] - q[2] * r[1], q[3] * r[1] - q[0] * r[2] + q[1] * r[3] + q[2] * r[0], q[3] * r[2] + q[0] * r[1] - q[1] * r[0] + q[2] * r[3], q[3] * r[3] - q[0] * r[0] - q[1] * r[1] - q[2] * r[2]];
};
/**
 * Inverse a quat.
 * @param {number[]} q quat
 * @returns {number[]} quat, `-q`
 * @static
 */


MathCat.quatInv = function (q) {
  return [-q[0], -q[1], -q[2], q[3]];
};
/**
 * Rotate a vec3 using one quat.
 * @param {number[]} v vec3
 * @param {number[]} q quat
 * @returns {number[]} vec3, rotated vector
 * @static
 */


MathCat.rotateVecByQuat = function (v, q) {
  var p = [v[0], v[1], v[2], 0.0];
  var r = MathCat.quatInv(q);
  var res = MathCat.quatMul(MathCat.quatMul(q, p), r);
  return [res[0], res[1], res[2]];
};
/**
 * Convert quat into mat4.
 * @param {number[]} q quat
 * @returns {number[]} mat4, rotation matrix made from quat
 * @static
 */


MathCat.quatToMat4 = function (q) {
  var x = MathCat.rotateVecByQuat([1.0, 0.0, 0.0], q);
  var y = MathCat.rotateVecByQuat([0.0, 1.0, 0.0], q);
  var z = MathCat.rotateVecByQuat([0.0, 0.0, 1.0], q);
  return [x[0], y[0], z[0], 0.0, x[1], y[1], z[1], 0.0, x[2], y[2], z[2], 0.0, 0.0, 0.0, 0.0, 1.0];
};
/**
 * Generate quat from angle and axis.
 * @param {number} angle scalar, Rotation angle in radian
 * @param {number[]} axis vec3, Rotation axis
 * @returns {number[]} quat, Generated quaternion
 * @static
 */


MathCat.quatAngleAxis = function (angle, axis) {
  var ha = angle / 2.0;
  var sha = Math.sin(ha);
  return [axis[0] * sha, axis[1] * sha, axis[2] * sha, Math.cos(ha)];
};
/**
 * Apply two mat4s.
 * @param {number[]} a mat4
 * @param {number[]} b mat4
 * @returns {number[]} mat4, Applied matrix
 * @static
 */


MathCat.mat4Apply = function (a, b) {
  return [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]];
};
/**
 * Invert a mat4.
 * @param {number[]} m mat4
 * @returns {number[]} mat4, Inverted matrix
 * @static
 */


MathCat.mat4Inverse = function (m) {
  var a00 = m[0],
      a01 = m[1],
      a02 = m[2],
      a03 = m[3],
      a10 = m[4],
      a11 = m[5],
      a12 = m[6],
      a13 = m[7],
      a20 = m[8],
      a21 = m[9],
      a22 = m[10],
      a23 = m[11],
      a30 = m[12],
      a31 = m[13],
      a32 = m[14],
      a33 = m[15],
      b00 = a00 * a11 - a01 * a10,
      b01 = a00 * a12 - a02 * a10,
      b02 = a00 * a13 - a03 * a10,
      b03 = a01 * a12 - a02 * a11,
      b04 = a01 * a13 - a03 * a11,
      b05 = a02 * a13 - a03 * a12,
      b06 = a20 * a31 - a21 * a30,
      b07 = a20 * a32 - a22 * a30,
      b08 = a20 * a33 - a23 * a30,
      b09 = a21 * a32 - a22 * a31,
      b10 = a21 * a33 - a23 * a31,
      b11 = a22 * a33 - a23 * a32;
  return MathCat.vecScale(1.0 / b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06, [a11 * b11 - a12 * b10 + a13 * b09, a02 * b10 - a01 * b11 - a03 * b09, a31 * b05 - a32 * b04 + a33 * b03, a22 * b04 - a21 * b05 - a23 * b03, a12 * b08 - a10 * b11 - a13 * b07, a00 * b11 - a02 * b08 + a03 * b07, a32 * b02 - a30 * b05 - a33 * b01, a20 * b05 - a22 * b02 + a23 * b01, a10 * b10 - a11 * b08 + a13 * b06, a01 * b08 - a00 * b10 - a03 * b06, a30 * b04 - a31 * b02 + a33 * b00, a21 * b02 - a20 * b04 - a23 * b00, a11 * b07 - a10 * b09 - a12 * b06, a00 * b09 - a01 * b07 + a02 * b06, a31 * b01 - a30 * b03 - a32 * b00, a20 * b03 - a21 * b01 + a22 * b00]);
};
/**
 * Apply a mat4 to a vec4.
 * @param {number[]} m mat4
 * @param {number[]} v vec4
 * @returns {number[]} vec4, Applied vector
 * @static
 */


MathCat.mat4ApplyToVec4 = function (m, v) {
  return [m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3], m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3], m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3], m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3]];
};
/**
 * Transpose a mat4.
 * @param {number[]} m mat4
 * @returns {number[]} mat4, Transposed matrix
 * @static
 */


MathCat.mat4Transpose = function (m) {
  return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
};
/**
 * Generate an indentity mat4.
 * @returns {number[]} mat4, Identity matrix
 * @static
 */


MathCat.mat4Identity = function () {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};
/**
 * Generate a 3d translate matrix.
 * @param {number[]} v vec3, Translation
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4Translate = function (v) {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1];
};
/**
 * Generate a 3d scale matrix.  
 * See also: {@link MathCat#mat4ScaleXYZ}
 * @param {number[]} v vec3, Scaling
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4Scale = function (v) {
  return [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1];
};
/**
 * Generate a 3d scale matrix.  
 * See also: {@link MathCat#mat4Scale}
 * @param {number[]} s scalar, Scaling
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4ScaleXYZ = function (s) {
  return [s, 0, 0, 0, 0, s, 0, 0, 0, 0, s, 0, 0, 0, 0, 1];
};
/**
 * Generate a 3d rotation matrix.  
 * 2d rotation around x axis.
 * @param {number[]} t scalar, Rotation angle in radians
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4RotateX = function (t) {
  return [1, 0, 0, 0, 0, Math.cos(t), -Math.sin(t), 0, 0, Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1];
};
/**
 * Generate a 3d rotation matrix.  
 * 2d rotation around y axis.
 * @param {number[]} t scalar, Rotation angle in radians
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4RotateY = function (t) {
  return [Math.cos(t), 0, Math.sin(t), 0, 0, 1, 0, 0, -Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1];
};
/**
 * Generate a 3d rotation matrix.  
 * 2d rotation around z axis.
 * @param {number[]} t scalar, Rotation angle in radians
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4RotateZ = function (t) {
  return [Math.cos(t), -Math.sin(t), 0, 0, Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};
/**
 * Generate a "LookAt" view matrix.
 * @param {number[]} pos vec3, Position
 * @param {number[]} tar vec3, Target
 * @param {number[]} [air=[ 0.0, 1.0, 0.0 ]] vec3, Up vector
 * @param {number} [rot=0.0] scalar, Roll. yeahhhh I think such lookAt generator should have roll parameter
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4LookAt = function (pos, tar, air, rot) {
  var dir = MathCat.vecNormalize(MathCat.vecSub(tar, pos));
  var sid = MathCat.vecNormalize(MathCat.vec3Cross(dir, air || [0.0, 1.0, 0.0]));
  var top = MathCat.vec3Cross(sid, dir);
  sid = MathCat.vecAdd(MathCat.vecScale(Math.cos(rot || 0.0), sid), MathCat.vecScale(Math.sin(rot || 0.0), top));
  top = MathCat.vec3Cross(sid, dir);
  return [sid[0], top[0], dir[0], 0.0, sid[1], top[1], dir[1], 0.0, sid[2], top[2], dir[2], 0.0, -sid[0] * pos[0] - sid[1] * pos[1] - sid[2] * pos[2], -top[0] * pos[0] - top[1] * pos[1] - top[2] * pos[2], -dir[0] * pos[0] - dir[1] * pos[1] - dir[2] * pos[2], 1.0];
};
/**
 * Generate a "Perspective" projection matrix.  
 * It won't include aspect!
 * @param {number} fov scalar
 * @param {number} near scalar
 * @param {number} far scalar
 * @returns {number[]} mat4, Generated matrix
 * @static
 */


MathCat.mat4Perspective = function (fov, near, far) {
  var p = 1.0 / Math.tan(fov * Math.PI / 360.0);
  var d = far - near;
  return [p, 0.0, 0.0, 0.0, 0.0, p, 0.0, 0.0, 0.0, 0.0, (far + near) / d, 1.0, 0.0, 0.0, -2 * far * near / d, 0.0];
};

/* harmony default export */ __webpack_exports__["default"] = (MathCat);

/***/ }),

/***/ "./src/libs/ultracat.js":
/*!******************************!*\
  !*** ./src/libs/ultracat.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// お前、ナンデモアリかよ！
var UltraCat = {};
UltraCat.triangleStripQuad = [-1, -1, 1, -1, -1, 1, 1, 1];
UltraCat.triangleStripQuad3 = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
UltraCat.triangleStripQuadNor = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
UltraCat.triangleStripQuadUV = [0, 0, 1, 0, 0, 1, 1, 1]; // destructive

UltraCat.shuffleArrayD = function (array, dice) {
  var f = dice ? dice : function () {
    return Math.random();
  };

  for (var i = 0; i < array.length - 1; i++) {
    var ir = i + Math.floor(f() * (array.length - i));
    var temp = array[ir];
    array[ir] = array[i];
    array[i] = temp;
  }

  return array;
};

UltraCat.triIndexToLineIndex = function (array) {
  var ret = [];

  for (var i = 0; i < array.length / 3; i++) {
    var head = i * 3;
    ret.push(array[head], array[head + 1], array[head + 1], array[head + 2], array[head + 2], array[head]);
  }

  return ret;
};

UltraCat.matrix2d = function (w, h) {
  var arr = [];

  for (var iy = 0; iy < h; iy++) {
    for (var ix = 0; ix < w; ix++) {
      arr.push(ix, iy);
    }
  }

  return arr;
};

UltraCat.lerp = function (a, b, x) {
  return a + (b - a) * x;
};

UltraCat.clamp = function (x, l, h) {
  return Math.min(Math.max(x, l), h);
};

UltraCat.saturate = function (x) {
  return Math.min(Math.max(x, 0.0), 1.0);
};

UltraCat.linearstep = function (a, b, x) {
  return UltraCat.saturate((x - a) / (b - a));
};

UltraCat.smoothstep = function (a, b, x) {
  var t = UltraCat.linearstep(a, b, x);
  return t * t * (3.0 - 2.0 * t);
};

UltraCat.ExpSmooth =
/*#__PURE__*/
function () {
  function _class(factor) {
    _classCallCheck(this, _class);

    this.factor = factor;
    this.value = 0.0;
  }

  _createClass(_class, [{
    key: "update",
    value: function update(value, dt) {
      this.value = UltraCat.lerp(value, this.value, Math.exp(-this.factor * dt));
      return this.value;
    }
  }]);

  return _class;
}();

/* harmony default export */ __webpack_exports__["default"] = (UltraCat);

/***/ }),

/***/ "./src/libs/xorshift.js":
/*!******************************!*\
  !*** ./src/libs/xorshift.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Xorshift =
/*#__PURE__*/
function () {
  function Xorshift(_seed) {
    _classCallCheck(this, Xorshift);

    this.set(_seed);
  }

  _createClass(Xorshift, [{
    key: "gen",
    value: function gen(_seed) {
      if (_seed) {
        this.set(_seed);
      }

      this.seed = this.seed ^ this.seed << 13;
      this.seed = this.seed ^ this.seed >>> 17;
      this.seed = this.seed ^ this.seed << 5;
      return this.seed / Math.pow(2, 32) + 0.5;
    }
  }, {
    key: "set",
    value: function set(_seed) {
      this.seed = _seed || this.seed || 1;
    }
  }]);

  return Xorshift;
}();

/* harmony default export */ __webpack_exports__["default"] = (Xorshift);

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/main.scss */ "./src/styles/main.scss");
/* harmony import */ var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_main_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _libs_glcat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/glcat.js */ "./src/libs/glcat.js");
/* harmony import */ var _libs_glcat_path_gui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/glcat-path-gui */ "./src/libs/glcat-path-gui.js");
/* harmony import */ var _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/mathcat.js */ "./src/libs/mathcat.js");
/* harmony import */ var _libs_ultracat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./libs/ultracat.js */ "./src/libs/ultracat.js");
/* harmony import */ var _fms_cat_automaton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fms-cat/automaton */ "./node_modules/@fms-cat/automaton/dist/automaton.js");
/* harmony import */ var _fms_cat_automaton__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fms_cat_automaton__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _libs_canvas_saver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./libs/canvas-saver */ "./src/libs/canvas-saver.js");
/* harmony import */ var _libs_canvas_saver__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_libs_canvas_saver__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _config_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./config.json */ "./src/config.json");
var _config_json__WEBPACK_IMPORTED_MODULE_7___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./config.json */ "./src/config.json", 1);
 // == import various modules / stuff ===========================================







 // == we are stull struggling by this ==========================================

var $ = document.querySelector.bind(document); // == hi canvas ================================================================

var canvas = $('#canvas');
var width = canvas.width = _config_json__WEBPACK_IMPORTED_MODULE_7__.resolution[0];
var height = canvas.height = _config_json__WEBPACK_IMPORTED_MODULE_7__.resolution[1];
var saver = new _libs_canvas_saver__WEBPACK_IMPORTED_MODULE_6___default.a(canvas);
var gl = canvas.getContext('webgl');
gl.lineWidth(1); // e

var glCat = new _libs_glcat_js__WEBPACK_IMPORTED_MODULE_1__["default"](gl);
glCat.getExtension('OES_texture_float', true);
glCat.getExtension('OES_texture_float_linear', true);
glCat.getExtension('EXT_frag_depth', true);
glCat.getExtension('ANGLE_instanced_arrays', true);
var glCatPath = new _libs_glcat_path_gui__WEBPACK_IMPORTED_MODULE_2__["default"](glCat, {
  el: $('#divPath'),
  canvas: canvas,
  stretch: true,
  drawbuffers: true
}); // oh hi

var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat_js__WEBPACK_IMPORTED_MODULE_4__["default"].triangleStripQuad)); // == hello automaton ==========================================================

var totalFrame = 0;
var isInitialFrame = true;
var automaton = new _fms_cat_automaton__WEBPACK_IMPORTED_MODULE_5___default.a({
  loop: true,
  fps: 120,
  gui: $('#divAutomaton'),
  data: __webpack_require__(/*! ./automaton.json */ "./src/automaton.json")
});
var auto = automaton.auto;

if (false) {} // == lights, camera, action! ==================================================


var cameraPos = [0.0, 0.0, 0.0];
var cameraTar = [0.0, 0.0, 0.0];
var cameraRoll = 0.0; // protip: considering roll of cam is cool idea

var perspFov = 70.0;
var perspNear = 0.01;
var perspFar = 100.0;
var lightPos = [5.0, 5.0, 10.0]; // this is pretty random

var shadowReso = _config_json__WEBPACK_IMPORTED_MODULE_7__.shadowReso; // texture size for shadow buffer

var matP = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4Perspective(perspFov, perspNear, perspFar);
var matV = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4LookAt(cameraPos, cameraTar, [0.0, 1.0, 0.0], cameraRoll);
var matPL = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4Perspective(perspFov, perspNear, perspFar);
var matVL = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4LookAt(lightPos, cameraTar, [0.0, 1.0, 0.0], 0.0);

var updateMatrices = function updateMatrices(camOffset) {
  cameraPos = [0.0, 0.0, auto('camera-Radius')];
  cameraPos = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].rotateVecByQuat(cameraPos, _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].quatAngleAxis(auto('camera-rotX', {
    smooth: 10.0
  }) - 0.5, [1.0, 0.0, 0.0]));
  cameraPos = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].rotateVecByQuat(cameraPos, _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].quatAngleAxis(auto('camera-rotY', {
    smooth: 10.0
  }) - 0.5, [0.0, 1.0, 0.0]));

  if (camOffset) {
    cameraPos = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].vecAdd(cameraPos, camOffset);
  }

  matP = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4Perspective(perspFov, perspNear, perspFar);
  matV = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4LookAt(cameraPos, cameraTar, [0.0, 1.0, 0.0], cameraRoll);
  matPL = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4Perspective(perspFov, perspNear, perspFar);
  matVL = _libs_mathcat_js__WEBPACK_IMPORTED_MODULE_3__["default"].mat4LookAt(lightPos, cameraTar, [0.0, 1.0, 0.0], 0.0);
};

updateMatrices(); // == mouse listener, why tho ==================================================

var mouseX = 0.0;
var mouseY = 0.0;
canvas.addEventListener('mousemove', function (event) {
  mouseX = event.offsetX;
  mouseY = event.offsetY;
}); // == global uniform variables =================================================

glCatPath.setGlobalFunc(function () {
  glCat.uniform1i('isInitialFrame', isInitialFrame);
  glCat.uniform1f('time', automaton.time);
  glCat.uniform1f('deltaTime', automaton.deltaTime * auto('deltaTime-multiplier'));
  glCat.uniform1f('totalFrame', totalFrame);
  glCat.uniform3fv('cameraPos', cameraPos);
  glCat.uniform3fv('cameraTar', cameraTar);
  glCat.uniform1f('cameraRoll', cameraRoll);
  glCat.uniform1f('perspFov', perspFov);
  glCat.uniform1f('perspNear', perspNear);
  glCat.uniform1f('perspFar', perspFar);
  glCat.uniform3fv('lightPos', lightPos);
  glCat.uniformMatrix4fv('matP', matP);
  glCat.uniformMatrix4fv('matV', matV);
  glCat.uniformMatrix4fv('matPL', matPL);
  glCat.uniformMatrix4fv('matVL', matVL);
  glCat.uniform2fv('mouse', [mouseX, mouseY]);
  glCat.uniform4fv('bgColor', [0.0, 0.0, 0.0, 1.0]);
}); // == glcat-path setup =========================================================

glCatPath.add({
  return: {
    width: width,
    height: height,
    vert: __webpack_require__(/*! ./shaders/quad.vert */ "./src/shaders/quad.vert"),
    frag: __webpack_require__(/*! ./shaders/return.frag */ "./src/shaders/return.frag"),
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    func: function func(path, params) {
      glCat.attribute('p', vboQuad, 2);
      glCat.uniformTexture('sampler0', params.input, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  },
  inspector: {
    width: width,
    height: height,
    vert: __webpack_require__(/*! ./shaders/quad.vert */ "./src/shaders/quad.vert"),
    frag: __webpack_require__(/*! ./shaders/inspector.frag */ "./src/shaders/inspector.frag"),
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    func: function func(path, params) {
      glCat.attribute('p', vboQuad, 2);
      glCat.uniform3fv('circleColor', [1.0, 1.0, 1.0]);
      glCat.uniformTexture('sampler0', params.input, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  },
  target: {
    width: width,
    height: height,
    vert: __webpack_require__(/*! ./shaders/quad.vert */ "./src/shaders/quad.vert"),
    frag: __webpack_require__(/*! ./shaders/bg.frag */ "./src/shaders/bg.frag"),
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    framebuffer: true,
    float: true,
    drawbuffers: 2,
    depthWrite: false,
    func: function func() {
      glCat.attribute('p', vboQuad, 2);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  },
  shadow: {
    width: shadowReso,
    height: shadowReso,
    vert: __webpack_require__(/*! ./shaders/quad.vert */ "./src/shaders/quad.vert"),
    frag: __webpack_require__(/*! ./shaders/bg.frag */ "./src/shaders/bg.frag"),
    blend: [gl.ONE, gl.ZERO],
    clear: [perspFar, 0.0, 0.0, 1.0],
    framebuffer: true,
    float: true,
    func: function func() {// glCat.attribute( 'p', vboQuad, 2 );
      // gl.drawArrays( gl.TRIANGLE_STRIP, 0, 4 );
    }
  }
}); // == setup paths ==============================================================

var context = {
  glCatPath: glCatPath,
  automaton: automaton,
  width: width,
  height: height
};

__webpack_require__(/*! ./paths/bloom */ "./src/paths/bloom.js").default(context);

__webpack_require__(/*! ./paths/box */ "./src/paths/box.js").default(context);

__webpack_require__(/*! ./paths/pixelsort */ "./src/paths/pixelsort.js").default(context);

__webpack_require__(/*! ./paths/particles */ "./src/paths/particles.js").default(context);

__webpack_require__(/*! ./paths/postfx */ "./src/paths/postfx.js").default(context); // == loop here ================================================================


var update = function update() {
  if (!$('#active').checked) {
    setTimeout(update, 100);
    return;
  } // == update some bunch of shit ==============================================


  automaton.update();
  updateMatrices(); // == let's render this ======================================================

  glCatPath.begin(); // == compute stuff ==========================================================

  glCatPath.render('particlesComputeReturn');
  glCatPath.render('particlesMotionRead');
  glCatPath.render('particlesEnforce');
  glCatPath.render('particlesDivergence');
  glCatPath.render('particlesPressure');
  glCatPath.render('particlesMotionWrite');
  glCatPath.render('particlesCompute'); // == shadow =================================================================

  glCatPath.render('shadow');
  glCatPath.render('particlesRender', {
    target: glCatPath.fb('shadow'),
    isShadow: true,
    width: shadowReso,
    height: shadowReso
  }); // == foreground =============================================================

  glCatPath.render('target');
  glCatPath.render('particlesRender', {
    target: glCatPath.fb('target'),
    textureShadow: glCatPath.fb('shadow').texture,
    width: width,
    height: height
  });
  glCatPath.render('box', {
    target: glCatPath.fb('target'),
    width: width,
    height: height
  }); // == post ===================================================================

  glCatPath.render('preBloom', {
    input: glCatPath.fb('target').textures[0],
    bias: [-0.9, -0.9, -0.9],
    factor: [1.0, 1.0, 1.0]
  });
  glCatPath.render('bloom');
  glCatPath.render('postBloom', {
    dry: glCatPath.fb('target').textures[0]
  });
  glCatPath.render('pixelsortCompare', {
    input: glCatPath.fb('postBloom').texture
  });
  glCatPath.render('pixelsortRender', {
    input: glCatPath.fb('postBloom').texture
  });
  glCatPath.render('post', {
    input: glCatPath.fb('pixelsortRender').texture
  });
  glCatPath.render('return', {
    target: _libs_glcat_path_gui__WEBPACK_IMPORTED_MODULE_2__["default"].nullFb,
    input: glCatPath.fb('post').texture
  }); // glCatPath.render( 'inspector', {
  //   target: GLCatPath.nullFb,
  //   input: glCatPath.fb( 'particlesMotionWrite' ).texture
  // } );
  // == end ====================================================================

  glCatPath.end(); // == save ===================================================================

  if ($('#save').checked) {
    saver.capture();

    if (automaton.fps * automaton.length * 1.1 < saver.frameCount) {
      $('#save').checked = false;
      saver.save();
    }
  } // == finalize the loop ======================================================


  isInitialFrame = false;
  totalFrame++;
  requestAnimationFrame(update);
};

update(); // == keyboard is good =========================================================

window.addEventListener('keydown', function (event) {
  if (event.which === 27) {
    // panic button
    $('#active').checked = false;
  }

  if (event.which === 32) {
    // play / pause
    automaton.isPlaying ? automaton.pause() : automaton.play();
  }
});

/***/ }),

/***/ "./src/paths/bloom.js":
/*!****************************!*\
  !*** ./src/paths/bloom.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

 // ------

/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var width = context.width;
  var height = context.height; // ------

  var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_0__["default"].triangleStripQuad)); // ------

  glCatPath.add({
    preBloom: {
      width: width / 4,
      height: height / 4,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/bloom-pre.frag */ "./src/shaders/bloom-pre.frag"),
      blend: [gl.ONE, gl.ONE],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform3fv('bias', params.bias);
        glCat.uniform3fv('factor', params.factor);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    bloom: {
      width: width / 4,
      height: height / 4,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/gauss.frag */ "./src/shaders/gauss.frag"),
      blend: [gl.ONE, gl.ONE],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      tempFb: glCat.createFramebuffer(width / 4, height / 4),
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);

        for (var i = 0; i < 3; i++) {
          var gaussVar = [3.0, 10.0, 30.0][i];
          glCat.uniform1f('var', gaussVar);
          gl.bindFramebuffer(gl.FRAMEBUFFER, path.tempFb.framebuffer);
          glCat.clear.apply(glCat, _toConsumableArray(path.clear));
          glCat.uniform1i('isVert', false);
          glCat.uniformTexture('sampler0', i === 0 ? glCatPath.fb('preBloom').texture : path.framebuffer.texture, 0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          gl.bindFramebuffer(gl.FRAMEBUFFER, params.framebuffer);
          glCat.uniform1i('isVert', true);
          glCat.uniformTexture('sampler0', path.tempFb.texture, 0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
      }
    },
    postBloom: {
      width: width,
      height: height,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/bloom-post.frag */ "./src/shaders/bloom-post.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('samplerDry', params.dry, 0);
        glCat.uniformTexture('samplerWet', glCatPath.fb('bloom').texture, 1);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
});

/***/ }),

/***/ "./src/paths/box.js":
/*!**************************!*\
  !*** ./src/paths/box.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_mathcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/mathcat */ "./src/libs/mathcat.js");
/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
/* harmony import */ var _geoms_cube__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geoms/cube */ "./src/geoms/cube.js");
/* harmony import */ var _geoms_cube__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_geoms_cube__WEBPACK_IMPORTED_MODULE_2__);


 // ------

/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  // == hi context =============================================================
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var auto = context.automaton.auto; // == hi vbo =================================================================

  var box = _geoms_cube__WEBPACK_IMPORTED_MODULE_2___default()();
  var vboBoxPos = glCat.createVertexbuffer(new Float32Array([-1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0])); // == path definition begin ==================================================

  glCatPath.add({
    box: {
      vert: __webpack_require__(/*! ../shaders/box.vert */ "./src/shaders/box.vert"),
      frag: __webpack_require__(/*! ../shaders/box.frag */ "./src/shaders/box.frag"),
      blend: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],
      func: function func(path, params) {
        glCat.attribute('pos', vboBoxPos, 3);
        var matM = _libs_mathcat__WEBPACK_IMPORTED_MODULE_0__["default"].mat4Identity();
        matM = _libs_mathcat__WEBPACK_IMPORTED_MODULE_0__["default"].mat4Apply(_libs_mathcat__WEBPACK_IMPORTED_MODULE_0__["default"].mat4Scale([2.1, 2.1 * auto('box-phase'), 2.1]), matM);
        matM = _libs_mathcat__WEBPACK_IMPORTED_MODULE_0__["default"].mat4Apply(_libs_mathcat__WEBPACK_IMPORTED_MODULE_0__["default"].mat4Translate([0.0, -2.1 + 2.1 * auto('box-phase'), 0.0]), matM);
        glCat.uniformMatrix4fv('matM', matM);
        gl.drawArrays(gl.LINES, 0, 24);
      }
    }
  });

  if (false) {}
});

/***/ }),

/***/ "./src/paths/particles.js":
/*!********************************!*\
  !*** ./src/paths/particles.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_xorshift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/xorshift */ "./src/libs/xorshift.js");
/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
// == load some modules ========================================================

 // == roll the dice ============================================================

var seed = 15882356;
var xorshift = new _libs_xorshift__WEBPACK_IMPORTED_MODULE_0__["default"](seed); // == very basic constants =====================================================

var ppp = 2;
var nParticleSqrt = 512;
var nParticle = nParticleSqrt * nParticleSqrt;
var jacobiIter = 50;
var motionFieldVoxelUnit = 0.2;
var motionFieldResolutionXY = 256;
var motionFieldResolution = [motionFieldResolutionXY * 4, motionFieldResolutionXY * 8];
/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  // == prepare context ========================================================
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var auto = context.automaton.auto; // == prepare vbos ===========================================================

  var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_1__["default"].triangleStripQuad));
  var vboComputeUV = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_1__["default"].matrix2d(nParticleSqrt, nParticleSqrt).map(function (v, i) {
    return i % 2 === 0 ? (v * ppp + 0.5) / nParticleSqrt / ppp : (v + 0.5) / nParticleSqrt;
  })));

  var oct = __webpack_require__(/*! ../geoms/octahedron */ "./src/geoms/octahedron.js")({
    div: 1.0
  });

  var vboOctPos = glCat.createVertexbuffer(new Float32Array(oct.position));
  var vboOctNor = glCat.createVertexbuffer(new Float32Array(oct.normal));
  var iboOct = glCat.createIndexbuffer(new Uint16Array(oct.index)); // == prepare random texture =================================================

  var textureRandomSize = 32;

  var textureRandomUpdate = function textureRandomUpdate(_tex) {
    glCat.setTextureFromArray(_tex, textureRandomSize, textureRandomSize, function () {
      var len = textureRandomSize * textureRandomSize * 4;
      var ret = new Uint8Array(len);

      for (var i = 0; i < len; i++) {
        ret[i] = Math.floor(xorshift.gen() * 256.0);
      }

      return ret;
    }());
  };

  var textureRandomStatic = glCat.createTexture();
  glCat.textureWrap(textureRandomStatic, gl.REPEAT);
  textureRandomUpdate(textureRandomStatic);
  var textureRandom = glCat.createTexture();
  glCat.textureWrap(textureRandom, gl.REPEAT); // == Toby Fox - Dummy! ======================================================

  var textureDummy = glCat.createTexture();
  glCat.setTextureFromArray(textureDummy, 1, 1, new Uint8Array([0, 0, 0, 0])); // == let's create paths =====================================================

  glCatPath.add({
    // == framebuffer sucks ====================================================
    particlesComputeReturn: {
      width: nParticleSqrt * ppp,
      height: nParticleSqrt,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/return.frag */ "./src/shaders/return.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      filter: gl.NEAREST,
      func: function func(path, params) {
        if (context.automaton.time === 0.0) {
          xorshift.set(seed);
        }

        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', glCatPath.fb('particlesCompute').texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    // == generate motion field by particles ===================================
    particlesMotionRead: {
      width: motionFieldResolution[0],
      height: motionFieldResolution[1],
      vert: __webpack_require__(/*! ../shaders/particles-motion-read.vert */ "./src/shaders/particles-motion-read.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-motion-read.frag */ "./src/shaders/particles-motion-read.frag"),
      blend: [gl.ONE, gl.ONE],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('computeUV', vboComputeUV, 2);
        glCat.uniform2fv('resolutionPcompute', [nParticleSqrt * ppp, nParticleSqrt]);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);
        glCat.uniformTexture('samplerPcompute', glCatPath.fb('particlesComputeReturn').texture, 0);
        gl.drawArrays(gl.POINTS, 0, nParticle);
      }
    },
    // == enforce ==============================================================
    particlesEnforce: {
      width: motionFieldResolution[0],
      height: motionFieldResolution[1],
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-enforce.frag */ "./src/shaders/particles-enforce.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);
        glCat.uniformTexture('samplerMotion', glCatPath.fb('particlesMotionRead').texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    // == generate divergence field by motion field ============================
    particlesDivergence: {
      width: motionFieldResolution[0],
      height: motionFieldResolution[1],
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-divergence.frag */ "./src/shaders/particles-divergence.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1f('nParticle', nParticle);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);
        glCat.uniformTexture('samplerMotion', glCatPath.fb('particlesEnforce').texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    // == let's calculate pressure =============================================
    particlesPressure: {
      width: motionFieldResolution[0],
      height: motionFieldResolution[1],
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-pressure.frag */ "./src/shaders/particles-pressure.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      tempFb: [glCat.createFramebuffer.apply(glCat, motionFieldResolution), glCat.createFramebuffer.apply(glCat, motionFieldResolution)],
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);

        for (var i = 0; i < jacobiIter; i++) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, i === jacobiIter - 1 ? params.framebuffer : path.tempFb[i % 2].framebuffer);
          glCat.uniformTexture('samplerDivergence', glCatPath.fb('particlesDivergence').texture, 0);
          glCat.uniformTexture('samplerPressure', path.tempFb[(i + 1) % 2].texture, 1);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
      }
    },
    // == write back the velocity ==============================================
    particlesMotionWrite: {
      width: motionFieldResolution[0],
      height: motionFieldResolution[1],
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-motion-write.frag */ "./src/shaders/particles-motion-write.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);
        glCat.uniformTexture('samplerMotion', glCatPath.fb('particlesMotionRead').texture, 0);
        glCat.uniformTexture('samplerPressure', glCatPath.fb('particlesPressure').texture, 1);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    // == compute particles =======================================================
    particlesCompute: {
      width: nParticleSqrt * ppp,
      height: nParticleSqrt,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-compute.frag */ "./src/shaders/particles-compute.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      filter: gl.NEAREST,
      func: function func(path, params) {
        textureRandomUpdate(textureRandom);
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1f('nParticle', nParticle);
        glCat.uniform1f('nParticleSqrt', nParticleSqrt);
        glCat.uniform1f('ppp', ppp);
        glCat.uniform1i('isInitFrame', context.automaton.time === 0.0 ? true : false);
        glCat.uniform2fv('resolutionMotion', motionFieldResolution);
        glCat.uniform2fv('planeResolution', [motionFieldResolutionXY, motionFieldResolutionXY]);
        glCat.uniform1f('voxelUnit', motionFieldVoxelUnit);
        glCat.uniformTexture('samplerPcompute', glCatPath.fb('particlesComputeReturn').texture, 0);
        glCat.uniformTexture('samplerRandom', textureRandom, 1);
        glCat.uniformTexture('samplerRandomStatic', textureRandomStatic, 2);
        glCat.uniformTexture('samplerMotionWrite', glCatPath.fb('particlesMotionWrite').texture, 3);
        glCat.uniform1f('noisePhase', auto('particles-noisePhase'));
        glCat.uniform1f('noiseAmp', auto('particles-noiseAmp'));
        glCat.uniform1f('fluidAmp', auto('particles-fluidAmp'));
        glCat.uniform1f('genRate', auto('particles-genRate'));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    // == render particles =====================================================
    particlesRender: {
      vert: __webpack_require__(/*! ../shaders/particles-render.vert */ "./src/shaders/particles-render.vert"),
      frag: __webpack_require__(/*! ../shaders/particles-render.frag */ "./src/shaders/particles-render.frag"),
      blend: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],
      drawbuffers: 2,
      func: function func(path, params) {
        glCat.attributeDivisor('computeUV', vboComputeUV, 2, 1);
        glCat.attribute('geomPos', vboOctPos, 3);
        glCat.attribute('geomNor', vboOctNor, 3);
        glCat.uniform1f('nParticle', nParticle);
        glCat.uniform1f('nParticleSqrt', nParticleSqrt);
        glCat.uniform1f('ppp', ppp);
        glCat.uniform2fv('resolutionPcompute', [nParticleSqrt * ppp, nParticleSqrt]);
        glCat.uniform1i('isShadow', params.isShadow ? 1 : 0);
        glCat.uniform1f('colorVar', auto('particles-colorVar'));
        glCat.uniform1f('colorOffset', auto('particles-colorOffset'));
        glCat.uniformTexture('samplerPcompute', glCatPath.fb('particlesCompute').texture, 0);
        glCat.uniformTexture('samplerRandom', textureRandom, 1);
        glCat.uniformTexture('samplerRandomStatic', textureRandomStatic, 2);
        glCat.uniformTexture('samplerShadow', params.textureShadow || textureDummy, 3);
        var ext = glCat.getExtension('ANGLE_instanced_arrays');
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboOct);
        ext.drawElementsInstancedANGLE(gl.TRIANGLES, oct.index.length, gl.UNSIGNED_SHORT, 0, nParticle);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }
    }
  });

  if (false) {}
});

/***/ }),

/***/ "./src/paths/pixelsort.js":
/*!********************************!*\
  !*** ./src/paths/pixelsort.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
 // ------

/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var width = context.width;
  var height = context.height;
  var auto = context.automaton.auto; // ------

  var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_0__["default"].triangleStripQuad)); // ------

  glCatPath.add({
    pixelsortCompare: {
      width: width,
      height: height,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/pixelsort-compare.frag */ "./src/shaders/pixelsort-compare.frag"),
      blend: [gl.ONE, gl.ONE],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      tempFb: glCat.createFloatFramebuffer(width, height),
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1i('shadow', auto('pixelsort-shadow') < 0.5 ? false : true);
        glCat.uniform1f('threshold', auto('pixelsort-threshold'));
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    pixelsortRender: {
      width: width,
      height: height,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/pixelsort-render.frag */ "./src/shaders/pixelsort-render.frag"),
      blend: [gl.ONE, gl.ONE],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      tempFb: glCat.createFloatFramebuffer(width, height),
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1f('threshold', auto('pixelsort-threshold'));
        glCat.uniformTexture('sampler0', params.input, 0);
        glCat.uniformTexture('samplerMap', glCatPath.fb('pixelsortCompare').texture, 1);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
});

/***/ }),

/***/ "./src/paths/postfx.js":
/*!*****************************!*\
  !*** ./src/paths/postfx.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _libs_ultracat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/ultracat */ "./src/libs/ultracat.js");
 // ------

/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  var glCatPath = context.glCatPath;
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;
  var width = context.width;
  var height = context.height;
  var auto = context.automaton.auto; // ------

  var vboQuad = glCat.createVertexbuffer(new Float32Array(_libs_ultracat__WEBPACK_IMPORTED_MODULE_0__["default"].triangleStripQuad)); // ------

  glCatPath.add({
    post: {
      width: width,
      height: height,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/post.frag */ "./src/shaders/post.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1f('barrelAmp', auto('post-barrelAmp'));
        glCat.uniform1f('barrelOffset', auto('post-barrelOffset'));
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },
    fxaa: {
      width: width,
      height: height,
      vert: __webpack_require__(/*! ../shaders/quad.vert */ "./src/shaders/quad.vert"),
      frag: __webpack_require__(/*! ../shaders/fxaa.frag */ "./src/shaders/fxaa.frag"),
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
});

/***/ }),

/***/ "./src/shaders/bg.frag":
/*!*****************************!*\
  !*** ./src/shaders/bg.frag ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#extension GL_EXT_draw_buffers : require\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec4 bgColor;\nuniform float perspFar;\n\n// ------\n\nvoid main() {\n  gl_FragData[ 0 ] = bgColor;\n  gl_FragData[ 1 ] = vec4( perspFar, 0.0, 0.0, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/bloom-post.frag":
/*!*************************************!*\
  !*** ./src/shaders/bloom-post.frag ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define saturate(i) clamp(i,0.,1.)\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D samplerDry;\nuniform sampler2D samplerWet;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec3 dry = texture2D( samplerDry, uv ).xyz;\n  vec3 wet = texture2D( samplerWet, uv ).xyz;\n  gl_FragColor = vec4( max( vec3( 0.0 ), saturate( dry + wet ) ), 1.0 );\n}\n"

/***/ }),

/***/ "./src/shaders/bloom-pre.frag":
/*!************************************!*\
  !*** ./src/shaders/bloom-pre.frag ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec3 bias;\nuniform vec3 factor;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 deltaTexel = 0.25 / resolution;\n  vec2 uvOrigin = ( floor( gl_FragCoord.xy ) + deltaTexel * 0.5 ) / resolution;\n\n  vec3 sum = vec3( 0.0 );\n  for ( int iy = 0; iy < 4; iy ++ ) {\n    for ( int ix = 0; ix < 4; ix ++ ) {\n      vec2 uv = uvOrigin + vec2( ix, iy ) * deltaTexel;\n      sum += texture2D( sampler0, uv ).xyz / 16.0;\n    }\n  }\n\n  gl_FragColor = vec4(\n    max( vec3( 0.0 ), ( sum + bias ) * factor ),\n    1.0\n  );\n}\n"

/***/ }),

/***/ "./src/shaders/box.frag":
/*!******************************!*\
  !*** ./src/shaders/box.frag ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define TAU 6.283185307\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPos;\n\nuniform float time;\n\nvoid main() {\n  float h = vPos.x + vPos.y + vPos.z; // h\n  float wave = sin( 20.0 * h + 4.0 * TAU * time );\n  float slash = step( -0.3, wave );\n  gl_FragColor = vec4( vec3( slash * 0.8 ), 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/box.vert":
/*!******************************!*\
  !*** ./src/shaders/box.vert ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nattribute vec3 pos;\n\nuniform vec2 resolution;\nuniform vec3 color;\n\nvarying vec3 vPos;\n\nuniform bool isShadow;\n\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matPL;\nuniform mat4 matVL;\nuniform mat4 matM;\n\n// ------\n\nvoid main() {\n  vec4 pos = matM * vec4( pos, 1.0 );\n  vPos = pos.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * pos;\n  } else {\n    outPos = matP * matV * pos;\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n}"

/***/ }),

/***/ "./src/shaders/fxaa.frag":
/*!*******************************!*\
  !*** ./src/shaders/fxaa.frag ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n\n#define FXAA_REDUCE_MIN (1.0 / 128.0)\n#define FXAA_REDUCE_MUL (1.0 / 8.0)\n#define FXAA_SPAN_MAX 16.0\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\n\nuniform sampler2D texture;\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  #define T(v) texture2D( texture, (v) / resolution ).xyz\n  vec3 rgb11 = T( gl_FragCoord.xy );\n  vec3 rgb00 = T( gl_FragCoord.xy + V.zz );\n  vec3 rgb02 = T( gl_FragCoord.xy + V.zy );\n  vec3 rgb20 = T( gl_FragCoord.xy + V.yz );\n  vec3 rgb22 = T( gl_FragCoord.xy + V.yy );\n  #undef T\n\n  vec3 luma = vec3( 0.299, 0.587, 0.114 );\n  #define L(c) dot( c, luma )\n  float luma11 = L( rgb11 );\n  float luma00 = L( rgb00 );\n  float luma02 = L( rgb02 );\n  float luma20 = L( rgb20 );\n  float luma22 = L( rgb22 );\n  #undef L\n\n  float lumaMin = min( luma00, min( min( luma00, luma02 ), min( luma20, luma22 ) ) );\n  float lumaMax = max( luma00, max( max( luma00, luma02 ), max( luma20, luma22 ) ) );\n\n  vec2 dir = vec2(\n    -( ( luma00 + luma20 ) - ( luma02 + luma22 ) ),\n    ( ( luma00 + luma02 ) - ( luma20 + luma22 ) )\n  );\n\n  float dirReduce = max(\n    ( luma00 + luma02 + luma20 + luma22 ) * 0.25 * FXAA_REDUCE_MUL,\n    FXAA_REDUCE_MIN\n  );\n  float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n  dir = min(\n    vec2( FXAA_SPAN_MAX ),\n    max(\n      vec2( -FXAA_SPAN_MAX ),\n      dir * rcpDirMin\n    )\n  ) / resolution;\n\n  vec3 rgbA = 0.5 * (\n    texture2D( texture, uv + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +\n    texture2D( texture, uv + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz\n  );\n  vec3 rgbB = rgbA * 0.5 + 0.25 * (\n    texture2D( texture, uv - dir * 0.5 ).xyz +\n    texture2D( texture, uv + dir * 0.5 ).xyz\n  );\n\n  float lumaB = dot( rgbB, luma );\n  gl_FragColor = (\n    ( ( lumaB < lumaMin ) || ( lumaMax < lumaB ) ) ?\n    vec4( rgbA, 1.0 ) :\n    vec4( rgbB, 1.0 )\n  );\n}"

/***/ }),

/***/ "./src/shaders/gauss.frag":
/*!********************************!*\
  !*** ./src/shaders/gauss.frag ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define saturate(i) clamp(i,0.,1.)\n#define PI 3.14159265\n#define SAMPLES 20\n#define MUL_THR 0.01\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform bool isVert;\nuniform sampler2D sampler0;\n\nuniform float var;\n\nfloat gaussian( float _x, float _v ) {\n  return 1.0 / sqrt( 2.0 * PI * _v ) * exp( - _x * _x / 2.0 / _v );\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  if ( var <= 0.0 ) {\n    gl_FragColor = texture2D( sampler0, uv );\n    return;\n  }\n\n  vec2 bv = ( isVert ? vec2( 0.0, 1.0 ) : vec2( 1.0, 0.0 ) ) / resolution;\n\n  vec3 sum = vec3( 0.0 );\n  for ( int i = 0; i <= SAMPLES; i ++ ) {\n    float mul = gaussian( abs( float( i ) ), var );\n    if ( mul < MUL_THR ) { break; }\n    for ( int j = -1; j < 2; j += 2 ) {\n      vec2 v = saturate( uv + bv * float( i * j ) );\n      vec3 tex = texture2D( sampler0, v ).xyz;\n      sum += tex * mul;\n      if ( i == 0 ) { break; }\n    }\n  }\n\n  gl_FragColor = vec4( sum, 1.0 );\n}\n"

/***/ }),

/***/ "./src/shaders/inspector.frag":
/*!************************************!*\
  !*** ./src/shaders/inspector.frag ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define RADIUS 40.0\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 mouse;\nuniform vec3 circleColor;\nuniform sampler2D sampler0;\n\nbool print( in vec2 _coord, float _in ) {\n  vec2 coord = _coord;\n\n  // vertical restriction\n  if ( coord.y <= 0.0 || 5.0 <= coord.y ) { return false; }\n  \n  // dot\n  if ( 0.0 < coord.x && coord.x < 2.0 ) {\n    return coord.x < 1.0 && coord.y < 1.0;\n  }\n\n  // padded by dot\n  if ( 2.0 < coord.x ) { coord.x -= 2.0; }\n  \n  // determine digit\n  float ci = floor( coord.x / 5.0 ) + 1.0;\n\n  // too low / too high\n  if ( 4.0 < ci ) { return false; }\n  if ( ci < -4.0 ) { return false; }\n\n  // x of char\n  float cfx = floor( mod( coord.x, 5.0 ) );\n\n  // width is 4\n  if ( 4.0 == cfx ) { return false; }\n\n  // y of char\n  float cfy = floor( coord.y );\n\n  // bit of char\n  float cf = cfx + 4.0 * cfy;\n\n  // determine char  \n  float num = 0.0;\n  if ( 0.0 < ci ) {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( ci < float( i ) ) { break; }\n      \n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n *= 10.0;\n    }\n  } else {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( -ci < float( i ) ) { break; }\n      \n      if ( ci != 0.0 && n < 1.0 ) {\n        // minus\n        return float( i ) == -ci && _in < 0.0 && cfy == 2.0 && 0.0 < cfx;\n      }\n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n /= 10.0;\n    }\n  }\n\n  bool a;\n  a = 1.0 == mod( floor( (\n    num == 0.0 ? 432534.0 :\n    num == 1.0 ? 410692.0 :\n    num == 2.0 ? 493087.0 :\n    num == 3.0 ? 493191.0 :\n    num == 4.0 ? 630408.0 :\n    num == 5.0 ? 989063.0 :\n    num == 6.0 ? 399254.0 :\n    num == 7.0 ? 1016898.0 :\n    num == 8.0 ? 431766.0 :\n    433798.0\n  ) / pow( 2.0, cf ) ), 2.0 );\n  \n  return a ? true : false;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  vec2 m = floor( vec2( 0.0, resolution.y ) + vec2( 1.0, -1.0 ) * mouse );\n  vec2 center = floor( m + vec2( 1.0, 0.7 ) * RADIUS );\n  float circle = length( gl_FragCoord.xy - center ) - RADIUS;\n\n  vec4 col = texture2D( sampler0, uv );\n  vec4 mcol = texture2D( sampler0, ( m + 0.5 ) / resolution );\n  vec4 bcol = vec4( circleColor, 1.0 );\n\n  col = mix(\n    col,\n    mix(\n      bcol,\n      mcol,\n      smoothstep( 1.0, 0.0, circle + 5.0 )\n    ),\n    smoothstep( 1.0, 0.0, circle )\n  );\n\n  if ( circle < 0.0 ) {\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, 8.0 ), mcol.x ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, 0.0 ), mcol.y ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, -8.0 ), mcol.z ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, -16.0 ), mcol.w ) ? bcol : col;\n  }\n\n  gl_FragColor = col;\n}"

/***/ }),

/***/ "./src/shaders/particles-compute.frag":
/*!********************************************!*\
  !*** ./src/shaders/particles-compute.frag ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define PARTICLE_LIFE_LENGTH 1.0\n\n#define HUGE 9E16\n#define PI 3.14159265\n#define TAU 6.283185307\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i)/(m)+.5)*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nuniform float nParticleSqrt;\nuniform float nParticle;\nuniform float ppp;\n\nuniform float totalFrame;\nuniform bool init;\nuniform float deltaTime;\nuniform vec2 resolution;\n\nuniform bool isInitFrame;\n\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform sampler2D samplerPcompute;\nuniform sampler2D samplerMotionWrite;\nuniform sampler2D samplerRandom;\n\nuniform float noisePhase;\nuniform float noiseAmp;\nuniform float fluidAmp;\nuniform float velScale;\nuniform float genRate;\n\n// ------\n\nvec2 vInvert( vec2 _uv ) {\n  return vec2( 0.0, 1.0 ) + vec2( 1.0, -1.0 ) * _uv;\n}\n\n// ------\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\nfloat fractSin( float i ) {\n  return fract( sin( i ) * 1846.42 );\n}\n\nvec4 sampleRandom( vec2 _uv ) {\n  return texture2D( samplerRandom, _uv );\n}\n\nfloat GPURnd(inout vec4 n)\n{\n\t// Based on the post http://gpgpu.org/forums/viewtopic.php?t=2591&sid=17051481b9f78fb49fba5b98a5e0f1f3\n\t// (The page no longer exists as of March 17th, 2015. Please let me know if you see why this code works.)\n\tconst vec4 q = vec4(   1225.0,    1585.0,    2457.0,    2098.0);\n\tconst vec4 r = vec4(   1112.0,     367.0,      92.0,     265.0);\n\tconst vec4 a = vec4(   3423.0,    2646.0,    1707.0,    1999.0);\n\tconst vec4 m = vec4(4194287.0, 4194277.0, 4194191.0, 4194167.0);\n\n\tvec4 beta = floor(n / q);\n\tvec4 p = a * (n - beta * q) - beta * r;\n\tbeta = (sign(-p) + vec4(1.0)) * vec4(0.5) * m;\n\tn = (p + beta);\n\n\treturn fract(dot(n / m, vec4(1.0, -1.0, 1.0, -1.0)));\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\nvec3 randomSphere( inout vec4 seed ) {\n  vec3 v;\n  for ( int i = 0; i < 10; i ++ ) {\n    v = vec3(\n      GPURnd( seed ),\n      GPURnd( seed ),\n      GPURnd( seed )\n    ) * 2.0 - 1.0;\n    if ( length( v ) < 1.0 ) { break; }\n  }\n  return v;\n}\n\nvec2 randomCircle( inout vec4 seed ) {\n  vec2 v;\n  for ( int i = 0; i < 10; i ++ ) {\n    v = vec2(\n      GPURnd( seed ),\n      GPURnd( seed )\n    ) * 2.0 - 1.0;\n    if ( length( v ) < 1.0 ) { break; }\n  }\n  return v;\n}\n\nvec3 randomBox( inout vec4 seed ) {\n  vec3 v;\n  v = vec3(\n    GPURnd( seed ),\n    GPURnd( seed ),\n    GPURnd( seed )\n  ) * 2.0 - 1.0;\n  return v;\n}\n\n// == deal with motion field ===================================================\nvec3 fetchMotionLinear( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec3 vf = ( _v / voxelUnit );\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec3( 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange ) + ( fract( vf.z ) < 0.5 ? -1.0 : 0.0 );\n  vec2 planeOrigin0 = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n  planeIndex += 1.0;\n  vec2 planeOrigin1 = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec3( 0.0 );\n  }\n\n  vec2 uv0 = planeOrigin0 + ( vf.xy + xyRange ) / planeResolution * planeSize;\n  vec2 uv1 = planeOrigin1 + ( vf.xy + xyRange ) / planeResolution * planeSize;\n  return mix(\n    texture2D( samplerMotionWrite, uv0 ).xyz,\n    texture2D( samplerMotionWrite, uv1 ).xyz,\n    fract( vf.z + 0.5 )\n  );\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 puv = vec2( ( floor( gl_FragCoord.x / ppp ) * ppp + 0.5 ) / resolution.x, uv.y );\n  float mode = mod( gl_FragCoord.x, ppp );\n  vec2 dpix = vec2( 1.0 ) / resolution;\n\n  float dt = deltaTime;\n\n  // == prepare some vars ======================================================\n  vec4 seed = texture2D( samplerRandom, puv );\n  GPURnd( seed );\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dpix * vec2( 1.0, 0.0 ) );\n\n  float timing = mix(\n    0.0,\n    PARTICLE_LIFE_LENGTH,\n    lofi( floor( puv.y * nParticleSqrt ) / nParticleSqrt, 1.0 / 4.0 )\n  );\n  timing += lofi( time, PARTICLE_LIFE_LENGTH );\n\n  if ( time - deltaTime + PARTICLE_LIFE_LENGTH < timing ) {\n    timing -= PARTICLE_LIFE_LENGTH;\n  }\n\n  // == initialize particles ===================================================\n  // if ( isInitFrame ) {\n  //   pos.w = 0.0;\n  // }\n\n  // == generate particles =====================================================\n  if (\n    time - deltaTime < timing && timing <= time &&\n    GPURnd( seed ) < genRate\n  ) {\n    dt = time - timing;\n\n    vec4 thisIsVeryTemporaryVariable = vec4( time );\n    pos.xyz = 0.1 * randomSphere( seed ) + randomSphere( thisIsVeryTemporaryVariable );\n    pos.xyz += 0.6 * vec3(\n      -snoise( vec4( 1.8 * pos.xyz, 1.8112 + noisePhase ) ),\n      snoise( vec4( 1.8 * pos.xyz, 3.8112 + noisePhase ) ),\n      -snoise( vec4( 1.8 * pos.xyz, 5.8112 + noisePhase ) )\n    );\n\n    vel.xyz = 0.1 * randomSphere( seed );\n    vel.w = 0.0;\n\n    pos.w = 1.0; // life\n  }\n  \n  if ( pos.w <= 0.0 ) {\n    pos = vec4( 0.0 );\n    vel = vec4( 0.0 );\n  } else {\n    // == update particles =====================================================\n    // fluid\n    {\n      vec3 motion = fetchMotionLinear( pos.xyz );\n      vec3 tmp = pos.xyz + dt * 0.5 * ( vel.xyz + motion );\n      motion = fetchMotionLinear( pos.xyz );\n      vel.xyz += fluidAmp * motion;\n    }\n\n    // wall\n    float border = 2.0;\n    for ( int i = 0; i < 3; i ++ ) {\n      if ( border < abs( pos[ i ] ) ) {\n        float s = sign( pos[ i ] );\n        pos[ i ] = s * border;\n      }\n    }\n\n    // voltex\n    // vel.zx -= dt * 10.0 * vec2( -1.0, 1.0 ) * normalize( pos.xz );\n\n    // noise\n    // vel.xyz += dt * noiseAmp * 20.0 * vec3(\n    //   -noise( vec4( 1.8 * pos.xyz, 1.485 + noisePhase ) ),\n    //   noise( vec4( 1.8 * pos.xyz, 3.485 + noisePhase ) ),\n    //   -noise( vec4( 1.8 * pos.xyz, 5.485 + noisePhase ) )\n    // );\n\n    // gravity\n    // vel.y -= dt * 10.8;\n\n    pos.xyz += vel.xyz * dt;\n    pos.xyz += 0.01 * dt * ( vec3(\n      GPURnd( seed ),\n      GPURnd( seed ),\n      GPURnd( seed )\n    ) - 0.5 );\n    pos.w -= dt / PARTICLE_LIFE_LENGTH;\n  }\n\n  gl_FragColor = (\n    mode < 1.0 ? pos :\n    vel\n  );\n}"

/***/ }),

/***/ "./src/shaders/particles-divergence.frag":
/*!***********************************************!*\
  !*** ./src/shaders/particles-divergence.frag ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\n// == variables ================================================================\nuniform float nParticle;\n\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform sampler2D samplerMotion;\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\nvec3 motionCoordInv( vec2 _coord ) {\n  vec2 planeSize = planeResolution / resolutionMotion;\n  vec3 ret = vec3( 0.0 );\n\n  // == x and y ================================================================\n  ret.xy = ( ( fract( _coord / planeSize ) - 0.5 ) * planeResolution ) * voxelUnit;\n\n  // == z ======================================================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  vec2 planePlace = floor( _coord / planeSize );\n  ret.z = ( planePlace.x + floor( planePlace.y / planeSize.x ) - zRange + 0.5 ) * voxelUnit;\n\n  return ret;\n}\n\n// == main =====================================================================\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolutionMotion;\n  vec3 v = motionCoordInv( uv );\n\n  vec2 d = vec2( 0.0, voxelUnit );\n\n  vec4 center = texture2D( samplerMotion, uv );\n  float xm = texture2D( samplerMotion, motionCoord( v - d.yxx ) ).x;\n  float xp = texture2D( samplerMotion, motionCoord( v + d.yxx ) ).x;\n  float ym = texture2D( samplerMotion, motionCoord( v - d.xyx ) ).y;\n  float yp = texture2D( samplerMotion, motionCoord( v + d.xyx ) ).y;\n  float zm = texture2D( samplerMotion, motionCoord( v - d.xxy ) ).z;\n  float zp = texture2D( samplerMotion, motionCoord( v + d.xxy ) ).z;\n\n  float divergence = xp - xm + yp - ym + zp - zm;\n  divergence -= max( center.w / nParticle * 600.0 - 1.0, 0.0 );\n\n  gl_FragColor = vec4( divergence, 0.0, 0.0, center.w );\n}"

/***/ }),

/***/ "./src/shaders/particles-enforce.frag":
/*!********************************************!*\
  !*** ./src/shaders/particles-enforce.frag ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\n// == variables ================================================================\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform float deltaTime;\nuniform sampler2D samplerMotion;\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\nvec3 motionCoordInv( vec2 _coord ) {\n  vec2 planeSize = planeResolution / resolutionMotion;\n  vec3 ret = vec3( 0.0 );\n\n  // == x and y ================================================================\n  ret.xy = ( ( fract( _coord / planeSize ) - 0.5 ) * planeResolution ) * voxelUnit;\n\n  // == z ======================================================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  vec2 planePlace = floor( _coord / planeSize );\n  ret.z = ( planePlace.x + floor( planePlace.y / planeSize.x ) - zRange + 0.5 ) * voxelUnit;\n\n  return ret;\n}\n\n// == um =======================================================================\nvec3 extractVelocity( vec4 tex ) {\n  return tex.w == 0.0 ? vec3( 0.0 ) : tex.xyz / tex.w;\n}\n\n// == main =====================================================================\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolutionMotion;\n  vec3 v = motionCoordInv( uv );\n  vec3 mul = vec3( 1.0 );\n\n  for ( int i = 0; i < 3; i ++ ) {\n    float border = 2.0;\n    if ( border < abs( v[ i ] ) ) {\n      v[ i ] = border;\n      mul[ i ] *= -1.0;\n    }\n  }\n\n  vec3 vel = vec3( 0.0 );\n\n  for ( int iz = -1; iz <= 1; iz ++ ) {\n    for ( int iy = -1; iy <= 1; iy ++ ) {\n      for ( int ix = -1; ix <= 1; ix ++ ) {\n        vec4 tex = texture2D( samplerMotion, motionCoord( v + vec3( ix, iy, iz ) * voxelUnit ) );\n        vel += extractVelocity( tex ) / 27.0;\n      }\n    }\n  }\n\n  vec4 tex = texture2D( samplerMotion, uv );\n  vel += deltaTime * ( tex.w == 0.0 ? vec3( 0.0 ) : vec3( 0.0, -10.0, 0.0 ) );\n\n  gl_FragColor = vec4( mul * vel, tex.w );\n}"

/***/ }),

/***/ "./src/shaders/particles-motion-read.frag":
/*!************************************************!*\
  !*** ./src/shaders/particles-motion-read.frag ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\n// == variables ================================================================\nvarying vec3 vCol;\nvarying float vValid;\n\nvoid main() {\n  // == if it is invalid then just discard =====================================\n  if ( vValid == 0.0 ) { discard; }\n\n  // == just shot a dot ========================================================\n  gl_FragColor = vec4( vCol, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/particles-motion-read.vert":
/*!************************************************!*\
  !*** ./src/shaders/particles-motion-read.vert ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.141592654\n#define TAU 6.283185307\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i+0.5)/(m))*(m))\n\n// == variables ================================================================\nattribute vec2 computeUV;\n\nvarying vec3 vCol;\nvarying float vValid;\n\nuniform vec2 resolutionPcompute;\n\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform sampler2D samplerPcompute;\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\n// == main =====================================================================\nvoid main() {\n  // == fetch compute texture ==================================================\n  vec2 puv = computeUV;\n  vec2 dppix = vec2( 1.0 ) / resolutionPcompute;\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dppix * vec2( 1.0, 0.0 ) );\n\n  // == place a dot ============================================================\n  vec2 coord = motionCoord( pos.xyz );\n  vValid = coord != vec2( 0.0, 0.0 ) ? 1.0 : 0.0; // out of compute cells\n  vValid = 0.0 < pos.w ? 1.0 : 0.0; // life is depleted\n  gl_Position = vec4( coord * 2.0 - 1.0, 0.0, 1.0 );\n  gl_PointSize = 1.0;\n\n  // == set a color ============================================================\n  vCol = vel.xyz;\n}"

/***/ }),

/***/ "./src/shaders/particles-motion-write.frag":
/*!*************************************************!*\
  !*** ./src/shaders/particles-motion-write.frag ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\n// == variables ================================================================\nuniform float deltaTime;\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform sampler2D samplerMotion;\nuniform sampler2D samplerPressure;\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\nvec3 motionCoordInv( vec2 _coord ) {\n  vec2 planeSize = planeResolution / resolutionMotion;\n  vec3 ret = vec3( 0.0 );\n\n  // == x and y ================================================================\n  ret.xy = ( ( fract( _coord / planeSize ) - 0.5 ) * planeResolution ) * voxelUnit;\n\n  // == z ======================================================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  vec2 planePlace = floor( _coord / planeSize );\n  ret.z = ( planePlace.x + floor( planePlace.y / planeSize.x ) - zRange + 0.5 ) * voxelUnit;\n\n  return ret;\n}\n\n// == um =======================================================================\nvec3 extractVelocity( vec4 tex ) {\n  return tex.w == 0.0 ? vec3( 0.0 ) : tex.xyz / tex.w;\n}\n\n// == main =====================================================================\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolutionMotion;\n  vec3 v = motionCoordInv( uv );\n  vec3 mul = vec3( 1.0 );\n\n  for ( int i = 0; i < 3; i ++ ) {\n    float border = 2.0;\n    if ( border < abs( v[ i ] ) ) {\n      v[ i ] = border;\n      mul[ i ] *= -1.0;\n    }\n  }\n\n  vec2 d = vec2( 0.0, voxelUnit );\n\n  float xm = texture2D( samplerPressure, motionCoord( v - d.yxx ) ).x;\n  float xp = texture2D( samplerPressure, motionCoord( v + d.yxx ) ).x;\n  float ym = texture2D( samplerPressure, motionCoord( v - d.xyx ) ).x;\n  float yp = texture2D( samplerPressure, motionCoord( v + d.xyx ) ).x;\n  float zm = texture2D( samplerPressure, motionCoord( v - d.xxy ) ).x;\n  float zp = texture2D( samplerPressure, motionCoord( v + d.xxy ) ).x;\n\n  vec3 oldVel = extractVelocity( texture2D( samplerMotion, uv ) );\n  vec3 newVel = oldVel - vec3( xp - xm, yp - ym, zp - zm );\n  newVel *= mul;\n\n  if ( voxelUnit / deltaTime < length( newVel ) ) {\n    newVel = normalize( newVel ) * voxelUnit / deltaTime;\n  }\n\n  gl_FragColor = vec4( newVel - oldVel, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/particles-pressure.frag":
/*!*********************************************!*\
  !*** ./src/shaders/particles-pressure.frag ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\n// == variables ================================================================\nuniform vec2 resolutionMotion;\nuniform vec2 planeResolution;\nuniform float voxelUnit;\n\nuniform sampler2D samplerDivergence;\nuniform sampler2D samplerPressure;\n\n// == deal with motion field ===================================================\nvec2 motionCoord( vec3 _v ) {\n  vec3 v = floor( _v / voxelUnit ) + 0.5;\n  vec2 planeSize = planeResolution / resolutionMotion;\n\n  // == where are the plane origin? ============================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  if ( v.z < -zRange || zRange < v.z ) {\n    return vec2( 0.0, 0.0 );\n  }\n  float planeIndex = floor( v.z + zRange );\n  vec2 planeOrigin = vec2( fract( planeIndex * planeSize.x ), floor( planeIndex * planeSize.x ) * planeSize.y );\n\n  // == place a dot on the plane ===============================================\n  vec2 xyRange = planeResolution / 2.0;\n  if ( v.x < -xyRange.x || xyRange.x < v.x || v.y < -xyRange.y || xyRange.y < v.y ) {\n    return vec2( 0.0, 0.0 );\n  }\n  return planeOrigin + ( v.xy + xyRange ) / planeResolution * planeSize;\n}\n\nvec3 motionCoordInv( vec2 _coord ) {\n  vec2 planeSize = planeResolution / resolutionMotion;\n  vec3 ret = vec3( 0.0 );\n\n  // == x and y ================================================================\n  ret.xy = ( ( fract( _coord / planeSize ) - 0.5 ) * planeResolution ) * voxelUnit;\n\n  // == z ======================================================================\n  float zRange = floor( 1.0 / planeSize.x ) * floor( 1.0 / planeSize.y ) / 2.0;\n  vec2 planePlace = floor( _coord / planeSize );\n  ret.z = ( planePlace.x + floor( planePlace.y / planeSize.x ) - zRange + 0.5 ) * voxelUnit;\n\n  return ret;\n}\n\n// == main =====================================================================\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolutionMotion;\n  vec3 v = motionCoordInv( uv );\n\n  vec2 d = vec2( 0.0, voxelUnit );\n\n  vec4 divergence = texture2D( samplerDivergence, uv );\n  if ( divergence.w == 0.0 ) { discard; } // this is an air\n\n  float xm = texture2D( samplerPressure, motionCoord( v - d.yxx ) ).x;\n  float xp = texture2D( samplerPressure, motionCoord( v + d.yxx ) ).x;\n  float ym = texture2D( samplerPressure, motionCoord( v - d.xyx ) ).x;\n  float yp = texture2D( samplerPressure, motionCoord( v + d.xyx ) ).x;\n  float zm = texture2D( samplerPressure, motionCoord( v - d.xxy ) ).x;\n  float zp = texture2D( samplerPressure, motionCoord( v + d.xxy ) ).x;\n\n  float pressure = ( xm + xp + ym + yp + zm + zp - divergence.x ) / 6.0;\n\n  gl_FragColor = vec4( pressure, 0.0, 0.0, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/particles-render.frag":
/*!*******************************************!*\
  !*** ./src/shaders/particles-render.frag ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define PI 3.14159265\n#define TAU 6.28318531\n#define saturate(i) clamp(i,0.,1.)\n\n// ------\n\n#extension GL_EXT_draw_buffers : require\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPos;\nvarying vec3 vNor;\nvarying vec3 vCol;\nvarying float vLife;\n\nuniform mat4 matPL;\nuniform mat4 matVL;\n\nuniform vec3 cameraPos;\nuniform float perspFar;\nuniform vec3 lightPos;\n\nuniform bool isShadow;\n\nuniform sampler2D samplerShadow;\n\n// == rotate ===================================================================\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\n// == uh =======================================================================\nfloat shadow( float d ) {\n  vec4 pl = matPL * matVL * vec4( vPos, 1.0 );\n  vec2 uv = pl.xy / pl.w * 0.5 + 0.5;\n\n  float dc = length( vPos - lightPos );\n  float ret = 0.0;\n  for ( int iy = -1; iy <= 1; iy ++ ) {\n    for ( int ix = -1; ix <= 1; ix ++ ) {\n      vec2 uv = uv + vec2( float( ix ), float ( iy ) ) * 1E-3;\n      float proj = texture2D( samplerShadow, uv ).x;\n      float bias = 0.1 + ( 1.0 - d ) * 0.3;\n\n      float dif = smoothstep( bias * 2.0, bias, ( dc - proj ) );\n      ret += dif / 9.0;\n    }\n  }\n  return ret;\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  if ( vLife <= 0.0 ) { discard; }\n\n  if ( isShadow ) {\n    float depth = length( vPos - lightPos );\n    gl_FragData[ 0 ] = vec4( depth, 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  vec3 lightDir = normalize( vPos - lightPos );\n  vec3 rayDir = normalize( vPos - cameraPos );\n  float d = dot( -vNor, lightDir );\n  float dif = mix( 1.0, d, 0.5 );\n  vec3 col = dif * vCol;\n\n  float shadowFactor = shadow( d );\n  col *= mix( 0.5, 1.0, shadowFactor );\n  col = max( vec3( 0.0 ), col );\n\n  gl_FragData[ 0 ] = vec4( col, 1.0 );\n  gl_FragData[ 1 ] = vec4( length( cameraPos - vPos ), 0.0, 0.0, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/particles-render.vert":
/*!*******************************************!*\
  !*** ./src/shaders/particles-render.vert ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.141592654\n#define TAU 6.283185307\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i+0.5)/(m))*(m))\n\n// ------\n\nattribute vec2 computeUV;\nattribute vec3 geomPos;\nattribute vec3 geomNor;\n\nvarying vec3 vPos;\nvarying vec3 vNor;\nvarying vec3 vCol;\nvarying float vLife;\n\nuniform vec2 resolution;\nuniform vec2 resolutionPcompute;\n\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matVL;\nuniform mat4 matPL;\n\nuniform bool isShadow;\n\nuniform float colorVar;\nuniform float colorOffset;\n\nuniform sampler2D samplerPcompute;\nuniform sampler2D samplerRandomStatic;\n\n// ------\n\nvec3 catColor( float _p ) {\n  return 0.5 + 0.5 * vec3(\n    cos( _p ),\n    cos( _p + PI / 3.0 * 4.0 ),\n    cos( _p + PI / 3.0 * 2.0 )\n  );\n}\n\nvec4 random( vec2 _uv ) {\n  return texture2D( samplerRandomStatic, _uv );\n}\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\n// ------\n\nvec3 rotateGeometry( vec3 _p, vec3 _v ) {\n  vec3 v = _v;\n  v.yz = rotate2D( 4.0 * _p.x ) * v.yz;\n  v.zx = rotate2D( 4.0 * _p.y ) * v.zx;\n  v.xy = rotate2D( 4.0 * _p.z ) * v.xy;\n  return v;\n}\n\nvoid main() {\n  // == fetch compute texture ==================================================\n  vec2 puv = computeUV;\n  vec2 dppix = vec2( 1.0 ) / resolutionPcompute;\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dppix * vec2( 1.0, 0.0 ) );\n\n  // == ???????? ===============================================================\n  vec4 dice = random( puv.yy * 182.92 );\n\n  // == assign varying variables ===============================================\n  vLife = pos.w;\n\n  // vCol = (\n  //   dice.y < 0.8\n  //   ? pow( catColor( TAU * ( ( dice.x * 2.0 - 1.0 ) * colorVar + colorOffset ) ), vec3( 2.0 ) )\n  //   : vec3( 0.4 )\n  // );\n  // vCol = abs( vel.xyz );\n  vCol = catColor( 4.5 - length( vel ) * 0.3 );\n  vCol *= 0.5 + 0.4 * length( vel );\n  vCol *= vLife;\n  // vCol = vec3( 5.0 );\n\n  // == geometry ===============================================================\n  float size = ( 0.01 + 0.01 * pow( dice.w, 2.0 ) );\n  size *= min( length( vCol ), 1.0 );\n\n  vNor = rotateGeometry( pos.xyz, geomNor );\n  pos.xyz += size * rotateGeometry( pos.xyz, geomPos );\n\n  // == finalize ===============================================================\n  vPos = pos.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * vec4( pos.xyz, 1.0 );\n  } else {\n    outPos = matP * matV * vec4( pos.xyz, 1.0 );\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n  // gl_PointSize = resolution.y * size / outPos.z;\n}"

/***/ }),

/***/ "./src/shaders/pixelsort-compare.frag":
/*!********************************************!*\
  !*** ./src/shaders/pixelsort-compare.frag ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define DIR false\n#define REVERSE false\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\n\nuniform float threshold;\nuniform bool shadow;\nuniform sampler2D sampler0;\n\nfloat gray( vec3 c ) {\n  return dot( c, vec3( 0.299, 0.587, 0.114 ) );\n}\n\nvec3 toRgb( float i ) {\n  return vec3(\n    mod( i, 256.0 ),\n    mod( floor( i / 256.0 ), 256.0 ),\n    floor( i / 65536.0 )\n  ) / 255.0;\n}\n\nbool thr( float v ) {\n  return shadow ? ( threshold < v ) : ( v < 1.0 - threshold );\n}\n\nvec4 draw( vec2 uv ) {\n  vec2 dir = DIR ? vec2( 0.0, 1.0 ) : vec2( 1.0, 0.0 );\n  float wid = DIR ? resolution.y : resolution.x;\n  float pos = DIR ? floor( uv.y * resolution.y ) : floor( uv.x * resolution.x );\n  \n  float val = gray( texture2D( sampler0, uv ).xyz );\n  \n  if ( !thr( val ) ) {\n    float post = pos;\n    float rank = 0.0;\n    float head = 0.0;\n    float tail = 0.0;\n    \n    for ( int i = 0; i < 2000; i ++ ) {\n      if ( int( wid ) == i ) { break; }\n      post -= 1.0;\n      if ( post == -1.0 ) { head = post + 1.0; break; }\n      vec2 p = dir * ( post + 0.5 ) / wid + dir.yx * uv;\n      float v = gray( texture2D( sampler0, p ).xyz );\n      if ( thr( v ) ) { head = post + 1.0; break; }\n      if ( v <= val ) { rank += 1.0; }\n    }\n    \n    post = pos;\n    for ( int i = 0; i < 2000; i ++ ) {\n      if ( int( wid ) == i ) { break; }\n      post += 1.0;\n      if ( wid == post ) { tail = post - 1.0; break; }\n      vec2 p = dir * ( post + 0.5 ) / wid + dir.yx * uv;\n      float v = gray( texture2D( sampler0, p ).xyz );\n      if ( thr( v ) ) { tail = post - 1.0; break; }\n      if ( v < val ) { rank += 1.0; }\n    }\n    \n    pos = REVERSE ? ( tail - rank ) : ( head + rank );\n  }\n  \n  return vec4( toRgb( pos ), 1.0 );\n}\n\nvoid main() {\n  gl_FragColor = draw( gl_FragCoord.xy / resolution.xy );\n}"

/***/ }),

/***/ "./src/shaders/pixelsort-render.frag":
/*!*******************************************!*\
  !*** ./src/shaders/pixelsort-render.frag ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define DIR false\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\n\nuniform sampler2D sampler0;\nuniform sampler2D samplerMap;\n\nfloat fromRgb( vec3 v ) {\n  return ( ( v.z * 256.0 + v.y ) * 256.0 + v.x ) * 255.0;\n}\n\nvec4 draw( vec2 uv ) {\n  vec2 dir = DIR ? vec2( 0.0, 1.0 ) : vec2( 1.0, 0.0 );\n  float wid = DIR ? resolution.y : resolution.x;\n  float pos = DIR ? floor( uv.y * resolution.y ) : floor( uv.x * resolution.x );\n  \n  for ( int i = 0; i < 2000; i ++ ) {\n    if ( int( wid ) == i ) { break; }\n\n    vec2 p = uv + dir * float( i ) / wid;\n    if ( p.x < 1.0 && p.y < 1.0 ) {\n      float v = fromRgb( texture2D( samplerMap, p ).xyz );\n      if ( abs( v - pos ) < 0.5 ) {\n        return texture2D( sampler0, p );\n        break;\n      }\n    }\n    \n    p = uv - dir * float( i ) / wid;\n    if ( 0.0 < p.x && 0.0 < p.y ) {\n      float v = fromRgb( texture2D( samplerMap, p ).xyz );\n      if ( abs( v - pos ) < 0.5 ) {\n        return texture2D( sampler0, p );\n        break;\n      }\n    }\n  }\n  \n  return vec4( 1.0, 0.0, 1.0, 1.0 );\n}\n\nvoid main() {\n  gl_FragColor = draw( gl_FragCoord.xy / resolution.xy );\n}"

/***/ }),

/***/ "./src/shaders/post.frag":
/*!*******************************!*\
  !*** ./src/shaders/post.frag ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define BARREL_ITER 10\n\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\n\nuniform float barrelAmp;\nuniform float barrelOffset;\nuniform float qualityShit6;\n\nuniform sampler2D sampler0;\n\n// ------\n\nvec3 barrel( float amp, vec2 uv ) {\n\tfloat corn = length( vec2( 0.5 ) );\n\tfloat a = min( 3.0 * sqrt( amp ), corn * PI );\n\tfloat zoom = corn / ( tan( corn * a ) + corn );\n\tvec2 p = saturate(\n    ( uv + normalize( uv - 0.5 ) * tan( length( uv - 0.5 ) * a ) ) * zoom +\n    0.5 * ( 1.0 - zoom )\n  );\n\treturn texture2D( sampler0, vec2( p.x, p.y ) ).xyz;\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution.y;\n  float vig = 1.0 - length( p ) * 0.2;\n\n  vec3 tex = vec3( 0.0 );\n\n  for ( int i = 0; i < BARREL_ITER; i ++ ) {\n    float fi = ( float( i ) + 0.5 ) / float( BARREL_ITER );\n    vec3 a = saturate( vec3(\n      1.0 - 3.0 * abs( 1.0 / 6.0 - fi ),\n      1.0 - 3.0 * abs( 1.0 / 2.0 - fi ),\n      1.0 - 3.0 * abs( 5.0 / 6.0 - fi )\n    ) ) / float( BARREL_ITER ) * 4.0;\n    tex += a * barrel( barrelOffset + barrelAmp * fi, uv );\n  }\n\n  tex = mix( vec3( 0.0 ), tex, vig );\n\n  vec3 col = pow( saturate( tex.xyz ), vec3( 1.0 / 2.2 ) );\n  col = vec3(\n    smoothstep( -0.10, 1.10, col.x ),\n    smoothstep(  0.00, 1.00, col.y ),\n    smoothstep( -0.30, 1.30, col.z )\n  );\n  col = mix( col, 1.0 - col, qualityShit6 );\n\n  gl_FragColor = vec4( col, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/quad.vert":
/*!*******************************!*\
  !*** ./src/shaders/quad.vert ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}"

/***/ }),

/***/ "./src/shaders/return.frag":
/*!*********************************!*\
  !*** ./src/shaders/return.frag ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  gl_FragColor = texture2D( sampler0, uv );\n}"

/***/ }),

/***/ "./src/styles/main.scss":
/*!******************************!*\
  !*** ./src/styles/main.scss ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/lib/loader.js!./main.scss */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js!./src/styles/main.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9tYXRoL2xvZzEwLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL21hdGgvc2lnbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUucnVudGltZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy92dWVpZnkvbGliL2luc2VydC1jc3MuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hc3MuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jbG9jay1mcmFtZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2Nsb2NrLXJlYWx0aW1lLmpzIiwid2VicGFjazovLy9zcmMvY2xvY2suanMiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wYXQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9jdWJpYy1iZXppZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9meC1kZWZpbml0aW9ucy5qcyIsIndlYnBhY2s6Ly8vc3JjL2Z4cy9hZGQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9meHMvY2RzLmpzIiwid2VicGFjazovLy9zcmMvZnhzL2NsYW1wLmpzIiwid2VicGFjazovLy9zcmMvZnhzL2V4cC5qcyIsIndlYnBhY2s6Ly8vc3JjL2Z4cy9ncmF2aXR5LmpzIiwid2VicGFjazovLy9zcmMvZnhzL2xvZmkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9meHMvbW9kdWxlcy94b3JzaGlmdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2Z4cy9ub2lzZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2Z4cy9wb3cuanMiLCJ3ZWJwYWNrOi8vL3NyYy9meHMvc2luZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2dlbi1pZC5qcyIsIndlYnBhY2s6Ly8vc3JjL2hhcy1vdmVyd3JhcC5qcyIsIndlYnBhY2s6Ly8vc3JjL2ltYWdlcy9hYm91dC1jbG9zZS5zdmciLCJ3ZWJwYWNrOi8vL3NyYy9qc29uLWNvcHkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9tYWluLWd1aS5qcyIsIndlYnBhY2s6Ly8vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vL3NyYy9wYXJhbS1ndWkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9wYXJhbS5qcyIsIndlYnBhY2s6Ly8vc3JjL3Z1ZS9hYm91dC52dWUiLCJ3ZWJwYWNrOi8vL3NyYy92dWUvY29udGV4dC1tZW51LnZ1ZSIsIndlYnBhY2s6Ly8vc3JjL3Z1ZS9oZWFkZXIudnVlIiwid2VicGFjazovLy9zcmMvdnVlL21haW4udnVlIiwid2VicGFjazovLy9zcmMvdnVlL3BhcmFtbGlzdC52dWUiLCJ3ZWJwYWNrOi8vL3NyYy92dWUvcHJvcGJveC52dWUiLCJ3ZWJwYWNrOi8vL3NyYy92dWUvcHJvcG1lbnUudnVlIiwid2VicGFjazovLy9zcmMvdnVlL3Njcm9sbGFibGUudnVlIiwid2VicGFjazovLy9zcmMvdnVlL3N0YWxrZXIudnVlIiwid2VicGFjazovLy9zcmMvdnVlL3RpbWVsaW5lLWZ4bWVudS52dWUiLCJ3ZWJwYWNrOi8vL3NyYy92dWUvdGltZWxpbmUudnVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvbWFpbi5zY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1tZWRpYXRlL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvYmFzZTY0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvY29tcHJlc3NlZE9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NyYzMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9leHRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2ZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvZ2VuZXJhdGUvWmlwRmlsZVdvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9sb2FkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkYWJsZS1zdHJlYW0tYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9BcnJheVJlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9EYXRhUmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL05vZGVCdWZmZXJSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvU3RyaW5nUmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1VpbnQ4QXJyYXlSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvcmVhZGVyRm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc2lnbmF0dXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NvbnZlcnRXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ3JjMzJQcm9iZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YVdvcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9HZW5lcmljV29ya2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL1N0cmVhbUhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGY4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwRW50cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanN6aXAvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzemlwL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3ppcC9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGllL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9nZW9tcy9jdWJlLmpzIiwid2VicGFjazovLy8uL3NyYy9nZW9tcy9vY3RhaGVkcm9uLmpzIiwid2VicGFjazovLy8uL3NyYy9saWJzL2NhbnZhcy1zYXZlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGlicy9nbGNhdC1wYXRoLWd1aS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGlicy9nbGNhdC1wYXRoLmpzIiwid2VicGFjazovLy8uL3NyYy9saWJzL2dsY2F0LmpzIiwid2VicGFjazovLy8uL3NyYy9saWJzL21hdGhjYXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYnMvdWx0cmFjYXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYnMveG9yc2hpZnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhdGhzL2Jsb29tLmpzIiwid2VicGFjazovLy8uL3NyYy9wYXRocy9ib3guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhdGhzL3BhcnRpY2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGF0aHMvcGl4ZWxzb3J0LmpzIiwid2VicGFjazovLy8uL3NyYy9wYXRocy9wb3N0ZnguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYmcuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9ibG9vbS1wb3N0LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYmxvb20tcHJlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYm94LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvYm94LnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvZnhhYS5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL2dhdXNzLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvaW5zcGVjdG9yLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcGFydGljbGVzLWNvbXB1dGUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9wYXJ0aWNsZXMtZGl2ZXJnZW5jZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL3BhcnRpY2xlcy1lbmZvcmNlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcGFydGljbGVzLW1vdGlvbi1yZWFkLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcGFydGljbGVzLW1vdGlvbi1yZWFkLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcGFydGljbGVzLW1vdGlvbi13cml0ZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL3BhcnRpY2xlcy1wcmVzc3VyZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL3BhcnRpY2xlcy1yZW5kZXIuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9wYXJ0aWNsZXMtcmVuZGVyLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcGl4ZWxzb3J0LWNvbXBhcmUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9waXhlbHNvcnQtcmVuZGVyLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWRlcnMvcG9zdC5mcmFnIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL3F1YWQudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9yZXR1cm4uZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL21haW4uc2Nzcz8zMmQzIiwid2VicGFjazovLy91dGlsIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCk/YTQ0NSJdLCJuYW1lcyI6WyJleHBvcnRzIiwiYnl0ZUxlbmd0aCIsInRvQnl0ZUFycmF5IiwiZnJvbUJ5dGVBcnJheSIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsIlVpbnQ4QXJyYXkiLCJBcnJheSIsImNvZGUiLCJpIiwibGVuIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImdldExlbnMiLCJiNjQiLCJFcnJvciIsInZhbGlkTGVuIiwiaW5kZXhPZiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImFyciIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJlbmQiLCJvdXRwdXQiLCJwdXNoIiwiam9pbiIsImV4dHJhQnl0ZXMiLCJwYXJ0cyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsImJhc2U2NCIsInJlcXVpcmUiLCJpZWVlNzU0IiwiaXNBcnJheSIsIkJ1ZmZlciIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJnbG9iYWwiLCJ1bmRlZmluZWQiLCJ0eXBlZEFycmF5U3VwcG9ydCIsImtNYXhMZW5ndGgiLCJfX3Byb3RvX18iLCJwcm90b3R5cGUiLCJmb28iLCJzdWJhcnJheSIsImUiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiUmFuZ2VFcnJvciIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwidmFsdWUiLCJUeXBlRXJyb3IiLCJBcnJheUJ1ZmZlciIsImZyb21BcnJheUJ1ZmZlciIsImZyb21TdHJpbmciLCJmcm9tT2JqZWN0IiwiU3ltYm9sIiwic3BlY2llcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiYXNzZXJ0U2l6ZSIsInNpemUiLCJhbGxvYyIsImZpbGwiLCJlbmNvZGluZyIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiYWN0dWFsIiwid3JpdGUiLCJzbGljZSIsImZyb21BcnJheUxpa2UiLCJhcnJheSIsImJ5dGVPZmZzZXQiLCJvYmoiLCJpc0J1ZmZlciIsImNvcHkiLCJidWZmZXIiLCJpc25hbiIsInR5cGUiLCJkYXRhIiwidG9TdHJpbmciLCJiIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsImEiLCJ4IiwieSIsIk1hdGgiLCJtaW4iLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImxpc3QiLCJwb3MiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwibiIsIm0iLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJhcmd1bWVudHMiLCJhcHBseSIsImVxdWFscyIsImluc3BlY3QiLCJzdHIiLCJtYXgiLCJtYXRjaCIsInRhcmdldCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsInZhbCIsImRpciIsImlzTmFOIiwiYXJyYXlJbmRleE9mIiwiY2FsbCIsImxhc3RJbmRleE9mIiwiaW5kZXhTaXplIiwiYXJyTGVuZ3RoIiwidmFsTGVuZ3RoIiwicmVhZCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImoiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwib2Zmc2V0IiwiTnVtYmVyIiwicmVtYWluaW5nIiwic3RyTGVuIiwicGFyc2VkIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwidG9KU09OIiwiX2FyciIsInJlcyIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJvdXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsImZsb29yIiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsInNldCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwicmVwbGFjZSIsInRyaW0iLCJ1bml0cyIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImMiLCJoaSIsImxvIiwic3JjIiwiZHN0Iiwib2JqZWN0VG9TdHJpbmciLCJpc0Jvb2xlYW4iLCJpc051bGwiLCJpc051bGxPclVuZGVmaW5lZCIsImlzTnVtYmVyIiwiaXNTdHJpbmciLCJpc1N5bWJvbCIsImlzVW5kZWZpbmVkIiwiaXNSZWdFeHAiLCJyZSIsImlzT2JqZWN0IiwiaXNEYXRlIiwiZCIsImlzRXJyb3IiLCJpc0Z1bmN0aW9uIiwiaXNQcmltaXRpdmUiLCJvIiwibW9kdWxlIiwidXNlU291cmNlTWFwIiwibWFwIiwiaXRlbSIsImNvbnRlbnQiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwiaWQiLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJFdmVudEVtaXR0ZXIiLCJfZXZlbnRzIiwiX21heExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJzZXRNYXhMaXN0ZW5lcnMiLCJlbWl0IiwiZXIiLCJoYW5kbGVyIiwiYXJncyIsImxpc3RlbmVycyIsImVycm9yIiwiZXJyIiwiY29udGV4dCIsImFkZExpc3RlbmVyIiwibGlzdGVuZXIiLCJuZXdMaXN0ZW5lciIsIndhcm5lZCIsImNvbnNvbGUiLCJ0cmFjZSIsIm9uIiwib25jZSIsImZpcmVkIiwiZyIsInJlbW92ZUxpc3RlbmVyIiwicG9zaXRpb24iLCJzcGxpY2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJrZXkiLCJsaXN0ZW5lckNvdW50IiwiZXZsaXN0ZW5lciIsImVtaXR0ZXIiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsInMiLCJOYU4iLCJydCIsImFicyIsImxvZyIsIkxOMiIsIk11dGF0aW9uIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJzY2hlZHVsZURyYWluIiwiY2FsbGVkIiwib2JzZXJ2ZXIiLCJuZXh0VGljayIsImVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJzZXRJbW1lZGlhdGUiLCJNZXNzYWdlQ2hhbm5lbCIsImNoYW5uZWwiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvcnQyIiwicG9zdE1lc3NhZ2UiLCJjcmVhdGVFbGVtZW50Iiwic2NyaXB0RWwiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJkb2N1bWVudEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsInNldFRpbWVvdXQiLCJkcmFpbmluZyIsInF1ZXVlIiwib2xkUXVldWUiLCJpbW1lZGlhdGUiLCJ0YXNrIiwiY3JlYXRlIiwiaW5oZXJpdHMiLCJjdG9yIiwic3VwZXJDdG9yIiwic3VwZXJfIiwiY29uc3RydWN0b3IiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJUZW1wQ3RvciIsInV0aWxzIiwic3VwcG9ydCIsIl9rZXlTdHIiLCJlbmNvZGUiLCJpbnB1dCIsImNocjEiLCJjaHIyIiwiY2hyMyIsImVuYzEiLCJlbmMyIiwiZW5jMyIsImVuYzQiLCJyZW1haW5pbmdCeXRlcyIsImdldFR5cGVPZiIsImNoYXJBdCIsImRlY29kZSIsInJlc3VsdEluZGV4IiwiZGF0YVVybFByZWZpeCIsInRvdGFsTGVuZ3RoIiwidWludDhhcnJheSIsImV4dGVybmFsIiwiRGF0YVdvcmtlciIsIkRhdGFMZW5ndGhQcm9iZSIsIkNyYzMyUHJvYmUiLCJDb21wcmVzc2VkT2JqZWN0IiwiY29tcHJlc3NlZFNpemUiLCJ1bmNvbXByZXNzZWRTaXplIiwiY3JjMzIiLCJjb21wcmVzc2lvbiIsImNvbXByZXNzZWRDb250ZW50IiwiZ2V0Q29udGVudFdvcmtlciIsIndvcmtlciIsIlByb21pc2UiLCJyZXNvbHZlIiwicGlwZSIsInVuY29tcHJlc3NXb3JrZXIiLCJzdHJlYW1JbmZvIiwiZ2V0Q29tcHJlc3NlZFdvcmtlciIsIndpdGhTdHJlYW1JbmZvIiwiY3JlYXRlV29ya2VyRnJvbSIsInVuY29tcHJlc3NlZFdvcmtlciIsImNvbXByZXNzaW9uT3B0aW9ucyIsImNvbXByZXNzV29ya2VyIiwiR2VuZXJpY1dvcmtlciIsIlNUT1JFIiwibWFnaWMiLCJERUZMQVRFIiwibWFrZVRhYmxlIiwidGFibGUiLCJrIiwiY3JjVGFibGUiLCJjcmMiLCJ0IiwiY3JjMzJzdHIiLCJjcmMzMndyYXBwZXIiLCJiaW5hcnkiLCJjcmVhdGVGb2xkZXJzIiwiZGF0ZSIsImNvbW1lbnQiLCJ1bml4UGVybWlzc2lvbnMiLCJkb3NQZXJtaXNzaW9ucyIsIkVTNlByb21pc2UiLCJVU0VfVFlQRURBUlJBWSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJwYWtvIiwiQVJSQVlfVFlQRSIsIkZsYXRlV29ya2VyIiwiYWN0aW9uIiwib3B0aW9ucyIsIl9wYWtvIiwiX3Bha29BY3Rpb24iLCJfcGFrb09wdGlvbnMiLCJtZXRhIiwicHJvY2Vzc0NodW5rIiwiY2h1bmsiLCJfY3JlYXRlUGFrbyIsInRyYW5zZm9ybVRvIiwiZmx1c2giLCJjbGVhblVwIiwicmF3IiwibGV2ZWwiLCJzZWxmIiwib25EYXRhIiwidXRmOCIsInNpZ25hdHVyZSIsImRlY1RvSGV4IiwiZGVjIiwiaGV4IiwiZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciIsImlzRGlyIiwicmVzdWx0IiwiZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyIiwiZ2VuZXJhdGVaaXBQYXJ0cyIsInN0cmVhbWVkQ29udGVudCIsInN0cmVhbWluZ0VuZGVkIiwicGxhdGZvcm0iLCJlbmNvZGVGaWxlTmFtZSIsImZpbGUiLCJ1c2VDdXN0b21FbmNvZGluZyIsInV0ZjhlbmNvZGUiLCJlbmNvZGVkRmlsZU5hbWUiLCJuYW1lIiwidXRmRW5jb2RlZEZpbGVOYW1lIiwiZW5jb2RlZENvbW1lbnQiLCJ1dGZFbmNvZGVkQ29tbWVudCIsInVzZVVURjhGb3JGaWxlTmFtZSIsInVzZVVURjhGb3JDb21tZW50IiwiZG9zVGltZSIsImRvc0RhdGUiLCJleHRyYUZpZWxkcyIsInVuaWNvZGVQYXRoRXh0cmFGaWVsZCIsInVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCIsImRhdGFJbmZvIiwiYml0ZmxhZyIsImV4dEZpbGVBdHRyIiwidmVyc2lvbk1hZGVCeSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImhlYWRlciIsImZpbGVSZWNvcmQiLCJMT0NBTF9GSUxFX0hFQURFUiIsImRpclJlY29yZCIsIkNFTlRSQUxfRklMRV9IRUFERVIiLCJnZW5lcmF0ZUNlbnRyYWxEaXJlY3RvcnlFbmQiLCJlbnRyaWVzQ291bnQiLCJjZW50cmFsRGlyTGVuZ3RoIiwibG9jYWxEaXJMZW5ndGgiLCJkaXJFbmQiLCJDRU5UUkFMX0RJUkVDVE9SWV9FTkQiLCJnZW5lcmF0ZURhdGFEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCJEQVRBX0RFU0NSSVBUT1IiLCJaaXBGaWxlV29ya2VyIiwic3RyZWFtRmlsZXMiLCJieXRlc1dyaXR0ZW4iLCJ6aXBDb21tZW50IiwiemlwUGxhdGZvcm0iLCJhY2N1bXVsYXRlIiwiY29udGVudEJ1ZmZlciIsImRpclJlY29yZHMiLCJjdXJyZW50U291cmNlT2Zmc2V0IiwiY3VycmVudEZpbGUiLCJfc291cmNlcyIsImN1cnJlbnRGaWxlUGVyY2VudCIsInBlcmNlbnQiLCJyZW1haW5pbmdGaWxlcyIsIm9wZW5lZFNvdXJjZSIsInJlY29yZCIsImNsb3NlZFNvdXJjZSIsInNoaWZ0IiwicHJlcGFyZU5leHRTb3VyY2UiLCJwcmV2aW91cyIsImlzUGF1c2VkIiwicGF1c2UiLCJyZXN1bWUiLCJyZWdpc3RlclByZXZpb3VzIiwiZ2VuZXJhdGVkRXJyb3IiLCJsb2NrIiwiY29tcHJlc3Npb25zIiwiZ2V0Q29tcHJlc3Npb24iLCJmaWxlQ29tcHJlc3Npb24iLCJ6aXBDb21wcmVzc2lvbiIsImNvbXByZXNzaW9uTmFtZSIsImdlbmVyYXRlV29ya2VyIiwiemlwIiwiemlwRmlsZVdvcmtlciIsImZvckVhY2giLCJyZWxhdGl2ZVBhdGgiLCJfY29tcHJlc3NXb3JrZXIiLCJKU1ppcCIsImZpbGVzIiwicm9vdCIsImNsb25lIiwibmV3T2JqIiwibG9hZEFzeW5jIiwiZGVmYXVsdHMiLCJ2ZXJzaW9uIiwiWmlwRW50cmllcyIsIm5vZGVqc1V0aWxzIiwiY2hlY2tFbnRyeUNSQzMyIiwiemlwRW50cnkiLCJyZWplY3QiLCJkZWNvbXByZXNzZWQiLCJleHRlbmQiLCJjaGVja0NSQzMyIiwib3B0aW1pemVkQmluYXJ5U3RyaW5nIiwiZGVjb2RlRmlsZU5hbWUiLCJ1dGY4ZGVjb2RlIiwiaXNOb2RlIiwiaXNTdHJlYW0iLCJwcmVwYXJlQ29udGVudCIsInRoZW4iLCJ6aXBFbnRyaWVzIiwibG9hZCIsInByb21pc2VzIiwiYWxsIiwiYWRkRmlsZXMiLCJyZXN1bHRzIiwiZmlsZU5hbWVTdHIiLCJmaWxlQ29tbWVudFN0ciIsIk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciIsImZpbGVuYW1lIiwic3RyZWFtIiwiX3Vwc3RyZWFtRW5kZWQiLCJfYmluZFN0cmVhbSIsIl9zdHJlYW0iLCJSZWFkYWJsZSIsIk5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIiLCJoZWxwZXIiLCJ1cGRhdGVDYiIsIl9oZWxwZXIiLCJfcmVhZCIsIm5ld0J1ZmZlckZyb20iLCJhbGxvY0J1ZmZlciIsIlN0cmVhbUhlbHBlciIsIlppcE9iamVjdCIsImdlbmVyYXRlIiwiZmlsZUFkZCIsIm9yaWdpbmFsT3B0aW9ucyIsImRhdGFUeXBlIiwicGFyZW50IiwiRGF0ZSIsInRvVXBwZXJDYXNlIiwiZm9yY2VUcmFpbGluZ1NsYXNoIiwicGFyZW50Rm9sZGVyIiwiZm9sZGVyQWRkIiwiaXNVbmljb2RlU3RyaW5nIiwiaXNDb21wcmVzc2VkRW1wdHkiLCJ6aXBPYmplY3RDb250ZW50Iiwib2JqZWN0IiwicGF0aCIsInN1YnN0cmluZyIsImxhc3RTbGFzaCIsImNiIiwiaGFzT3duUHJvcGVydHkiLCJmaWx0ZXIiLCJzZWFyY2giLCJlbnRyeSIsInJlZ2V4cCIsInRlc3QiLCJmb2xkZXIiLCJuZXdGb2xkZXIiLCJyZW1vdmUiLCJraWRzIiwiZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbSIsIm9wdHMiLCJtaW1lVHlwZSIsImNoZWNrU3VwcG9ydCIsImdlbmVyYXRlQXN5bmMiLCJvblVwZGF0ZSIsImdlbmVyYXRlTm9kZVN0cmVhbSIsInRvTm9kZWpzU3RyZWFtIiwiRGF0YVJlYWRlciIsIkFycmF5UmVhZGVyIiwiYnl0ZUF0IiwiemVybyIsImxhc3RJbmRleE9mU2lnbmF0dXJlIiwic2lnIiwic2lnMCIsInNpZzEiLCJzaWcyIiwic2lnMyIsInJlYWRBbmRDaGVja1NpZ25hdHVyZSIsInJlYWREYXRhIiwiaW5kZXgiLCJjaGVja0luZGV4IiwibmV3SW5kZXgiLCJzZXRJbmRleCIsInNraXAiLCJyZWFkSW50IiwicmVhZFN0cmluZyIsInJlYWREYXRlIiwiZG9zdGltZSIsIlVUQyIsIlVpbnQ4QXJyYXlSZWFkZXIiLCJOb2RlQnVmZmVyUmVhZGVyIiwiU3RyaW5nUmVhZGVyIiwiWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiIsIlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCIsIkNvbnZlcnRXb3JrZXIiLCJkZXN0VHlwZSIsInByb3BOYW1lIiwiREVGQVVMVF9CTE9DS19TSVpFIiwiZGF0YVAiLCJkYXRhSXNSZWFkeSIsIl90aWNrU2NoZWR1bGVkIiwiX3RpY2tBbmRSZXBlYXQiLCJkZWxheSIsImlzRmluaXNoZWQiLCJfdGljayIsIm5leHRJbmRleCIsImV4dHJhU3RyZWFtSW5mbyIsImlzTG9ja2VkIiwiX2xpc3RlbmVycyIsIm5leHQiLCJtZXJnZVN0cmVhbUluZm8iLCJ3aXRoRXJyb3IiLCJtZSIsIm5vZGVzdHJlYW0iLCJ0cmFuc2Zvcm1aaXBPdXRwdXQiLCJuZXdCbG9iIiwiZGF0YUFycmF5IiwidXBkYXRlQ2FsbGJhY2siLCJjaHVua1R5cGUiLCJfaW50ZXJuYWxUeXBlIiwicmVzdWx0VHlwZSIsIl9vdXRwdXRUeXBlIiwiX21pbWVUeXBlIiwib3V0cHV0VHlwZSIsImludGVybmFsVHlwZSIsIl93b3JrZXIiLCJldnQiLCJmbiIsIm9iamVjdE1vZGUiLCJhcnJheWJ1ZmZlciIsIm5vZGVidWZmZXIiLCJibG9iIiwiQmxvYiIsIkJ1aWxkZXIiLCJCbG9iQnVpbGRlciIsIldlYktpdEJsb2JCdWlsZGVyIiwiTW96QmxvYkJ1aWxkZXIiLCJNU0Jsb2JCdWlsZGVyIiwiYnVpbGRlciIsImFwcGVuZCIsImdldEJsb2IiLCJfdXRmOGxlbiIsInN0cmluZzJidWYiLCJjMiIsIm1fcG9zIiwic3RyX2xlbiIsImJ1Zl9sZW4iLCJ1dGY4Ym9yZGVyIiwiYnVmMnN0cmluZyIsImNfbGVuIiwidXRmMTZidWYiLCJhcHBseUZyb21DaGFyQ29kZSIsIlV0ZjhEZWNvZGVXb3JrZXIiLCJsZWZ0T3ZlciIsInByZXZpb3VzRGF0YSIsIm5leHRCb3VuZGFyeSIsInVzYWJsZURhdGEiLCJVdGY4RW5jb2RlV29ya2VyIiwic3RyaW5nMmJpbmFyeSIsInN0cmluZ1RvQXJyYXlMaWtlIiwicGFydCIsImlkZW50aXR5IiwiYXJyYXlUb1N0cmluZ0hlbHBlciIsInN0cmluZ2lmeUJ5Q2h1bmsiLCJzdHJpbmdpZnlCeUNoYXIiLCJyZXN1bHRTdHIiLCJhcHBseUNhbkJlVXNlZCIsImFycmF5TGlrZVRvU3RyaW5nIiwiY2FuVXNlQXBwbHkiLCJhcnJheUxpa2VUb0FycmF5TGlrZSIsImFycmF5RnJvbSIsImFycmF5VG8iLCJ0cmFuc2Zvcm0iLCJpbnB1dFR5cGUiLCJzdXBwb3J0ZWQiLCJNQVhfVkFMVUVfMTZCSVRTIiwiTUFYX1ZBTFVFXzMyQklUUyIsInByZXR0eSIsImNhbGxiYWNrIiwiT2JqIiwiYXR0ciIsImlucHV0RGF0YSIsImlzQmluYXJ5IiwiaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmciLCJpc0Jhc2U2NCIsInByb21pc2UiLCJpc0Jsb2IiLCJGaWxlUmVhZGVyIiwicmVhZGVyIiwib25sb2FkIiwib25lcnJvciIsInJlYWRBc0FycmF5QnVmZmVyIiwicmVhZGVyRm9yIiwiWmlwRW50cnkiLCJsb2FkT3B0aW9ucyIsImNoZWNrU2lnbmF0dXJlIiwiZXhwZWN0ZWRTaWduYXR1cmUiLCJpc1NpZ25hdHVyZSIsImFza2VkSW5kZXgiLCJjdXJyZW50SW5kZXgiLCJyZWFkQmxvY2tFbmRPZkNlbnRyYWwiLCJkaXNrTnVtYmVyIiwiZGlza1dpdGhDZW50cmFsRGlyU3RhcnQiLCJjZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2siLCJjZW50cmFsRGlyUmVjb3JkcyIsImNlbnRyYWxEaXJTaXplIiwiY2VudHJhbERpck9mZnNldCIsInppcENvbW1lbnRMZW5ndGgiLCJkZWNvZGVQYXJhbVR5cGUiLCJkZWNvZGVDb250ZW50IiwicmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWwiLCJ6aXA2NEVuZE9mQ2VudHJhbFNpemUiLCJ6aXA2NEV4dGVuc2libGVEYXRhIiwiZXh0cmFEYXRhU2l6ZSIsImV4dHJhRmllbGRJZCIsImV4dHJhRmllbGRMZW5ndGgiLCJleHRyYUZpZWxkVmFsdWUiLCJyZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3IiLCJkaXNrV2l0aFppcDY0Q2VudHJhbERpclN0YXJ0IiwicmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciIsImRpc2tzQ291bnQiLCJyZWFkTG9jYWxGaWxlcyIsImxvY2FsSGVhZGVyT2Zmc2V0IiwicmVhZExvY2FsUGFydCIsImhhbmRsZVVURjgiLCJwcm9jZXNzQXR0cmlidXRlcyIsInJlYWRDZW50cmFsRGlyIiwiemlwNjQiLCJyZWFkQ2VudHJhbFBhcnQiLCJyZWFkRW5kT2ZDZW50cmFsIiwiaXNHYXJiYWdlIiwiZW5kT2ZDZW50cmFsRGlyT2Zmc2V0IiwiZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQiLCJwcmVwYXJlUmVhZGVyIiwiY3JjMzJmbiIsIk1BREVfQllfRE9TIiwiTUFERV9CWV9VTklYIiwiZmluZENvbXByZXNzaW9uIiwiY29tcHJlc3Npb25NZXRob2QiLCJtZXRob2QiLCJpc0VuY3J5cHRlZCIsImJpdEZsYWciLCJ1c2VVVEY4IiwibG9jYWxFeHRyYUZpZWxkc0xlbmd0aCIsImZpbGVOYW1lTGVuZ3RoIiwiZmlsZU5hbWUiLCJleHRyYUZpZWxkc0xlbmd0aCIsImZpbGVDb21tZW50TGVuZ3RoIiwiZGlza051bWJlclN0YXJ0IiwiaW50ZXJuYWxGaWxlQXR0cmlidXRlcyIsImV4dGVybmFsRmlsZUF0dHJpYnV0ZXMiLCJyZWFkRXh0cmFGaWVsZHMiLCJwYXJzZVpJUDY0RXh0cmFGaWVsZCIsImZpbGVDb21tZW50IiwibWFkZUJ5IiwiZXh0cmFSZWFkZXIiLCJ1cGF0aCIsImZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGgiLCJmaWxlTmFtZUJ5dGVBcnJheSIsInVjb21tZW50IiwiZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudCIsImNvbW1lbnRCeXRlQXJyYXkiLCJ1cGF0aEZpZWxkIiwidWNvbW1lbnRGaWVsZCIsIl9kYXRhIiwiX2RhdGFCaW5hcnkiLCJpbnRlcm5hbFN0cmVhbSIsImFza1VuaWNvZGVTdHJpbmciLCJfZGVjb21wcmVzc1dvcmtlciIsImFzeW5jIiwibm9kZVN0cmVhbSIsInJlbW92ZWRNZXRob2RzIiwicmVtb3ZlZEZuIiwiaXQiLCJjb3JlIiwiX19lIiwiYUZ1bmN0aW9uIiwiZ2V0IiwiaXMiLCJjdHgiLCJoaWRlIiwiUFJPVE9UWVBFIiwiJGV4cG9ydCIsIklTX0ZPUkNFRCIsIkYiLCJJU19HTE9CQUwiLCJHIiwiSVNfU1RBVElDIiwiUyIsIklTX1BST1RPIiwiUCIsIklTX0JJTkQiLCJCIiwiSVNfV1JBUCIsIlciLCJleHBQcm90byIsIm93biIsIkMiLCJGdW5jdGlvbiIsInZpcnR1YWwiLCJSIiwiVSIsImV4ZWMiLCJ3aW5kb3ciLCJfX2ciLCJkUCIsImNyZWF0ZURlc2MiLCJmIiwidW4iLCJhbk9iamVjdCIsIklFOF9ET01fREVGSU5FIiwidG9QcmltaXRpdmUiLCJPIiwiQXR0cmlidXRlcyIsImJpdG1hcCIsImludm9rZSIsImh0bWwiLCJjZWwiLCJwcm9jZXNzIiwic2V0VGFzayIsImNsZWFyVGFzayIsImNsZWFySW1tZWRpYXRlIiwiY291bnRlciIsIk9OUkVBRFlTVEFURUNIQU5HRSIsImRlZmVyIiwicG9ydCIsInJ1biIsImV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImltcG9ydFNjcmlwdHMiLCJjbGVhciIsInZhbHVlT2YiLCIkdGFzayIsIklOVEVSTkFMIiwiaGFuZGxlcnMiLCJSRUpFQ1RFRCIsIkZVTEZJTExFRCIsIlBFTkRJTkciLCJyZXNvbHZlciIsInN0YXRlIiwib3V0Y29tZSIsInNhZmVseVJlc29sdmVUaGVuYWJsZSIsIm9uUmVqZWN0ZWQiLCJvbkZ1bGZpbGxlZCIsInVud3JhcCIsIlF1ZXVlSXRlbSIsImNhbGxGdWxmaWxsZWQiLCJvdGhlckNhbGxGdWxmaWxsZWQiLCJjYWxsUmVqZWN0ZWQiLCJvdGhlckNhbGxSZWplY3RlZCIsImZ1bmMiLCJyZXR1cm5WYWx1ZSIsInRyeUNhdGNoIiwiZ2V0VGhlbiIsInN0YXR1cyIsInRoZW5hYmxlIiwiYXBweVRoZW4iLCJvbkVycm9yIiwib25TdWNjZXNzIiwidHJ5VG9VbndyYXAiLCJyZWFzb24iLCJpdGVyYWJsZSIsInZhbHVlcyIsInJlc29sdmVkIiwiYWxsUmVzb2x2ZXIiLCJyZXNvbHZlRnJvbUFsbCIsIm91dFZhbHVlIiwicmFjZSIsInJlc3BvbnNlIiwiX25vcm1hbGl6ZUVuY29kaW5nIiwiZW5jIiwicmV0cmllZCIsIm5vcm1hbGl6ZUVuY29kaW5nIiwibmVuYyIsIlN0cmluZ0RlY29kZXIiLCJuYiIsInRleHQiLCJ1dGYxNlRleHQiLCJ1dGYxNkVuZCIsImZpbGxMYXN0IiwidXRmOEZpbGxMYXN0IiwiYmFzZTY0VGV4dCIsImJhc2U2NEVuZCIsInNpbXBsZVdyaXRlIiwic2ltcGxlRW5kIiwibGFzdE5lZWQiLCJsYXN0VG90YWwiLCJsYXN0Q2hhciIsInIiLCJ1dGY4RW5kIiwidXRmOFRleHQiLCJ1dGY4Q2hlY2tCeXRlIiwiYnl0ZSIsInV0ZjhDaGVja0luY29tcGxldGUiLCJ1dGY4Q2hlY2tFeHRyYUJ5dGVzIiwicCIsInRvdGFsIiwiYXNzaWduIiwiZGVmbGF0ZSIsImluZmxhdGUiLCJjb25zdGFudHMiLCJ6bGliX2RlZmxhdGUiLCJzdHJpbmdzIiwibXNnIiwiWlN0cmVhbSIsIlpfTk9fRkxVU0giLCJaX0ZJTklTSCIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX1NZTkNfRkxVU0giLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0RFRkFVTFRfU1RSQVRFR1kiLCJaX0RFRkxBVEVEIiwiRGVmbGF0ZSIsImNodW5rU2l6ZSIsIndpbmRvd0JpdHMiLCJtZW1MZXZlbCIsInN0cmF0ZWd5IiwidG8iLCJvcHQiLCJnemlwIiwiZW5kZWQiLCJjaHVua3MiLCJzdHJtIiwiYXZhaWxfb3V0IiwiZGVmbGF0ZUluaXQyIiwiZGVmbGF0ZVNldEhlYWRlciIsImRpY3Rpb25hcnkiLCJkaWN0IiwiZGVmbGF0ZVNldERpY3Rpb25hcnkiLCJfZGljdF9zZXQiLCJtb2RlIiwiX21vZGUiLCJuZXh0X2luIiwiYXZhaWxfaW4iLCJCdWY4IiwibmV4dF9vdXQiLCJvbkVuZCIsImJ1ZjJiaW5zdHJpbmciLCJzaHJpbmtCdWYiLCJkZWZsYXRlRW5kIiwiZmxhdHRlbkNodW5rcyIsImRlZmxhdG9yIiwiZGVmbGF0ZVJhdyIsInpsaWJfaW5mbGF0ZSIsIkdaaGVhZGVyIiwiSW5mbGF0ZSIsImluZmxhdGVJbml0MiIsImluZmxhdGVHZXRIZWFkZXIiLCJuZXh0X291dF91dGY4IiwidGFpbCIsInV0ZjhzdHIiLCJhbGxvd0J1ZkVycm9yIiwiYmluc3RyaW5nMmJ1ZiIsIlpfTkVFRF9ESUNUIiwiaW5mbGF0ZVNldERpY3Rpb25hcnkiLCJaX0JVRl9FUlJPUiIsImFycmF5U2V0IiwiaW5mbGF0ZUVuZCIsImluZmxhdG9yIiwiaW5mbGF0ZVJhdyIsInVuZ3ppcCIsIlRZUEVEX09LIiwiSW50MzJBcnJheSIsIl9oYXMiLCJmblR5cGVkIiwiZGVzdCIsInNyY19vZmZzIiwiZGVzdF9vZmZzIiwibCIsImZuVW50eXBlZCIsInNldFR5cGVkIiwiQnVmMTYiLCJCdWYzMiIsIlNUUl9BUFBMWV9PSyIsIlNUUl9BUFBMWV9VSUFfT0siLCJfXyIsInEiLCJhZGxlcjMyIiwiYWRsZXIiLCJzMSIsInMyIiwiWl9QQVJUSUFMX0ZMVVNIIiwiWl9GVUxMX0ZMVVNIIiwiWl9CTE9DSyIsIlpfVFJFRVMiLCJaX0VSUk5PIiwiWl9TVFJFQU1fRVJST1IiLCJaX0RBVEFfRVJST1IiLCJaX05PX0NPTVBSRVNTSU9OIiwiWl9CRVNUX1NQRUVEIiwiWl9CRVNUX0NPTVBSRVNTSU9OIiwiWl9GSUxURVJFRCIsIlpfSFVGRk1BTl9PTkxZIiwiWl9STEUiLCJaX0ZJWEVEIiwiWl9CSU5BUlkiLCJaX1RFWFQiLCJaX1VOS05PV04iLCJ0cmVlcyIsIk1BWF9NRU1fTEVWRUwiLCJNQVhfV0JJVFMiLCJERUZfTUVNX0xFVkVMIiwiTEVOR1RIX0NPREVTIiwiTElURVJBTFMiLCJMX0NPREVTIiwiRF9DT0RFUyIsIkJMX0NPREVTIiwiSEVBUF9TSVpFIiwiTUFYX0JJVFMiLCJNSU5fTUFUQ0giLCJNQVhfTUFUQ0giLCJNSU5fTE9PS0FIRUFEIiwiUFJFU0VUX0RJQ1QiLCJJTklUX1NUQVRFIiwiRVhUUkFfU1RBVEUiLCJOQU1FX1NUQVRFIiwiQ09NTUVOVF9TVEFURSIsIkhDUkNfU1RBVEUiLCJCVVNZX1NUQVRFIiwiRklOSVNIX1NUQVRFIiwiQlNfTkVFRF9NT1JFIiwiQlNfQkxPQ0tfRE9ORSIsIkJTX0ZJTklTSF9TVEFSVEVEIiwiQlNfRklOSVNIX0RPTkUiLCJPU19DT0RFIiwiZXJyb3JDb2RlIiwicmFuayIsImZsdXNoX3BlbmRpbmciLCJwZW5kaW5nIiwicGVuZGluZ19idWYiLCJwZW5kaW5nX291dCIsInRvdGFsX291dCIsImZsdXNoX2Jsb2NrX29ubHkiLCJsYXN0IiwiX3RyX2ZsdXNoX2Jsb2NrIiwiYmxvY2tfc3RhcnQiLCJzdHJzdGFydCIsInB1dF9ieXRlIiwicHV0U2hvcnRNU0IiLCJyZWFkX2J1ZiIsIndyYXAiLCJ0b3RhbF9pbiIsImxvbmdlc3RfbWF0Y2giLCJjdXJfbWF0Y2giLCJjaGFpbl9sZW5ndGgiLCJtYXhfY2hhaW5fbGVuZ3RoIiwic2NhbiIsImJlc3RfbGVuIiwicHJldl9sZW5ndGgiLCJuaWNlX21hdGNoIiwid19zaXplIiwiX3dpbiIsIndtYXNrIiwid19tYXNrIiwicHJldiIsInN0cmVuZCIsInNjYW5fZW5kMSIsInNjYW5fZW5kIiwiZ29vZF9tYXRjaCIsImxvb2thaGVhZCIsIm1hdGNoX3N0YXJ0IiwiZmlsbF93aW5kb3ciLCJfd19zaXplIiwibW9yZSIsIndpbmRvd19zaXplIiwiaGFzaF9zaXplIiwiaGVhZCIsImluc2VydCIsImluc19oIiwiaGFzaF9zaGlmdCIsImhhc2hfbWFzayIsImRlZmxhdGVfc3RvcmVkIiwibWF4X2Jsb2NrX3NpemUiLCJwZW5kaW5nX2J1Zl9zaXplIiwibWF4X3N0YXJ0IiwiZGVmbGF0ZV9mYXN0IiwiaGFzaF9oZWFkIiwiYmZsdXNoIiwibWF0Y2hfbGVuZ3RoIiwiX3RyX3RhbGx5IiwibWF4X2xhenlfbWF0Y2giLCJsYXN0X2xpdCIsImRlZmxhdGVfc2xvdyIsIm1heF9pbnNlcnQiLCJwcmV2X21hdGNoIiwibWF0Y2hfYXZhaWxhYmxlIiwiZGVmbGF0ZV9ybGUiLCJkZWZsYXRlX2h1ZmYiLCJDb25maWciLCJnb29kX2xlbmd0aCIsIm1heF9sYXp5IiwibmljZV9sZW5ndGgiLCJtYXhfY2hhaW4iLCJjb25maWd1cmF0aW9uX3RhYmxlIiwibG1faW5pdCIsIkRlZmxhdGVTdGF0ZSIsImd6aGVhZCIsImd6aW5kZXgiLCJsYXN0X2ZsdXNoIiwid19iaXRzIiwiaGFzaF9iaXRzIiwiZHluX2x0cmVlIiwiZHluX2R0cmVlIiwiYmxfdHJlZSIsImxfZGVzYyIsImRfZGVzYyIsImJsX2Rlc2MiLCJibF9jb3VudCIsImhlYXAiLCJoZWFwX2xlbiIsImhlYXBfbWF4IiwiZGVwdGgiLCJsX2J1ZiIsImxpdF9idWZzaXplIiwiZF9idWYiLCJvcHRfbGVuIiwic3RhdGljX2xlbiIsIm1hdGNoZXMiLCJiaV9idWYiLCJiaV92YWxpZCIsImRlZmxhdGVSZXNldEtlZXAiLCJkYXRhX3R5cGUiLCJfdHJfaW5pdCIsImRlZmxhdGVSZXNldCIsImRlZmxhdGVJbml0Iiwib2xkX2ZsdXNoIiwiYmVnIiwiaGNyYyIsImV4dHJhIiwidGltZSIsIm9zIiwibGV2ZWxfZmxhZ3MiLCJic3RhdGUiLCJfdHJfYWxpZ24iLCJfdHJfc3RvcmVkX2Jsb2NrIiwiZGljdExlbmd0aCIsImF2YWlsIiwidG1wRGljdCIsImRlZmxhdGVJbmZvIiwieGZsYWdzIiwiZXh0cmFfbGVuIiwiZG9uZSIsIkJBRCIsIlRZUEUiLCJpbmZsYXRlX2Zhc3QiLCJfaW4iLCJfb3V0IiwiZG1heCIsIndzaXplIiwid2hhdmUiLCJ3bmV4dCIsInNfd2luZG93IiwiaG9sZCIsImJpdHMiLCJsY29kZSIsImRjb2RlIiwibG1hc2siLCJkbWFzayIsImhlcmUiLCJvcCIsImRpc3QiLCJmcm9tX3NvdXJjZSIsImxlbmNvZGUiLCJkaXN0Y29kZSIsImxlbmJpdHMiLCJkaXN0Yml0cyIsInRvcCIsImRvbGVuIiwiZG9kaXN0Iiwic2FuZSIsImluZmxhdGVfdGFibGUiLCJDT0RFUyIsIkxFTlMiLCJESVNUUyIsIlpfTUVNX0VSUk9SIiwiSEVBRCIsIkZMQUdTIiwiVElNRSIsIk9TIiwiRVhMRU4iLCJFWFRSQSIsIk5BTUUiLCJDT01NRU5UIiwiSENSQyIsIkRJQ1RJRCIsIkRJQ1QiLCJUWVBFRE8iLCJTVE9SRUQiLCJDT1BZXyIsIkNPUFkiLCJUQUJMRSIsIkxFTkxFTlMiLCJDT0RFTEVOUyIsIkxFTl8iLCJMRU4iLCJMRU5FWFQiLCJESVNUIiwiRElTVEVYVCIsIk1BVENIIiwiTElUIiwiQ0hFQ0siLCJMRU5HVEgiLCJET05FIiwiTUVNIiwiU1lOQyIsIkVOT1VHSF9MRU5TIiwiRU5PVUdIX0RJU1RTIiwiREVGX1dCSVRTIiwienN3YXAzMiIsIkluZmxhdGVTdGF0ZSIsImhhdmVkaWN0IiwiZmxhZ3MiLCJjaGVjayIsIndiaXRzIiwibmNvZGUiLCJubGVuIiwibmRpc3QiLCJoYXZlIiwid29yayIsImxlbmR5biIsImRpc3RkeW4iLCJiYWNrIiwid2FzIiwiaW5mbGF0ZVJlc2V0S2VlcCIsImluZmxhdGVSZXNldCIsImluZmxhdGVSZXNldDIiLCJpbmZsYXRlSW5pdCIsInZpcmdpbiIsImxlbmZpeCIsImRpc3RmaXgiLCJmaXhlZHRhYmxlcyIsInN5bSIsInVwZGF0ZXdpbmRvdyIsInB1dCIsImxlZnQiLCJoZXJlX2JpdHMiLCJoZXJlX29wIiwiaGVyZV92YWwiLCJsYXN0X2JpdHMiLCJsYXN0X29wIiwibGFzdF92YWwiLCJoYnVmIiwib3JkZXIiLCJpbmZfbGVhdmUiLCJkaWN0aWQiLCJpbmZsYXRlSW5mbyIsIk1BWEJJVFMiLCJsYmFzZSIsImxleHQiLCJkYmFzZSIsImRleHQiLCJsZW5zX2luZGV4IiwiY29kZXMiLCJ0YWJsZV9pbmRleCIsImN1cnIiLCJkcm9wIiwidXNlZCIsImh1ZmYiLCJpbmNyIiwibG93IiwibWFzayIsImJhc2UiLCJiYXNlX2luZGV4IiwiY291bnQiLCJvZmZzIiwiZXh0cmFfaW5kZXgiLCJTVE9SRURfQkxPQ0siLCJTVEFUSUNfVFJFRVMiLCJEWU5fVFJFRVMiLCJCdWZfc2l6ZSIsIk1BWF9CTF9CSVRTIiwiRU5EX0JMT0NLIiwiUkVQXzNfNiIsIlJFUFpfM18xMCIsIlJFUFpfMTFfMTM4IiwiZXh0cmFfbGJpdHMiLCJleHRyYV9kYml0cyIsImV4dHJhX2JsYml0cyIsImJsX29yZGVyIiwiRElTVF9DT0RFX0xFTiIsInN0YXRpY19sdHJlZSIsInN0YXRpY19kdHJlZSIsIl9kaXN0X2NvZGUiLCJfbGVuZ3RoX2NvZGUiLCJiYXNlX2xlbmd0aCIsImJhc2VfZGlzdCIsIlN0YXRpY1RyZWVEZXNjIiwic3RhdGljX3RyZWUiLCJleHRyYV9iaXRzIiwiZXh0cmFfYmFzZSIsImVsZW1zIiwibWF4X2xlbmd0aCIsImhhc19zdHJlZSIsInN0YXRpY19sX2Rlc2MiLCJzdGF0aWNfZF9kZXNjIiwic3RhdGljX2JsX2Rlc2MiLCJUcmVlRGVzYyIsImR5bl90cmVlIiwic3RhdF9kZXNjIiwibWF4X2NvZGUiLCJkX2NvZGUiLCJwdXRfc2hvcnQiLCJ3Iiwic2VuZF9iaXRzIiwic2VuZF9jb2RlIiwidHJlZSIsImJpX3JldmVyc2UiLCJiaV9mbHVzaCIsImdlbl9iaXRsZW4iLCJkZXNjIiwic3RyZWUiLCJoIiwieGJpdHMiLCJvdmVyZmxvdyIsImdlbl9jb2RlcyIsIm5leHRfY29kZSIsInRyX3N0YXRpY19pbml0IiwiaW5pdF9ibG9jayIsImJpX3dpbmR1cCIsImNvcHlfYmxvY2siLCJzbWFsbGVyIiwiX24yIiwiX20yIiwicHFkb3duaGVhcCIsInYiLCJjb21wcmVzc19ibG9jayIsImx0cmVlIiwiZHRyZWUiLCJsYyIsImx4IiwiYnVpbGRfdHJlZSIsIm5vZGUiLCJzY2FuX3RyZWUiLCJwcmV2bGVuIiwiY3VybGVuIiwibmV4dGxlbiIsIm1heF9jb3VudCIsIm1pbl9jb3VudCIsInNlbmRfdHJlZSIsImJ1aWxkX2JsX3RyZWUiLCJtYXhfYmxpbmRleCIsInNlbmRfYWxsX3RyZWVzIiwibGNvZGVzIiwiZGNvZGVzIiwiYmxjb2RlcyIsImRldGVjdF9kYXRhX3R5cGUiLCJibGFja19tYXNrIiwic3RhdGljX2luaXRfZG9uZSIsInN0b3JlZF9sZW4iLCJvcHRfbGVuYiIsInN0YXRpY19sZW5iIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYWZ0ZXJUaWNrT25lIiwiYWZ0ZXJUaWNrVHdvIiwiYWZ0ZXJUaWNrVGhyZWUiLCJhZnRlclRpY2siLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwiSXRlbSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvZmYiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJwbmEiLCJvYmplY3RLZXlzIiwia2V5cyIsIkR1cGxleCIsInV0aWwiLCJXcml0YWJsZSIsInJlYWRhYmxlIiwiYWxsb3dIYWxmT3BlbiIsIm9uZW5kIiwiX3dyaXRhYmxlU3RhdGUiLCJoaWdoV2F0ZXJNYXJrIiwib25FbmROVCIsIl9yZWFkYWJsZVN0YXRlIiwiZGVzdHJveWVkIiwiX2Rlc3Ryb3kiLCJQYXNzVGhyb3VnaCIsIlRyYW5zZm9ybSIsIl90cmFuc2Zvcm0iLCJSZWFkYWJsZVN0YXRlIiwiRUUiLCJFRWxpc3RlbmVyQ291bnQiLCJTdHJlYW0iLCJPdXJVaW50OEFycmF5IiwiX3VpbnQ4QXJyYXlUb0J1ZmZlciIsIl9pc1VpbnQ4QXJyYXkiLCJkZWJ1Z1V0aWwiLCJkZWJ1ZyIsImRlYnVnbG9nIiwiQnVmZmVyTGlzdCIsImRlc3Ryb3lJbXBsIiwia1Byb3h5RXZlbnRzIiwidW5zaGlmdCIsImlzRHVwbGV4IiwicmVhZGFibGVPYmplY3RNb2RlIiwiaHdtIiwicmVhZGFibGVId20iLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJkZWZhdWx0SHdtIiwicGlwZXMiLCJwaXBlc0NvdW50IiwiZmxvd2luZyIsImVuZEVtaXR0ZWQiLCJyZWFkaW5nIiwic3luYyIsIm5lZWRSZWFkYWJsZSIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwicmVzdW1lU2NoZWR1bGVkIiwiZGVmYXVsdEVuY29kaW5nIiwiYXdhaXREcmFpbiIsInJlYWRpbmdNb3JlIiwiZGVjb2RlciIsImRlc3Ryb3kiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95Iiwic2tpcENodW5rQ2hlY2siLCJyZWFkYWJsZUFkZENodW5rIiwiYWRkVG9Gcm9udCIsIm9uRW9mQ2h1bmsiLCJjaHVua0ludmFsaWQiLCJnZXRQcm90b3R5cGVPZiIsImFkZENodW5rIiwibWF5YmVSZWFkTW9yZSIsIm5lZWRNb3JlRGF0YSIsImVtaXRSZWFkYWJsZSIsInNldEVuY29kaW5nIiwiTUFYX0hXTSIsImNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrIiwiaG93TXVjaFRvUmVhZCIsIm5PcmlnIiwiZW5kUmVhZGFibGUiLCJkb1JlYWQiLCJmcm9tTGlzdCIsImVtaXRSZWFkYWJsZV8iLCJmbG93IiwibWF5YmVSZWFkTW9yZV8iLCJwaXBlT3B0cyIsImRvRW5kIiwic3Rkb3V0Iiwic3RkZXJyIiwiZW5kRm4iLCJ1bnBpcGUiLCJvbnVucGlwZSIsInVucGlwZUluZm8iLCJoYXNVbnBpcGVkIiwiY2xlYW51cCIsIm9uZHJhaW4iLCJwaXBlT25EcmFpbiIsImNsZWFuZWRVcCIsIm9uY2xvc2UiLCJvbmZpbmlzaCIsIm9uZGF0YSIsIm5lZWREcmFpbiIsImluY3JlYXNlZEF3YWl0RHJhaW4iLCJkZXN0cyIsImV2IiwiblJlYWRpbmdOZXh0VGljayIsInJlc3VtZV8iLCJfdGhpcyIsInBhdXNlZCIsImJpbmQiLCJfZnJvbUxpc3QiLCJmcm9tTGlzdFBhcnRpYWwiLCJoYXNTdHJpbmdzIiwiY29weUZyb21CdWZmZXJTdHJpbmciLCJjb3B5RnJvbUJ1ZmZlciIsImVuZFJlYWRhYmxlTlQiLCJ4cyIsImFmdGVyVHJhbnNmb3JtIiwidHMiLCJfdHJhbnNmb3JtU3RhdGUiLCJ0cmFuc2Zvcm1pbmciLCJ3cml0ZWNiIiwid3JpdGVjaHVuayIsInJzIiwibmVlZFRyYW5zZm9ybSIsIndyaXRlZW5jb2RpbmciLCJfZmx1c2giLCJwcmVmaW5pc2giLCJfd3JpdGUiLCJfdGhpczIiLCJlcnIyIiwiV3JpdGVSZXEiLCJDb3JrZWRSZXF1ZXN0IiwiZmluaXNoIiwib25Db3JrZWRGaW5pc2giLCJhc3luY1dyaXRlIiwiV3JpdGFibGVTdGF0ZSIsImludGVybmFsVXRpbCIsImRlcHJlY2F0ZSIsIm5vcCIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIndyaXRhYmxlSHdtIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwiZmluYWxDYWxsZWQiLCJlbmRpbmciLCJmaW5pc2hlZCIsIm5vRGVjb2RlIiwiZGVjb2RlU3RyaW5ncyIsIndyaXRpbmciLCJjb3JrZWQiLCJidWZmZXJQcm9jZXNzaW5nIiwib253cml0ZSIsIndyaXRlbGVuIiwiYnVmZmVyZWRSZXF1ZXN0IiwibGFzdEJ1ZmZlcmVkUmVxdWVzdCIsInBlbmRpbmdjYiIsInByZWZpbmlzaGVkIiwiZXJyb3JFbWl0dGVkIiwiYnVmZmVyZWRSZXF1ZXN0Q291bnQiLCJjb3JrZWRSZXF1ZXN0c0ZyZWUiLCJnZXRCdWZmZXIiLCJjdXJyZW50IiwiXyIsInJlYWxIYXNJbnN0YW5jZSIsImhhc0luc3RhbmNlIiwid3JpdGV2IiwiX3dyaXRldiIsImZpbmFsIiwiX2ZpbmFsIiwid3JpdGVBZnRlckVuZCIsInZhbGlkQ2h1bmsiLCJ2YWxpZCIsImlzQnVmIiwid3JpdGVPckJ1ZmZlciIsImNvcmsiLCJ1bmNvcmsiLCJjbGVhckJ1ZmZlciIsInNldERlZmF1bHRFbmNvZGluZyIsImRlY29kZUNodW5rIiwibmV3Q2h1bmsiLCJkb1dyaXRlIiwib253cml0ZUVycm9yIiwiZmluaXNoTWF5YmUiLCJvbndyaXRlU3RhdGVVcGRhdGUiLCJuZWVkRmluaXNoIiwiYWZ0ZXJXcml0ZSIsIm9ud3JpdGVEcmFpbiIsImhvbGRlciIsImFsbEJ1ZmZlcnMiLCJlbmRXcml0YWJsZSIsImNhbGxGaW5hbCIsIm5lZWQiLCJjb3JrUmVxIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsImNvcHlCdWZmZXIiLCJjdXN0b20iLCJyZWFkYWJsZURlc3Ryb3llZCIsIndyaXRhYmxlRGVzdHJveWVkIiwiZW1pdEVycm9yTlQiLCJjb3B5UHJvcHMiLCJTYWZlQnVmZmVyIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJkb2MiLCJyZWdpc3RlckltbWVkaWF0ZSIsImhhbmRsZSIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4IiwicmFuZG9tIiwib25HbG9iYWxNZXNzYWdlIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24iLCJzY3JpcHQiLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJfaXNTdGRpbyIsImRpZE9uRW5kIiwiY3NzIiwibG9jYXRpb24iLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJob3N0IiwiY3VycmVudERpciIsInBhdGhuYW1lIiwiZml4ZWRDc3MiLCJmdWxsTWF0Y2giLCJvcmlnVXJsIiwidW5xdW90ZWRPcmlnVXJsIiwiJDEiLCJuZXdVcmwiLCJzY29wZSIsIlRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjbG9zZSIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwicmVmIiwiZW5yb2xsIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwiYWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsImNvbmZpZyIsImRlcHJlY2F0ZWQiLCJ3YXJuIiwibG9jYWxTdG9yYWdlIiwiZXZhbCIsImdlbkN1YmUiLCJfcHJvcHMiLCJwcm9wcyIsIm5vciIsImluZCIsIlBJIiwieiIsImNvcyIsInNpbiIsIm5vcm1hbCIsImdlbk9jdGFoZWRyb24iLCJkaXYiLCJpaSIsImlxIiwiaXkiLCJpeCIsImxhdDAiLCJsYXQxIiwibG9uMCIsImxvbjEiLCJsb24yIiwibG9uMyIsIngxIiwieTEiLCJ6MSIsIngyIiwieTIiLCJ6MiIsIngzIiwieTMiLCJ6MyIsInNxcnQiLCJDYW52YXNTYXZlciIsImNhbnZhcyIsInF1ZXVlU2F2ZSIsImFuY2hvciIsImZyYW1lQ291bnQiLCJpblByb2dyZXNzIiwidG9CbG9iIiwiX19kb25lIiwiaHJlZiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImRvd25sb2FkIiwibm93IiwiY2xpY2siLCJyZXF1aXJlZEZpZWxkcyIsIm5hbml0aGVmdWNrIiwiZmllbGRzIiwiZmllbGQiLCJQYXRoR1VJIiwiZ2xDYXQiLCJwYXJhbXMiLCJndWkiLCJlbCIsImluZm8iLCJyYW5nZSIsInN0ZXAiLCJkYXRlTGlzdCIsImRhdGVMaXN0SW5kZXgiLCJ0b3RhbEZyYW1lcyIsImZwcyIsInZpZXdOYW1lIiwidmlld0luZGV4IiwiZ2wiLCJ2Ym9RdWFkIiwiY3JlYXRlVmVydGV4YnVmZmVyIiwiRmxvYXQzMkFycmF5IiwiYWRkIiwiX19QYXRoR3VpUmV0dXJuIiwid2lkdGgiLCJoZWlnaHQiLCJ2ZXJ0IiwiZnJhZyIsImJsZW5kIiwiT05FIiwiX3AiLCJ2aWV3cG9ydCIsInVuaWZvcm0yZnYiLCJhdHRyaWJ1dGUiLCJ1bmlmb3JtVGV4dHVyZSIsImRyYXdBcnJheXMiLCJUUklBTkdMRV9TVFJJUCIsInRvRml4ZWQiLCJpbm5lclRleHQiLCJ2aWV3IiwicGF0aHMiLCJmcmFtZWJ1ZmZlciIsInRleHR1cmVzIiwidGV4dHVyZSIsInN0cmV0Y2giLCJudWxsRmIiLCJQYXRoIiwiZ2xvYmFsRnVuYyIsImRlcHRoVGVzdCIsImRlcHRoV3JpdGUiLCJTUkNfQUxQSEEiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiY3VsbCIsImRyYXdidWZmZXJzIiwiY3JlYXRlRHJhd0J1ZmZlcnMiLCJmbG9hdCIsImNyZWF0ZUZsb2F0RnJhbWVidWZmZXIiLCJjcmVhdGVGcmFtZWJ1ZmZlciIsInRleHR1cmVGaWx0ZXIiLCJ0ZXh0dXJlV3JhcCIsInByb2dyYW0iLCJjcmVhdGVQcm9ncmFtIiwidXNlUHJvZ3JhbSIsImVuYWJsZSIsIkNVTExfRkFDRSIsImRpc2FibGUiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImRyYXdCdWZmZXJzIiwiQkFDSyIsIkNPTE9SX0FUVEFDSE1FTlQwIiwiYmxlbmRGdW5jIiwiREVQVEhfVEVTVCIsImRlcHRoTWFzayIsInByZXZQcm9ncmFtIiwibmV3UHJvZ3JhbSIsImRlbGV0ZVByb2dyYW0iLCJkZWxldGVTaGFkZXIiLCJyZXNpemVGbG9hdEZyYW1lYnVmZmVyIiwicmVzaXplRnJhbWVidWZmZXIiLCJvbnJlc2l6ZSIsIkdMQ2F0IiwiX2dsIiwiZGVwdGhGdW5jIiwiTEVRVUFMIiwiQkxFTkQiLCJfX2V4dGVuc2lvbnMiLCJfX2N1cnJlbnRQcm9ncmFtIiwiX25hbWUiLCJfdGhyb3ciLCJldmVyeSIsImdldEV4dGVuc2lvbiIsIl92ZXJ0IiwiX2ZyYWciLCJfb25FcnJvciIsIl9zdHIiLCJjcmVhdGVTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZ2V0U2hhZGVySW5mb0xvZyIsIkZSQUdNRU5UX1NIQURFUiIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwibG9jYXRpb25zIiwiZ2V0UHJvZ3JhbUluZm9Mb2ciLCJfcHJvZ3JhbSIsIl9zb3VyY2UiLCJzZXRWZXJ0ZXhidWZmZXIiLCJfdGFyZ2V0IiwiX3VzYWdlIiwidXNhZ2UiLCJTVEFUSUNfRFJBVyIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJidWZmZXJEYXRhIiwic2V0SW5kZXhidWZmZXIiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsImdldEF0dHJpYkxvY2F0aW9uIiwiX2J1ZmZlciIsIl9zaXplIiwiX3R5cGUiLCJfc3RyaWRlIiwiX29mZnNldCIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwidmVydGV4QXR0cmliRGl2aXNvckFOR0xFIiwiX2RpdiIsImdldFVuaWZvcm1Mb2NhdGlvbiIsIl92YWx1ZSIsInVuaWZvcm0xaSIsInVuaWZvcm0xZiIsInVuaWZvcm0zZnYiLCJ1bmlmb3JtNGZ2IiwiX3RyYW5zcG9zZSIsInVuaWZvcm1NYXRyaXg0ZnYiLCJfdGV4dHVyZSIsIl9udW1iZXIiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJURVhUVVJFX0NVQkVfTUFQIiwiY3JlYXRlVGV4dHVyZSIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01BR19GSUxURVIiLCJMSU5FQVIiLCJURVhUVVJFX01JTl9GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsIl9maWx0ZXIiLCJfd3JhcCIsInRleEltYWdlMkQiLCJSR0JBIiwiVU5TSUdORURfQllURSIsIl93aWR0aCIsIl9oZWlnaHQiLCJORUFSRVNUIiwiY29weVRleEltYWdlMkQiLCJfYXJyYXlPZkltYWdlIiwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YIiwiY3JlYXRlUmVuZGVyYnVmZmVyIiwiYmluZFJlbmRlcmJ1ZmZlciIsIlJFTkRFUkJVRkZFUiIsInJlbmRlcmJ1ZmZlclN0b3JhZ2UiLCJERVBUSF9DT01QT05FTlQxNiIsImZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyIiwiREVQVEhfQVRUQUNITUVOVCIsImZyYW1lYnVmZmVyVGV4dHVyZTJEIiwiX2ZyYW1lYnVmZmVyIiwiX251bURyYXdCdWZmZXJzIiwiTUFYX0RSQVdfQlVGRkVSU19XRUJHTCIsIkNPTE9SX0FUVEFDSE1FTlQwX1dFQkdMIiwiY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyIsIkZSQU1FQlVGRkVSX0NPTVBMRVRFIiwiZHJhd0J1ZmZlcnNXRUJHTCIsIl9yIiwiX2ciLCJfYiIsIl9hIiwiX2RlcHRoIiwiY2xlYXJDb2xvciIsImNsZWFyRGVwdGgiLCJDT0xPUl9CVUZGRVJfQklUIiwiREVQVEhfQlVGRkVSX0JJVCIsIk1hdGhDYXQiLCJ2ZWNBZGQiLCJ2ZWNTdWIiLCJ2ZWNNdWwiLCJ2ZWMzQ3Jvc3MiLCJ2ZWNTY2FsZSIsInZlY0RvdCIsInJlZHVjZSIsInZlY0xlbmd0aCIsInZlY05vcm1hbGl6ZSIsInF1YXRNdWwiLCJxdWF0SW52Iiwicm90YXRlVmVjQnlRdWF0IiwicXVhdFRvTWF0NCIsInF1YXRBbmdsZUF4aXMiLCJhbmdsZSIsImF4aXMiLCJoYSIsInNoYSIsIm1hdDRBcHBseSIsIm1hdDRJbnZlcnNlIiwiYTAwIiwiYTAxIiwiYTAyIiwiYTAzIiwiYTEwIiwiYTExIiwiYTEyIiwiYTEzIiwiYTIwIiwiYTIxIiwiYTIyIiwiYTIzIiwiYTMwIiwiYTMxIiwiYTMyIiwiYTMzIiwiYjAwIiwiYjAxIiwiYjAyIiwiYjAzIiwiYjA0IiwiYjA1IiwiYjA2IiwiYjA3IiwiYjA4IiwiYjA5IiwiYjEwIiwiYjExIiwibWF0NEFwcGx5VG9WZWM0IiwibWF0NFRyYW5zcG9zZSIsIm1hdDRJZGVudGl0eSIsIm1hdDRUcmFuc2xhdGUiLCJtYXQ0U2NhbGUiLCJtYXQ0U2NhbGVYWVoiLCJtYXQ0Um90YXRlWCIsIm1hdDRSb3RhdGVZIiwibWF0NFJvdGF0ZVoiLCJtYXQ0TG9va0F0IiwidGFyIiwiYWlyIiwicm90Iiwic2lkIiwibWF0NFBlcnNwZWN0aXZlIiwiZm92IiwibmVhciIsImZhciIsInRhbiIsIlVsdHJhQ2F0IiwidHJpYW5nbGVTdHJpcFF1YWQiLCJ0cmlhbmdsZVN0cmlwUXVhZDMiLCJ0cmlhbmdsZVN0cmlwUXVhZE5vciIsInRyaWFuZ2xlU3RyaXBRdWFkVVYiLCJzaHVmZmxlQXJyYXlEIiwiZGljZSIsImlyIiwidGVtcCIsInRyaUluZGV4VG9MaW5lSW5kZXgiLCJtYXRyaXgyZCIsImxlcnAiLCJjbGFtcCIsInNhdHVyYXRlIiwibGluZWFyc3RlcCIsInNtb290aHN0ZXAiLCJFeHBTbW9vdGgiLCJmYWN0b3IiLCJkdCIsImV4cCIsIlhvcnNoaWZ0IiwiX3NlZWQiLCJzZWVkIiwiJCIsInF1ZXJ5U2VsZWN0b3IiLCJDT05GSUciLCJyZXNvbHV0aW9uIiwic2F2ZXIiLCJnZXRDb250ZXh0IiwibGluZVdpZHRoIiwiZ2xDYXRQYXRoIiwiR0xDYXRQYXRoIiwidG90YWxGcmFtZSIsImlzSW5pdGlhbEZyYW1lIiwiYXV0b21hdG9uIiwiQXV0b21hdG9uIiwibG9vcCIsImF1dG8iLCJjYW1lcmFQb3MiLCJjYW1lcmFUYXIiLCJjYW1lcmFSb2xsIiwicGVyc3BGb3YiLCJwZXJzcE5lYXIiLCJwZXJzcEZhciIsImxpZ2h0UG9zIiwic2hhZG93UmVzbyIsIm1hdFAiLCJtYXRWIiwibWF0UEwiLCJtYXRWTCIsInVwZGF0ZU1hdHJpY2VzIiwiY2FtT2Zmc2V0Iiwic21vb3RoIiwibW91c2VYIiwibW91c2VZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJzZXRHbG9iYWxGdW5jIiwiZGVsdGFUaW1lIiwicmV0dXJuIiwiWkVSTyIsImluc3BlY3RvciIsInNoYWRvdyIsImRlZmF1bHQiLCJ1cGRhdGUiLCJiZWdpbiIsInJlbmRlciIsImZiIiwiaXNTaGFkb3ciLCJ0ZXh0dXJlU2hhZG93IiwiYmlhcyIsImRyeSIsImNhcHR1cmUiLCJzYXZlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2hpY2giLCJpc1BsYXlpbmciLCJwbGF5IiwicHJlQmxvb20iLCJibG9vbSIsInRlbXBGYiIsImdhdXNzVmFyIiwicG9zdEJsb29tIiwiYm94IiwidmJvQm94UG9zIiwibWF0TSIsIkxJTkVTIiwieG9yc2hpZnQiLCJwcHAiLCJuUGFydGljbGVTcXJ0IiwiblBhcnRpY2xlIiwiamFjb2JpSXRlciIsIm1vdGlvbkZpZWxkVm94ZWxVbml0IiwibW90aW9uRmllbGRSZXNvbHV0aW9uWFkiLCJtb3Rpb25GaWVsZFJlc29sdXRpb24iLCJ2Ym9Db21wdXRlVVYiLCJvY3QiLCJ2Ym9PY3RQb3MiLCJ2Ym9PY3ROb3IiLCJpYm9PY3QiLCJjcmVhdGVJbmRleGJ1ZmZlciIsInRleHR1cmVSYW5kb21TaXplIiwidGV4dHVyZVJhbmRvbVVwZGF0ZSIsIl90ZXgiLCJzZXRUZXh0dXJlRnJvbUFycmF5IiwiZ2VuIiwidGV4dHVyZVJhbmRvbVN0YXRpYyIsIlJFUEVBVCIsInRleHR1cmVSYW5kb20iLCJ0ZXh0dXJlRHVtbXkiLCJwYXJ0aWNsZXNDb21wdXRlUmV0dXJuIiwicGFydGljbGVzTW90aW9uUmVhZCIsIlBPSU5UUyIsInBhcnRpY2xlc0VuZm9yY2UiLCJwYXJ0aWNsZXNEaXZlcmdlbmNlIiwicGFydGljbGVzUHJlc3N1cmUiLCJwYXJ0aWNsZXNNb3Rpb25Xcml0ZSIsInBhcnRpY2xlc0NvbXB1dGUiLCJwYXJ0aWNsZXNSZW5kZXIiLCJhdHRyaWJ1dGVEaXZpc29yIiwiZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUiLCJUUklBTkdMRVMiLCJVTlNJR05FRF9TSE9SVCIsInBpeGVsc29ydENvbXBhcmUiLCJwaXhlbHNvcnRSZW5kZXIiLCJwb3N0IiwiZnhhYSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVB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QUhBLENBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FKQSxDQUtBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUhBLENBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUhBLENBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLFNBRkEsTUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FYQSxDLENBYUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxPQUZBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkIsQ0FBQTs7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQSxPQUZBOztBQUlBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0EsT0FGQTs7QUFHQTtBQUFBO0FBQUE7VTNEdkxBOzs7QTREQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0MsQ0FFQTs7QUFFQTtBQUNBO0FBQ0EsU0FGQTs7QUFHQTtBQUNBO0FBQ0EsU0FGQTs7QUFHQSwrQkFDQTtBQUFBO0FBQUEsU0FEQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsU0FGQSxDLENBSUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBSEE7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RUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0EsK0JBQ0EsRUFEQSxHQUVBLDZCQUNBLDRCQURBLEdBRUEsV0FKQTtBQUtBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBLHlCQUNBLEdBREEsRUFFQSxnQkFGQSxFQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0Esb0NBQ0E7QUFBQTtBQUFBLFdBREEsR0FFQTtBQUFBO0FBQUEsV0FGQTtBQUdBO0FBRUE7Ozs7O0FBR0E7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUhBO0FBSUE7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0EsU0FGQTtBQUlBOzs7O0FBR0E7QUFDQTtBQUNBLFNBRkE7QUFJQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBRkE7QUFJQTs7Ozs7Ozs7QUFRQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFDQSxRQUNBLHdCQURBLEdBRUEsZUFIQSxHQUlBLFlBSkE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZDQUNBLFVBREEsR0FFQSxZQUZBO0FBSUE7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFFQTs7Ozs7QUFHQTtBQUFBO0FBQUE7QUFFQTs7Ozs7QUFHQTtB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LGtEQUNBLG9DQURBO0FBR0E7QUFDQSxXQU5BOztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLHVFQUNBLFVBREEsR0FFQSxZQUNBLHFDQURBLEdBRUEsUUFKQTtBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQ0EsdURBQ0Esa0RBREEsQ0FEQTtBQUlBLFdBcEJBOztBQXNCQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0EsV0FSQTs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFKQSxNQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBLCtDQUNBLEdBREEsQ0FDQTtBQUFBLGdHQUNBLGtFQURBLEdBRUEsdUJBRkE7QUFFQSxlQUhBLEVBSUEsSUFKQSxDQUlBLElBSkE7QUFLQSxhQXZCQSxNQXVCQTtBQUNBO0FBQ0E7QUFDQSxXQTNCQTtBQTRCQTtBQUVBOzs7QUFHQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLFNBSEE7O0FBS0E7QUFDQTtBQUNBLFNBRkE7O0FBSUE7QUFDQTtBQUNBLFNBRkE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUpBOztBQU1BO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQU5BLEMsQ0FRQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUEsbUNBQ0EsR0FEQSxFQUVBLElBRkEsRUFHQSxRQUhBLEVBSUEsSUFKQSxFQUtBLEdBTEEsRUFNQSxPQU5BLEVBT0EsZ0JBUEEsRUFRQSxZQVJBLEVBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FqQ0E7O0FBbUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVSxDQUVBOztBQUNBOztBQUNBO0FBQ0E7QUFDQSxTQUZBOztBQUlBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBUEE7O0FBU0E7QUFDQTtBQUNBLFMsQ0FFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQSxpQ0FDQSxTQURBLEVBRUEsVUFGQSxFQUdBLGNBSEEsRUFJQSxVQUpBLEVBS0EsU0FMQSxFQU1BLGFBTkEsRUFPQSxzQkFQQSxFQVFBLGtCQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUVBLDhCQUNBLE1BREEsRUFFQSxLQUZBLEVBR0EsT0FIQSxFQUlBLFNBSkEsRUFLQSxRQUxBLEVBTUEsTUFOQSxFQU9BLFNBUEE7QUFVQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBUEE7O0FBU0E7QUFBQTtBQUFBLGFBaEJBLENBaUJBOzs7QUFDQTtBQUNBO0FBQ0EsV0FwQkE7QUFxQkEsU0F4QkE7QUEwQkE7O0FBRUE7QUFFQTs7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EscUNBQ0EsWUFEQSxHQUVBLFdBRkE7QUFHQTtBQUNBO0FBQ0EsV0FOQSxNQU1BO0FBQ0E7QUFDQTtBQUNBLFNBZEE7QUFnQkE7Ozs7Ozs7QUFLQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBTEE7QUFPQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBSkEsQyxDQU1BOztBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBSUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLFdBRkEsTUFFQSxJQUNBLGlCQUNBLG9CQURBLEtBRUEsNENBRkEsS0FHQSwwQkFIQSxJQUlBLGFBTEEsRUFNQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQSxnQ0FDQSxHQURBLEVBRUEsR0FGQSxFQUdBLEdBSEEsRUFJQSxZQUpBLEVBS0EsT0FMQSxFQU1BO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0EsV0FOQSxDQVFBOzs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0EsNEJBREE7QUFFQSw4QkFGQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxhQWZBO0FBZ0JBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxlQUZBLE1BRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQWpDQTtBQW1DQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQSx3REFDQSxzQ0FEQSxHQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0EsMERBQ0EsMEVBQ0EscURBRkE7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQSx3REFDQSxzQ0FEQSxHQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBLDBEQUNBLG1FQUNBLHdCQUZBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7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QTtBQUtBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQSxXQUpBLE1BSUE7QUFDQTtBQUNBO0FBQ0EscURBQ0E7QUFBQTtBQUFBLHFCQURBLEdBRUE7QUFBQTtBQUFBLGVBRkE7QUFHQTtBQUNBLFdBUEEsTUFPQTtBQUNBLGlCQUNBLDBFQUNBLFVBREEsR0FDQSxpQkFEQSxHQUNBLEdBRkEsRUFHQSxFQUhBO0FBS0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQ0Esb0VBQ0EsVUFEQSxHQUNBLGdCQURBLEdBQ0EsR0FGQSxFQUdBLEVBSEE7QUFLQTtBQUNBO0FBRUE7Ozs7OztBQUlBLDhCQUNBLE1BREEsRUFFQSxLQUZBLEVBR0EsRUFIQSxFQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBLDhCQUNBLE9BREEsRUFFQSxJQUZBLEVBR0EsRUFIQSxFQUlBLFdBSkEsRUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLHFDQUxBLENBTUE7O0FBQ0E7QUFBQTtBQUFBOztBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUEsV0FYQSxDQVlBOzs7QUFDQTs7QUFDQTtBQUNBLGlCQUNBLG9EQURBLEVBRUEsT0FGQTtBQUlBOztBQUNBO0FBQ0E7QUFFQTs7O0FBRUEsOEJBQ0EsR0FEQSxFQUVBLFdBRkEsRUFHQSxTQUhBLEVBSUEsRUFKQSxFQUtBO0FBQ0E7QUFDQTtBQUNBLHFDQUhBLENBSUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FqQkEsQ0FrQkE7OztBQUNBO0FBQ0EsdURBREEsQ0FFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsY0FDQSx5Q0FDQTtBQUNBLDREQUhBLEVBSUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGlDQUxBLENBTUE7O0FBQ0E7QUFDQSxpQkFDQSxtREFDQSwyREFEQSxHQUVBLDhCQUhBLEVBSUEsRUFKQTtBQU1BLFdBZEEsQ0FlQTtBQUNBOzs7QUFDQSw2Q0FDQSx3Q0FEQSxJQUVBLDRCQUZBLEVBR0E7QUFDQTtBQUNBLFdBdEJBLENBdUJBO0FBQ0E7OztBQUNBLGtGQUNBLFlBREEsR0FFQSxHQUZBO0FBR0E7QUFFQTs7Ozs7QUFHQSw0QkFDQSxJQURBLEVBRUEsSUFGQSxFQUdBLEtBSEEsRUFJQSxFQUpBLEVBS0EsTUFMQSxFQU1BO0FBQ0E7QUFDQSxpQkFDQSx1Q0FEQSxFQUVBLEVBRkE7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EsaUJBQ0EsK0RBQ0EsWUFEQSxHQUNBLHdDQURBLEdBRUEsUUFGQSxHQUVBLGdCQUZBLEdBRUEsR0FIQSxFQUlBLEVBSkE7QUFNQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQSxtQkFDQSxzRUFEQSxFQUVBLEVBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0EscURBRkEsQ0FHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQVBBLE1BT0E7QUFDQTtBQUNBLFdBRkEsTUFFQTtBQUNBO0FBQ0EsV0FGQSxNQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLHdCQURBO0FBRUE7QUFGQTtBQUlBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBLG1CQUhBLENBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBRkEsQ0FFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQSxXQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBLGlDLENBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FGQTtBQUdBLFNBSkEsTUFJQSw4Q0FDQSw0QkFDQTtBQUNBLDBFQUhBLEdBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLFdBRkE7QUFHQSxTQVhBLE1BV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUZBO0FBR0EsUyxDQUVBOztBQUNBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0EsbUNBREEsQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBLFdBUkE7QUFTQSxTQVhBLE1BV0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FMQTtBQU1BOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUZBLENBRUE7QUFDQTtBQUNBO0FBQ0EsYUFOQSxNQU1BO0FBQ0E7QUFDQTtBQUNBLFdBVkE7O0FBV0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsYUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBLFdBcEJBLENBcUJBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUZBO0FBR0E7QUFDQTtBQUVBOztBQUVBOzs7QUFFQTs7QUFFQTtBQUNBLHVDQUNBLDJDQUNBLGdGQURBLEdBRUEsd0VBRkEsR0FHQSxTQUpBLENBSUE7QUFKQTs7QUFPQTtBQUNBLGlCQUNBLDJFQUNBLHNFQURBLEdBRUEsK0RBRkEsR0FHQSw2QkFIQSxHQUlBLGdGQUxBLEVBTUEsTUFOQTtBQVFBLFdBVEE7O0FBV0EseUJBQ0EsK0NBREE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFIQSxNQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFOQTs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUNBLFVBREEsR0FFQSxVQUZBO0FBR0E7QUFDQSxhQVBBLE1BT0E7QUFDQTtBQUNBO0FBQ0EsV0FYQTtBQVlBO0FBRUE7OztBQUVBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQSxXQUhBLE1BR0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0EsY0FDQSxRQUNBLFNBREEsSUFFQSxZQUZBLElBR0EsZUFIQSxJQUlBLGtCQUxBLEVBTUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBTEE7QUFNQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUhBLENBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFEQTtBQUVBLHlCQUZBO0FBR0EsNEJBSEE7QUFJQTtBQUpBO0FBTUEsU0FiQTs7QUFlQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBTEEsTUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FDQSxFQURBLEVBRUEsS0FGQSxFQUdBLEdBSEEsRUFJQSxTQUpBLEVBS0EsRUFMQSxFQU1BO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLDREQUNBLHNFQURBLEVBRUEsRUFGQTtBQUlBLGFBTEEsTUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLGFBTEEsTUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FEQSxDQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUhBLE1BR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFKQSxNQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUVBLDJDQUNBLElBREEsRUFFQSxJQUZBLEVBR0EsR0FIQSxFQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQSxvQkFDQSwwQkFDQSxLQURBLElBQ0EsNkJBRkEsRUFHQTtBQUNBLHNCQUNBLDREQUNBLGdDQURBLEdBQ0Es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O0FBQ0E7QUFDQSxrREFGQSxDQUVBOztBQUNBO0FBQ0E7O0FBQ0Esa0NBVEEsQ0FVQTs7QUFDQTtBQUNBLFdBekNBLENBMkNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUEvQ0EsQ0FpREE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBTEEsTUFLQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUZBLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0EsMEJBRkEsQ0FJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQSxhQVpBLENBY0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUpBLENBS0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBLHFCQUNBLDJDQUNBLGVBQ0EsMkRBREEsR0FFQSxpQ0FIQSxDQURBLEVBTUEsVUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBLFdBcENBLENBc0NBOzs7QUFDQTtBQUNBO0FBRUEsZ0NBMUNBLENBNENBOztBQUNBO0FBQ0EseUNBOUNBLENBZ0RBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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RUFHQSxHQUhBLEVBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQ0EsSUFEQSxFQUVBLEdBRkEsRUFHQSxNQUhBLEVBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQU5BLE1BTUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0REFDQSwrQ0FEQSxFQUVBLElBRkE7QUFJQSxhQUxBLE1BS0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUEseUNBQ0EsSUFEQSxFQUVBLEtBRkEsRUFHQSxRQUhBLEVBSUEsTUFKQSxFQUtBLElBTEEsRUFNQTtBQUNBLHFDQURBLENBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBLDhDQURBLENBRUE7O0FBQ0E7QUFDQSxXQUpBLE1BSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFKQSxDQUtBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUEsWUExQkEsQ0E0QkE7OztBQUNBO0FBQ0E7QUFDQSxvQ0FGQSxDQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxhQVBBO0FBUUEsV0FUQSxNQVNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQ0FDQSxJQURBLEVBRUEsU0FGQSxFQUdBLElBSEEsRUFJQSxTQUpBLEVBS0EsUUFMQSxFQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FKQSxNQUlBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFB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O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLFdBaEJBO0FBaUJBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FIQTtBQUlBO0FBRUE7OztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUVBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUZBOztBQUdBO0FBQ0E7QUFDQTtBQUNBLHVDQUNBLGFBREEsRUFFQSxhQUZBO0FBSUEsaUNBeEJBLENBMEJBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLGFBbENBLENBb0NBOzs7QUFDQTtBQUNBO0FBQ0EsZ0NBdkNBLENBeUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLGFBRkEsRUEzQ0EsQ0E4Q0E7O0FBQ0E7QUFDQTtBQUNBLGFBakRBLENBbURBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBLHdEQXhEQSxDQTBEQTs7QUFDQTtBQUNBO0FBQ0EsV0E3REE7QUE4REE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7OztBQUdBO0FBQ0Esa0NBQ0EsRUFEQSxFQUVBLFVBRkEsRUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFyQkE7QUFzQkEsV0F2QkE7QUF3QkE7QUFFQTs7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBRkEsTUFFQTtBQUNBO0FBQ0EsV0FGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQ0EsS0FEQSxFQUVBLEdBRkEsRUFHQSxJQUhBLEVBSUEsT0FKQSxFQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0EsNEJBREE7QUFFQSx3QkFGQTtBQUlBO0FBQ0EsaUNBREE7QUFFQSxpQ0FGQTtBQUdBO0FBSEEsV0FKQTtBQVVBO0FBQ0E7QUFDQTtBQUNBLFdBYkE7QUFlQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBckJBO0FBdUJBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBLGFBRkE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBLGFBRkE7QUFHQSxXQWhDQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsbUJBQ0E7QUFDQSwrREFDQTtBQUNBLHVEQUpBLEVBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUNBO0FBQ0E7QUFGQSxnQkFHQSxxRkFIQSxHQUlBLFNBSkE7O0FBS0E7QUFDQSx1RUFEQSxDQUVBOztBQUNBO0FBQ0E7QUFDQSxlQUxBLE1BS0E7QUFDQTtBQUNBLCtCQUZBLENBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBOUVBO0FBaUZBO0FBQ0E7QUFHQTs7QUFKQTs7QUFNQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQSxtQkFDQSxzRUFEQTtBQUdBLGFBSkE7QUFLQTs7QUFDQSwwREFYQSxDQWFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLHNCQURBO0FBRUEsMEJBRkE7QUFHQSxzQ0FIQTtBQUlBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUZBLEVBNUJBLENBZ0NBO0FBQ0E7O0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsVyxDQU9BOztBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBRUE7QUFFQTtBQUNBOztBQUNBLG9ELENBRUE7O0FBQ0E7O0FBQ0E7QUFDQSxpQkFDQSw2REFDQSx1Q0FEQSxJQUVBLHFDQUZBLElBR0EsbUNBSkE7QUFNQSxTQVBBOztBQVNBO0FBRUEsb0NBQ0EsK0VBQ0EscUVBREEsR0FFQSxrRkFGQSxHQUdBLDRFQUhBLEdBSUEsZ0VBSkEsR0FLQSxpQ0FOQTtBQVNBOztBQUVBO0FBQ0E7QUFDQSxTQUZBOztBQUlBO0FBQ0E7QUFDQSxTQUZBOztBQUlBO0FBQ0E7QUFDQSxTQUZBO0FBSUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRUFEQTtBQUVBLHdDQUNBLDJCQURBLEdBRUE7QUFKQTtBQU1BOztBQUVBLDZCQUNBLFdBREEsRUFFQSxZQUZBLEVBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBLDJDQURBO0FBRUE7QUFGQTtBQUtBLGdDQUNBLCtDQUNBLDJFQURBLEdBRUEsb0VBRkEsR0FHQSx3RUFIQSxHQUlBLDZFQUpBLEdBS0EsMkRBTEEsR0FNQSxrREFOQSxHQU9BLHlFQVBBLEdBUUEsa0NBUkEsR0FTQSx1Q0FUQSxHQVVBLHlEQVhBLEUsQ0FjQTtBQUNBOztBQUNBLDRCQUNBLDJFQUNBLDBFQURBLEdBRUEsa0VBSEEsRUFJQSxJQUpBOztBQVNBO0FBQ0E7QUFDQSxTQUZBOztBQUlBO0FBQ0E7QUFDQTtBQUNBLFdBSEEsQ0FJQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsOENBQ0EsZ0RBQ0EscUNBRkE7QUFJQSxXQU5BLE1BTUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTs7OztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLDREQUNBLDRCQURBO0FBR0E7QUFDQTs7QUFDQTtBQUNBLFdBVEEsTUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxXQUpBLENBS0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQSx3Q0FEQTtBQUVBLDBDQUZBO0FBR0Esd0NBSEE7QUFJQSxzQ0FKQTtBQUtBLG9DQUxBO0FBTUEsa0NBTkE7QUFPQSxrQ0FQQTtBQVFBLGdDQVJBO0FBU0Esa0NBVEE7QUFVQSwwQkFWQTtBQVdBLHdDQVhBO0FBWUE7QUFaQTtBQWVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBSEE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FUQTtBQVVBO0FBQ0E7QUFDQTtBQVpBOztBQWVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0EsV0FOQSxNQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFQQSxNQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7OztBQVlBO0FBRUE7O0FBRUE7QUFDQSxpQkFDQSxvQkFFQSxtQkFDQSwyQkFEQSxJQUVBLCtCQUZBLElBR0EsbUJBSkEsSUFNQSxnQ0FDQSxpQ0FEQSxJQUVBLDZCQVRBLENBREE7QUFjQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQURBLENBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFDQSxXQUNBLFNBREEsSUFFQSxFQUNBLGlDQUNBO0FBQ0Esd0NBQ0Esc0JBREEsR0FFQSxvQkFGQTtBQUdBLGFBSkEsQ0FGQSxDQUZBLElBVUEsa0NBWEE7QUFhQTs7QUFFQTs7QUFFQSw2QkFDQSxLQURBLEVBRUEsa0JBRkEsRUFHQSxTQUhBLEVBSUEsTUFKQSxFQUtBLE1BTEEsRUFNQSxVQU5BLEVBT0EsS0FQQSxFQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FWQSxDQVVBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLHVCQUNBLHFEQUNBLDhEQURBLEdBRUEseUNBSEEsRUFJQSxhQUpBO0FBTUE7QUFDQTs7QUFFQSxxQ0FDQSxzQ0FEQSxHQUVBLGlDQUZBO0FBR0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBaENBLE1BZ0NBO0FBQ0E7QUFDQTtBQUNBLGFBSEEsTUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBLGVBSkEsQ0FLQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUhBLE1BR0E7QUFDQTtBQUNBO0FBQ0EsaUNBSEEsQ0FJQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFEQSxDQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFoQkEsQ0FpQkE7QUFDQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUpBLE1BSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBUEEsTUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGdDQUpBLENBSUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQSxXQWpPQSxDQW1PQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBLGFBRkEsTUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSxhQVpBLENBYUE7OztBQUNBLDZDQUNBLG1CQURBLElBRUEscUJBRkEsSUFHQSw4QkFIQSxFQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFIQSxNQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFKQSxNQUlBO0FBQ0E7QUFDQTtBQUNBLGVBVkEsQ0FXQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsZUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBLGFBdkJBLE1BdUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQVRBLENBV0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBREEsQ0FDQTtBQUNBLGVBRkEsTUFFQTtBQUNBO0FBQ0EsZUFGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFKQSxNQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFKQSxNQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBTEEsTUFLQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUxBLE1BS0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0Esc0RBQ0EsOEJBREEsR0FFQSwwREFGQTs7QUFHQTtBQUFBO0FBQ0E7QUFDQSxpQkFGQSxNQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFKQSxNQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBSEEsTUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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UEEsQ0FRQTtBQUNBOztBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBREEsQ0FDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBTEE7QUFNQTs7QUFFQSx1QkFDQSxLQURBLEVBRUEsT0FGQSxFQUdBLE9BSEEsRUFJQSxPQUpBLEVBS0EsT0FMQSxFQU1BO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBLG9DQUNBLEtBREEsRUFFQSxPQUZBLEVBR0Esa0JBQ0E7QUFBQTtBQUFBO0FBQUEsV0FEQSxHQUVBLE9BTEE7QUFPQTs7QUFFQSwwQkFDQSxLQURBLEVBRUEsT0FGQSxFQUdBLE9BSEEsRUFJQSxPQUpBLEVBS0E7QUFDQSxvREFDQSxLQURBLEVBRUEsNEJBRkEsRUFHQSxPQUhBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FEQTtBQUVBO0FBR0E7O0FBTEE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBUEEsQ0FRQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLDZCQURBLENBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQSxlQUZBLENBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBSEEsQ0FJQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQVRBLE1BU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTLENBRUE7OztBQUdBO0FBQ0Esb0NBQ0EsNEJBQ0EsbUNBREEsSUFFQSxtQ0FIQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUhBLENBSUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBRkEsQ0FFQTs7QUFDQTtBQUNB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QTs7OztBQUtBOztBQUNBO0FBQ0EsZTs7O0FBR0E7QUFDQTtBQUNBOztBQUNBOztBQUdBO0FBQ0EsZTs7O0FBR0E7QUFDQSxhO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUhBLE1BR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxhO0FBQ0E7QUFFQTs7QUFHQSxhO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0EsZUFGQSxFQUVBLElBRkE7QUFHQTs7O0FBakZBLE87Ozs7Ozs7Ozs7QUFoRUE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O00zRkFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBNEYrREEsa0M7QUFDQSxvQztBQUNBLDBDO0FBQ0Esd0M7QUFDQSx3QztBQUNBLDhDO0FBQ0E7Ozs7QUFNQTtBQUNBLGdDQURBO0FBRUEscUNBRkE7QUFHQSxpQ0FIQTtBQUlBLCtCQUpBO0FBS0Esd0JBTEE7QUFNQSxzQ0FOQTtBQU9BLDZCQVBBO0FBUUEsNkJBUkE7QUFTQTtBQVRBO0FBQ0EsVzs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQTtBQUVBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFFQTtBQUNBO0FBQ0EsYTtBQUNBO0FBRUE7QUFDQTtBQUNBLGE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBOzs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBLGE7QUFDQSxXO0FBQ0E7O0FBdEVBLE87Ozs7Ozs7Ozs7QUE5REE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TTVGQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0E2RmtDQTs7OztBQU1BO0FBQ0EsVzs7QUFJQTtBQUNBOzs7QUFDQSxzQztBQUNBLHNDO0FBQ0E7QUFDQSxzQ0FEQTtBQUdBO0FBQ0E7QUFDQTtBQUxBLG1CQU1BO0FBSkEsc0NBSUE7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFOQSxpQkFOQTs7QUFGQTs7O0FBZEEsTzs7Ozs7Ozs7OztBQWpDQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O003RkFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBOEZtQ0E7QUFDQTtBQUNBO0FBQUE7OztBQUVBO0FBQ0EsV0FMQTs7O0FBUUE7QUFDQSxTOzs7Ozs7QUFlQTtBQUNBLDBCQURBO0FBRUE7QUFGQTtBQUNBLFc7O0FBTUE7QUFDQTs7O0FBQ0E7QUFBQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxpQkFIQSxFQUdBLEVBSEE7QUFJQTs7QUFDQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGlCLE1BQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQVRBLE1BU0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBLGUsRUFBQTtBQUNBO0FBQ0E7QUFBQTs7QUFBQTtBQUNBLGU7QUFDQSxhO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFFQTtBQUNBLGE7QUFDQTtBQUVBO0FBQ0E7QUFBQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUF2RkEsTzs7Ozs7Ozs7OztBQS9DQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TTlGQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0ErRmlRQSxzQztBQUNBOzs7QUFJQTtBQUNBO0FBQ0EseUJBREE7QUFFQTtBQUZBO0FBREE7QUFDQSxXOztBQVFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0EsYTtBQUNBO0FBRUE7QUFDQSxhO0FBS0E7QUFFQTtBQUNBLGE7QUFLQTtBQUVBO0FBQ0EsYTtBQUtBO0FBRUE7QUFDQTs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUEzRUEsTzs7Ozs7Ozs7OztBQXRQQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O00vRkFBOzs7Ozs7Ozs7Ozs7O0FnRzZCQTtBQUNBLG9CQURBO0FBRUE7QUFGQTtBQUNBLFc7O0FBTUE7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFFQTtBQUNBOzs7QUFJQTs7O0FBQ0E7O0FBQ0E7QUFDQSxhOztBQUNBO0FBQ0E7O0FBNUNBLE87Ozs7Ozs7Ozs7QUF4QkE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNaEdBQTs7Ozs7Ozs7Ozs7OztBaUdvQkE7QUFDQSxxQkFEQTtBQUVBLHNCQUZBO0FBR0Esb0JBSEE7QUFJQSx1QkFKQTtBQUtBO0FBTEE7QUFDQSxXOztBQVNBO0FBQ0E7OztBQUNBO0FBQ0EsZSxFQUFBLEU7QUFDQTs7O0FBSUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOztBQUdBO0FBQ0E7QUFDQTs7O0FBR0EsYTs7QUFHQTtBQUNBLGE7O0FBR0E7QUFDQSxhO0FBQ0E7O0FBN0NBLE87Ozs7Ozs7Ozs7QUFqQkE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TWpHQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QWtHMENBOzs7QUFJQTtBQUNBLHdCQURBO0FBRUEsNEJBRkE7QUFHQTtBQUhBO0FBQ0EsVzs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUEsZUFEQTtBQUNBLGE7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0EsYTtBQUNBO0FBRUE7QUFDQTtBQUNBLGVBRkEsTUFFQTtBQUNBO0FBQ0EsZUFGQSxNQUVBO0FBQ0E7QUFDQSxlQUZBLE1BRUE7QUFDQTtBQUNBLGVBRkEsTUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQSxXOztBQUdBO0FBQ0E7QUFBQTs7O0FBQ0E7QUFFQSxlOzs7QUFJQTtBQUFBLGU7QUFBQTtBQUNBOzs7QUFJQTtBQUNBOzs7QUFDQTtBQUFBOztBQUFBO0FBQ0E7QUFDQSxlQUZBLEVBRUEsRUFGQTtBQUdBOzs7QUEvRUEsTzs7Ozs7Ozs7OztBQXBDQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNbEdBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FtR3NQQTtBQUNBO0FBQ0E7QUFBQTs7O0FBRUE7QUFDQSxXQUxBOzs7QUFRQTtBQUNBLFM7Ozs7QUFJQTs7OztBQVdBO0FBQ0Esd0JBREE7QUFFQSx5QkFGQTtxQkFBQTtBQUtBLHVDQUxBO0FBTUEsdUJBTkE7QUFPQSxzQkFQQTs7QUFVQSxxQjtBQUNBO2VBWEE7NkJBQUE7aUNBQUE7QUFpQkE7QUFqQkE7QUFDQSxXOztBQXFCQTtBQUNBO0FBQ0EscUJBREE7QUFFQTtBQUZBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUNBO0FBS0E7QUFDQSxtQ0FEQTtBQUVBLHNDQUZBO0FBR0E7QUFIQTtBQUNBOztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7QUFHQTs7QUFDQTtBQUtBO0FBQ0Esb0NBREE7QUFFQSx1Q0FGQTtBQUdBO0FBSEE7QUFDQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFBQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxhO0FBQ0E7QUFFQTtBQUNBO0FBQ0EsYTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYTtBQUNBO0FBUUE7QUFDQTs7OztBQUtBO0FBQUE7O0FBR0E7QUFDQSxhO0FBQ0E7QUFVQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsYTtBQUNBO0FBUUE7O0FBQ0E7QUFDQTtBQUFBOzs7QUFFQTs7QUFHQTs7QUFHQTtBQUVBLGUsRUFBQTtBQUFBO0FBQ0EsZTtBQUFBLGE7QUFFQTtBQU9BOztBQUNBO0FBQ0E7QUFBQTs7OztBQUVBO0FBQ0E7QUFBQTs7O0FBRUE7QUFFQSxlLEVBQUE7QUFBQTtBQUNBLGUsRUFBQSxJOztBQUlBLGE7QUFDQTtBQVFBOztBQUNBO0FBQ0E7QUFBQTs7OztBQUlBOzs7QUFLQTtBQUVBLGUsRUFBQTtBQUFBO0FBQ0EsZSxFQUFBLEk7QUFBQSxhO0FBR0E7QUFPQTs7QUFDQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUdBO0FBQ0EsZSxFQUFBO0FBQ0E7QUFFQTtBQUNBLGUsRUFBQSxJO0FBQ0EsYTtBQUdBO0FBUUE7OztBQUNBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7OztBQUtBLGU7OztBQUdBO0FBQ0E7QUFDQTs7QUFHQTs7O0FBR0E7QUFDQSxlOzs7QUFHQTtBQUNBLGE7QUFDQTtBQU9BO0FBQ0E7QUFBQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYTtBQUNBO0FBT0E7QUFDQTtBQUFBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFRQTs7OztBQUNBO0FBQ0E7QUFBQTs7O0FBRUE7O0FBR0E7QUFDQTs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBLGlCLE1BQUE7QUFBQTtBQUNBOzs7OztBQUlBO0FBQ0E7QUFFQSxtQkFIQSxFQUdBO0FBQUE7QUFDQSxtQkFKQTtBQUlBO0FBRUEsZTtBQUNBLGE7QUFDQTtBQVNBOzs7O0FBQ0E7QUFDQTtBQUFBOzs7QUFFQTs7QUFHQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGlCLE1BQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBR0E7QUFDQSxtQkFMQSxFQUtBO0FBQ0E7QUFFQTtBQUNBLG1CQVRBO0FBVUE7QUFFQSxlO0FBQ0EsYTtBQUNBO0FBT0E7QUFDQTtBQUNBLGE7QUFDQTtBQVFBOztBQUNBO0FBQ0E7QUFBQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUFBOztBQUFBO0FBQ0E7O0FBR0E7QUFFQSxlLEVBQUE7QUFBQTtBQUNBLGU7QUFBQSxhO0FBRUE7QUFPQTs7QUFDQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUVBLGUsRUFBQTtBQUFBO0FBQ0EsZSxFQUFBLEk7O0FBSUEsYTtBQUNBO0FBUUE7Ozs7QUFDQTtBQUNBO0FBQUE7OztBQUVBOzs7QUFLQTs7O0FBS0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUVBLG1CQUhBLEVBR0E7QUFBQTtBQUNBLG1CQUpBO0FBSUE7QUFFQSxlO0FBQ0EsYTtBQUNBO0FBUUE7Ozs7QUFDQTtBQUNBO0FBQUE7OztBQUVBOzs7QUFLQTs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUVBLG1CQUhBLEVBR0E7QUFBQTtBQUNBLG1CQUpBO0FBSUE7QUFFQSxlO0FBQ0EsYTtBQUNBO0FBUUE7Ozs7QUFDQTtBQUNBO0FBQUE7OztBQUVBOzs7QUFLQTs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUVBLG1CQUhBLEVBR0E7QUFBQTtBQUNBLG1CQUpBO0FBSUE7QUFFQSxlO0FBQ0EsYTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGlCLE1BQUE7QUFDQTtBQUNBO0FBQ0EsbUJBRkEsTUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxlOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsZTs7O0FBR0E7QUFDQSxhO0FBQ0E7QUFFQTs7O0FBQ0E7QUFBQTs7O0FBRUE7O0FBR0Esc0M7QUFDQSxzQztBQUNBO0FBQ0Esa0NBREE7QUFHQTtBQUNBO0FBQ0E7QUFMQSxtQkFNQTtBQUpBLGdDQUlBO0FBR0E7QUFDQTtBQUNBO0FBTEEsaUJBTkE7O0FBRkEsYTtBQWtCQTtBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsZSxNQUFBO0FBQ0E7QUFDQSxlQUZBLE1BRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGE7QUFDQTtBQUVBOzs7QUFDQTtBQUNBOztBQUdBOztBQUNBO0FBQ0EsZTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTs7O0FBSUE7OztBQUNBO0FBQ0E7QUFDQSxhOztBQUdBO0FBQ0E7OztBQUdBLGE7O0FBR0E7QUFDQSxhOztBQUdBO0FBQ0EsYTtBQUNBO0FBQ0EsVztBQUNBO0FBRUE7QUFDQTs7QUFqd0JBLE87Ozs7Ozs7Ozs7QUFsUUE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFB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RUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0EsS0FBSyxLQUF3QyxFQUFFLEVBRTdDOztBQUVGLFFBQVEsc0JBQWlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtB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QTJELEdBQUcsMEJBQTBCLHlEQUF5RCxrREFBa0Qsa0ZBQWtGLHdCQUF3QixVQUFVLFNBQVMsOEJBQThCLE9BQU8sRUFBRSw2Q0FBNkMscUNBQXFDLDREQUE0RCxxQ0FBcUMsMENBQTBDLGdCQUFnQixTQUFTLE9BQU8sNENBQTRDLHFDQUFxQyw0REFBNEQscUNBQXFDLDBDQUEwQyxnQkFBZ0IsU0FBUyxPQUFPLEtBQUssMENBQTBDLEdBQUcsaUJBQWlCLDJEQUEyRCxHQUFHLEM7Ozs7Ozs7Ozs7O0FDQXhxQyxrT0FBa08sMENBQTBDLDBCQUEwQiw0QkFBNEIsNkJBQTZCLDZCQUE2QiwrQkFBK0Isb0RBQW9ELHVDQUF1QyxrREFBa0QsbURBQW1ELG1JQUFtSSx1REFBdUQsR0FBRyw4QkFBOEIsMkNBQTJDLG1FQUFtRSx3Q0FBd0MsNkJBQTZCLHNCQUFzQixpQkFBaUIsU0FBUyw2REFBNkQsa01BQWtNLDZEQUE2RCxLQUFLLHlDQUF5QywrREFBK0QseUlBQXlJLDhDQUE4QyxzQ0FBc0MsR0FBRyxDOzs7Ozs7Ozs7OztBQ0FscUQsc0RBQXNELGlCQUFpQixzQ0FBc0MsR0FBRyxDOzs7Ozs7Ozs7OztBQ0FoSCx3Q0FBd0MsK0NBQStDLDZCQUE2QixpQkFBaUIsMkNBQTJDLDZDQUE2QyxHQUFHLEM7Ozs7Ozs7Ozs7OztBQ0NoTyxjQUFjLG1CQUFPLENBQUMsbU1BQW1HOztBQUV6SCw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsc0dBQW1EOztBQUV4RTs7QUFFQSxHQUFHLEtBQVUsRUFBRSxFOzs7Ozs7Ozs7OztBQ25CZixlOzs7Ozs7Ozs7OztBQ0FBLGUiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvbWFpbi5qc1wiKTtcbiIsIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9mcm9tID0gcmVxdWlyZShcIi4uL2NvcmUtanMvYXJyYXkvZnJvbVwiKTtcblxudmFyIF9mcm9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Zyb20pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2Zyb20yLmRlZmF1bHQpKGFycik7XG4gIH1cbn07IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuTWF0aC5sb2cxMDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuTWF0aC5zaWduO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjcnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBoYXMoZXhwb3J0cywga2V5KSkgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTggRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzaWduOiByZXF1aXJlKCcuL19tYXRoLXNpZ24nKSB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsInZhciBWdWUgLy8gbGF0ZSBiaW5kXG52YXIgdmVyc2lvblxudmFyIG1hcCA9ICh3aW5kb3cuX19WVUVfSE9UX01BUF9fID0gT2JqZWN0LmNyZWF0ZShudWxsKSlcbnZhciBpbnN0YWxsZWQgPSBmYWxzZVxudmFyIGlzQnJvd3NlcmlmeSA9IGZhbHNlXG52YXIgaW5pdEhvb2tOYW1lID0gJ2JlZm9yZUNyZWF0ZSdcblxuZXhwb3J0cy5pbnN0YWxsID0gZnVuY3Rpb24gKHZ1ZSwgYnJvd3NlcmlmeSkge1xuICBpZiAoaW5zdGFsbGVkKSB7IHJldHVybiB9XG4gIGluc3RhbGxlZCA9IHRydWVcblxuICBWdWUgPSB2dWUuX19lc01vZHVsZSA/IHZ1ZS5kZWZhdWx0IDogdnVlXG4gIHZlcnNpb24gPSBWdWUudmVyc2lvbi5zcGxpdCgnLicpLm1hcChOdW1iZXIpXG4gIGlzQnJvd3NlcmlmeSA9IGJyb3dzZXJpZnlcblxuICAvLyBjb21wYXQgd2l0aCA8IDIuMC4wLWFscGhhLjdcbiAgaWYgKFZ1ZS5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmluZGV4T2YoJ2luaXQnKSA+IC0xKSB7XG4gICAgaW5pdEhvb2tOYW1lID0gJ2luaXQnXG4gIH1cblxuICBleHBvcnRzLmNvbXBhdGlibGUgPSB2ZXJzaW9uWzBdID49IDJcbiAgaWYgKCFleHBvcnRzLmNvbXBhdGlibGUpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnW0hNUl0gWW91IGFyZSB1c2luZyBhIHZlcnNpb24gb2YgdnVlLWhvdC1yZWxvYWQtYXBpIHRoYXQgaXMgJyArXG4gICAgICAgICdvbmx5IGNvbXBhdGlibGUgd2l0aCBWdWUuanMgY29yZSBeMi4wLjAuJ1xuICAgIClcbiAgICByZXR1cm5cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlY29yZCBmb3IgYSBob3QgbW9kdWxlLCB3aGljaCBrZWVwcyB0cmFjayBvZiBpdHMgY29uc3RydWN0b3JcbiAqIGFuZCBpbnN0YW5jZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZXhwb3J0cy5jcmVhdGVSZWNvcmQgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgaWYobWFwW2lkXSkgeyByZXR1cm4gfVxuICBcbiAgdmFyIEN0b3IgPSBudWxsXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIEN0b3IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9uc1xuICB9XG4gIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKVxuICBtYXBbaWRdID0ge1xuICAgIEN0b3I6IEN0b3IsXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICBpbnN0YW5jZXM6IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBtb2R1bGUgaXMgcmVjb3JkZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqL1xuXG5leHBvcnRzLmlzUmVjb3JkZWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBbaWRdICE9PSAndW5kZWZpbmVkJ1xufVxuXG4vKipcbiAqIE1ha2UgYSBDb21wb25lbnQgb3B0aW9ucyBvYmplY3QgaG90LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBtYWtlT3B0aW9uc0hvdChpZCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgdmFyIHJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiAoaCwgY3R4KSB7XG4gICAgICB2YXIgaW5zdGFuY2VzID0gbWFwW2lkXS5pbnN0YW5jZXNcbiAgICAgIGlmIChjdHggJiYgaW5zdGFuY2VzLmluZGV4T2YoY3R4LnBhcmVudCkgPCAwKSB7XG4gICAgICAgIGluc3RhbmNlcy5wdXNoKGN0eC5wYXJlbnQpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVuZGVyKGgsIGN0eClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5qZWN0SG9vayhvcHRpb25zLCBpbml0SG9va05hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgICAgIGlmICghcmVjb3JkLkN0b3IpIHtcbiAgICAgICAgcmVjb3JkLkN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yXG4gICAgICB9XG4gICAgICByZWNvcmQuaW5zdGFuY2VzLnB1c2godGhpcylcbiAgICB9KVxuICAgIGluamVjdEhvb2sob3B0aW9ucywgJ2JlZm9yZURlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBtYXBbaWRdLmluc3RhbmNlc1xuICAgICAgaW5zdGFuY2VzLnNwbGljZShpbnN0YW5jZXMuaW5kZXhPZih0aGlzKSwgMSlcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogSW5qZWN0IGEgaG9vayB0byBhIGhvdCByZWxvYWRhYmxlIGNvbXBvbmVudCBzbyB0aGF0XG4gKiB3ZSBjYW4ga2VlcCB0cmFjayBvZiBpdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhvb2tcbiAqL1xuXG5mdW5jdGlvbiBpbmplY3RIb29rKG9wdGlvbnMsIG5hbWUsIGhvb2spIHtcbiAgdmFyIGV4aXN0aW5nID0gb3B0aW9uc1tuYW1lXVxuICBvcHRpb25zW25hbWVdID0gZXhpc3RpbmdcbiAgICA/IEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpID8gZXhpc3RpbmcuY29uY2F0KGhvb2spIDogW2V4aXN0aW5nLCBob29rXVxuICAgIDogW2hvb2tdXG59XG5cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKGlkLCBhcmcpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJ1xuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zIChvbGRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvbGRPcHRpb25zKSB7XG4gICAgaWYgKCEoa2V5IGluIG5ld09wdGlvbnMpKSB7XG4gICAgICBkZWxldGUgb2xkT3B0aW9uc1trZXldXG4gICAgfVxuICB9XG4gIGZvciAodmFyIGtleSQxIGluIG5ld09wdGlvbnMpIHtcbiAgICBvbGRPcHRpb25zW2tleSQxXSA9IG5ld09wdGlvbnNba2V5JDFdXG4gIH1cbn1cblxuZXhwb3J0cy5yZXJlbmRlciA9IHRyeVdyYXAoZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gIHZhciByZWNvcmQgPSBtYXBbaWRdXG4gIGlmICghb3B0aW9ucykge1xuICAgIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuJGZvcmNlVXBkYXRlKClcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zLm9wdGlvbnNcbiAgfVxuICBpZiAocmVjb3JkLkN0b3IpIHtcbiAgICByZWNvcmQuQ3Rvci5vcHRpb25zLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgcmVjb3JkLkN0b3Iub3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZuc1xuICAgIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuJG9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgIGluc3RhbmNlLiRvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zXG4gICAgICAvLyByZXNldCBzdGF0aWMgdHJlZXNcbiAgICAgIC8vIHByZSAyLjUsIGFsbCBzdGF0aWMgdHJlZXMgYXJlIGNhaGNlZCB0b2dldGhlciBvbiB0aGUgaW5zdGFuY2VcbiAgICAgIGlmIChpbnN0YW5jZS5fc3RhdGljVHJlZXMpIHtcbiAgICAgICAgaW5zdGFuY2UuX3N0YXRpY1RyZWVzID0gW11cbiAgICAgIH1cbiAgICAgIC8vIDIuNS4wXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWNvcmQuQ3Rvci5vcHRpb25zLmNhY2hlZCkpIHtcbiAgICAgICAgcmVjb3JkLkN0b3Iub3B0aW9ucy5jYWNoZWQgPSBbXVxuICAgICAgfVxuICAgICAgLy8gMi41LjNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGluc3RhbmNlLiRvcHRpb25zLmNhY2hlZCkpIHtcbiAgICAgICAgaW5zdGFuY2UuJG9wdGlvbnMuY2FjaGVkID0gW11cbiAgICAgIH1cbiAgICAgIC8vIHBvc3QgMi41LjQ6IHYtb25jZSB0cmVlcyBhcmUgY2FjaGVkIG9uIGluc3RhbmNlLl9zdGF0aWNUcmVlcy5cbiAgICAgIC8vIFB1cmUgc3RhdGljIHRyZWVzIGFyZSBjYWNoZWQgb24gdGhlIHN0YXRpY1JlbmRlckZucyBhcnJheVxuICAgICAgLy8gKGJvdGggYWxyZWFkeSByZXNldCBhYm92ZSlcbiAgICAgIGluc3RhbmNlLiRmb3JjZVVwZGF0ZSgpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBmdW5jdGlvbmFsIG9yIG5vIGluc3RhbmNlIGNyZWF0ZWQgeWV0XG4gICAgcmVjb3JkLm9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICByZWNvcmQub3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZuc1xuXG4gICAgLy8gaGFuZGxlIGZ1bmN0aW9uYWwgY29tcG9uZW50IHJlLXJlbmRlclxuICAgIGlmIChyZWNvcmQub3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyByZXJlbmRlciB3aXRoIGZ1bGwgb3B0aW9uc1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhyZWNvcmQub3B0aW9ucywgb3B0aW9ucylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRlbXBsYXRlLW9ubHkgcmVyZW5kZXIuXG4gICAgICAgIC8vIG5lZWQgdG8gaW5qZWN0IHRoZSBzdHlsZSBpbmplY3Rpb24gY29kZSBmb3IgQ1NTIG1vZHVsZXNcbiAgICAgICAgLy8gdG8gd29yayBwcm9wZXJseS5cbiAgICAgICAgdmFyIGluamVjdFN0eWxlcyA9IHJlY29yZC5vcHRpb25zLl9pbmplY3RTdHlsZXNcbiAgICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICAgIHZhciByZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgICAgIHJlY29yZC5vcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIChoLCBjdHgpIHtcbiAgICAgICAgICAgIGluamVjdFN0eWxlcy5jYWxsKGN0eClcbiAgICAgICAgICAgIHJldHVybiByZW5kZXIoaCwgY3R4KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb3JkLm9wdGlvbnMuX0N0b3IgPSBudWxsXG4gICAgICAvLyAyLjUuM1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVjb3JkLm9wdGlvbnMuY2FjaGVkKSkge1xuICAgICAgICByZWNvcmQub3B0aW9ucy5jYWNoZWQgPSBbXVxuICAgICAgfVxuICAgICAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLiRmb3JjZVVwZGF0ZSgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufSlcblxuZXhwb3J0cy5yZWxvYWQgPSB0cnlXcmFwKGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMub3B0aW9uc1xuICAgIH1cbiAgICBtYWtlT3B0aW9uc0hvdChpZCwgb3B0aW9ucylcbiAgICBpZiAocmVjb3JkLkN0b3IpIHtcbiAgICAgIGlmICh2ZXJzaW9uWzFdIDwgMikge1xuICAgICAgICAvLyBwcmVzZXJ2ZSBwcmUgMi4yIGJlaGF2aW9yIGZvciBnbG9iYWwgbWl4aW4gaGFuZGxpbmdcbiAgICAgICAgcmVjb3JkLkN0b3IuZXh0ZW5kT3B0aW9ucyA9IG9wdGlvbnNcbiAgICAgIH1cbiAgICAgIHZhciBuZXdDdG9yID0gcmVjb3JkLkN0b3Iuc3VwZXIuZXh0ZW5kKG9wdGlvbnMpXG4gICAgICByZWNvcmQuQ3Rvci5vcHRpb25zID0gbmV3Q3Rvci5vcHRpb25zXG4gICAgICByZWNvcmQuQ3Rvci5jaWQgPSBuZXdDdG9yLmNpZFxuICAgICAgcmVjb3JkLkN0b3IucHJvdG90eXBlID0gbmV3Q3Rvci5wcm90b3R5cGVcbiAgICAgIGlmIChuZXdDdG9yLnJlbGVhc2UpIHtcbiAgICAgICAgLy8gdGVtcG9yYXJ5IGdsb2JhbCBtaXhpbiBzdHJhdGVneSB1c2VkIGluIDwgMi4wLjAtYWxwaGEuNlxuICAgICAgICBuZXdDdG9yLnJlbGVhc2UoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHJlY29yZC5vcHRpb25zLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuICByZWNvcmQuaW5zdGFuY2VzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UuJHZub2RlICYmIGluc3RhbmNlLiR2bm9kZS5jb250ZXh0KSB7XG4gICAgICBpbnN0YW5jZS4kdm5vZGUuY29udGV4dC4kZm9yY2VVcGRhdGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLidcbiAgICAgIClcbiAgICB9XG4gIH0pXG59KVxuIiwiLyohXG4gKiBWdWUuanMgdjIuNS4xNlxuICogKGMpIDIwMTQtMjAxOCBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUgZS5nLiBbb2JqZWN0IE9iamVjdF1cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0Li4uIGUuZy5cbiAqIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5IHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlIHNpbmNlIG5hdGl2ZSBiaW5kIGlzXG4gKiBub3cgbW9yZSBwZXJmb3JtYW50IGluIG1vc3QgYnJvd3NlcnMsIGJ1dCByZW1vdmluZyBpdCB3b3VsZCBiZSBicmVha2luZyBmb3JcbiAqIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW4gUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yXG4gKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cblxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxufVxuXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gID8gbmF0aXZlQmluZFxuICA6IHBvbHlmaWxsQmluZDtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pXG5cbi8qICAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBpbldlZXggPSB0eXBlb2YgV1hFbnZpcm9ubWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFXWEVudmlyb25tZW50LnBsYXRmb3JtO1xudmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSAoVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMCkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbnZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICA/IHZtLm9wdGlvbnNcbiAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICA6IHZtIHx8IHt9O1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIHZub2RlLmNoaWxkcmVuLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl07XG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUob2JqLCBrZXlzW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIGlmICghZ2V0dGVyICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YWwgPSBvYmpba2V5XTtcbiAgfVxuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgaWYgKGNoaWxkVmFsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cbiAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgcGFyZW50VmFsID0gdW5kZWZpbmVkOyB9XG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgY2hpbGRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5JDFdO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBpZiAoY2hpbGRWYWwgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XG4gIHJldHVybiByZXRcbn07XG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xuICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICk7XG4gIH1cbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICdpZDogJyArIG5hbWVcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xuICAgICEoZmFsc2UgJiYgaXNPYmplY3QodmFsdWUpICYmICgnQGJpbmRpbmcnIGluIHZhbHVlKSlcbiAgKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpICtcbiAgICAgIFwiLCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHZtKSB7XG4gICAgdmFyIGN1ciA9IHZtO1xuICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgIGlmIChob29rcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNZXNzYWdlQ2hhbm5lbCAqL1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBib3RoIG1pY3JvdGFza3MgYW5kIChtYWNybykgdGFza3MuXG4vLyBJbiA8IDIuNCB3ZSB1c2VkIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYnV0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvcyB3aGVyZVxuLy8gbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTApIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZVxuLy8gZXZlbnQgKCM2NTY2KS4gSG93ZXZlciwgdXNpbmcgKG1hY3JvKSB0YXNrcyBldmVyeXdoZXJlIGFsc28gaGFzIHN1YnRsZSBwcm9ibGVtc1xuLy8gd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50IChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gSGVyZSB3ZSB1c2UgbWljcm90YXNrIGJ5IGRlZmF1bHQsIGJ1dCBleHBvc2UgYSB3YXkgdG8gZm9yY2UgKG1hY3JvKSB0YXNrIHdoZW5cbi8vIG5lZWRlZCAoZS5nLiBpbiBldmVudCBoYW5kbGVycyBhdHRhY2hlZCBieSB2LW9uKS5cbnZhciBtaWNyb1RpbWVyRnVuYztcbnZhciBtYWNyb1RpbWVyRnVuYztcbnZhciB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcblxuLy8gRGV0ZXJtaW5lIChtYWNybykgdGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8vIFRlY2huaWNhbGx5IHNldEltbWVkaWF0ZSBzaG91bGQgYmUgdGhlIGlkZWFsIGNob2ljZSwgYnV0IGl0J3Mgb25seSBhdmFpbGFibGVcbi8vIGluIElFLiBUaGUgb25seSBwb2x5ZmlsbCB0aGF0IGNvbnNpc3RlbnRseSBxdWV1ZXMgdGhlIGNhbGxiYWNrIGFmdGVyIGFsbCBET01cbi8vIGV2ZW50cyB0cmlnZ2VyZWQgaW4gdGhlIHNhbWUgbG9vcCBpcyBieSB1c2luZyBNZXNzYWdlQ2hhbm5lbC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE1lc3NhZ2VDaGFubmVsKSB8fFxuICAvLyBQaGFudG9tSlNcbiAgTWVzc2FnZUNoYW5uZWwudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTWVzc2FnZUNoYW5uZWxDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaENhbGxiYWNrcztcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZSgxKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG4vLyBEZXRlcm1pbmUgbWljcm90YXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBtaWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIGZhbGxiYWNrIHRvIG1hY3JvXG4gIG1pY3JvVGltZXJGdW5jID0gbWFjcm9UaW1lckZ1bmM7XG59XG5cbi8qKlxuICogV3JhcCBhIGZ1bmN0aW9uIHNvIHRoYXQgaWYgYW55IGNvZGUgaW5zaWRlIHRyaWdnZXJzIHN0YXRlIGNoYW5nZSxcbiAqIHRoZSBjaGFuZ2VzIGFyZSBxdWV1ZWQgdXNpbmcgYSAobWFjcm8pIHRhc2sgaW5zdGVhZCBvZiBhIG1pY3JvdGFzay5cbiAqL1xuZnVuY3Rpb24gd2l0aE1hY3JvVGFzayAoZm4pIHtcbiAgcmV0dXJuIGZuLl93aXRoVGFzayB8fCAoZm4uX3dpdGhUYXNrID0gZnVuY3Rpb24gKCkge1xuICAgIHVzZU1hY3JvVGFzayA9IHRydWU7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgdXNlTWFjcm9UYXNrID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc1xuICB9KVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGN0eCkge1xuICB2YXIgX3Jlc29sdmU7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZShjdHgpO1xuICAgIH1cbiAgfSk7XG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIGlmICh1c2VNYWNyb1Rhc2spIHtcbiAgICAgIG1hY3JvVGltZXJGdW5jKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pY3JvVGltZXJGdW5jKCk7XG4gICAgfVxuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSkge1xuICBpZiAob25jZSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmIChmbikge1xuICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgICAgdmFyIGNiO1xuICAgICAgdmFyIGkkMSA9IGNicy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSQxLS0pIHtcbiAgICAgICAgY2IgPSBjYnNbaSQxXTtcbiAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgICBjYnMuc3BsaWNlKGkkMSwgMSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgICAvLyBubyBuZWVkIGZvciB0aGUgcmVmIG5vZGVzIGFmdGVyIGluaXRpYWwgcGF0Y2hcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCBudWxsLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9ucyxcbiAgaXNSZW5kZXJXYXRjaGVyXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICB9XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMTsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIGlmICghaXNSb290KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgfVxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogdXNlckRlZjtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmplY3QsIGtleSkuZW51bWVyYWJsZVxuICAgICAgfSlcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICB2YXIgbm9kZXM7XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzbG90Tm9kZXMuX3JlbmRlcmVkKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcbiAgICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBub2RlcyA9IHNsb3ROb2RlcyB8fCBmYWxsYmFjaztcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xuICBpZiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2ggKGV4cGVjdCwgYWN0dWFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcbiAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWxcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbktleUNvZGUsXG4gIGV2ZW50S2V5TmFtZSxcbiAgYnVpbHRJbktleU5hbWVcbikge1xuICB2YXIgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xuICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXG4gIH0gZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcbiAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcCxcbiAgaXNTeW5jXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICBkYXRhLFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIHBhcmVudCxcbiAgQ3RvclxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIGNvbnRleHRWbTtcbiAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcbiAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXG4gICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gIH1cbiAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICB2YXIgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgdGhpcy5zbG90cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KTsgfTtcblxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gZGF0YS5zY29wZWRTbG90cyB8fCBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zKSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG5cblxuXG4vLyBSZWdpc3RlciB0aGUgY29tcG9uZW50IGhvb2sgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cbi8vIFRoZSBob29rIHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IG5hdGl2ZSwgbm90IGphdmFzY3JpcHQuXG5cblxuLy8gVXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuXG4vKiAgKi9cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuXG4vLyBsaXN0ZW5pbmcgb24gbmF0aXZlIGNhbGxiYWNrXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxuICAgIGFzeW5jRmFjdG9yeVxuICApO1xuXG4gIC8vIFdlZXggc3BlY2lmaWM6IGludm9rZSByZWN5Y2xlLWxpc3Qgb3B0aW1pemVkIEByZW5kZXIgZnVuY3Rpb24gZm9yXG4gIC8vIGV4dHJhY3RpbmcgY2VsbC1zbG90IHRlbXBsYXRlLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgaG9va3Nba2V5XSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgLy8gcmVzZXQgX3JlbmRlcmVkIGZsYWcgb24gc2xvdHMgZm9yIGR1cGxpY2F0ZSBzbG90IGNoZWNrXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHZtLiRzbG90c1trZXldLl9yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xucmVuZGVyTWl4aW4oVnVlKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlLCBrZXksIHRoaXMkMS5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5cblZ1ZS52ZXJzaW9uID0gJzIuNS4xNic7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5cblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUsIGNoaWxkcmVuLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBmYWxzZSwgdm5vZGVzLCBzdGFydElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlU2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgLy8gaW1tZWRpYXRlbHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFxuICAgICAgaXNJRSAmJiAhaXNJRTkgJiZcbiAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufVxuXG4vKiAgKi9cblxuLyogICovXG5cblxuXG5cblxuXG5cblxuXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcblxuXG5cblxuXG5cblxuXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cblxuLyogICovXG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaGFuZGxlciA9IHdpdGhNYWNyb1Rhc2soaGFuZGxlcik7XG4gIGlmIChvbmNlJCQxKSB7IGhhbmRsZXIgPSBjcmVhdGVPbmNlSGFuZGxlcihoYW5kbGVyLCBldmVudCwgY2FwdHVyZSk7IH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLl93aXRoVGFzayB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAvLyBpbnB1dHMgd2l0aCBsYXp5IHNob3VsZCBvbmx5IGJlIHVwZGF0ZWQgd2hlbiBub3QgaW4gZm9jdXNcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZik7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZilcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fVxuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dXG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufVxuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufVxuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpbkJyb3dzZXIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICAgIGlzQ2hyb21lXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgICApO1xuICAgIH1cbiAgfSwgMCk7XG59XG5cbi8qICAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZTtcbiIsInZhciBpbnNlcnRlZCA9IGV4cG9ydHMuY2FjaGUgPSB7fVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmV4cG9ydHMuaW5zZXJ0ID0gZnVuY3Rpb24gKGNzcykge1xuICBpZiAoaW5zZXJ0ZWRbY3NzXSkgcmV0dXJuIG5vb3BcbiAgaW5zZXJ0ZWRbY3NzXSA9IHRydWVcblxuICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKVxuXG4gIGlmICgndGV4dENvbnRlbnQnIGluIGVsZW0pIHtcbiAgICBlbGVtLnRleHRDb250ZW50ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgZWxlbS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfVxuXG4gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZWxlbSlcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLnJlbW92ZUNoaWxkKGVsZW0pXG4gICAgaW5zZXJ0ZWRbY3NzXSA9IGZhbHNlXG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0ICggdmFsdWUsIG1lc3NhZ2UgKSA9PiB7XG4gIGlmICggdmFsdWUgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7XG4gIH1cbn07IiwiaW1wb3J0IENsb2NrIGZyb20gJy4vY2xvY2snO1xuXG4vKipcbiAqICoqVXN1YWxseSB5b3UgZG9uJ3QgbmVlZCB0byBrbm93IGFib3V0IHRoaXMgY2xhc3MuKipcbiAqIENsYXNzIHRoYXQgZGVhbHMgd2l0aCB0aW1lLlxuICogVGhpcyBpcyBcImZyYW1lXCIgdHlwZSBjbG9jaywgdGhlIGZyYW1lIGluY3JlYXNlcyBldmVyeSB1cGRhdGUgY2FsbC5cbiAqIEBleHRlbmRzIENsb2NrXG4gKiBAcGFyYW0ge0F1dG9tYXRvbn0gX2F1dG9tYXRvbiBQYXJlbnQgYXV0b21hdG9uIG9iamVjdFxuICogQHBhcmFtIHtudW1iZXJ9IF9mcHMgRnJhbWVzIHBlciBzZWNvbmRcbiAqL1xuY29uc3QgQ2xvY2tGcmFtZSA9IGNsYXNzIGV4dGVuZHMgQ2xvY2sge1xuICBjb25zdHJ1Y3RvciggX2F1dG9tYXRvbiwgX2ZwcyApIHtcbiAgICBzdXBlciggX2F1dG9tYXRvbiApO1xuXG4gICAgdGhpcy5mcmFtZSA9IDAuMDtcbiAgICB0aGlzLmZwcyA9IF9mcHM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjbG9jay4gSXQgd2lsbCBpbmNyZWFzZSB0aGUgZnJhbWUgYnkgMS5cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIHRoaXMuaXNQbGF5aW5nICkge1xuICAgICAgdGhpcy50aW1lID0gdGhpcy5mcmFtZSAvIHRoaXMuZnBzO1xuICAgICAgdGhpcy5kZWx0YVRpbWUgPSAxLjAgLyB0aGlzLmZwcztcbiAgICAgIHRoaXMuZnJhbWUgKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gMC4wO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2xvY2tGcmFtZTsiLCJpbXBvcnQgQ2xvY2sgZnJvbSAnLi9jbG9jayc7XG5cbi8qKlxuICogKipVc3VhbGx5IHlvdSBkb24ndCBuZWVkIHRvIGtub3cgYWJvdXQgdGhpcyBjbGFzcy4qKlxuICogQ2xhc3MgdGhhdCBkZWFscyB3aXRoIHRpbWUuXG4gKiBUaGlzIGlzIFwicmVhbHRpbWVcIiB0eXBlIGNsb2NrLCB0aGUgdGltZSBnb2VzIG9uIGFzIHJlYWwgd29ybGQuXG4gKiBAZXh0ZW5kcyBDbG9ja1xuICogQHBhcmFtIHtBdXRvbWF0b259IF9hdXRvbWF0b24gUGFyZW50IGF1dG9tYXRvbiBvYmplY3RcbiAqL1xuY29uc3QgQ2xvY2tSZWFsdGltZSA9IGNsYXNzIGV4dGVuZHMgQ2xvY2sge1xuICBjb25zdHJ1Y3RvciggX2F1dG9tYXRvbiApIHtcbiAgICBzdXBlciggX2F1dG9tYXRvbiApO1xuXG4gICAgdGhpcy5yZWFsdGltZSA9IHRydWU7XG4gICAgdGhpcy5ydFRpbWUgPSAwLjA7XG4gICAgdGhpcy5ydERhdGUgPSArbmV3IERhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNsb2NrLiBUaW1lIGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGltZSBpbiByZWFsIHdvcmxkLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdXBkYXRlKCkge1xuICAgIGlmICggdGhpcy5pc1BsYXlpbmcgKSB7XG4gICAgICBjb25zdCBwcmV2VGltZSA9IHRoaXMudGltZTtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBkZWx0YURhdGUgPSAoIG5vdyAtIHRoaXMucnREYXRlICk7XG4gICAgICB0aGlzLnRpbWUgPSB0aGlzLnJ0VGltZSArIGRlbHRhRGF0ZSAvIDEwMDAuMDtcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy50aW1lIC0gcHJldlRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnRUaW1lID0gdGhpcy50aW1lO1xuICAgICAgdGhpcy5ydERhdGUgPSArbmV3IERhdGUoKTtcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gMC4wO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRpbWUgbWFudWFsbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdGltZSBUaW1lXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBzZXRUaW1lKCBfdGltZSApIHtcbiAgICB0aGlzLnRpbWUgPSBfdGltZTtcbiAgICB0aGlzLnJ0VGltZSA9IHRoaXMudGltZTtcbiAgICB0aGlzLnJ0RGF0ZSA9ICtuZXcgRGF0ZSgpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDbG9ja1JlYWx0aW1lOyIsIi8qKlxuICogKipVc3VhbGx5IHlvdSBkb24ndCBuZWVkIHRvIGtub3cgYWJvdXQgdGhpcyBjbGFzcy4qKlxuICogQ2xhc3MgdGhhdCBkZWFscyB3aXRoIHRpbWUuXG4gKiBJbiB0aGlzIGJhc2UgY2xhc3MsIHlvdSBuZWVkIHRvIHNldCB0aW1lIG1hbnVhbGx5IGZyb20gYEF1dG9tYXRvbi51cGRhdGUoKWAuXG4gKiBCZXN0IGZvciBzeW5jIHdpdGggZXh0ZXJuYWwgY2xvY2sgc3R1ZmYuXG4gKiBAcGFyYW0ge0F1dG9tYXRvbn0gX2F1dG9tYXRvbiBQYXJlbnQgYXV0b21hdG9uIG9iamVjdFxuICovXG5jb25zdCBDbG9jayA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoIF9hdXRvbWF0b24gKSB7XG4gICAgdGhpcy5hdXRvbWF0b24gPSBfYXV0b21hdG9uO1xuXG4gICAgdGhpcy50aW1lID0gMC4wO1xuICAgIHRoaXMuZGVsdGFUaW1lID0gMC4wO1xuICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNsb2NrLlxuICAgKiBAcGFyYW0ge251bWJlcn0gX3RpbWUgVGltZS4gWW91IG5lZWQgdG8gc2V0IG1hbnVhbGx5XG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICB1cGRhdGUoIF90aW1lICkge1xuICAgIGNvbnN0IHByZXZUaW1lID0gdGhpcy50aW1lO1xuICAgIHRoaXMudGltZSA9IF90aW1lO1xuICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy50aW1lIC0gcHJldlRpbWU7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIGNsb2NrLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgcGxheSgpIHtcbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgY2xvY2suXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGltZSBtYW51YWxseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IF90aW1lIFRpbWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHNldFRpbWUoIF90aW1lICkge1xuICAgIHRoaXMudGltZSA9IF90aW1lO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDbG9jazsiLCJjb25zdCBkZWZhdWx0RGF0YSA9IHtcbiAgdjogXCIyLjAuMVwiLFxuXG4gIGxlbmd0aDogMS4wLFxuICByZXNvbHV0aW9uOiAxMDAwLjAsXG4gIHBhcmFtczoge30sXG5cbiAgZ3VpU2V0dGluZ3M6IHtcbiAgICBzbmFwQWN0aXZlOiBmYWxzZSxcbiAgICBzbmFwVGltZTogMC4xLFxuICAgIHNuYXBWYWx1ZTogMC4xXG4gIH1cbn07XG5cbmNvbnN0IGNvbXBhdCA9ICggX2RhdGEgKSA9PiB7XG4gIGlmICggIV9kYXRhICkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKCB7fSwgZGVmYXVsdERhdGEgKTtcbiAgfVxuXG4gIGxldCBkYXRhO1xuICBpZiAoIHR5cGVvZiBfZGF0YSA9PT0gJ29iamVjdCcgKSB7XG4gICAgZGF0YSA9IF9kYXRhO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgX2RhdGEgPT09ICdzdHJpbmcnICkge1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZSggX2RhdGEgKTtcbiAgICB9IGNhdGNoICggZSApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoICdMb2FkZWQgZGF0YSBpcyBpbnZhbGlkJyApO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0RGF0YSApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCAnTG9hZGVkIGRhdGEgaXMgaW52YWxpZCcgKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbigge30sIGRlZmF1bHREYXRhICk7XG4gIH1cblxuICBsZXQgdiA9IHBhcnNlRmxvYXQoIGRhdGEudiApO1xuXG4gIGlmICggIXYgJiYgIWRhdGEucmV2ICkge1xuICAgIGlmICggZGF0YS5ndWkgKSB7IC8vIFwiU2hpZnRcIiB2ZXJzaW9uIG9mIGF1dG9tYXRvbiwgaGFzIGluY29tcGF0aWJsZSBndWkgcGFyYW1zXG4gICAgICBkZWxldGUgZGF0YS5ndWk7XG4gICAgICBkYXRhLmd1aSA9IE9iamVjdC5hc3NpZ24oIHt9LCBkZWZhdWx0RGF0YS5ndWkgKTtcbiAgICB9IGVsc2UgeyAvLyB3dGYgaXMgdGhpc1xuICAgICAgY29uc29sZS5lcnJvciggJ0xvYWRlZCBkYXRhIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhpcyByZXZpc2lvbicgKTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKCB7fSwgZGVmYXVsdERhdGEgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIGRhdGEucmV2ICkgeyAvLyBmdWNrXG4gICAgdiA9IDEuMDtcbiAgICBkZWxldGUgZGF0YS5yZXY7XG4gIH1cblxuICBpZiAoIHYgPCAyLjAgKSB7IC8vIHYxLCBtb2RlcyBhbmQgbW9kaWZpZXJzLCBDVVJTRURcbiAgICBmb3IgKCBjb25zdCBuYW1lIGluIGRhdGEucGFyYW1zICkge1xuICAgICAgY29uc3Qgb2xkUGFyYW0gPSBkYXRhLnBhcmFtc1sgbmFtZSBdO1xuICAgICAgY29uc3QgbmV3UGFyYW0gPSB7XG4gICAgICAgIG5vZGVzOiBvbGRQYXJhbS5tYXAoICggbm9kZSwgaSApID0+ICgge1xuICAgICAgICAgIHRpbWU6IG5vZGUudGltZSxcbiAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZSxcbiAgICAgICAgICBpbjogaSA9PT0gMCA/IHVuZGVmaW5lZCA6IHsgdGltZTogMC4wLCB2YWx1ZTogMC4wIH0sXG4gICAgICAgICAgb3V0OiAoIGkgPT09IG9sZFBhcmFtLmxlbmd0aCAtIDEgKSA/IHVuZGVmaW5lZCA6IHsgdGltZTogMC4wLCB2YWx1ZTogMC4wIH1cbiAgICAgICAgfSApICksXG4gICAgICAgIGZ4czogW11cbiAgICAgIH07XG5cbiAgICAgIGxldCBoZWFkID0gMDtcbiAgICAgIGZvciAoIGxldCBpID0gMTsgaSA8IG9sZFBhcmFtLmxlbmd0aDsgaSArKyApIHtcbiAgICAgICAgaGVhZCArKztcblxuICAgICAgICBpZiAoIG9sZFBhcmFtWyBpIF0ubW9kZSA9PT0gMCApIHsgLy8gaG9sZFxuICAgICAgICAgIG5ld1BhcmFtLm5vZGVzLnNwbGljZSggaGVhZCwgMCwge1xuICAgICAgICAgICAgdGltZTogb2xkUGFyYW1bIGkgXS50aW1lLFxuICAgICAgICAgICAgdmFsdWU6IG9sZFBhcmFtWyBpIC0gMSBdLnZhbHVlLFxuICAgICAgICAgICAgaW46IHsgdGltZTogMC4wLCB2YWx1ZTogMC4wIH0sXG4gICAgICAgICAgICBvdXQ6IHsgdGltZTogMC4wLCB2YWx1ZTogMC4wIH1cbiAgICAgICAgICB9ICk7XG4gICAgICAgICAgaGVhZCArKztcbiAgICAgICAgfSBlbHNlIGlmICggb2xkUGFyYW1bIGkgXS5tb2RlID09PSAxICkgeyAvLyBsaW5lYXJcbiAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH0gZWxzZSBpZiAoIG9sZFBhcmFtWyBpIF0ubW9kZSA9PT0gMiApIHsgLy8gY29zaW5lXG4gICAgICAgICAgY29uc3QgbCA9IG5ld1BhcmFtLm5vZGVzWyBoZWFkIF0udGltZSAtIG5ld1BhcmFtLm5vZGVzWyBoZWFkIC0gMSBdLnRpbWU7XG4gICAgICAgICAgbmV3UGFyYW0ubm9kZXNbIGhlYWQgLSAxIF0ub3V0ID0geyB0aW1lOiBsICogMC4zNywgdmFsdWU6IDAuMCB9O1xuICAgICAgICAgIG5ld1BhcmFtLm5vZGVzWyBoZWFkIF0uaW4gPSB7IHRpbWU6IC1sICogMC4zNywgdmFsdWU6IDAuMCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1BhcmFtLm5vZGVzLnNwbGljZSggaGVhZCwgMCwge1xuICAgICAgICAgICAgdGltZTogb2xkUGFyYW1bIGkgLSAxIF0udGltZSxcbiAgICAgICAgICAgIHZhbHVlOiBvbGRQYXJhbVsgaSBdLnZhbHVlLFxuICAgICAgICAgICAgaW46IHsgdGltZTogMC4wLCB2YWx1ZTogMC4wIH0sXG4gICAgICAgICAgICBvdXQ6IHsgdGltZTogMC4wLCB2YWx1ZTogMC4wIH1cbiAgICAgICAgICB9ICk7XG4gICAgICAgICAgaGVhZCArKztcblxuICAgICAgICAgIGlmICggb2xkUGFyYW1bIGkgXS5tb2RlID09PSAzICkgeyAvLyBleHBcbiAgICAgICAgICAgIG5ld1BhcmFtLmZ4cy5wdXNoKCB7XG4gICAgICAgICAgICAgIG5hbWU6ICdFeHBvbmVudGlhbCBTbW9vdGhpbmcnLFxuICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgICByb3c6IDAsXG4gICAgICAgICAgICAgIHRpbWU6IG9sZFBhcmFtWyBpIC0gMSBdLnRpbWUgLSAxLjAgLyBkYXRhLnJlc29sdXRpb24sIC8vIPCflKVcbiAgICAgICAgICAgICAgbGVuZ3RoOiBvbGRQYXJhbVsgaSBdLnRpbWUgLSBvbGRQYXJhbVsgaSAtIDEgXS50aW1lLFxuICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBmYWN0b3I6IG9sZFBhcmFtWyBpIF0ucGFyYW1zLmZhY3RvcixcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZTogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfSBlbHNlIGlmICggb2xkUGFyYW1bIGkgXS5tb2RlID09PSA0ICkgeyAvLyBzcHJpbmdcbiAgICAgICAgICAgIG5ld1BhcmFtLmZ4cy5wdXNoKCB7XG4gICAgICAgICAgICAgIG5hbWU6ICdDcml0aWNhbGx5IERhbXBlZCBTcHJpbmcnLFxuICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgICByb3c6IDAsXG4gICAgICAgICAgICAgIHRpbWU6IG9sZFBhcmFtWyBpIC0gMSBdLnRpbWUgLSAxLjAgLyBkYXRhLnJlc29sdXRpb24sIC8vIPCflKVcbiAgICAgICAgICAgICAgbGVuZ3RoOiBvbGRQYXJhbVsgaSBdLnRpbWUgLSBvbGRQYXJhbVsgaSAtIDEgXS50aW1lLFxuICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBmYWN0b3I6IG9sZFBhcmFtWyBpIF0ucGFyYW1zLnJhdGUsXG4gICAgICAgICAgICAgICAgcmF0aW86IG9sZFBhcmFtWyBpIF0ucGFyYW1zLmRhbXAsXG4gICAgICAgICAgICAgICAgcHJlc2VydmU6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIG9sZFBhcmFtWyBpIF0ubW9kZSA9PT0gNSApIHsgLy8gZ3Jhdml0eVxuICAgICAgICAgICAgbmV3UGFyYW0uZnhzLnB1c2goIHtcbiAgICAgICAgICAgICAgbmFtZTogJ0dyYXZpdHknLFxuICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgICByb3c6IDAsXG4gICAgICAgICAgICAgIHRpbWU6IG9sZFBhcmFtWyBpIC0gMSBdLnRpbWUgLSAxLjAgLyBkYXRhLnJlc29sdXRpb24sIC8vIPCflKVcbiAgICAgICAgICAgICAgbGVuZ3RoOiBvbGRQYXJhbVsgaSBdLnRpbWUgLSBvbGRQYXJhbVsgaSAtIDEgXS50aW1lLFxuICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBhOiBvbGRQYXJhbVsgaSBdLnBhcmFtcy5ncmF2aXR5LFxuICAgICAgICAgICAgICAgIGU6IG9sZFBhcmFtWyBpIF0ucGFyYW1zLmJvdW5jZSxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZTogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvbGRQYXJhbVsgaSBdLm1vZHNbIDEgXSApIHtcbiAgICAgICAgICBuZXdQYXJhbS5meHMucHVzaCgge1xuICAgICAgICAgICAgbmFtZTogJ1NpbmV3YXZlJyxcbiAgICAgICAgICAgIGJ5cGFzczogZmFsc2UsXG4gICAgICAgICAgICByb3c6IDEsXG4gICAgICAgICAgICB0aW1lOiBvbGRQYXJhbVsgaSAtIDEgXS50aW1lLFxuICAgICAgICAgICAgbGVuZ3RoOiBvbGRQYXJhbVsgaSBdLnRpbWUgLSBvbGRQYXJhbVsgaSAtIDEgXS50aW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIGZyZXE6IG9sZFBhcmFtWyBpIF0ubW9kc1sgMSBdLmZyZXEsXG4gICAgICAgICAgICAgIGFtcDogb2xkUGFyYW1bIGkgXS5tb2RzWyAxIF0uYW1wLFxuICAgICAgICAgICAgICBwaGFzZTogb2xkUGFyYW1bIGkgXS5tb2RzWyAxIF0ucGhhc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9sZFBhcmFtWyBpIF0ubW9kc1sgMiBdICkge1xuICAgICAgICAgIG5ld1BhcmFtLmZ4cy5wdXNoKCB7XG4gICAgICAgICAgICBuYW1lOiAnRnJhY3RhbCBOb2lzZScsXG4gICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxuICAgICAgICAgICAgcm93OiAyLFxuICAgICAgICAgICAgdGltZTogb2xkUGFyYW1bIGkgLSAxIF0udGltZSxcbiAgICAgICAgICAgIGxlbmd0aDogb2xkUGFyYW1bIGkgXS50aW1lIC0gb2xkUGFyYW1bIGkgLSAxIF0udGltZSxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICBhbXA6IG9sZFBhcmFtWyBpIF0ubW9kc1sgMiBdLmFtcCxcbiAgICAgICAgICAgICAgcmVjdXJzaW9uOiBvbGRQYXJhbVsgaSBdLm1vZHNbIDIgXS5yZWN1cnNpb24sXG4gICAgICAgICAgICAgIGZyZXE6IG9sZFBhcmFtWyBpIF0ubW9kc1sgMiBdLmZyZXEsXG4gICAgICAgICAgICAgIHJlc286IG9sZFBhcmFtWyBpIF0ubW9kc1sgMiBdLnJlc28sXG4gICAgICAgICAgICAgIHNlZWQ6IG9sZFBhcmFtWyBpIF0ubW9kc1sgMiBdLnNlZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9sZFBhcmFtWyBpIF0ubW9kc1sgMyBdICkge1xuICAgICAgICAgIG5ld1BhcmFtLmZ4cy5wdXNoKCB7XG4gICAgICAgICAgICBuYW1lOiAnTG8tRmknLFxuICAgICAgICAgICAgYnlwYXNzOiBmYWxzZSxcbiAgICAgICAgICAgIHJvdzogMyxcbiAgICAgICAgICAgIHRpbWU6IG9sZFBhcmFtWyBpIC0gMSBdLnRpbWUsXG4gICAgICAgICAgICBsZW5ndGg6IG9sZFBhcmFtWyBpIF0udGltZSAtIG9sZFBhcmFtWyBpIC0gMSBdLnRpbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgcmVzb2x1dGlvbjogb2xkUGFyYW1bIGkgXS5tb2RzWyAzIF0uZnJlcSxcbiAgICAgICAgICAgICAgcmVsYXRpdmU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRhdGEucGFyYW1zWyBuYW1lIF0gPSBuZXdQYXJhbTtcbiAgICB9XG5cbiAgICBkYXRhLmd1aVNldHRpbmdzID0ge1xuICAgICAgc25hcEFjdGl2ZTogZmFsc2UsXG4gICAgICBzbmFwVGltZTogMC4xLFxuICAgICAgc25hcFZhbHVlOiAwLjFcbiAgICB9O1xuICB9XG5cbiAgZGF0YS52ID0gXCIyLjAuMVwiO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBhdDsiLCIvLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2luZy9ibG9iL21hc3Rlci9zcmMvaW5kZXguanNcblxuY29uc3QgTkVXVE9OX0lURVIgPSA0O1xuY29uc3QgTkVXVE9OX0VQU0lMT04gPSAwLjAwMTtcbmNvbnN0IFNVQkRJVl9JVEVSID0gMTA7XG5jb25zdCBTVUJESVZfRVBTSUxPTiA9IDAuMDAwMDAxO1xuY29uc3QgVEFCTEVfU0laRSA9IDIxO1xuXG5sZXQgdGFiID0gW107XG5cbmNvbnN0IEEgPSAoIGExLCBhMiApID0+IDEuMCAtIDMuMCAqIGEyICsgMy4wICogYTE7XG5jb25zdCBCID0gKCBhMSwgYTIgKSA9PiAzLjAgKiBhMiAtIDYuMCAqIGExO1xuY29uc3QgQyA9ICggYTEgKSA9PiAzLjAgKiBhMTtcblxuY29uc3Qgc2F0dXJhdGUgPSAoIHggKSA9PiBNYXRoLm1pbiggTWF0aC5tYXgoIHgsIDAuMCApLCAxLjAgKTtcblxuY29uc3QgY2FsYyA9ICggdCwgYTEsIGEyICkgPT5cbiAgKCAoIEEoIGExLCBhMiApICogdCArIEIoIGExLCBhMiApICkgKiB0ICsgQyggYTEgKSApICogdDtcblxuY29uc3QgZGVsdGEgPSAoIHQsIGExLCBhMiApID0+XG4gIDMuMCAqIEEoIGExLCBhMiApICogdCAqIHQgKyAyLjAgKiBCKCBhMSwgYTIgKSAqIHQgKyBDKCBhMSApO1xuXG5jb25zdCBzdWJkaXYgPSAoIHgsIGEsIGIsIHgxLCB4MiApID0+IHtcbiAgbGV0IGN4ID0gMDtcbiAgbGV0IGN0ID0gMDtcblxuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBTVUJESVZfSVRFUjsgaSArKyApIHtcbiAgICBjdCA9IGEgKyAoIGIgLSBhICkgLyAyLjA7XG4gICAgY3ggPSBjYWxjKCBjdCwgeDEsIHgyICkgLSB4O1xuICAgICggMC4wIDwgY3ggKSA/ICggYiA9IGN0ICkgOiAoIGEgPSBjdCApO1xuICAgIGlmICggU1VCRElWX0VQU0lMT04gPCBNYXRoLmFicyggY3ggKSApIHsgYnJlYWs7IH1cbiAgfVxuXG4gIHJldHVybiBjdDtcbn07XG5cbmNvbnN0IG5ld3RvbiA9ICggeCwgZ3QsIHgxLCB4MiApID0+IHtcbiAgZm9yICggbGV0IGkgPSAwOyBpIDwgTkVXVE9OX0lURVI7IGkgKysgKSB7XG4gICAgY29uc3QgZCA9IGRlbHRhKCBndCwgeDEsIHgyICk7XG4gICAgaWYgKCBkID09PSAwLjAgKSB7IHJldHVybiBndDsgfVxuICAgIGNvbnN0IGN4ID0gY2FsYyggZ3QsIHgxLCB4MiApIC0geDtcbiAgICBndCA9IGd0IC0gY3ggLyBkO1xuICB9XG5cbiAgcmV0dXJuIGd0O1xufTtcblxuY29uc3QgcmF3Q3ViaWNCZXppZXIgPSAoIHgxLCB5MSwgeDIsIHkyLCB4ICkgPT4ge1xuICBpZiAoIGlzTmFOKCB4MSApIHx8IGlzTmFOKCB5MSApIHx8IGlzTmFOKCB4MiApIHx8IGlzTmFOKCB5MiApICkgeyByZXR1cm4geDsgfSAvLyBoZWhcbiAgaWYgKCB4MSA9PT0geTEgJiYgeDIgPT09IHkyICkgeyByZXR1cm4geDsgfSAvLyBsaW5lYXJcbiAgaWYgKCB4IDw9IDAuMCApIHsgcmV0dXJuIDAuMDsgfVxuICBpZiAoIDEuMCA8PSB4ICkgeyByZXR1cm4gMS4wOyB9XG5cbiAgeDEgPSBzYXR1cmF0ZSggeDEgKTtcbiAgeDIgPSBzYXR1cmF0ZSggeDIgKTtcblxuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBUQUJMRV9TSVpFOyBpICsrICkge1xuICAgIHRhYlsgaSBdID0gY2FsYyggaSAvICggVEFCTEVfU0laRSAtIDEuMCApLCB4MSwgeDIgKTtcbiAgfVxuXG4gIGxldCBzYW1wbGUgPSAxO1xuICBmb3IgKCBsZXQgaSA9IDE7IGkgPCBUQUJMRV9TSVpFOyBpICsrICkge1xuICAgIHNhbXBsZSA9IGkgLSAxO1xuICAgIGlmICggeCA8IHRhYlsgaSBdICkgeyBicmVhazsgfVxuICB9XG5cbiAgY29uc3QgZGlzdCA9ICggeCAtIHRhYlsgc2FtcGxlIF0gKSAvICggdGFiWyBzYW1wbGUgKyAxIF0gLSB0YWJbIHNhbXBsZSBdICk7XG4gIGxldCB0ID0gKCBzYW1wbGUgKyBkaXN0ICkgLyAoIFRBQkxFX1NJWkUgLSAxICk7XG4gIGNvbnN0IGQgPSBkZWx0YSggdCwgeDEsIHgyICk7XG4gIGlmICggTkVXVE9OX0VQU0lMT04gPD0gZCApIHtcbiAgICB0ID0gbmV3dG9uKCB4LCB0LCB4MSwgeDIgKTtcbiAgfSBlbHNlIGlmICggZCAhPT0gMC4wICkge1xuICAgIHQgPSBzdWJkaXYoIHgsICggc2FtcGxlICkgLyAoIFRBQkxFX1NJWkUgLSAxICksICggc2FtcGxlICsgMS4wICkgLyAoIFRBQkxFX1NJWkUgLSAxICksIHgxLCB4MiApO1xuICB9XG5cbiAgcmV0dXJuIGNhbGMoIHQsIHkxLCB5MiApO1xufTtcblxuY29uc3QgY3ViaWNCZXppZXIgPSAoIG5vZGUwLCBub2RlMSwgdGltZSApID0+IHtcbiAgY29uc3QgdEwgPSBub2RlMS50aW1lIC0gbm9kZTAudGltZTtcbiAgY29uc3QgdkwgPSBub2RlMS52YWx1ZSAtIG5vZGUwLnZhbHVlO1xuICBjb25zdCB4MSA9IG5vZGUwLm91dC50aW1lIC8gdEw7XG4gIGNvbnN0IHkxID0gbm9kZTAub3V0LnZhbHVlIC8gdkw7XG4gIGNvbnN0IHgyID0gKCBub2RlMS50aW1lICsgbm9kZTEuaW4udGltZSAtIG5vZGUwLnRpbWUgKSAvIHRMO1xuICBjb25zdCB5MiA9ICggbm9kZTEudmFsdWUgKyBub2RlMS5pbi52YWx1ZSAtIG5vZGUwLnZhbHVlICkgLyB2TDtcbiAgY29uc3QgeCA9ICggdGltZSAtIG5vZGUwLnRpbWUgKSAvIHRMO1xuICByZXR1cm4gbm9kZTAudmFsdWUgKyByYXdDdWJpY0JlemllciggeDEsIHkxLCB4MiwgeTIsIHggKSAqIHZMO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3ViaWNCZXppZXI7IiwiZXhwb3J0IGRlZmF1bHQgW1xuICByZXF1aXJlKCAnLi9meHMvYWRkJyApLmRlZmF1bHQsXG4gIHJlcXVpcmUoICcuL2Z4cy9jZHMnICkuZGVmYXVsdCxcbiAgcmVxdWlyZSggJy4vZnhzL2NsYW1wJyApLmRlZmF1bHQsXG4gIHJlcXVpcmUoICcuL2Z4cy9leHAnICkuZGVmYXVsdCxcbiAgcmVxdWlyZSggJy4vZnhzL2dyYXZpdHknICkuZGVmYXVsdCxcbiAgcmVxdWlyZSggJy4vZnhzL2xvZmknICkuZGVmYXVsdCxcbiAgcmVxdWlyZSggJy4vZnhzL25vaXNlJyApLmRlZmF1bHQsXG4gIHJlcXVpcmUoICcuL2Z4cy9wb3cnICkuZGVmYXVsdCxcbiAgcmVxdWlyZSggJy4vZnhzL3NpbmUnICkuZGVmYXVsdFxuXTsiLCJleHBvcnQgZGVmYXVsdCBbICdhZGQnLCB7XG4gIG5hbWU6ICdBZGQnLFxuICBkZXNjcmlwdGlvbjogJ1RoZSBzaW1wbGVzdCBmeCBldmVyLiBKdXN0IGFkZCBhIGNvbnN0YW50IHZhbHVlIHRvIHRoZSBjdXJ2ZS4nLFxuICBwYXJhbXM6IHtcbiAgICB2YWx1ZTogeyBuYW1lOiAnVmFsdWUnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxLjAgfVxuICB9LFxuICBmdW5jKCBjb250ZXh0ICkge1xuICAgIHJldHVybiBjb250ZXh0LnYgKyBjb250ZXh0LnBhcmFtcy52YWx1ZTtcbiAgfVxufSBdOyIsImV4cG9ydCBkZWZhdWx0IFsgJ2NkcycsIHtcbiAgbmFtZTogJ0NyaXRpY2FsbHkgRGFtcGVkIFNwcmluZycsXG4gIGRlc2NyaXB0aW9uOiAnQmFzaWNhbGx5IHRoZSBiZXN0IHNtb290aGluZyBtZXRob2QuIFNob3V0b3V0cyB0byBLZWlqaXJvIFRha2FoYXNoaScsXG4gIHBhcmFtczoge1xuICAgIGZhY3RvcjogeyBuYW1lOiAnRmFjdG9yJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMTAwLjAsIG1pbjogMC4wIH0sXG4gICAgcmF0aW86IHsgbmFtZTogJ0RhbXAgUmF0aW8nLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxLjAgfSxcbiAgICBwcmVzZXJ2ZTogeyBuYW1lOiAnUHJlc2VydmUgVmVsb2NpdHknLCB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH1cbiAgfSxcbiAgZnVuYyggY29udGV4dCApIHtcbiAgICBjb25zdCBkdCA9IGNvbnRleHQuZHQ7XG4gICAgY29uc3QgdiA9IGNvbnRleHQudjtcbiAgICBjb25zdCBrID0gY29udGV4dC5wYXJhbXMuZmFjdG9yO1xuXG4gICAgaWYgKCBjb250ZXh0LmluaXQgKSB7XG4gICAgICBjb250ZXh0LnBvcyA9IGNvbnRleHQudjtcbiAgICAgIGlmICggY29udGV4dC5wYXJhbXMucHJlc2VydmUgKSB7XG4gICAgICAgIGNvbnN0IGR2ID0gdiAtIGNvbnRleHQuZ2V0VmFsdWUoIGNvbnRleHQudCAtIGR0ICk7XG4gICAgICAgIGNvbnRleHQudmVsID0gZHYgLyBkdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQudmVsID0gMC4wO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQudmVsICs9ICggLWsgKiAoIGNvbnRleHQucG9zIC0gdiApIC0gMi4wICogY29udGV4dC52ZWwgKiBNYXRoLnNxcnQoIGsgKSAqIGNvbnRleHQucGFyYW1zLnJhdGlvICkgKiBkdDtcbiAgICBjb250ZXh0LnBvcyArPSBjb250ZXh0LnZlbCAqIGR0O1xuICAgIHJldHVybiBjb250ZXh0LnBvcztcbiAgfVxufSBdOyIsImNvbnN0IGNsYW1wID0gKCB4LCBhLCBiICkgPT4gTWF0aC5taW4oIE1hdGgubWF4KCB4LCBhICksIGIgKTtcblxuY29uc3Qgc21pbiA9ICggYSwgYiwgayApID0+IHtcbiAgY29uc3QgaCA9IE1hdGgubWF4KCBrIC0gTWF0aC5hYnMoIGEgLSBiICksIDAuMCApO1xuICByZXR1cm4gTWF0aC5taW4oIGEsIGIgKSAtIGggKiBoICogaCAvICggNi4wICogayAqIGsgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFsgJ2NsYW1wJywge1xuICBuYW1lOiAnQ2xhbXAnLFxuICBkZXNjcmlwdGlvbjogJ0NvbnN0cmFpbiB0aGUgY3VydmUgYmV0d2VlbiB0d28gdmFsdWVzLCBmZWF0dXJpbmcgc21vb3RoIG1pbmltdW0uJyxcbiAgcGFyYW1zOiB7XG4gICAgbWluOiB7IG5hbWU6ICdNaW4nLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjAgfSxcbiAgICBtYXg6IHsgbmFtZTogJ01heCcsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDEuMCB9LFxuICAgIHNtb290aDogeyBuYW1lOiAnU21vb3RoJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC4wLCBtaW46IDAuMCB9XG4gIH0sXG4gIGZ1bmMoIGNvbnRleHQgKSB7XG4gICAgaWYgKCBjb250ZXh0LnBhcmFtcy5zbW9vdGggPT09IDAuMCApIHtcbiAgICAgIHJldHVybiBjbGFtcCggY29udGV4dC52LCBjb250ZXh0LnBhcmFtcy5taW4sIGNvbnRleHQucGFyYW1zLm1heCApO1xuICAgIH1cblxuICAgIGxldCB2ID0gLXNtaW4oIC1jb250ZXh0LnBhcmFtcy5taW4sIC1jb250ZXh0LnYsIGNvbnRleHQucGFyYW1zLnNtb290aCApO1xuICAgIHJldHVybiBzbWluKCBjb250ZXh0LnBhcmFtcy5tYXgsIHYsIGNvbnRleHQucGFyYW1zLnNtb290aCApO1xuICB9XG59IF07IiwiZXhwb3J0IGRlZmF1bHQgWyAnZXhwJywge1xuICBuYW1lOiAnRXhwb25lbnRpYWwgU21vb3RoaW5nJyxcbiAgZGVzY3JpcHRpb246ICdTbW9vdGggdGhlIGN1cnZlLiBTaW1wbGUgYnV0IGdvb2QuJyxcbiAgcGFyYW1zOiB7XG4gICAgZmFjdG9yOiB7IG5hbWU6ICdGYWN0b3InLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxMC4wLCBtaW46IDAuMCB9XG4gIH0sXG4gIGZ1bmMoIGNvbnRleHQgKSB7XG4gICAgY29uc3QgdiA9IGNvbnRleHQudjtcblxuICAgIGlmICggY29udGV4dC5pbml0ICkge1xuICAgICAgY29udGV4dC5wb3MgPSB2O1xuICAgIH1cblxuICAgIGNvbnN0IGsgPSBNYXRoLmV4cCggLWNvbnRleHQuZHQgKiBjb250ZXh0LnBhcmFtcy5mYWN0b3IgKTtcbiAgICBjb250ZXh0LnBvcyA9IGNvbnRleHQucG9zICogayArIHYgKiAoIDEuMCAtIGsgKTtcbiAgICByZXR1cm4gY29udGV4dC5wb3M7XG4gIH1cbn0gXTsiLCJleHBvcnQgZGVmYXVsdCBbICdncmF2aXR5Jywge1xuICBuYW1lOiAnR3Jhdml0eScsXG4gIGRlc2NyaXB0aW9uOiAnQWNjZWxlcmF0ZSBhbmQgYm91bmNlIHRoZSBjdXJ2ZS4nLFxuICBwYXJhbXM6IHtcbiAgICBhOiB7IG5hbWU6ICdBY2NlbGVyYXRpb24nLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiA5LjggfSxcbiAgICBlOiB7IG5hbWU6ICdSZXN0aXR1dGlvbicsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuNSwgbWluOiAwLjAgfSxcbiAgICBwcmVzZXJ2ZTogeyBuYW1lOiAnUHJlc2VydmUgVmVsb2NpdHknLCB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH1cbiAgfSxcbiAgZnVuYyggY29udGV4dCApIHtcbiAgICBjb25zdCBkdCA9IGNvbnRleHQuZHQ7XG4gICAgY29uc3QgdiA9IGNvbnRleHQudjtcblxuICAgIGlmICggY29udGV4dC5pbml0ICkge1xuICAgICAgY29udGV4dC5wb3MgPSB2O1xuICAgICAgaWYgKCBjb250ZXh0LnBhcmFtcy5wcmVzZXJ2ZSApIHtcbiAgICAgICAgY29uc3QgZHYgPSB2IC0gY29udGV4dC5nZXRWYWx1ZSggY29udGV4dC50IC0gZHQgKTtcbiAgICAgICAgY29udGV4dC52ZWwgPSBkdiAvIGR0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC52ZWwgPSAwLjA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYSA9IE1hdGguc2lnbiggdiAtIGNvbnRleHQucG9zICkgKiBjb250ZXh0LnBhcmFtcy5hO1xuICAgIGNvbnRleHQudmVsICs9IGEgKiBkdDtcbiAgICBjb250ZXh0LnBvcyArPSBjb250ZXh0LnZlbCAqIGR0O1xuXG4gICAgaWYgKCBNYXRoLnNpZ24oIGEgKSAhPT0gTWF0aC5zaWduKCB2IC0gY29udGV4dC5wb3MgKSApIHtcbiAgICAgIGNvbnRleHQudmVsICo9IC1jb250ZXh0LnBhcmFtcy5lO1xuICAgICAgY29udGV4dC5wb3MgPSB2ICsgY29udGV4dC5wYXJhbXMuZSAqICggdiAtIGNvbnRleHQucG9zICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQucG9zO1xuICB9XG59IF07IiwiZXhwb3J0IGRlZmF1bHQgWyAnbG9maScsIHtcbiAgbmFtZTogJ0xvLUZpJyxcbiAgZGVzY3JpcHRpb246ICdNYWtlIGN1cnZlIG1vcmUgY3J1bmNoeS4nLFxuICBwYXJhbXM6IHtcbiAgICByYXRlOiB7IG5hbWU6ICdGcmFtZSBSYXRlJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMTAuMCwgbWluOiAwLjAsIG1heDogMTAwMC4wIH0sXG4gICAgcmVsYXRpdmU6IHsgbmFtZTogJ1JlbGF0aXZlJywgdHlwZTogJ2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHJlc286IHsgbmFtZTogJ1Jlc28gUGVyIFVuaXQnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjEsIG1pbjogMC4wLCBtYXg6IDEwMDAuMCB9LFxuICAgIHJvdW5kOiB7IG5hbWU6ICdSb3VuZCcsIHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UgfVxuICB9LFxuICBmdW5jKCBjb250ZXh0ICkge1xuICAgIGxldCB0O1xuICAgIGlmICggY29udGV4dC5wYXJhbXMucmF0ZSA9PT0gMC4wICkge1xuICAgICAgdCA9IGNvbnRleHQudDtcbiAgICB9IGVsc2UgaWYgKCBjb250ZXh0LnBhcmFtcy5yZWxhdGl2ZSApIHtcbiAgICAgIHQgPSBjb250ZXh0LnQwICsgTWF0aC5mbG9vciggKCBjb250ZXh0LnQgLSBjb250ZXh0LnQwICkgKiBjb250ZXh0LnBhcmFtcy5yYXRlICkgLyBjb250ZXh0LnBhcmFtcy5yYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ID0gTWF0aC5mbG9vciggKCBjb250ZXh0LnQgKSAqIGNvbnRleHQucGFyYW1zLnJhdGUgKSAvIGNvbnRleHQucGFyYW1zLnJhdGU7XG4gICAgfVxuXG4gICAgbGV0IHYgPSBjb250ZXh0LmdldFZhbHVlKCB0ICk7XG4gICAgaWYgKCBjb250ZXh0LnBhcmFtcy5yZXNvICE9PSAwLjAgKSB7XG4gICAgICB2ID0gTWF0aC5mbG9vciggdiAqIGNvbnRleHQucGFyYW1zLnJlc28gKyAoIGNvbnRleHQucGFyYW1zLnJvdW5kID8gMC41IDogMC4wICkgKSAvIGNvbnRleHQucGFyYW1zLnJlc287XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG59IF07IiwibGV0IFhvcnNoaWZ0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciggX3NlZWQgKSB7XG4gICAgdGhpcy5zZXQoIF9zZWVkICk7XG4gIH1cblxuICBnZW4oIF9zZWVkICkge1xuICAgIGlmICggX3NlZWQgKSB7IHRoaXMuc2V0KCBfc2VlZCApOyB9XG4gICAgdGhpcy5zZWVkID0gdGhpcy5zZWVkIF4gKCB0aGlzLnNlZWQgPDwgMTMgKTtcbiAgICB0aGlzLnNlZWQgPSB0aGlzLnNlZWQgXiAoIHRoaXMuc2VlZCA+Pj4gMTcgKTtcbiAgICB0aGlzLnNlZWQgPSB0aGlzLnNlZWQgXiAoIHRoaXMuc2VlZCA8PCA1ICk7XG4gICAgcmV0dXJuIHRoaXMuc2VlZCAvIE1hdGgucG93KCAyLCAzMiApICsgMC41O1xuICB9XG5cbiAgc2V0KCBfc2VlZCApIHtcbiAgICB0aGlzLnNlZWQgPSBfc2VlZCB8fCB0aGlzLnNlZWQgfHwgMTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYb3JzaGlmdDtcbiIsImltcG9ydCBYb3JzaGlmdCBmcm9tICcuL21vZHVsZXMveG9yc2hpZnQnO1xuXG5jb25zdCB4b3JzaGlmdCA9IG5ldyBYb3JzaGlmdCgpO1xuXG5jb25zdCBzbW9vdGhzdGVwID0gKCBfYSwgX2IsIF9rICkgPT4ge1xuICBjb25zdCBzbW9vdGggPSBfayAqIF9rICogKCAzLjAgLSAyLjAgKiBfayApO1xuICByZXR1cm4gX2EgKyAoIF9iIC0gX2EgKSAqIHNtb290aDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFsgJ25vaXNlJywge1xuICBuYW1lOiAnRnJhY3RhbCBOb2lzZScsXG4gIGRlc2NyaXB0aW9uOiAnd2lnZ2xlKCknLFxuICBwYXJhbXM6IHtcbiAgICByZWN1cnNpb246IHsgbmFtZTogJ1JlY3Vyc2lvbicsIHR5cGU6ICdpbnQnLCBkZWZhdWx0OiA0LCBtaW46IDEsIG1heDogOTkgfSxcbiAgICBmcmVxOiB7IG5hbWU6ICdGcmVxdWVuY3knLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxLjAsIG1pbjogMC4wIH0sXG4gICAgcmVzbzogeyBuYW1lOiAnUmVzb2x1dGlvbicsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDguMCwgbWluOiAxLjAgfSxcbiAgICBzZWVkOiB7IG5hbWU6ICdTZWVkJywgdHlwZTogJ2ludCcsIGRlZmF1bHQ6IDEsIG1pbjogMCB9LFxuICAgIGFtcDogeyBuYW1lOiAnQW1wJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC4yIH1cbiAgfSxcbiAgZnVuYyggY29udGV4dCApIHtcbiAgICBpZiAoIGNvbnRleHQuaW5pdCApIHtcbiAgICAgIHhvcnNoaWZ0LmdlbiggY29udGV4dC5wYXJhbXMuc2VlZCApO1xuXG4gICAgICBjb250ZXh0LnRhYmxlID0gbmV3IEZsb2F0MzJBcnJheSggTWF0aC5mbG9vciggY29udGV4dC5wYXJhbXMucmVzbyApICsgMiApO1xuICAgICAgZm9yICggbGV0IGkgPSAxOyBpIDwgY29udGV4dC5wYXJhbXMucmVzbzsgaSArKyApIHtcbiAgICAgICAgY29udGV4dC50YWJsZVsgaSBdID0geG9yc2hpZnQuZ2VuKCkgKiAyLjAgLSAxLjA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHYgPSBjb250ZXh0LnY7XG4gICAgY29uc3QgcCA9IGNvbnRleHQucHJvZ3Jlc3M7XG5cbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb250ZXh0LnBhcmFtcy5yZWN1cnNpb247IGkgKysgKSB7XG4gICAgICBjb25zdCBpbmRleCA9ICggcCAqIGNvbnRleHQucGFyYW1zLmZyZXEgKiBjb250ZXh0LnBhcmFtcy5yZXNvICogTWF0aC5wb3coIDIuMCwgaSApICkgJSBjb250ZXh0LnBhcmFtcy5yZXNvO1xuICAgICAgY29uc3QgaW5kZXhpID0gTWF0aC5mbG9vciggaW5kZXggKTtcbiAgICAgIGNvbnN0IGluZGV4ZiA9IGluZGV4IC0gaW5kZXhpO1xuICAgICAgY29uc3QgZmFjdG9yID0gTWF0aC5wb3coIDAuNSwgaSArIDEuMCApO1xuXG4gICAgICB2ICs9IGNvbnRleHQucGFyYW1zLmFtcCAqIGZhY3RvciAqIHNtb290aHN0ZXAoXG4gICAgICAgIGNvbnRleHQudGFibGVbIGluZGV4aSBdLFxuICAgICAgICBjb250ZXh0LnRhYmxlWyBpbmRleGkgKyAxIF0sXG4gICAgICAgIGluZGV4ZlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbn0gXTsiLCJleHBvcnQgZGVmYXVsdCBbICdwb3cnLCB7XG4gIG5hbWU6ICdQb3dlcicsXG4gIGRlc2NyaXB0aW9uOiAnWW91IGdvdCBib29zdCBwb3dlciEnLFxuICBwYXJhbXM6IHtcbiAgICBwb3c6IHsgbmFtZTogJ1Bvd2VyJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMi4wIH0sXG4gICAgYmlhczogeyBuYW1lOiAnQmlhcycsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuMCB9LFxuICAgIHBvc2l0aXZlOiB7IG5hbWU6ICdGb3JjZSBQb3NpdGl2ZScsIHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UgfVxuICB9LFxuICBmdW5jKCBjb250ZXh0ICkge1xuICAgIGNvbnN0IHYgPSBjb250ZXh0LnYgLSBjb250ZXh0LnBhcmFtcy5iaWFzO1xuICAgIGNvbnN0IHNpZ24gPSBjb250ZXh0LnBhcmFtcy5wb3NpdGl2ZSA/IDEuMCA6IE1hdGguc2lnbiggdiApO1xuICAgIHJldHVybiBNYXRoLnBvdyhcbiAgICAgIE1hdGguYWJzKCB2ICksXG4gICAgICBjb250ZXh0LnBhcmFtcy5wb3dcbiAgICApICogc2lnbiArIGNvbnRleHQucGFyYW1zLmJpYXM7XG4gIH1cbn0gXTsiLCJjb25zdCBUQVUgPSBNYXRoLlBJICogMi4wO1xuXG5leHBvcnQgZGVmYXVsdCBbICdzaW5lJywge1xuICBuYW1lOiAnU2luZXdhdmUnLFxuICBkZXNjcmlwdGlvbjogJ092ZXJsYXkgYSBzaW5ld2F2ZSB0byB0aGUgY3VydmUuJyxcbiAgcGFyYW1zOiB7XG4gICAgYW1wOiB7IG5hbWU6ICdBbXAnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjEgfSxcbiAgICBmcmVxOiB7IG5hbWU6ICdGcmVxdWVuY3knLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiA1LjAgfSxcbiAgICBwaGFzZTogeyBuYW1lOiAnUGhhc2UnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjAsIG1pbjogMC4wLCBtYXg6IDEuMCB9XG4gIH0sXG4gIGZ1bmMoIGNvbnRleHQgKSB7XG4gICAgY29uc3QgdiA9IGNvbnRleHQudjtcbiAgICBjb25zdCBwID0gY29udGV4dC5wcm9ncmVzcyAqIGNvbnRleHQucGFyYW1zLmZyZXEgKyBjb250ZXh0LnBhcmFtcy5waGFzZTtcbiAgICByZXR1cm4gdiArIGNvbnRleHQucGFyYW1zLmFtcCAqIE1hdGguc2luKCBwICogVEFVICk7XG4gIH1cbn0gXTsiLCJleHBvcnQgZGVmYXVsdCAoKSA9PiB7XG4gIGxldCByZXQgPSAnJztcbiAgZm9yICggbGV0IGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG4gICAgcmV0ICs9IE1hdGguZmxvb3IoIDE2LjAgKiBNYXRoLnJhbmRvbSgpICkudG9TdHJpbmcoIDE2ICk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07IiwiY29uc3QgaGFzT3ZlcndyYXAgPSAoIHQxLCBsMSwgdDIsIGwyICkgPT4ge1xuICBpZiAoIGwyIDwgbDEgKSB7IHJldHVybiBoYXNPdmVyd3JhcCggdDIsIGwyLCB0MSwgbDEgKTsgfVxuICByZXR1cm4gKFxuICAgIHQyIDwgdDEgJiYgdDEgPCB0MiArIGwyIHx8XG4gICAgdDIgPCB0MSArIGwxICYmIHQxICsgbDEgPCB0MiArIGwyXG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBoYXNPdmVyd3JhcDsiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCB2ZXJzaW9uPScxLjAnIGVuY29kaW5nPSdVVEYtOCcgc3RhbmRhbG9uZT0nbm8nJTNGJTNFICUzQyFET0NUWVBFIHN2ZyBQVUJMSUMgJy0vL1czQy8vRFREIFNWRyAxLjEvL0VOJyAnaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkJyUzRSAlM0Nzdmcgd2lkdGg9JzEwMCUyNScgaGVpZ2h0PScxMDAlMjUnIHZpZXdCb3g9JzAgMCAxMjggMTI4JyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHhtbDpzcGFjZT0ncHJlc2VydmUnIHhtbG5zOnNlcmlmPSdodHRwOi8vd3d3LnNlcmlmLmNvbS8nIHN0eWxlPSdmaWxsLXJ1bGU6ZXZlbm9kZCUzQmNsaXAtcnVsZTpldmVub2RkJTNCc3Ryb2tlLWxpbmVqb2luOnJvdW5kJTNCc3Ryb2tlLW1pdGVybGltaXQ6MS40MTQyMSUzQiclM0UgICAgICUzQ3BhdGggZD0nTTY0JTJDNTUuNTM3TDEwNS4wMjMlMkMxNC41MTNMMTEzLjQ4NyUyQzIyLjk3N0w3Mi40NjMlMkM2NEwxMTMuNDg3JTJDMTA1LjAyM0wxMDUuMDIzJTJDMTEzLjQ4N0w2NCUyQzcyLjQ2M0wyMi45NzclMkMxMTMuNDg3TDE0LjUxMyUyQzEwNS4wMjNMNTUuNTM3JTJDNjRMMTQuNTEzJTJDMjIuOTc3TDIyLjk3NyUyQzE0LjUxM0w2NCUyQzU1LjUzN1onIHN0eWxlPSdmaWxsOnJnYigyMDElMkMyMjYlMkMyNTUpJTNCJy8lM0UgJTNDL3N2ZyUzRVwiIiwiZXhwb3J0IGRlZmF1bHQgKCBkYXRhICkgPT4gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGRhdGEgKSApOyIsImltcG9ydCBhc3MgZnJvbSAnLi9hc3MnO1xuaW1wb3J0IGNvbXBhdCBmcm9tICcuL2NvbXBhdCc7XG5pbXBvcnQganNvbkNvcHkgZnJvbSAnLi9qc29uLWNvcHknO1xuXG5pbXBvcnQgUGFyYW0gZnJvbSAnLi9wYXJhbS1ndWknO1xuXG5pbXBvcnQgQXV0b21hdG9uIGZyb20gJy4vbWFpbic7XG5pbXBvcnQgZnhEZWZpbml0aW9ucyBmcm9tICcuL2Z4LWRlZmluaXRpb25zJztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IEdVSSBmcm9tICcuL3Z1ZS9tYWluLnZ1ZSc7XG5cbi8qKlxuICogSVQnUyBBVVRPTUFUT04hXG4gKiBJdCdzIGBhdXRvbWF0b24uanNgIGFuZCBgYXV0b21hdG9uLm1pbi5qc2AgdmVyc2lvbi5cbiAqIFNpbmNlIEdVSSBzdHVmZiBpcyBwcmV0dHkgYmlnIGZvciBpbnRybyBoZWhcbiAqIEBleHRlbmRzIEF1dG9tYXRvblxuICogQHBhcmFtIHtPYmplY3R9IFtfcHJvcHNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtfcHJvcHMubG9vcF0gV2hldGhlciBsZXQgdGhlIHRpbWUgbG9vcCBvciBub3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbX3Byb3BzLmZwc10gSWYgdGhpcyBpcyBzZXQsIHRoZSBjbG9jayB3aWxsIGJlY29tZSBmcmFtZSBtb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtfcHJvcHMucmVhbHRpbWVdIElmIHRoaXMgaXMgdHJ1ZSwgdGhlIGNsb2NrIHdpbGwgYmVjb21lIHJlYWx0aW1lIG1vZGVcbiAqIEBwYXJhbSB7RE9NfSBbX3Byb3BzLmd1aV0gRE9NIGVsZW1lbnQgd2hlcmUgeW91IHdhbnQgdG8gYXR0YWNoIHRoZSBBdXRvbWF0b24gR1VJXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtfcHJvcHMuZGF0YV0gRGF0YSBvZiB0aGUgYXV0b21hdG9uLiBEb24ndCB3b3JyeSwgSSBjYW4gZ2VuZXJhdGUgYW4gaW5pdGlhbCBkYXRhIGZvciB5b3UhXG4gKi9cbmNvbnN0IEF1dG9tYXRvbldpdGhHVUkgPSBjbGFzcyBleHRlbmRzIEF1dG9tYXRvbiB7XG4gIGNvbnN0cnVjdG9yKCBfcHJvcHMgKSB7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgX3Byb3BzICk7XG5cbiAgICBhc3MoICFfcHJvcHMub25zZWVrLCAnVGhlIGhhbmRsZXIgXCJvbnNlZWtcIiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2UgQXV0b21hdG9uLm9uKCBcInNlZWtcIiwgLi4uICkgaW5zdGVhZC4nICk7XG4gICAgYXNzKCAhX3Byb3BzLm9ucGxheSwgJ1RoZSBoYW5kbGVyIFwib25wbGF5XCIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNlIEF1dG9tYXRvbi5vbiggXCJwbGF5XCIsIC4uLiApIGluc3RlYWQuJyApO1xuICAgIGFzcyggIV9wcm9wcy5vbnBhdXNlLCAnVGhlIGhhbmRsZXIgXCJvbnBhdXNlXCIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNlIEF1dG9tYXRvbi5vbiggXCJwYXVzZVwiLCAuLi4gKSBpbnN0ZWFkLicgKTtcblxuICAgIHN1cGVyKCBwcm9wcyApO1xuXG4gICAgLyoqXG4gICAgICogSGlzdG9yeSBzdGFjay5cbiAgICAgKiBXaWxsIGJlIG1hbmFnZWQgZnJvbSB7QGxpbmsgQXV0b21hdG9uV2l0aEdVSSNwdXNoSGlzdG9yeXxwdXNoSGlzdG9yeSgpfSwgbmF2aWdhdGVkIGZyb20ge0BsaW5rIEF1dG9tYXRvbldpdGhHVUkjdW5kb3x1bmRvKCl9IGFuZCB7QGxpbmsgQXV0b21hdG9uV2l0aEdVSSNyZWRvfHJlZG8oKX0uXG4gICAgICogQHR5cGUge09iamVjdFtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9faGlzdG9yeSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBwb3NpdGlvbiBvZiBoaXN0b3J5IHN0YWNrLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19oaXN0b3J5SW5kZXggPSAwO1xuXG4gICAgZnhEZWZpbml0aW9ucy5tYXAoICggZnhEZWYgKSA9PiB7XG4gICAgICB0aGlzLmFkZEZ4RGVmaW5pdGlvbiggLi4uZnhEZWYgKTtcbiAgICB9ICk7XG5cbiAgICBpZiAoIF9wcm9wcy5ndWkgKSB7IHRoaXMuX19wcmVwYXJlR1VJKCBfcHJvcHMuZ3VpICk7IH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnYmVmb3JldW5sb2FkJywgKCBldmVudCApID0+IHtcbiAgICAgIGlmICggdGhpcy5fX2hpc3RvcnlJbmRleCAhPT0gMCApIHtcbiAgICAgICAgdmFyIGNvbmZpcm1hdGlvbk1lc3NhZ2UgPSAnQXV0b21hdG9uOiBEaWQgeW91IHNhdmVkIHlvdXIgcHJvZ3Jlc3M/JztcblxuICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGNvbmZpcm1hdGlvbk1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBjb25maXJtYXRpb25NZXNzYWdlO1xuICAgICAgfVxuICAgIH0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIEdVSS5cbiAgICogQHBhcmFtIHtET019IF90YXJnZXQgRE9NIGVsZW1lbnQgd2hlcmUgeW91IHdhbnQgdG8gYXR0YWNoIHRoZSBBdXRvbWF0b24gR1VJXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9fcHJlcGFyZUdVSSggX3RhcmdldCApIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG4gICAgX3RhcmdldC5hcHBlbmRDaGlsZCggZWwgKTtcblxuICAgIC8qKlxuICAgICAqIFZ1ZSBpbnN0YW5jZSB0aGF0IG1hbmFnZXMgYXV0b21hdG9uIGd1aS5cbiAgICAgKiBAdHlwZSB7VnVlfVxuICAgICAqL1xuICAgIHRoaXMuX192dWUgPSBuZXcgVnVlKCB7XG4gICAgICBlbDogZWwsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGF1dG9tYXRvbjogdGhpc1xuICAgICAgfSxcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oIGNyZWF0ZUVsZW1lbnQgKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgICAgIEdVSSxcbiAgICAgICAgICB7IHByb3BzOiB7IGF1dG9tYXRvbjogdGhpcy5hdXRvbWF0b24gfSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGRlZmF1bHQgZnggcGFyYW1zIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgZnhcbiAgICogQHJldHVybnMge09iamVjdH0gRGVmYXVsdCBmeCBwYXJhbXMgb2JqZWN0XG4gICAqL1xuICBnZW5lcmF0ZURlZmF1bHRGeFBhcmFtcyggX2lkICkge1xuICAgIGNvbnN0IGZ4RGVmID0gdGhpcy5fX3BhcmFtRnhEZWZzWyBfaWQgXTtcbiAgICBpZiAoICFmeERlZiApIHsgdGhyb3cgbmV3IEVycm9yKCBgRnggZGVmaW5pdGlvbiBjYWxsZWQgJHtfaWR9IGlzIG5vdCBkZWZpbmVkYCApOyB9XG5cbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBmb3IgKCBsZXQga2V5IGluIGZ4RGVmLnBhcmFtcyApIHtcbiAgICAgIHJldFsga2V5IF0gPSBmeERlZi5wYXJhbXNbIGtleSBdLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgcGxheSAvIHBhdXNlLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdG9nZ2xlUGxheSgpIHtcbiAgICBpZiAoIHRoaXMuaXNQbGF5aW5nICkgeyB0aGlzLnBhdXNlKCk7IH1cbiAgICBlbHNlIHsgdGhpcy5wbGF5KCk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXQgc29tZSBvcGVyYXRpb24gaW50byB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICogU2luY2UgaXQgc2hvdWxkIGFjY2Vzc2libGUgZnJvbSBHVUkgdGhpcyBmdW5jdGlvbiBpcyBwdWJsaWMsIGJhc2ljYWxseSBgLS0gRE9OJ1QgVE9VQ0ggSVQgS0lERE8gLS1gXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZGVzYyBEZXNjcmlwdGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IF9kbyBPcGVyYXRpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gX3VuZG8gT3BlcmF0aW9uIHRoYXQgdW5kb2VzIHRoZSBgX2RvYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtfZXhlY3V0ZT1mYWxzZV0gX2RvIHdpbGwgYmUgZXhlY3V0ZWQgaW5zdGFudGx5IGlmIHRydWVcbiAgICogQHJldHVybnMge2FueX0gYW55IGlmIGBfZXhlY3V0ZWAgaXMgdHJ1ZSwgdm9pZCBvdGhlcndpc2VcbiAgICovXG4gIHB1c2hIaXN0b3J5KCBfZGVzYywgX2RvLCBfdW5kbywgX2V4ZWN1dGUgKSB7XG4gICAgdGhpcy5fX2hpc3Rvcnkuc3BsaWNlKCB0aGlzLl9faGlzdG9yeUluZGV4ICk7XG4gICAgdGhpcy5fX2hpc3RvcnkucHVzaCggeyBkZXNjOiBfZGVzYywgZG86IF9kbywgdW5kbzogX3VuZG8gfSApO1xuICAgIHRoaXMuX19oaXN0b3J5SW5kZXggKys7XG5cbiAgICBpZiAoIF9leGVjdXRlIHx8IGZhbHNlICkge1xuICAgICAgcmV0dXJuIF9kbygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbmRvIHRoZSBvcGVyYXRpb24gYmFzZWQgb24gaGlzdG9yeSBzdGFjay5cbiAgICogQ2FuIGJlIHBlcmZvcm1lZCB2aWEgR1VJLlxuICAgKiBAcmV0dXJucyB7YW55fSBSZXN1bHQgb2YgX3VuZG9cbiAgICovXG4gIHVuZG8oKSB7XG4gICAgaWYgKCB0aGlzLl9faGlzdG9yeUluZGV4IDw9IDAgKSB7IHJldHVybjsgfVxuICAgIHRoaXMuX19oaXN0b3J5SW5kZXggLS07XG4gICAgcmV0dXJuIHRoaXMuX19oaXN0b3J5WyB0aGlzLl9faGlzdG9yeUluZGV4IF0udW5kbygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZG8gdGhlIG9wZXJhdGlvbiBiYXNlZCBvbiBoaXN0b3J5IHN0YWNrLlxuICAgKiBDYW4gYmUgcGVyZm9ybWVkIHZpYSBHVUkuXG4gICAqIEByZXR1cm5zIHthbnl9IFJlc3VsdCBvZiBfZG9cbiAgICovXG4gIHJlZG8oKSB7XG4gICAgaWYgKCB0aGlzLl9faGlzdG9yeS5sZW5ndGggPD0gdGhpcy5fX2hpc3RvcnlJbmRleCApIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5fX2hpc3RvcnlJbmRleCArKztcbiAgICByZXR1cm4gdGhpcy5fX2hpc3RvcnlbIHRoaXMuX19oaXN0b3J5SW5kZXggLSAxIF0uZG8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gZGVzY3JpcHRpb24gb2YgbGF0ZXN0IG9wZXJhdGlvbi5cbiAgICogSWYgdGhlcmUgYXJlIG5vIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGN1cnJlbnQgc3RhdGUsIGl0IHdpbGwgcmV0dXJuIGVtcHR5IHN0cmluZyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBEZXNjcmlwdGlvbiBvZiBvcGVyYXRpb25cbiAgICovXG4gIGdldFVuZG9EZXNjKCkge1xuICAgIHJldHVybiB0aGlzLl9faGlzdG9yeVsgdGhpcy5fX2hpc3RvcnlJbmRleCAtIDEgXSA/IHRoaXMuX19oaXN0b3J5WyB0aGlzLl9faGlzdG9yeUluZGV4IC0gMSBdLmRlc2MgOiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gZGVzY3JpcHRpb24gb2YgcmVjZW50bHkgdW5kby1lZCBvcGVyYXRpb24uXG4gICAqIElmIHRoZXJlIGFyZSBubyBvcGVyYXRpb24gYWZ0ZXIgdGhlIGN1cnJlbnQgc3RhdGUsIGl0IHdpbGwgcmV0dXJuIGVtcHR5IHN0cmluZyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBEZXNjcmlwdGlvbiBvZiBvcGVyYXRpb25cbiAgICovXG4gIGdldFJlZG9EZXNjKCkge1xuICAgIHJldHVybiB0aGlzLl9faGlzdG9yeVsgdGhpcy5fX2hpc3RvcnlJbmRleCBdID8gdGhpcy5fX2hpc3RvcnlbIHRoaXMuX19oaXN0b3J5SW5kZXggXS5kZXNjIDogJyc7XG4gIH1cblxuICAvKipcbiAgICogRHJvcCBhbGwgdGhlIGhpc3RvcnkuIFlBQkFJLlxuICAgKi9cbiAgZHJvcEhpc3RvcnkoKSB7XG4gICAgdGhpcy5fX2hpc3Rvcnkuc3BsaWNlKCAwICk7XG4gICAgdGhpcy5fX2hpc3RvcnlJbmRleCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG5ldyBsZW5ndGggZm9yIHRoaXMgYXV0b21hdG9uIGluc3RhbmNlLlxuICAgKiAqKlNvbWUgbm9kZXMgLyBmeHMgbWlnaHQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIC8gY2hhbmdlZC4qKlxuICAgKiBDYW4gYmUgcGVyZm9ybWVkIHZpYSBHVUkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfbGVuZ3RoIE5ldyBsZW5ndGggZm9yIHRoZSBhdXRvbWF0b25cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHNldExlbmd0aCggX2xlbmd0aCApIHtcbiAgICAvLyBpZiBsZW5ndGggaXMgaW52YWxpZCB0aGVuIHRocm93IGVycm9yXG4gICAgaWYgKCBpc05hTiggX2xlbmd0aCApICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCAnQXV0b21hdG9uLnNldExlbmd0aDogX2xlbmd0aCBpcyBpbnZhbGlkJyApO1xuICAgIH1cblxuICAgIC8vIGlmIGxlbmd0aCBpcyBub3QgY2hhbmdlZCB0aGVuIGRvIGZhc3QtcmV0dXJuXG4gICAgaWYgKCBfbGVuZ3RoID09PSB0aGlzLmxlbmd0aCApIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBjaGFuZ2VMZW5ndGggaXMgYSBnb29kIG1ldGhvZFxuICAgIGZvciAoIGxldCBwYXJhbU5hbWUgaW4gdGhpcy5fX3BhcmFtcyApIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5fX3BhcmFtc1sgcGFyYW1OYW1lIF07XG4gICAgICBwYXJhbS5jaGFuZ2VMZW5ndGgoIF9sZW5ndGggKTtcbiAgICB9XG5cbiAgICAvLyBmaW5hbGx5IHNldCB0aGUgbGVuZ3RoXG4gICAgdGhpcy5fX2xlbmd0aCA9IF9sZW5ndGg7XG5cbiAgICAvLyBJdCdzIGlycmV2ZXJzaWJsZSBvcGVyYXRpb24sIHNvcnJ5LlxuICAgIHRoaXMuZHJvcEhpc3RvcnkoKTtcblxuICAgIC8vIFBva2UgdnVlXG4gICAgdGhpcy5fX3Z1ZS4kZW1pdCggJ2NoYW5nZWRMZW5ndGgnICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG5ldyByZXNvbHV0aW9uIGZvciB0aGlzIGF1dG9tYXRvbiBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IF9yZXNvbHVsdGlvbiBOZXcgcmVzb2x1dGlvbiBmb3IgdGhlIGF1dG9tYXRvbiBsdWxcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHNldFJlc29sdXRpb24oIF9yZXNvbHVsdGlvbiApIHsgLy8gbHVsXG4gICAgdGhpcy5fX3Jlc29sdXRpb24gPSBfcmVzb2x1bHRpb247IC8vIGx1bFxuICAgIHRoaXMucHJlY2FsY0FsbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwYXJhbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgcGFyYW1cbiAgICogQHJldHVybnMge1BhcmFtfSBDcmVhdGVkIHBhcmFtXG4gICAqL1xuICBjcmVhdGVQYXJhbSggX25hbWUsIF9kYXRhICkge1xuICAgIGNvbnN0IHBhcmFtID0gbmV3IFBhcmFtKCB7XG4gICAgICBhdXRvbWF0b246IHRoaXMsXG4gICAgICBkYXRhOiBfZGF0YVxuICAgIH0gKTtcbiAgICBWdWUuc2V0KCB0aGlzLl9fcGFyYW1zLCBfbmFtZSwgcGFyYW0gKTtcbiAgICByZXR1cm4gcGFyYW07XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgcGFyYW0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBOYW1lIG9mIHBhcmFtXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICByZW1vdmVQYXJhbSggX25hbWUgKSB7XG4gICAgVnVlLmRlbGV0ZSggdGhpcy5fX3BhcmFtcywgX25hbWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBwYXJhbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIHBhcmFtXG4gICAqIEByZXR1cm5zIHtQYXJhbX0gUGFyYW0gb2JqZWN0XG4gICAqL1xuICBnZXRQYXJhbSggX25hbWUgKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wYXJhbXNbIF9uYW1lIF0gfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gbGlzdCBvZiBuYW1lIG9mIHBhcmFtcy4gU29ydGVkLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IExpc3Qgb2YgbmFtZSBvZiBwYXJhbXNcbiAgICovXG4gIGdldFBhcmFtTmFtZXMoKSB7XG4gICAgbGV0IGFyciA9IFtdO1xuICAgIGZvciAoIGNvbnN0IG5hbWUgaW4gdGhpcy5fX3BhcmFtcyApIHsgYXJyLnB1c2goIG5hbWUgKTsgfVxuICAgIGFyciA9IGFyci5zb3J0KCk7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gbGlzdCBvZiBpZCBvZiBmeCBkZWZpbml0aW9ucy4gU29ydGVkLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IExpc3Qgb2YgaWQgb2YgZnggZGVmaW5pdGlvbnNcbiAgICovXG4gIGdldEZ4RGVmaW5pdGlvbklkcygpIHtcbiAgICBsZXQgYXJyID0gW107XG4gICAgZm9yICggY29uc3QgaWQgaW4gdGhpcy5fX3BhcmFtRnhEZWZzICkgeyBhcnIucHVzaCggaWQgKTsgfVxuICAgIGFyciA9IGFyci5zb3J0KCk7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gZGlzcGxheSBuYW1lIG9mIGEgZnggZGVmaW5pdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgZnggZGVmaW5pdGlvbiB5b3Ugd2FudCB0byBncmFiXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IE5hbWUgb2YgdGhlIGZ4IGRlZmluaXRpb25cbiAgICovXG4gIGdldEZ4RGVmaW5pdGlvbk5hbWUoIF9pZCApIHtcbiAgICBpZiAoIHRoaXMuX19wYXJhbUZ4RGVmc1sgX2lkIF0gKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3BhcmFtRnhEZWZzWyBfaWQgXS5uYW1lIHx8IF9pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGRlc2NyaXB0aW9uIG9mIGEgZnggZGVmaW5pdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgZnggZGVmaW5pdGlvbiB5b3Ugd2FudCB0byBncmFiXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IERlc2NyaXB0aW9uIG9mIHRoZSBmeCBkZWZpbml0aW9uXG4gICAqL1xuICBnZXRGeERlZmluaXRpb25EZXNjcmlwdGlvbiggX2lkICkge1xuICAgIGlmICggdGhpcy5fX3BhcmFtRnhEZWZzWyBfaWQgXSApIHtcbiAgICAgIHJldHVybiB0aGlzLl9fcGFyYW1GeERlZnNbIF9pZCBdLmRlc2NyaXB0aW9uIHx8ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gcGFyYW1zIHNlY3Rpb24gb2YgYSBmeCBkZWZpbml0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2lkIElkIG9mIHRoZSBmeCBkZWZpbml0aW9uIHlvdSB3YW50IHRvIGdyYWJcbiAgICogQHJldHVybnMge09iamVjdH0gUGFyYW1zIHNlY3Rpb25cbiAgICovXG4gIGdldEZ4RGVmaW5pdGlvblBhcmFtcyggX2lkICkge1xuICAgIGlmICggdGhpcy5fX3BhcmFtRnhEZWZzWyBfaWQgXSApIHtcbiAgICAgIHJldHVybiBqc29uQ29weSggdGhpcy5fX3BhcmFtRnhEZWZzWyBfaWQgXS5wYXJhbXMgfHwge30gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGNvdW50IG9mIHBhcmFtcy5cbiAgICogQHJldHVybnMge251bWJlcn0gQ291bnQgb2YgcGFyYW1zXG4gICAqL1xuICBjb3VudFBhcmFtcygpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKCBjb25zdCBuYW1lIGluIHRoaXMuX19wYXJhbXMgKSB7IHN1bSArKzsgfVxuICAgIHJldHVybiBzdW07XG4gIH1cblxuICAvKipcbiAgICogQXNzaWduZWQgdG8gYEF1dG9tYXRvbi5hdXRvYCBhdCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIG5hbWUgb2YgdGhlIHBhcmFtXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEN1cnJlbnQgdmFsdWUgb2YgdGhlIHBhcmFtXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9fYXV0byggX25hbWUgKSB7XG4gICAgbGV0IHBhcmFtID0gdGhpcy5fX3BhcmFtc1sgX25hbWUgXTtcbiAgICBpZiAoICFwYXJhbSApIHsgcGFyYW0gPSB0aGlzLmNyZWF0ZVBhcmFtKCBfbmFtZSApOyB9XG4gICAgcGFyYW0ubWFya0FzVXNlZCgpO1xuICAgIHJldHVybiBwYXJhbS5nZXRWYWx1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYXV0b21hdG9uIHN0YXRlIGRhdGEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBfZGF0YSBPYmplY3QgY29udGFpbnMgYXV0b21hdG9uIGRhdGEuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBsb2FkKCBfZGF0YSApIHtcbiAgICBsZXQgZGF0YSA9IGNvbXBhdCggX2RhdGEgKTtcbiAgICBzdXBlci5sb2FkKCBkYXRhICk7XG5cbiAgICAvKipcbiAgICAgKiBHVUkgc2V0dGluZ3MuXG4gICAgICogRmVlbCBmcmVlIHRvIGdldCAvIHNldCB0aGVzZSB2YWx1ZXMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmd1aVNldHRpbmdzID0gZGF0YS5ndWlTZXR0aW5ncztcblxuICAgIC8vIFBva2UgdnVlXG4gICAgaWYgKCB0aGlzLl9fdnVlICkge1xuICAgICAgdGhpcy5fX3Z1ZS4kZW1pdCggJ2xvYWRlZCcgKTtcbiAgICB9XG5cbiAgICAvLyBCeWUgaGlzdG9yeVxuICAgIGlmICggdGhpcy5fX2hpc3RvcnkgKSB7XG4gICAgICB0aGlzLmRyb3BIaXN0b3J5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydCBjdXJyZW50IHN0YXRlIGFzIEpTT04uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFNhdmVkIG9iamVjdCBhcyBKU09OXG4gICAqIEBleGFtcGxlXG4gICAqIOOBguOBqOOBp+OChOOCi1xuICAgKiBAdG9kbyDjga/jgYRcbiAgICovXG4gIHNhdmUoKSB7XG4gICAgY29uc3QgcmV0ID0ge1xuICAgICAgdjogdGhpcy52ZXJzaW9uLFxuICAgICAgbGVuZ3RoOiB0aGlzLmxlbmd0aCxcbiAgICAgIHJlc29sdXRpb246IHRoaXMucmVzb2x1dGlvbixcbiAgICAgIHBhcmFtczoge30sIC8vIHdpbGwgYmUgZmlsbGVkIGxhdGVyXG4gICAgICBndWlTZXR0aW5nczogdGhpcy5ndWlTZXR0aW5nc1xuICAgIH07XG5cbiAgICByZXQucGFyYW1zID0ge307XG4gICAgZm9yICggbGV0IG5hbWUgaW4gdGhpcy5fX3BhcmFtcyApIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5fX3BhcmFtc1sgbmFtZSBdO1xuICAgICAgcmV0LnBhcmFtc1sgbmFtZSBdID0ge1xuICAgICAgICBub2RlczogcGFyYW0uZHVtcE5vZGVzV2l0aG91dElkKCksXG4gICAgICAgIGZ4czogcGFyYW0uZHVtcEZ4c1dpdGhvdXRJZCgpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSggcmV0ICk7XG4gIH1cblxuICAvKipcbiAgICogUG9rZSB0aGUgdnVlIHJlbmRlcmVyLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgcG9rZVJlbmRlcmVyKCkge1xuICAgIGlmICggdGhpcy5fX3Z1ZSApIHtcbiAgICAgIHRoaXMuX192dWUuJGVtaXQoICdwb2tlJyApO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvbWF0b25XaXRoR1VJO1xuQXV0b21hdG9uV2l0aEdVSS5kZWZhdWx0ID0gQXV0b21hdG9uV2l0aEdVSTsiLCJpbXBvcnQgQ2xvY2sgZnJvbSAnLi9jbG9jayc7XG5pbXBvcnQgQ2xvY2tGcmFtZSBmcm9tICcuL2Nsb2NrLWZyYW1lJztcbmltcG9ydCBDbG9ja1JlYWx0aW1lIGZyb20gJy4vY2xvY2stcmVhbHRpbWUnO1xuXG5pbXBvcnQgUGFyYW0gZnJvbSAnLi9wYXJhbSc7XG5cbi8qKlxuICogSVQnUyBBVVRPTUFUT04hXG4gKiBJdCdzIGBhdXRvbWF0b24ubm9ndWkuanNgIHZlcnNpb24gYW5kIGFsc28gYmFzZSBjbGFzcyBmb3Ige0BsaW5rIEF1dG9tYXRvbldpdGhHVUl9LlxuICogQHBhcmFtIHtPYmplY3R9IF9wcm9wc1xuICogQHBhcmFtIHtib29sZWFufSBbX3Byb3BzLmxvb3BdIFdoZXRoZXIgbGV0IHRoZSB0aW1lIGxvb3Agb3Igbm90XG4gKiBAcGFyYW0ge251bWJlcn0gW19wcm9wcy5mcHNdIElmIHRoaXMgaXMgc2V0LCB0aGUgY2xvY2sgd2lsbCBiZWNvbWUgZnJhbWUgbW9kZVxuICogQHBhcmFtIHtib29sZWFufSBbX3Byb3BzLnJlYWx0aW1lXSBJZiB0aGlzIGlzIHRydWUsIHRoZSBjbG9jayB3aWxsIGJlY29tZSByZWFsdGltZSBtb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gX3Byb3BzLmRhdGEgRGF0YSBvZiB0aGUgYXV0b21hdG9uLiAqKlJlcXVpcmVkIGluIG5vR1VJIG1vZGUqKlxuICovXG5jb25zdCBBdXRvbWF0b24gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCBfcHJvcHMgKSB7XG4gICAgLyoqXG4gICAgICogVmVyc2lvbiBvZiB0aGUgYXV0b21hdG9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX192ZXJzaW9uID0gXCIyLjAuMVwiO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYW5pbWF0aW9uIHdpbGwgYmUgbG9vcGVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvb3AgPSBfcHJvcHMubG9vcCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENsb2NrIG9mIHRoZSBhdXRvbWF0b24uXG4gICAgICogQHR5cGUge0Nsb2NrfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9fY2xvY2sgPSAoXG4gICAgICBfcHJvcHMuZnBzID8gbmV3IENsb2NrRnJhbWUoIHRoaXMsIF9wcm9wcy5mcHMgKSA6XG4gICAgICBfcHJvcHMucmVhbHRpbWUgPyBuZXcgQ2xvY2tSZWFsdGltZSggdGhpcyApIDpcbiAgICAgIG5ldyBDbG9jayggdGhpcyApXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb25bXT59XG4gICAgICovXG4gICAgdGhpcy5fX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIHBhcmFtIGZ4IGRlZmluaXRpb25zLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgRng+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9fcGFyYW1GeERlZnMgPSB7fTtcblxuICAgIGNvbnN0IGRhdGEgPSBfcHJvcHMuZGF0YTtcbiAgICB0aGlzLmxvYWQoIGRhdGEgKTtcblxuICAgIC8qKlxuICAgICAqICoqVEhFIE1JR0hUWSBgYXV0bygpYCBGVU5DVElPTiEhIEdSQUIgSVQqKlxuICAgICAqIEl0IGNyZWF0ZXMgYSBuZXcgcGFyYW0gYXV0b21hdGljYWxseSBpZiB0aGVyZSBhcmUgbm8gcGFyYW0gY2FsbGVkIGBfbmFtZWAgKEdVSSBtb2RlIG9ubHkpLlxuICAgICAqIE90aGVyd2lzZSBpdCByZXR1cm5zIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHBhcmFtIGNhbGxlZCBgX25hbWVgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBuYW1lIG9mIHRoZSBwYXJhbVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEN1cnJlbnQgdmFsdWUgb2YgdGhlIHBhcmFtXG4gICAgICovXG4gICAgdGhpcy5hdXRvID0gKCBfbmFtZSApID0+IHRoaXMuX19hdXRvKCBfbmFtZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcnNpb24gb2YgdGhlIGF1dG9tYXRvbi5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdmVyc2lvbigpIHsgcmV0dXJuIHRoaXMuX192ZXJzaW9uOyB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgdGltZS4gU2FtZSBhcyBgYXV0b21hdG9uLl9fY2xvY2sudGltZWAuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHRpbWUoKSB7IHJldHVybiB0aGlzLl9fY2xvY2sudGltZTsgfVxuXG4gIC8qKlxuICAgKiBUb3RhbCBsZW5ndGggb2YgYW5pbWF0aW9uIGluIHNlY29uZHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuX19sZW5ndGg7IH1cblxuICAvKipcbiAgICogUmVzb2x1dGlvbiA9IFNhbXBsaW5nIHBvaW50IHBlciBzZWNvbmQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJlc29sdXRpb24oKSB7IHJldHVybiB0aGlzLl9fcmVzb2x1dGlvbjsgfVxuXG4gIC8qKlxuICAgKiBEZWx0YSBvZiB0aW1lIGJldHdlZW4gbm93IGFuZCBwcmV2aW91cyB1cGRhdGUgY2FsbC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZGVsdGFUaW1lKCkgeyByZXR1cm4gdGhpcy5fX2Nsb2NrLmRlbHRhVGltZTsgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGl0J3MgcGxheWluZyBvciBub3QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBpc1BsYXlpbmcoKSB7IHJldHVybiB0aGlzLl9fY2xvY2suaXNQbGF5aW5nOyB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgcHJvZ3Jlc3MgYnkgd2hvbGUgbGVuZ3RoLiBNaWdodCBOT1QgYmUgWzAtMV0gdW5sZXNzIGBfcHJvcHMubG9vcGAgKHNlZSBjb25zdHJ1Y3RvcikgaXMgdHJ1ZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJvZ3Jlc3MoKSB7IHJldHVybiB0aGlzLnRpbWUgLyB0aGlzLmxlbmd0aDsgfVxuXG4gIC8qKlxuICAgKiBGcmFtZSBwZXIgc2Vjb25kLiBJZiB0aGUgY2xvY2sgdHlwZSBpcyBub3QgZnBzLCBpdCB3aWxsIHJldHVybiBgMGAgaW5zdGVhZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZnBzKCkgeyByZXR1cm4gdGhpcy5fX2Nsb2NrLmZwcyA/IHRoaXMuX19jbG9jay5mcHMgOiAwOyB9XG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gdGhhdCByZXByZXNlbnRzIHdoZXRoZXIgdGhlIGNsb2NrIGlzIGJhc2VkIG9uIHJlYWx0aW1lIG9yIG5vdC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJlYWx0aW1lKCkgeyByZXR1cm4gQm9vbGVhbiggdGhpcy5fX2Nsb2NrLnJlYWx0aW1lICk7IH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHBhcmFtLlxuICAgKiBAcGFyYW0gX25hbWUgTmFtZSBvZiB0aGUgcGFyYW1cbiAgICogQHBhcmFtIF9kYXRhIERhdGEgZm9yIHRoZSBwYXJhbVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgY3JlYXRlUGFyYW0oIF9uYW1lLCBfZGF0YSApIHtcbiAgICB0aGlzLl9fcGFyYW1zWyBuYW1lIF0gPSBuZXcgUGFyYW0oIHtcbiAgICAgIGF1dG9tYXRvbjogdGhpcyxcbiAgICAgIGRhdGE6IF9kYXRhXG4gICAgfSApO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYXV0b21hdG9uIHN0YXRlIGRhdGEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBfZGF0YSBPYmplY3QgY29udGFpbnMgYXV0b21hdG9uIGRhdGEuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBsb2FkKCBfZGF0YSApIHtcbiAgICAvKipcbiAgICAgKiBUb3RhbCBsZW5ndGggb2YgYW5pbWF0aW9uIGluIHNlY29uZHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fX2xlbmd0aCA9IF9kYXRhLmxlbmd0aDtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdXRpb24gPSBTYW1wbGluZyBwb2ludCBwZXIgc2Vjb25kLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19yZXNvbHV0aW9uID0gX2RhdGEucmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgUGFyYW0uXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBQYXJhbT59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19wYXJhbXMgPSB7fTtcbiAgICBmb3IgKCBjb25zdCBuYW1lIGluIF9kYXRhLnBhcmFtcyApIHtcbiAgICAgIHRoaXMuY3JlYXRlUGFyYW0oIG5hbWUsIF9kYXRhLnBhcmFtc1sgbmFtZSBdICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZWsgdGhlIHRpbWVsaW5lLlxuICAgKiBDYW4gYmUgcGVyZm9ybWVkIHZpYSBHVUkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdGltZSBUaW1lXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBzZWVrKCBfdGltZSApIHtcbiAgICB0aGlzLl9fY2xvY2suc2V0VGltZSggX3RpbWUgKTtcbiAgICB0aGlzLl9fZW1pdCggJ3NlZWsnICk7XG4gIH1cblxuICAvKipcbiAgICogUGxheSB0aGUgdGltZWxpbmUuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqIEB0b2RvIFNIT1VMRCBiZSBwZXJmb3JtZWQgdmlhIEdVSS5cbiAgICovXG4gIHBsYXkoKSB7XG4gICAgdGhpcy5fX2Nsb2NrLnBsYXkoKTtcbiAgICB0aGlzLl9fZW1pdCggJ3BsYXknICk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIHRpbWVsaW5lLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKiBAdG9kbyBTSE9VTEQgYmUgcGVyZm9ybWVkIHZpYSBHVUkuXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICB0aGlzLl9fY2xvY2sucGF1c2UoKTtcbiAgICB0aGlzLl9fZW1pdCggJ3BhdXNlJyApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGZ4IGRlZmluaXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgVW5pcXVlIGlkIGZvciB0aGUgRnggZGVmaW5pdGlvblxuICAgKiBAcGFyYW0ge0Z4RGVmaW5pdGlvbn0gX2Z4RGVmIEZ4IGRlZmluaXRpb24gb2JqZWN0XG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBhZGRGeERlZmluaXRpb24oIF9pZCwgX2Z4RGVmICkge1xuICAgIHRoaXMuX19wYXJhbUZ4RGVmc1sgX2lkIF0gPSBfZnhEZWY7XG5cbiAgICB0aGlzLnByZWNhbGNBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGFuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2V2ZW50IEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHsuLi5hbnl9IF9hcmcgQXJndW1lbnRzIHBhc3NlZCB0byBsaXN0ZW5lcnNcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX19lbWl0KCBfZXZlbnQsIC4uLl9hcmcgKSB7XG4gICAgaWYgKCAhdGhpcy5fX2xpc3RlbmVyc1sgX2V2ZW50IF0gKSB7IHJldHVybjsgfVxuICAgIHRoaXMuX19saXN0ZW5lcnNbIF9ldmVudCBdLm1hcCggKCBsaXN0ZW5lciApID0+IGxpc3RlbmVyKCAuLi5fYXJnICkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2V2ZW50IEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gX2Z1bmMgTGlzdGVuZXIgZnVuY3Rpb25cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIG9uKCBfZXZlbnQsIF9mdW5jICkge1xuICAgIGlmICggIXRoaXMuX19saXN0ZW5lcnNbIF9ldmVudCBdICkge1xuICAgICAgdGhpcy5fX2xpc3RlbmVyc1sgX2V2ZW50IF0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5fX2xpc3RlbmVyc1sgX2V2ZW50IF0ucHVzaCggX2Z1bmMgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVjYWxjdWxhdGUgYWxsIHBhcmFtcy5cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHByZWNhbGNBbGwoKSB7XG4gICAgZm9yICggY29uc3QgbmFtZSBpbiB0aGlzLl9fcGFyYW1zICkge1xuICAgICAgdGhpcy5fX3BhcmFtc1sgbmFtZSBdLnByZWNhbGMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBlbnRpcmUgYXV0b21hdG9uLlxuICAgKiAqKllvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgaW4geW91ciB1cGRhdGUgbG9vcC4qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW190aW1lXSBDdXJyZW50IHRpbWUsICoqUmVxdWlyZWQgaWYgdGhlIGNsb2NrIG1vZGUgaXMgbWFudWFsKipcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVwZGF0ZSggX3RpbWUgKSB7XG4gICAgLy8gdXBkYXRlIHRoZSBjbG9ja1xuICAgIHRoaXMuX19jbG9jay51cGRhdGUoIF90aW1lICk7XG5cbiAgICAvLyBpZiBsb29wIGlzIGVuYWJsZWQsIGxvb3AgdGhlIHRpbWVcbiAgICBpZiAoIHRoaXMubG9vcCAmJiAoIHRoaXMudGltZSA8IDAgfHwgdGhpcy5sZW5ndGggPCB0aGlzLnRpbWUgKSApIHtcbiAgICAgIHRoaXMuX19jbG9jay5zZXRUaW1lKCB0aGlzLnRpbWUgLSBNYXRoLmZsb29yKCB0aGlzLnRpbWUgLyB0aGlzLmxlbmd0aCApICogdGhpcy5sZW5ndGggKTtcbiAgICB9XG5cbiAgICAvLyBncmFiIGN1cnJlbnQgdmFsdWUgZm9yIGVhY2ggcGFyYW1cbiAgICBmb3IgKCBsZXQgbmFtZSBpbiB0aGlzLl9fcGFyYW1zICkge1xuICAgICAgdGhpcy5fX3BhcmFtc1sgbmFtZSBdLmdldFZhbHVlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbmVkIHRvIEF1dG9tYXRvbi5hdXRvIGF0IGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgbmFtZSBvZiB0aGUgcGFyYW1cbiAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCB2YWx1ZSBvZiB0aGUgcGFyYW1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX19hdXRvKCBfbmFtZSApIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXNbIF9uYW1lIF0uX19jdXJyZW50VmFsdWU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b21hdG9uO1xuQXV0b21hdG9uLmRlZmF1bHQgPSBBdXRvbWF0b247IiwiaW1wb3J0IGpzb25Db3B5IGZyb20gJy4vanNvbi1jb3B5JztcbmltcG9ydCBhc3MgZnJvbSAnLi9hc3MnO1xuaW1wb3J0IGdlbklkIGZyb20gJy4vZ2VuLWlkJztcbmltcG9ydCBoYXNPdmVyd3JhcCBmcm9tICcuL2hhcy1vdmVyd3JhcCc7XG5cbmltcG9ydCBBdXRvbWF0b24gZnJvbSAnLi9tYWluLWd1aSc7XG5pbXBvcnQgUGFyYW0gZnJvbSAnLi9wYXJhbSc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlJztcblxuLyoqXG4gKiBJdCByZXByZXNlbnRzIGEgcGFyYW0gb2YgQXV0b21hdG9uLlxuICogSXQncyBgYXV0b21hdG9uLmpzYCBhbmQgYGF1dG9tYXRvbi5taW4uanNgIHZlcnNpb24uXG4gKiBJdCBoYXMgZXZlbiBtb3JlIHByZXR0eSBBUElzIHlheVxuICogQHBhcmFtIHtPYmplY3R9IF9wcm9wc1xuICogQHBhcmFtIHtBdXRvbWF0b259IF9wcm9wcy5hdXRvbWF0b24gUGFyZW50IGF1dG9tYXRvblxuICogQHBhcmFtIHtPYmplY3R9IFtfcHJvcHMuZGF0YV0gRGF0YSBvZiB0aGUgcGFyYW0uIERvbid0IHdvcnJ5LCBJIGNhbiBnZW5lcmF0ZSBhbiBpbml0aWFsIGRhdGEgZm9yIHlvdSFcbiAqL1xuY29uc3QgUGFyYW1XaXRoR1VJID0gY2xhc3MgZXh0ZW5kcyBQYXJhbSB7XG4gIGNvbnN0cnVjdG9yKCBfcHJvcHMgKSB7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKCB7fSwgX3Byb3BzICk7XG4gICAgY29uc3QgbGVuID0gX3Byb3BzLmF1dG9tYXRvbi5sZW5ndGg7XG4gICAgcHJvcHMuZGF0YSA9IHByb3BzLmRhdGEgPyBwcm9wcy5kYXRhIDoge1xuICAgICAgbm9kZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHRpbWU6IDAuMCxcbiAgICAgICAgICB2YWx1ZTogMC4wLFxuICAgICAgICAgIG91dDogeyB0aW1lOiBQYXJhbVdpdGhHVUkuREVGQVVMVF9IQU5ETEVfTEVOR1RILCB2YWx1ZTogMC4wIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRpbWU6IGxlbixcbiAgICAgICAgICB2YWx1ZTogMC4wLFxuICAgICAgICAgIGluOiB7IHRpbWU6IC1QYXJhbVdpdGhHVUkuREVGQVVMVF9IQU5ETEVfTEVOR1RILCB2YWx1ZTogMC4wIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIGZ4czogW11cbiAgICB9O1xuXG4gICAgc3VwZXIoIHByb3BzICk7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBwYXJhbSBpcyB1c2VkIG9uY2UgYXQgbGVhc3QgaW4gY3VycmVudCBzZXNzaW9uLlxuICAgICAqIENhbiBiZSBvcGVyYXRlZCBieSB7QGxpbmsgUGFyYW1XaXRoR1VJI21hcmtBc1VzZWR9LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9faXNVc2VkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIHBhcmFtIGRhdGEuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBfZGF0YSBEYXRhIG9mIHBhcmFtXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBsb2FkKCBfZGF0YSApIHtcbiAgICBjb25zdCBkYXRhID0ganNvbkNvcHkoIF9kYXRhICk7XG4gICAgc3VwZXIubG9hZCggZGF0YSApO1xuXG4gICAgdGhpcy5fX25vZGVzLmZvckVhY2goICggbm9kZSApID0+IG5vZGUuJGlkID0gZ2VuSWQoKSApO1xuICAgIHRoaXMuX19meHMuZm9yRWFjaCggKCBmeCApID0+IGZ4LiRpZCA9IGdlbklkKCkgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVjYWxjdWxhdGUgdmFsdWVzLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgcHJlY2FsYygpIHtcbiAgICBzdXBlci5wcmVjYWxjKCk7XG4gICAgdGhpcy5fX2F1dG9tYXRvbi5wb2tlUmVuZGVyZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIHRoaXMgcGFyYW0gYXMgdXNlZC5cbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIG1hcmtBc1VzZWQoKSB7XG4gICAgdGhpcy5fX2lzVXNlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBpcyB1c2VkIHBhcmFtIG9yIG5vdC5cbiAgICogQHJldHVybnMge2Jvb2x9IFRydWUgaWYgdGhlIHBhcmFtIGlzIHVzZWQgYXQgbGVhc3Qgb25jZSBpbiBjdXJyZW50IHNlc3Npb25cbiAgICovXG4gIGlzVXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2lzVXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0IG5vZGVzIGJ5IHRpbWUuXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9fc29ydE5vZGVzKCkge1xuICAgIHRoaXMuX19ub2RlcyA9IHRoaXMuX19ub2Rlcy5zb3J0KCAoIGEsIGIgKSA9PiBhLnRpbWUgLSBiLnRpbWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIG5vZGUgdGhhdCBoYXMgZ2l2ZW4gaWQgdGhlbiByZXR1cm4gaW5kZXggb2YgaXQuXG4gICAqIElmIGl0IGNvdWxkbid0IGZpbmQgdGhlIG5vZGUsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IF9pZCBJZCBvZiBub2RlIHlvdSB3YW50IHRvIGdyYWJcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX19nZXROb2RlSW5kZXhCeUlkKCBfaWQgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fbm9kZXMuZmluZEluZGV4KCAoIG5vZGUgKSA9PiBub2RlLiRpZCA9PT0gX2lkICk7XG4gICAgaWYgKCBpbmRleCA9PT0gLTEgKSB7IHRocm93IG5ldyBFcnJvciggYFNlYXJjaGVkIGZvciBub2RlIGlkOiAke19pZH0gYnV0IG5vdCBmb3VuZGAgKTsgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gaG93IG1hbnkgbm9kZSB0aGUgcGFyYW0gY3VycmVudGx5IGhhdmUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IE5vZGVzIGNvdW50XG4gICAqL1xuICBnZXROdW1Ob2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9fbm9kZXMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIER1bXAgZGF0YSBvZiBhIG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSWQgb2YgdGhlIG5vZGUgeW91IHdhbnQgdG8gZHVtcFxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBEYXRhIG9mIHRoZSBub2RlXG4gICAqL1xuICBkdW1wTm9kZSggX2lkICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldE5vZGVJbmRleEJ5SWQoIF9pZCApO1xuICAgIHJldHVybiBqc29uQ29weSggdGhpcy5fX25vZGVzWyBpbmRleCBdICk7XG4gIH1cblxuICAvKipcbiAgICogRHVtcCBkYXRhIG9mIG5vZGVzLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0W119IERhdGEgb2Ygbm9kZXNcbiAgICovXG4gIGR1bXBOb2RlcygpIHtcbiAgICByZXR1cm4ganNvbkNvcHkoIHRoaXMuX19ub2RlcyApO1xuICB9XG5cbiAgLyoqXG4gICAqIER1bXAgZGF0YSBvZiBub2Rlcywgd2l0aG91dCBgJGlkYC5cbiAgICogQHJldHVybnMge29iamVjdFtdfSBEYXRhIG9mIG5vZGVzXG4gICAqL1xuICBkdW1wTm9kZXNXaXRob3V0SWQoKSB7XG4gICAgbGV0IG5vZGVzID0gdGhpcy5kdW1wTm9kZXMoKTtcbiAgICByZXR1cm4gbm9kZXMubWFwKCAoIG5vZGUgKSA9PiB7XG4gICAgICBkZWxldGUgbm9kZS4kaWQ7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9ICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbm9kZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IF90aW1lIFRpbWUgb2YgbmV3IG5vZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IF92YWx1ZSBWYWx1ZSBvZiBuZXcgbm9kZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBJZCBvZiB0aGUgbmV3IG5vZGVcbiAgICovXG4gIGNyZWF0ZU5vZGUoIF90aW1lLCBfdmFsdWUgKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICRpZDogZ2VuSWQoKSxcbiAgICAgIHRpbWU6IF90aW1lLFxuICAgICAgdmFsdWU6IF92YWx1ZSxcbiAgICAgIGluOiB7IHRpbWU6IC1QYXJhbVdpdGhHVUkuREVGQVVMVF9IQU5ETEVfTEVOR1RILCB2YWx1ZTogMC4wIH0sXG4gICAgICBvdXQ6IHsgdGltZTogUGFyYW1XaXRoR1VJLkRFRkFVTFRfSEFORExFX0xFTkdUSCwgdmFsdWU6IDAuMCB9XG4gICAgfTtcbiAgICB0aGlzLl9fbm9kZXMucHVzaCggZGF0YSApO1xuICAgIHRoaXMuX19zb3J0Tm9kZXMoKTtcblxuICAgIHRoaXMucHJlY2FsYygpO1xuXG4gICAgcmV0dXJuIGRhdGEuJGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5vZGUgZnJvbSBkdW1wZWQgZGF0YS5cbiAgICogQHBhcmFtIHtvYmplY3R9IF9vYmogRHVtcGVkIG5vZGUgZGF0YVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBJZCBvZiB0aGUgbmV3IG5vZGVcbiAgICovXG4gIGNyZWF0ZU5vZGVGcm9tRGF0YSggX29iaiApIHtcbiAgICBjb25zdCBkYXRhID0ganNvbkNvcHkoIF9vYmogKTtcbiAgICB0aGlzLl9fbm9kZXMucHVzaCggZGF0YSApO1xuICAgIHRoaXMuX19zb3J0Tm9kZXMoKTtcblxuICAgIHRoaXMucHJlY2FsYygpO1xuXG4gICAgcmV0dXJuIGRhdGEuJGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSWQgb2YgdGhlIG5vZGUgeW91IHdhbnQgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICByZW1vdmVOb2RlKCBfaWQgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0Tm9kZUluZGV4QnlJZCggX2lkICk7XG5cbiAgICB0aGlzLl9fbm9kZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSBhIG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSWQgb2YgdGhlIG5vZGUgeW91IHdhbnQgdG8gbW92ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gX3RpbWUgVGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gX3ZhbHVlIFZhbHVlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBtb3ZlTm9kZSggX2lkLCBfdGltZSwgX3ZhbHVlICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldE5vZGVJbmRleEJ5SWQoIF9pZCApO1xuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX19ub2Rlc1sgaW5kZXggXTtcblxuICAgIGxldCB0aW1lID0gdHlwZW9mIF90aW1lID09PSAnbnVtYmVyJyA/IF90aW1lIDogbm9kZS50aW1lO1xuICAgIGlmICggaW5kZXggPT09IDAgKSB7XG4gICAgICB0aW1lID0gMDtcbiAgICB9IGVsc2UgaWYgKCBpbmRleCA9PT0gdGhpcy5fX25vZGVzLmxlbmd0aCAtIDEgKSB7XG4gICAgICB0aW1lID0gdGhpcy5fX2F1dG9tYXRvbi5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWUgPSBNYXRoLm1pbiggTWF0aC5tYXgoIHRpbWUsIHRoaXMuX19ub2Rlc1sgaW5kZXggLSAxIF0udGltZSApLCB0aGlzLl9fbm9kZXNbIGluZGV4ICsgMSBdLnRpbWUgKTtcbiAgICB9XG4gICAgbm9kZS50aW1lID0gdGltZTtcblxuICAgIG5vZGUudmFsdWUgPSB0eXBlb2YgX3ZhbHVlID09PSAnbnVtYmVyJyA/IF92YWx1ZSA6IG5vZGUudmFsdWU7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgaGFuZGxlIG9mIGEgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgbm9kZSB5b3Ugd2FudCB0byBvcGVyYXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gX2lzT3V0IElucHV0IGhhbmRsZSBpZiBmYWxzZSwgb3V0cHV0IGhhbmRsZSBpZiB0cnVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdGltZSBUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdmFsdWUgVmFsdWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIG1vdmVIYW5kbGUoIF9pZCwgX2lzT3V0LCBfdGltZSwgX3ZhbHVlICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldE5vZGVJbmRleEJ5SWQoIF9pZCApO1xuXG4gICAgaWYgKFxuICAgICAgKCBpbmRleCA9PT0gMCAmJiAoICFfaXNPdXQgKSApIHx8XG4gICAgICAoIGluZGV4ID09PSAoIHRoaXMuZ2V0TnVtTm9kZSgpIC0gMSApICYmIF9pc091dCApXG4gICAgKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX19ub2Rlc1sgaW5kZXggXTtcbiAgICBjb25zdCBoYW5kbGUgPSBfaXNPdXQgPyBub2RlLm91dCA6IG5vZGUuaW47XG5cbiAgICBsZXQgdGltZSA9IHR5cGVvZiBfdGltZSA9PT0gJ251bWJlcicgPyBfdGltZSA6IGhhbmRsZS50aW1lO1xuICAgIGlmICggX2lzT3V0ICkge1xuICAgICAgdGltZSA9IE1hdGgubWF4KCAwLjAsIHRpbWUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZSA9IE1hdGgubWluKCAwLjAsIHRpbWUgKTtcbiAgICB9XG4gICAgaGFuZGxlLnRpbWUgPSB0aW1lO1xuXG4gICAgaGFuZGxlLnZhbHVlID0gdHlwZW9mIF92YWx1ZSA9PT0gJ251bWJlcicgPyBfdmFsdWUgOiBoYW5kbGUudmFsdWU7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBhIGhhbmRsZSBvZiBhIG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSWQgb2YgdGhlIG5vZGUgeW91IHdhbnQgdG8gb3BlcmF0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IF9pc091dCBJbnB1dCBoYW5kbGUgaWYgZmFsc2UsIG91dHB1dCBoYW5kbGUgaWYgdHJ1ZVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgcmVzZXRIYW5kbGUoIF9pZCwgX2lzT3V0ICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldE5vZGVJbmRleEJ5SWQoIF9pZCApO1xuXG4gICAgaWYgKFxuICAgICAgKCBpbmRleCA9PT0gMCAmJiAoICFfaXNPdXQgKSApIHx8XG4gICAgICAoIGluZGV4ID09PSAoIHRoaXMuZ2V0TnVtTm9kZSgpIC0gMSApICYmIF9pc091dCApXG4gICAgKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX19ub2Rlc1sgaW5kZXggXTtcbiAgICBjb25zdCBoYW5kbGUgPSBfaXNPdXQgPyBub2RlLm91dCA6IG5vZGUuaW47XG5cbiAgICBoYW5kbGUudGltZSA9ICggX2lzT3V0ID8gMS4wIDogLTEuMCApICogUGFyYW1XaXRoR1VJLkRFRkFVTFRfSEFORExFX0xFTkdUSDtcbiAgICBoYW5kbGUudmFsdWUgPSAwLjA7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0IGZ4cyBieSB0aW1lLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfX3NvcnRGeHMoKSB7XG4gICAgdGhpcy5fX2Z4cyA9IHRoaXMuX19meHMuc29ydCggKCBhLCBiICkgPT4gYS50aW1lIC0gYi50aW1lICkuc29ydCggKCBhLCBiICkgPT4gYS5yb3cgLSBiLnJvdyApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBmb3IgZnggdGhhdCBoYXMgZ2l2ZW4gaWQgdGhlbiByZXR1cm4gaW5kZXggb2YgaXQuXG4gICAqIElmIGl0IGNvdWxkbid0IGZpbmQgdGhlIGZ4LCBpdCB3aWxsIHRocm93IGFuIGVycm9yIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfaWQgSWQgb2YgZnggeW91IHdhbnQgdG8gZ3JhYlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfX2dldEZ4SW5kZXhCeUlkKCBfaWQgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZnhzLmZpbmRJbmRleCggKCBmeCApID0+IGZ4LiRpZCA9PT0gX2lkICk7XG4gICAgaWYgKCBpbmRleCA9PT0gLTEgKSB7IHRocm93IG5ldyBFcnJvciggYFNlYXJjaGVkIGZvciBmeCBpZDogJHtfaWR9IGJ1dCBub3QgZm91bmRgICk7IH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIGZvciB2YWNhbmNlIGZ4IHJvdyBmb3IgZ2l2ZW4gdGltZSBhbmQgbGVuZ3RoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gX3RpbWUgQmVnaW5uaW5nIHRpbWUgb2YgZnhcbiAgICogQHBhcmFtIHtudW1iZXJ9IF9sZW5ndGggTGVuZ3RoIG9mIGZ4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbX3Jvdz0wXSBJZiBnaXZlbiwgcm93cyBsb3dlciB0aGFuIHRoaXMgdmFsdWUgd2lsbCBub3QgYmUgc2VhcmNoZWQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IE1pbmltYWwgZnJlZSBmeCByb3dcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX19nZXRGcmVlUm93KCBfdGltZSwgX2xlbmd0aCwgX3JvdyApIHtcbiAgICBsZXQgcm93ID0gX3JvdyB8fCAwO1xuICAgIGZvciAoIGxldCBpRnggPSAwOyBpRnggPCB0aGlzLl9fZnhzLmxlbmd0aDsgaUZ4ICsrICkge1xuICAgICAgY29uc3QgZnggPSB0aGlzLl9fZnhzWyBpRnggXTtcbiAgICAgIGlmICggZngucm93IDwgcm93ICkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKCByb3cgPCBmeC5yb3cgKSB7IGJyZWFrOyB9XG4gICAgICBpZiAoIGhhc092ZXJ3cmFwKCBfdGltZSwgX2xlbmd0aCwgZngudGltZSwgZngubGVuZ3RoICkgKSB7XG4gICAgICAgIHJvdyArKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvdztcbiAgfVxuXG4gIC8qKlxuICAgKiBEdW1wIGRhdGEgb2YgYSBmeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IF9pZCBJZCBvZiBhIGZ4IHlvdSB3YW50IHRvIGR1bXBcbiAgICogQHJldHVybnMge29iamVjdH0gRGF0YSBvZiB0aGUgZnhcbiAgICovXG4gIGR1bXBGeCggX2lkICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldEZ4SW5kZXhCeUlkKCBfaWQgKTtcbiAgICByZXR1cm4ganNvbkNvcHkoIHRoaXMuX19meHNbIGluZGV4IF0gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEdW1wIGRhdGEgb2YgZnhzLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0W119IERhdGEgb2YgZnhzXG4gICAqL1xuICBkdW1wRnhzKCkge1xuICAgIHJldHVybiBqc29uQ29weSggdGhpcy5fX2Z4cyApO1xuICB9XG5cbiAgLyoqXG4gICAqIER1bXAgZGF0YSBvZiBmeHMsIHdpdGhvdXQgYCRpZGAuXG4gICAqIEByZXR1cm5zIHtvYmplY3RbXX0gRGF0YSBvZiBmeHNcbiAgICovXG4gIGR1bXBGeHNXaXRob3V0SWQoKSB7XG4gICAgbGV0IGZ4cyA9IHRoaXMuZHVtcEZ4cygpO1xuICAgIHJldHVybiBmeHMubWFwKCAoIGZ4ICkgPT4ge1xuICAgICAgZGVsZXRlIGZ4LiRpZDtcbiAgICAgIHJldHVybiBmeDtcbiAgICB9ICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZnguXG4gICAqIElmIGl0IGNvdWxkbid0IGNyZWF0ZSBwYXJhbSwgaXQgd2lsbCByZXR1cm4gZW1wdHkgc3RyaW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdGltZSBCZWdpbm5pbmcgdGltZSBvZiBuZXcgZnhcbiAgICogQHBhcmFtIHtudW1iZXJ9IF9sZW5ndGggTGVuZ3RoIG9mIG5ldyBmeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2RlZiBEZWZpbml0aW9uIGlkIChraW5kKSBvZiBuZXcgZnhcbiAgICogQHJldHVybnMge3N0cmluZ30gSWQgb2YgdGhlIG5ldyBmeFxuICAgKi9cbiAgY3JlYXRlRngoIF90aW1lLCBfbGVuZ3RoLCBfZGVmICkge1xuICAgIGxldCByb3cgPSB0aGlzLl9fZ2V0RnJlZVJvdyggX3RpbWUsIF9sZW5ndGggKTtcbiAgICBpZiAoIFBhcmFtV2l0aEdVSS5GWF9ST1dfTUFYIDwgcm93ICkge1xuICAgICAgY29uc29sZS5lcnJvciggJ1RvbyBtYW55IGZ4IHN0YWNrcyBhdCBoZXJlIScgKTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgJGlkOiBnZW5JZCgpLFxuICAgICAgdGltZTogX3RpbWUsXG4gICAgICBsZW5ndGg6IF9sZW5ndGgsXG4gICAgICByb3c6IHJvdyxcbiAgICAgIGRlZjogX2RlZixcbiAgICAgIHBhcmFtczogdGhpcy5fX2F1dG9tYXRvbi5nZW5lcmF0ZURlZmF1bHRGeFBhcmFtcyggX2RlZiApXG4gICAgfTtcbiAgICB0aGlzLl9fZnhzLnB1c2goIGRhdGEgKTtcbiAgICB0aGlzLl9fc29ydEZ4cygpO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG5cbiAgICByZXR1cm4gZGF0YS4kaWQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZnggZnJvbSBkdW1wZWQgZGF0YS5cbiAgICogSWYgaXQgY291bGRuJ3QgY3JlYXRlIHBhcmFtLCBpdCB3aWxsIHJldHVybiBlbXB0eSBzdHJpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IF9vYmogRHVtcGVkIGZ4IGRhdGFcbiAgICogQHJldHVybnMge3N0cmluZ30gSWQgb2YgdGhlIG5ldyBmeFxuICAgKi9cbiAgY3JlYXRlRnhGcm9tRGF0YSggX29iaiApIHtcbiAgICBsZXQgcm93ID0gdGhpcy5fX2dldEZyZWVSb3coIF9vYmoudGltZSwgX29iai5sZW5ndGgsIF9vYmoucm93ICk7XG4gICAgaWYgKCBQYXJhbVdpdGhHVUkuRlhfUk9XX01BWCA8IHJvdyApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoICdUb28gbWFueSBmeCBzdGFja3MgYXQgaGVyZSEnICk7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IGRhdGEgPSBqc29uQ29weSggX29iaiApO1xuICAgIGRhdGEucm93ID0gcm93O1xuICAgIHRoaXMuX19meHMucHVzaCggZGF0YSApO1xuICAgIHRoaXMuX19zb3J0RnhzKCk7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcblxuICAgIHJldHVybiBkYXRhLiRpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmeC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgZnggeW91IHdhbnQgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICByZW1vdmVGeCggX2lkICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldEZ4SW5kZXhCeUlkKCBfaWQgKTtcblxuICAgIHRoaXMuX19meHMuc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSBhIGZ4LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2lkIElkIG9mIHRoZSBmeCB5b3Ugd2FudCB0byBtb3ZlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdGltZSBCZWdpbm5pbmcgdGltZVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgbW92ZUZ4KCBfaWQsIF90aW1lICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldEZ4SW5kZXhCeUlkKCBfaWQgKTtcblxuICAgIGNvbnN0IGZ4ID0gdGhpcy5fX2Z4c1sgaW5kZXggXTtcblxuICAgIGNvbnN0IHNhbWVSb3cgPSB0aGlzLl9fZnhzLmZpbHRlciggKCBmeE9wICkgPT4gZnhPcC5yb3cgPT09IGZ4LnJvdyApO1xuICAgIGNvbnN0IGluZGV4SW5Sb3cgPSBzYW1lUm93LmluZGV4T2YoIGZ4ICk7XG4gICAgY29uc3QgcHJldiA9IHNhbWVSb3dbIGluZGV4SW5Sb3cgLSAxIF07XG4gICAgY29uc3QgbmV4dCA9IHNhbWVSb3dbIGluZGV4SW5Sb3cgKyAxIF07XG5cbiAgICBjb25zdCBsZWZ0ID0gcHJldiA/ICggcHJldi50aW1lICsgcHJldi5sZW5ndGggKSA6IDAuMDtcbiAgICBjb25zdCByaWdodCA9IG5leHQgPyBuZXh0LnRpbWUgOiB0aGlzLl9fYXV0b21hdG9uLmxlbmd0aDtcbiAgICBmeC50aW1lID0gTWF0aC5taW4oIE1hdGgubWF4KCBfdGltZSwgbGVmdCApLCByaWdodCAtIGZ4Lmxlbmd0aCApO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHJvdyBvZiBhIGZ4LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2lkIElkIG9mIHRoZSBmeCB5b3Ugd2FudCB0byBtb3ZlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfcm93IFJvd1xuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgY2hhbmdlRnhSb3coIF9pZCwgX3JvdyApIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX19nZXRGeEluZGV4QnlJZCggX2lkICk7XG5cbiAgICBpZiAoIF9yb3cgPCAwIHx8IFBhcmFtV2l0aEdVSS5GWF9ST1dfTUFYIDwgX3JvdyApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvciggYFJvdyBudW1iZXIgJHtfcm93fSBpcyBpbnZhbGlkYCApO1xuICAgIH1cblxuICAgIGNvbnN0IGZ4ID0gdGhpcy5fX2Z4c1sgaW5kZXggXTtcbiAgICBpZiAoIGZ4LnJvdyA9PT0gX3JvdyApIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBzYW1lUm93ID0gdGhpcy5fX2Z4cy5maWx0ZXIoICggZnhPcCApID0+IGZ4T3Aucm93ID09PSBfcm93ICk7XG4gICAgY29uc3QgaXNWYWxpZCA9IHNhbWVSb3cuZXZlcnkoICggZnhPcCApID0+IChcbiAgICAgICEoIGZ4T3AudGltZSA8IGZ4LnRpbWUgJiYgZngudGltZSA8ICggZnhPcC50aW1lICsgZnhPcC5sZW5ndGggKSApICYmXG4gICAgICAhKCBmeE9wLnRpbWUgPCAoIGZ4LnRpbWUgKyBmeC5sZW5ndGggKSAmJiAoIGZ4LnRpbWUgKyBmeC5sZW5ndGggKSA8ICggZnhPcC50aW1lICsgZnhPcC5sZW5ndGggKSApICYmXG4gICAgICAhKCBmeC50aW1lIDwgZnhPcC50aW1lICYmIGZ4T3AudGltZSA8ICggZngudGltZSArIGZ4Lmxlbmd0aCApICkgJiZcbiAgICAgICEoIGZ4LnRpbWUgPCAoIGZ4T3AudGltZSArIGZ4T3AubGVuZ3RoICkgJiYgKCBmeE9wLnRpbWUgKyBmeE9wLmxlbmd0aCApIDwgKCBmeC50aW1lICsgZngubGVuZ3RoICkgKVxuICAgICkgKTtcblxuICAgIGlmICggIWlzVmFsaWQgKSB7IHJldHVybjsgfVxuXG4gICAgZngucm93ID0gX3JvdztcbiAgICB0aGlzLl9fc29ydEZ4cygpO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG4gIH1cblxuICAvKipcbiAgICogQnlwYXNzIG9yIHVuYnlwYXNzIGEgZnguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSWQgb2YgdGhlIGZ4IHlvdSB3YW50IHRvIGNoYW5nZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IF9ieXBhc3MgSWYgdHJ1ZSwgZnggd2lsbCBiZSBieXBhc3NlZFxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgYnlwYXNzRngoIF9pZCwgX2J5cGFzcyApIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX19nZXRGeEluZGV4QnlJZCggX2lkICk7XG5cbiAgICBjb25zdCBmeCA9IHRoaXMuX19meHNbIGluZGV4IF07XG4gICAgVnVlLnNldCggZngsICdieXBhc3MnLCAhIV9ieXBhc3MgKTtcblxuICAgIHRoaXMucHJlY2FsYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSBhIHBhcmFtIG9mIGEgZnguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSWQgb2YgdGhlIGZ4IHlvdSB3YW50IHRvIGNoYW5nZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgcGFyYW0geW91IHdhbnQgdG8gY2hhbmdlXG4gICAqIEBwYXJhbSB7YW55fSBfdmFsdWUgWW91ciBkZXNpcmVkIHZhbHVlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBjaGFuZ2VGeFBhcmFtKCBfaWQsIF9uYW1lLCBfdmFsdWUgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0RnhJbmRleEJ5SWQoIF9pZCApO1xuXG4gICAgY29uc3QgZnggPSB0aGlzLl9fZnhzWyBpbmRleCBdO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX19hdXRvbWF0b24uZ2V0RnhEZWZpbml0aW9uUGFyYW1zKCBmeC5kZWYgKTtcblxuICAgIGxldCB2YWx1ZSA9IF92YWx1ZTtcbiAgICBpZiAoIHR5cGVvZiBwYXJhbXNbIF9uYW1lIF0ubWluID09PSAnbnVtYmVyJyApIHsgdmFsdWUgPSBNYXRoLm1heCggcGFyYW1zWyBfbmFtZSBdLm1pbiwgdmFsdWUgKTsgfVxuICAgIGlmICggdHlwZW9mIHBhcmFtc1sgX25hbWUgXS5tYXggPT09ICdudW1iZXInICkgeyB2YWx1ZSA9IE1hdGgubWluKCBwYXJhbXNbIF9uYW1lIF0ubWF4LCB2YWx1ZSApOyB9XG4gICAgVnVlLnNldCggZngucGFyYW1zLCBfbmFtZSwgdmFsdWUgKTtcblxuICAgIHRoaXMucHJlY2FsYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgYSBmeCAtLWZvcmNlLlxuICAgKiBCZXN0IGZvciB1bmRvLXJlZG8gb3BlcmF0aW9uLiBwcm9iYWJseS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9pZCBJZCBvZiB0aGUgZnggeW91IHdhbnQgdG8gbW92ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gX3RpbWUgQmVnaW5uaW5nIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IF9yb3cgUm93XG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBmb3JjZU1vdmVGeCggX2lkLCBfdGltZSwgX3JvdyApIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX19nZXRGeEluZGV4QnlJZCggX2lkICk7XG5cbiAgICBjb25zdCBmeCA9IHRoaXMuX19meHNbIGluZGV4IF07XG5cbiAgICBmeC50aW1lID0gX3RpbWU7XG4gICAgZngucm93ID0gX3JvdztcbiAgICB0aGlzLl9fc29ydEZ4cygpO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzaXplIGEgZnguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfaWQgSW5kZXggb2YgdGhlIGZ4IHlvdSB3YW50IHRvIHJlc2l6ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gX2xlbmd0aCBMZW5ndGhcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHJlc2l6ZUZ4KCBfaWQsIF9sZW5ndGggKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9fZ2V0RnhJbmRleEJ5SWQoIF9pZCApO1xuXG4gICAgY29uc3QgZnggPSB0aGlzLl9fZnhzWyBpbmRleCBdO1xuXG4gICAgY29uc3Qgc2FtZVJvdyA9IHRoaXMuX19meHMuZmlsdGVyKCAoIGZ4T3AgKSA9PiBmeE9wLnJvdyA9PT0gZngucm93ICk7XG4gICAgY29uc3QgaW5kZXhJblJvdyA9IHNhbWVSb3cuaW5kZXhPZiggZnggKTtcbiAgICBjb25zdCBuZXh0ID0gc2FtZVJvd1sgaW5kZXhJblJvdyArIDEgXTtcblxuICAgIGNvbnN0IHJpZ2h0ID0gbmV4dCA/IG5leHQudGltZSA6IHRoaXMuX19hdXRvbWF0b24ubGVuZ3RoO1xuXG4gICAgZngubGVuZ3RoID0gTWF0aC5taW4oIE1hdGgubWF4KCBfbGVuZ3RoLCAwLjAgKSwgcmlnaHQgLSBmeC50aW1lICk7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemUgYSBmeCBieSBsZWZ0IHNpZGUgb2YgdGhlIGVuZC5cbiAgICogSXQncyB2ZXJ5IEdVSSBkZXYgZnJpZW5kbHkgbWV0aG9kLiB5ZWFoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2lkIEluZGV4IG9mIHRoZSBmeCB5b3Ugd2FudCB0byByZXNpemVcbiAgICogQHBhcmFtIHtudW1iZXJ9IF9sZW5ndGggTGVuZ3RoXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICByZXNpemVGeEJ5TGVmdCggX2lkLCBfbGVuZ3RoICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2dldEZ4SW5kZXhCeUlkKCBfaWQgKTtcblxuICAgIGNvbnN0IGZ4ID0gdGhpcy5fX2Z4c1sgaW5kZXggXTtcbiAgICBjb25zdCBlbmQgPSBmeC50aW1lICsgZngubGVuZ3RoO1xuXG4gICAgY29uc3Qgc2FtZVJvdyA9IHRoaXMuX19meHMuZmlsdGVyKCAoIGZ4T3AgKSA9PiBmeE9wLnJvdyA9PT0gZngucm93ICk7XG4gICAgY29uc3QgaW5kZXhJblJvdyA9IHNhbWVSb3cuaW5kZXhPZiggZnggKTtcbiAgICBjb25zdCBwcmV2ID0gc2FtZVJvd1sgaW5kZXhJblJvdyAtIDEgXTtcblxuICAgIGNvbnN0IGxlZnQgPSBwcmV2ID8gKCBwcmV2LnRpbWUgKyBwcmV2Lmxlbmd0aCApIDogMC4wO1xuXG4gICAgZngubGVuZ3RoID0gTWF0aC5taW4oIE1hdGgubWF4KCBfbGVuZ3RoLCAwLjAgKSwgZW5kIC0gbGVmdCApO1xuICAgIGZ4LnRpbWUgPSBlbmQgLSBmeC5sZW5ndGg7XG5cbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIHdoZW4geW91IG5lZWQgdG8gY2hhbmdlIGF1dG9tYXRvbiBsZW5ndGguXG4gICAqIFRoaXMgaXMgdmVyeSBoYXJkY29yZSBtZXRob2QuIFNob3VsZCBub3QgYmUgY2FsbGVkIGJ5IGFueXdoZXJlIGV4Y2VwdCB7QGxpbmsgQXV0b21hdG9uV2l0aEdVSSNzZXRMZW5ndGh9LlxuICAgKiBAcGFyYW0ge251bWJlcn0gX2xlbmd0aCBEZXNpcmVkIGxlbmd0aFxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgY2hhbmdlTGVuZ3RoKCBfbGVuZ3RoICkge1xuICAgIGZvciAoIGxldCBpID0gdGhpcy5fX25vZGVzLmxlbmd0aCAtIDE7IDAgPD0gaTsgaSAtLSApIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9fbm9kZXNbIGkgXTtcbiAgICAgIGlmICggX2xlbmd0aCA8IG5vZGUudGltZSApIHtcbiAgICAgICAgdGhpcy5fX25vZGVzLnNwbGljZSggaSwgMSApO1xuICAgICAgfSBlbHNlIGlmICggbm9kZS50aW1lID09PSBfbGVuZ3RoICkge1xuICAgICAgICBkZWxldGUgbm9kZS5vdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSB0aGlzLl9fbm9kZXNbIHRoaXMuX19ub2Rlcy5sZW5ndGggLSAxIF07XG4gICAgICAgIGlmICggbGFzdE5vZGUgKSB7XG4gICAgICAgICAgbGFzdE5vZGUub3V0ID0geyB0aW1lOiBQYXJhbVdpdGhHVUkuREVGQVVMVF9IQU5ETEVfTEVOR1RILCB2YWx1ZTogMC4wIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fbm9kZXMucHVzaCgge1xuICAgICAgICAgIHRpbWU6IF9sZW5ndGgsXG4gICAgICAgICAgdmFsdWU6IDAuMCxcbiAgICAgICAgICBpbjogeyB0aW1lOiAtUGFyYW1XaXRoR1VJLkRFRkFVTFRfSEFORExFX0xFTkdUSCwgdmFsdWU6IDAuMCB9XG4gICAgICAgIH0gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICggbGV0IGkgPSB0aGlzLl9fZnhzLmxlbmd0aCAtIDE7IDAgPD0gaTsgaSAtLSApIHtcbiAgICAgIGNvbnN0IGZ4ID0gdGhpcy5fX2Z4c1sgaSBdO1xuICAgICAgaWYgKCBfbGVuZ3RoIDwgZngudGltZSApIHtcbiAgICAgICAgdGhpcy5fX2Z4cy5zcGxpY2UoIGksIDEgKTtcbiAgICAgIH0gZWxzZSBpZiAoIF9sZW5ndGggPCBmeC50aW1lICsgZngubGVuZ3RoICkge1xuICAgICAgICBmeC5sZW5ndGggPSBfbGVuZ3RoIC0gZngudGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9fdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5fX2F1dG9tYXRvbi5yZXNvbHV0aW9uICogX2xlbmd0aCArIDEgKTtcbiAgICB0aGlzLnByZWNhbGMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIG9mIGEgbmV3IG5vZGUgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgbGVuZ3RoLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdGFudFxuICovXG5QYXJhbVdpdGhHVUkuREVGQVVMVF9IQU5ETEVfTEVOR1RIID0gMC41O1xuUGFyYW1XaXRoR1VJLkZYX1JPV19NQVggPSA0O1xuXG5leHBvcnQgZGVmYXVsdCBQYXJhbVdpdGhHVUk7IiwiaW1wb3J0IGN1YmljQmV6aWVyIGZyb20gJy4vY3ViaWMtYmV6aWVyJztcblxuaW1wb3J0IEF1dG9tYXRvbiBmcm9tICcuL21haW4nO1xuXG4vKipcbiAqIEl0IHJlcHJlc2VudHMgYSBwYXJhbSBvZiBBdXRvbWF0b24uXG4gKiBJdCdzIGBhdXRvbWF0b24ubm9ndWkuanNgIHZlcnNpb24gYW5kIGFsc28gYmFzZSBjbGFzcyBmb3Ige0BsaW5rIFBhcmFtV2l0aEdVSX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBfcHJvcHNcbiAqIEBwYXJhbSB7QXV0b21hdG9ufSBfcHJvcHMuYXV0b21hdG9uIFBhcmVudCBhdXRvbWF0b25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbX3Byb3BzLmRhdGFdIERhdGEgb2YgdGhlIHBhcmFtLiAqKlJlcXVpcmVkIGluIG5vR1VJIG1vZGUqKlxuICovXG5jb25zdCBQYXJhbSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoIF9wcm9wcyApIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IGF1dG9tYXRvbi5cbiAgICAgKiBAdHlwZSB7QXV0b21hdG9ufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9fYXV0b21hdG9uID0gX3Byb3BzLmF1dG9tYXRvbjtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHByZWNhbGN1bGF0ZWQgdmFsdWUuXG4gICAgICogSXRzIGxlbmd0aCBpcyBzYW1lIGFzIGBwYXJhbS5fX2F1dG9tYXRvbi5yZXNvbHV0aW9uICogcGFyYW0uX19hdXRvbWF0b24ubGVuZ3RoICsgMWAuXG4gICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9fdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5fX2F1dG9tYXRvbi5yZXNvbHV0aW9uICogdGhpcy5fX2F1dG9tYXRvbi5sZW5ndGggKyAxICk7XG5cbiAgICB0aGlzLmxvYWQoIF9wcm9wcy5kYXRhICk7XG5cbiAgICAvKipcbiAgICAgKiBBIGJ1ZmZlciBvZiBsYXN0IGNhbGN1bGF0ZWQgdmFsdWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fX2xhc3RWYWx1ZSA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIFdpbGwgYmUgdXNlZCBmb3IgY2FsY3VsYXRpb24gb2YgYHBhcmFtLl9fbGFzdFZhbHVlYC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9fbGFzdFRpbWUgPSAwLjA7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIHBhcmFtIGRhdGEuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBfZGF0YSBEYXRhIG9mIHBhcmFtXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBsb2FkKCBfZGF0YSApIHtcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIG5vZGUuXG4gICAgICogQHR5cGUge1BhcmFtTm9kZVtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9fbm9kZXMgPSBfZGF0YS5ub2RlcztcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgZnguXG4gICAgICogQHR5cGUge1BhcmFtRnhTdHJpcFtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9fZnhzID0gX2RhdGEuZnhzO1xuXG4gICAgdGhpcy5wcmVjYWxjKCk7XG4gIH1cblxuICAvKipcbiAgICogUHJlY2FsY3VsYXRlIHZhbHVlIG9mIGEgc2FtcGxlLlxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgcHJlY2FsYygpIHtcbiAgICBmb3IgKCBsZXQgaU5vZGUgPSAwOyBpTm9kZSA8IHRoaXMuX19ub2Rlcy5sZW5ndGggLSAxOyBpTm9kZSArKyApIHtcbiAgICAgIGNvbnN0IG5vZGUwID0gdGhpcy5fX25vZGVzWyBpTm9kZSBdO1xuICAgICAgY29uc3Qgbm9kZTEgPSB0aGlzLl9fbm9kZXNbIGlOb2RlICsgMSBdO1xuICAgICAgY29uc3QgaTAgPSBNYXRoLmZsb29yKCBub2RlMC50aW1lICogdGhpcy5fX2F1dG9tYXRvbi5yZXNvbHV0aW9uICk7XG4gICAgICBjb25zdCBpMSA9IE1hdGguZmxvb3IoIG5vZGUxLnRpbWUgKiB0aGlzLl9fYXV0b21hdG9uLnJlc29sdXRpb24gKTtcblxuICAgICAgdGhpcy5fX3ZhbHVlc1sgaTAgXSA9IG5vZGUwLnZhbHVlO1xuICAgICAgZm9yICggbGV0IGkgPSBpMCArIDE7IGkgPD0gaTE7IGkgKysgKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBpIC8gdGhpcy5fX2F1dG9tYXRvbi5yZXNvbHV0aW9uO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGN1YmljQmV6aWVyKCBub2RlMCwgbm9kZTEsIHRpbWUgKTtcbiAgICAgICAgdGhpcy5fX3ZhbHVlc1sgaSBdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICggbGV0IGlGeCA9IDA7IGlGeCA8IHRoaXMuX19meHMubGVuZ3RoOyBpRnggKysgKSB7XG4gICAgICBjb25zdCBmeCA9IHRoaXMuX19meHNbIGlGeCBdO1xuICAgICAgaWYgKCBmeC5ieXBhc3MgKSB7IGNvbnRpbnVlOyB9XG4gICAgICBjb25zdCBmeERlZiA9IHRoaXMuX19hdXRvbWF0b24uX19wYXJhbUZ4RGVmc1sgZnguZGVmIF07XG4gICAgICBpZiAoICFmeERlZiApIHsgY29udGludWU7IH1cblxuICAgICAgY29uc3QgaTAgPSBNYXRoLmNlaWwoIHRoaXMuX19hdXRvbWF0b24ucmVzb2x1dGlvbiAqIGZ4LnRpbWUgKTtcbiAgICAgIGNvbnN0IGkxID0gTWF0aC5mbG9vciggdGhpcy5fX2F1dG9tYXRvbi5yZXNvbHV0aW9uICogKCBmeC50aW1lICsgZngubGVuZ3RoICkgKTtcblxuICAgICAgY29uc3QgdGVtcFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGkxIC0gaTAgKTtcbiAgICAgIGNvbnN0IHRlbXBMZW5ndGggPSB0ZW1wVmFsdWVzLmxlbmd0aDtcblxuICAgICAgbGV0IGNvbnRleHQgPSB7XG4gICAgICAgIGkwOiBpMCxcbiAgICAgICAgaTE6IGkxLFxuICAgICAgICB0MDogZngudGltZSxcbiAgICAgICAgdDE6IGZ4LnRpbWUgKyBmeC5sZW5ndGgsXG4gICAgICAgIGR0OiAxLjAgLyB0aGlzLl9fYXV0b21hdG9uLnJlc29sdXRpb24sXG4gICAgICAgIHJlc29sdXRpb246IHRoaXMuX19hdXRvbWF0b24ucmVzb2x1dGlvbixcbiAgICAgICAgbGVuZ3RoOiBmeC5sZW5ndGgsXG4gICAgICAgIHBhcmFtczogZngucGFyYW1zLFxuICAgICAgICBhcnJheTogdGhpcy5fX3ZhbHVlcyxcbiAgICAgICAgZ2V0VmFsdWU6IHRoaXMuZ2V0VmFsdWUuYmluZCggdGhpcyApLFxuICAgICAgICBpbml0OiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZW1wTGVuZ3RoOyBpICsrICkge1xuICAgICAgICBjb250ZXh0LmkgPSBpICsgaTA7XG4gICAgICAgIGNvbnRleHQudCA9IGNvbnRleHQuaSAvIHRoaXMuX19hdXRvbWF0b24ucmVzb2x1dGlvbjtcbiAgICAgICAgY29udGV4dC52ID0gdGhpcy5fX3ZhbHVlc1sgaSArIGkwIF07XG4gICAgICAgIGNvbnRleHQucHJvZ3Jlc3MgPSAoIGNvbnRleHQudCAtIGZ4LnRpbWUgKSAvIGZ4Lmxlbmd0aDtcbiAgICAgICAgdGVtcFZhbHVlc1sgaSBdID0gZnhEZWYuZnVuYyggY29udGV4dCApO1xuXG4gICAgICAgIGNvbnRleHQuaW5pdCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9fdmFsdWVzLnNldCggdGVtcFZhbHVlcywgaTAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiBzcGVjaWZpZWQgdGltZSBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHtfdGltZX0gVGltZSBhdCB0aGUgcG9pbnQgeW91IHdhbnQgdG8gZ3JhYiB0aGUgdmFsdWUuXG4gICAqIElmIGl0IGlzIG5vdCBnaXZlbiwgdXNlIGN1cnJlbnQgdGltZSBvZiBwYXJlbnQgYXV0b21hdG9uIGluc3RlYWRcbiAgICogQHJldHVybnMge251bWJlcn0gUmVzdWx0IHZhbHVlXG4gICAqL1xuXG4gIGdldFZhbHVlKCBfdGltZSApIHtcbiAgICBsZXQgdGltZSA9IF90aW1lO1xuICAgIGlmICggdHlwZW9mIHRpbWUgIT09ICdudW1iZXInICkgeyAvLyB1c2UgcGFyZW50IGF1dG9tYXRvbiB0aW1lIGluc3RlYWRcbiAgICAgIHRpbWUgPSB0aGlzLl9fYXV0b21hdG9uLnRpbWU7XG4gICAgfVxuXG4gICAgaWYgKCB0aW1lID09PSB0aGlzLl9fbGFzdFRpbWUgKSB7IC8vIHVzZSB0aGUgYnVmZmVyIVxuICAgICAgcmV0dXJuIHRoaXMuX19sYXN0VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLl9fYXV0b21hdG9uLmxvb3AgKSB7XG4gICAgICB0aW1lID0gdGltZSAtIE1hdGguZmxvb3IoIHRpbWUgLyB0aGlzLl9fYXV0b21hdG9uLmxlbmd0aCApICogdGhpcy5fX2F1dG9tYXRvbi5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKCB0aW1lIDw9IDAuMCApIHsgLy8gbGVmdCBjbGFtcFxuICAgICAgcmV0dXJuIHRoaXMuX192YWx1ZXNbIDAgXTtcblxuICAgIH0gZWxzZSBpZiAoIHRoaXMuX19hdXRvbWF0b24ubGVuZ3RoIDw9IHRpbWUgKSB7IC8vIHJpZ2h0IGNsYW1wXG4gICAgICByZXR1cm4gdGhpcy5fX3ZhbHVlc1sgdGhpcy5fX3ZhbHVlcy5sZW5ndGggLSAxIF07XG5cbiAgICB9IGVsc2UgeyAvLyBmZXRjaCB0d28gdmFsdWUgdGhlbiBkbyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgY29uc3QgaW5kZXggPSB0aW1lICogdGhpcy5fX2F1dG9tYXRvbi5yZXNvbHV0aW9uO1xuICAgICAgY29uc3QgaW5kZXhpID0gTWF0aC5mbG9vciggaW5kZXggKTtcbiAgICAgIGNvbnN0IGluZGV4ZiA9IGluZGV4ICUgMS4wO1xuXG4gICAgICBjb25zdCB2MCA9IHRoaXMuX192YWx1ZXNbIGluZGV4aSBdO1xuICAgICAgY29uc3QgdjEgPSB0aGlzLl9fdmFsdWVzWyBpbmRleGkgKyAxIF07XG5cbiAgICAgIGNvbnN0IHYgPSB2MCArICggdjEgLSB2MCApICogaW5kZXhmO1xuXG4gICAgICAvLyBzdG9yZSBsYXN0VmFsdWVcbiAgICAgIHRoaXMuX19sYXN0VGltZSA9IHRpbWU7XG4gICAgICB0aGlzLl9fbGFzdFZhbHVlID0gdjtcblxuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgUGFyYW07IiwiPHRlbXBsYXRlPlxuPGRpdj5cbiAgPGRpdiBjbGFzcz1cImJsdXItbGF5ZXJcIlxuICAgIEBtb3VzZWRvd249XCJibHVyXCJcbiAgLz5cbiAgPGRpdiBjbGFzcz1cInJvb3RcIj5cbiAgICA8aW1nIGNsYXNzPVwibG9nby1iZ1wiXG4gICAgICA6c3JjPVwicmVxdWlyZSggJy4uL2ltYWdlcy9hdXRvbWF0b24tYS5zdmcnIClcIlxuICAgIC8+XG5cbiAgICA8aW1nIGNsYXNzPVwibG9nb1wiXG4gICAgICA6c3JjPVwicmVxdWlyZSggJy4uL2ltYWdlcy9hdXRvbWF0b24uc3ZnJyApXCJcbiAgICAvPlxuICAgIDxkaXYgY2xhc3M9XCJ2ZXJzaW9uXCI+e3sgYXV0b21hdG9uLnZlcnNpb24gfX08L2Rpdj48YnIgLz5cbiAgICBBbmltYXRpb24gZW5naW5lIHdpdGggVGltZWxpbmUgR1VJIGZvciBjcmVhdGl2ZSBjb2RpbmdcblxuICAgIDxkaXYgY2xhc3M9XCJsb2dvLWhyXCI+PC9kaXY+XG5cbiAgICBBdXRob3I6IDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZm1zLWNhdC9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5ARk1TX0NhdDwvYT48YnIgLz5cbiAgICBSZXBvc2l0b3J5OiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2Ztcy1jYXQvYXV0b21hdG9uL1wiIHRhcmdldD1cIl9ibGFua1wiPmh0dHBzOi8vZ2l0aHViLmNvbS9mbXMtY2F0L2F1dG9tYXRvbi88L2E+PGJyIC8+XG4gICAgQXV0b21hdG9uIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHBlcm1pc3NpdmUgPGEgaHJlZj1cImh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXCIgdGFyZ2V0PVwiX2JsYW5rXCI+TUlUIExpY2Vuc2U8L2E+LjxiciAvPlxuICAgIFNob3V0b3V0cyB0byA8YSBocmVmPVwiaHR0cHM6Ly93d3cuaW1hZ2UtbGluZS5jb20vZmxzdHVkaW8vXCIgdGFyZ2V0PVwiX2JsYW5rXCI+SW1hZ2UgTGluZSBTb2Z0d2FyZTwvYT4gJmx0OzNcblxuICAgIDxpbWcgY2xhc3M9XCJjbG9zZVwiXG4gICAgICA6c3JjPVwicmVxdWlyZSggJy4uL2ltYWdlcy9hYm91dC1jbG9zZS5zdmcnIClcIlxuICAgICAgQG1vdXNlZG93bj1cImJsdXJcIlxuICAgIC8+XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhYm91dCcsXG5cbiAgcHJvcHM6IFsgJ2F1dG9tYXRvbicgXSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7fVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBibHVyKCkge1xuICAgICAgdGhpcy4kZW1pdCggJ2JsdXInICk7XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCBcIi4vY29sb3JzLnNjc3NcIjtcblxuLmJsdXItbGF5ZXIge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcblxuICBiYWNrZ3JvdW5kOiAjMDAwMDAwNjY7XG59XG5cbi5yb290IHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBsZWZ0OiBjYWxjKCA1MCUgLSAxN2VtICk7XG4gIHRvcDogMWVtO1xuICB3aWR0aDogMzBlbTtcbiAgcGFkZGluZzogMWVtO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrMztcbiAgYm9yZGVyLXJhZGl1czogMC41ZW07XG4gIGNvbG9yOiAkY29sb3ItZm9yZTtcbiAgZm9udC1zaXplOiAwLjhlbTtcbiAgbGluZS1oZWlnaHQ6IDEuMjtcblxuICBmaWx0ZXI6IGRyb3Atc2hhZG93KCAwIDAgMnB4ICMwMDAwMDAgKTtcblxuICBhIHtcbiAgICBjb2xvcjogJGNvbG9yLWFjY2VudDtcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG5cbiAgICAmOmhvdmVyIHsgb3BhY2l0eTogMC43OyB9XG4gIH1cblxuICAubG9nby1iZyB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiAtMWVtO1xuICAgIGJvdHRvbTogLTFlbTtcbiAgICB3aWR0aDogMTRlbTtcblxuICAgIG9wYWNpdHk6IDAuMDc7XG4gIH1cblxuICAubG9nbyB7XG4gICAgd2lkdGg6IDIwZW07XG4gICAgbWFyZ2luLWJvdHRvbTogMC4zZW07XG4gIH1cblxuICAudmVyc2lvbiB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIHZlcnRpY2FsLWFsaWduOiBib3R0b207XG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcbiAgICBtYXJnaW4tYm90dG9tOiAwLjNlbTtcbiAgfVxuXG4gIC5sb2dvLWhyIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDFweDtcbiAgICBtYXJnaW46IDAuNWVtIDA7XG5cbiAgICBiYWNrZ3JvdW5kOiAkY29sb3ItZm9yZXN1YjtcbiAgfVxuXG4gIC5jbG9zZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiAwLjVlbTtcbiAgICB0b3A6IDAuNWVtO1xuICAgIHdpZHRoOiAxZW07XG5cbiAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAmOmhvdmVyIHsgb3BhY2l0eTogMC43OyB9XG4gIH1cbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG48ZGl2PlxuICA8ZGl2IGNsYXNzPVwiYmx1ci1sYXllclwiXG4gICAgdi1pZj1cImFjdGl2ZVwiXG4gICAgQG1vdXNlZG93bj1cImJsdXJcIlxuICAvPlxuICA8ZGl2IGNsYXNzPVwicm9vdFwiXG4gICAgdi1pZj1cImFjdGl2ZVwiXG4gICAgOnN0eWxlPVwie1xuICAgICAgbGVmdDogdHlwZW9mIGxlZnQgPT09ICdudW1iZXInID8gYCR7IGxlZnQgfXB4YCA6IHVuZGVmaW5lZCxcbiAgICAgIHJpZ2h0OiB0eXBlb2YgcmlnaHQgPT09ICdudW1iZXInID8gYCR7IHJpZ2h0IH1weGAgOiB1bmRlZmluZWQsXG4gICAgICB0b3A6IHR5cGVvZiB0b3AgPT09ICdudW1iZXInID8gYCR7IHRvcCB9cHhgIDogdW5kZWZpbmVkLFxuICAgICAgYm90dG9tOiB0eXBlb2YgYm90dG9tID09PSAnbnVtYmVyJyA/IGAkeyBib3R0b20gfXB4YCA6IHVuZGVmaW5lZFxuICAgIH1cIlxuICA+XG4gICAgPGRpdiBjbGFzcz1cImNvbW1hbmRcIlxuICAgICAgdi1mb3I9XCIoIGNvbW1hbmQsIGluZGV4ICkgaW4gY29tbWFuZHNcIlxuICAgICAgOmtleT1cIidjb21tYW5kJytpbmRleFwiXG4gICAgICBAbW91c2V1cD1cInNlbGVjdENvbW1hbmQoIGluZGV4IClcIlxuICAgID57eyBjb21tYW5kLnRleHQgfX08L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb250ZXh0LW1lbnUnLFxuXG4gIHByb3BzOiBbXG4gICAgJ2FjdGl2ZScsXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAnY29tbWFuZHMnXG4gIF0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgYmx1cigpIHtcbiAgICAgIHRoaXMuJGVtaXQoICdibHVyJyApO1xuICAgIH0sXG5cbiAgICBtb3ZlUm9vdCgpIHtcbiAgICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgICAgY29uc3QgdyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgICBjb25zdCBiTGVmdFNpZGUgPSB3IC0gMjQwIDwgeDtcbiAgICAgIGNvbnN0IGJVcFNpZGUgPSBoIC0gNDAgPCB5O1xuXG4gICAgICB0aGlzLmxlZnQgPSBiTGVmdFNpZGUgPyBudWxsIDogeDtcbiAgICAgIHRoaXMucmlnaHQgPSBiTGVmdFNpZGUgPyAoIHcgLSB4ICkgOiBudWxsO1xuICAgICAgdGhpcy50b3AgPSBiVXBTaWRlID8gbnVsbCA6IHk7XG4gICAgICB0aGlzLmJvdHRvbSA9IGJVcFNpZGUgPyAoIGggLSB5ICkgOiBudWxsO1xuICAgIH0sXG5cbiAgICBzZWxlY3RDb21tYW5kKCBpbmRleCApIHtcbiAgICAgIHRoaXMuY29tbWFuZHNbIGluZGV4IF0uZnVuYygpO1xuICAgICAgdGhpcy4kZW1pdCggJ2JsdXInICk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgeCgpIHsgdGhpcy5tb3ZlUm9vdCgpIH0sXG4gICAgeSgpIHsgdGhpcy5tb3ZlUm9vdCgpIH1cbiAgfVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG5AaW1wb3J0IFwiLi9jb2xvcnMuc2Nzc1wiO1xuXG4uYmx1ci1sYXllciB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgbGVmdDogMDtcbiAgdG9wOiAwO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xufVxuXG4ucm9vdCB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgcGFkZGluZzogMC40ZW07XG4gIGZvbnQtc2l6ZTogMC44ZW07XG5cbiAgYmFja2dyb3VuZDogcmdiYSggMCwgMCwgMCwgMC41ICk7XG4gIGJvcmRlcjogc29saWQgMXB4ICRjb2xvci1iYWNrNDtcbiAgY29sb3I6ICRjb2xvci1mb3Jlc3ViO1xuICBib3JkZXItcmFkaXVzOiAwLjJlbTtcblxuICBmaWx0ZXI6IGRyb3Atc2hhZG93KCAwIDAgMnB4ICMwMDAwMDAgKTtcblxuICAuY29tbWFuZCB7XG4gICAgcGFkZGluZy1sZWZ0OiAwLjJlbTtcbiAgICBwYWRkaW5nLXJpZ2h0OiAyZW07XG5cbiAgICBib3JkZXItcmFkaXVzOiAwLjJlbTtcblxuICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICY6aG92ZXIge1xuICAgICAgYmFja2dyb3VuZDogJGNvbG9yLWJhY2s0O1xuICAgICAgY29sb3I6ICRjb2xvci1mb3JlO1xuICAgIH1cbiAgfVxufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbjxkaXY+XG4gIDxkaXYgY2xhc3M9XCJyb290XCI+XG4gICAgPGRpdiBjbGFzcz1cInJvdyByb3ctY2VudGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibG9nb2JveFwiXG4gICAgICAgIEBjbGljay5zdG9wPVwiJGVtaXQoICdsb2dvQ2xpY2tlZCcgKVwiXG4gICAgICA+XG4gICAgICAgIDxpbWcgY2xhc3M9XCJsb2dvXCJcbiAgICAgICAgICA6c3JjPVwicmVxdWlyZSggJy4uL2ltYWdlcy9hdXRvbWF0b24uc3ZnJyApXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJyb3cgcm93LWxlZnRcIj5cbiAgICAgIDxpbWcgY2xhc3M9XCJidXR0b25cIlxuICAgICAgICA6c3JjPVwiYXV0b21hdG9uLmlzUGxheWluZyA/IHJlcXVpcmUoICcuLi9pbWFnZXMvcGF1c2Uuc3ZnJyApIDogcmVxdWlyZSggJy4uL2ltYWdlcy9wbGF5LnN2ZycgKVwiXG4gICAgICAgIEBjbGljay5zdG9wPVwiYXV0b21hdG9uLnRvZ2dsZVBsYXkoKVwiXG4gICAgICAvPlxuICAgICAgPGRpdiBjbGFzcz1cInRpbWVcIlxuICAgICAgICA6Y2xhc3M9XCJ7IHNlZWtpbmc6IHNlZWtpbmcgfVwiXG4gICAgICAgIEBtb3VzZWRvd24uc3RvcD1cInNlZWtcIlxuICAgICAgPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImN1cnJlbnRcIj57eyBhdXRvbWF0b24udGltZS50b0ZpeGVkKCAzICkgfX08L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibGVuZ3RoXCI+IC8ge3sgYXV0b21hdG9uLmxlbmd0aC50b0ZpeGVkKCAzICkgfX08L3NwYW4+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJiYXIgYmFyLWJnXCJcbiAgICAgICAgICA6c3R5bGU9XCJ7IHdpZHRoOiAnMTAwJScgfVwiXG4gICAgICAgID48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJhciBiYXItZmdcIlxuICAgICAgICAgIDpzdHlsZT1cInsgd2lkdGg6IGAkeyBhdXRvbWF0b24ucHJvZ3Jlc3MgKiAxMDAgfSVgIH1cIlxuICAgICAgICA+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicm93IHJvdy1yaWdodFwiPlxuICAgICAgPGltZyBjbGFzcz1cImJ1dHRvblwiXG4gICAgICAgIDpzcmM9XCJyZXF1aXJlKCAnLi4vaW1hZ2VzL3VuZG8uc3ZnJyApXCJcbiAgICAgICAgOnN0YWxrZXItdGV4dD1cImF1dG9tYXRvbi5nZXRVbmRvRGVzYygpID8gYFVuZG86ICR7YXV0b21hdG9uLmdldFVuZG9EZXNjKCl9YCA6ICdDYW5cXCd0IHVuZG8nXCJcbiAgICAgICAgQGNsaWNrLnN0b3A9XCJ1bmRvKClcIlxuICAgICAgLz5cbiAgICAgIDxpbWcgY2xhc3M9XCJidXR0b25cIlxuICAgICAgICA6c3JjPVwicmVxdWlyZSggJy4uL2ltYWdlcy9yZWRvLnN2ZycgKVwiXG4gICAgICAgIDpzdGFsa2VyLXRleHQ9XCJhdXRvbWF0b24uZ2V0UmVkb0Rlc2MoKSA/IGBSZWRvOiAke2F1dG9tYXRvbi5nZXRSZWRvRGVzYygpfWAgOiAnQ2FuXFwndCByZWRvJ1wiXG4gICAgICAgIEBjbGljay5zdG9wPVwicmVkbygpXCJcbiAgICAgIC8+XG4gICAgICA8aW1nIGNsYXNzPVwiYnV0dG9uXCJcbiAgICAgICAgOnNyYz1cInJlcXVpcmUoICcuLi9pbWFnZXMvc25hcC5zdmcnIClcIlxuICAgICAgICBzdGFsa2VyLXRleHQ9XCJTbmFwIFNldHRpbmdzXCJcbiAgICAgICAgQGNsaWNrLnN0b3A9XCIkZW1pdCggJ2NvbmZpZ1NlbGVjdGVkJywgJ3NuYXAnIClcIlxuICAgICAgLz5cbiAgICAgIDxpbWcgY2xhc3M9XCJidXR0b25cIlxuICAgICAgICA6c3JjPVwicmVxdWlyZSggJy4uL2ltYWdlcy9jb2cuc3ZnJyApXCJcbiAgICAgICAgc3RhbGtlci10ZXh0PVwiR2VuZXJhbCBDb25maWdcIlxuICAgICAgICBAY2xpY2suc3RvcD1cIiRlbWl0KCAnY29uZmlnU2VsZWN0ZWQnLCAnZ2VuZXJhbCcgKVwiXG4gICAgICAvPlxuICAgICAgPGltZyBjbGFzcz1cImJ1dHRvblwiXG4gICAgICAgIDpzcmM9XCJyZXF1aXJlKCAnLi4vaW1hZ2VzL3NhdmUuc3ZnJyApXCJcbiAgICAgICAgOnN0YWxrZXItdGV4dD1cInNhdmVUZXh0XCJcbiAgICAgICAgQGNsaWNrLnN0b3A9XCJzYXZlXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG1vdW50ZWQoKSB7fSxcblxuICBiZWZvcmVEZXN0cm95KCkge30sXG5cbiAgcHJvcHM6IFsgXCJhdXRvbWF0b25cIiBdLFxuXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhdmVUZXh0OiAnQ29weSBjdXJyZW50IHN0YXRlIGFzIEpTT04nLFxuICAgICAgc2Vla2luZzogZmFsc2UsXG4gICAgICBjYW50VW5kb1RoaXM6IDBcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHNlZWsoIGV2ZW50ICkge1xuICAgICAgY29uc3Qgd2lkdGggPSBldmVudC50YXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgICBjb25zdCB4T2Zmc2V0MCA9IGV2ZW50Lm9mZnNldFg7XG4gICAgICBjb25zdCB4Q2xpZW50MCA9IGV2ZW50LmNsaWVudFg7XG5cbiAgICAgIGNvbnN0IGlzUGxheWluZzAgPSB0aGlzLmF1dG9tYXRvbi5pc1BsYXlpbmc7XG5cbiAgICAgIGlmICggaXNQbGF5aW5nMCApIHtcbiAgICAgICAgdGhpcy5hdXRvbWF0b24ucGF1c2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXV0b21hdG9uLnNlZWsoIHRoaXMuYXV0b21hdG9uLmxlbmd0aCAqIHhPZmZzZXQwIC8gd2lkdGggKTtcblxuICAgICAgdGhpcy5zZWVraW5nID0gdHJ1ZTtcblxuICAgICAgY29uc3QgbW92ZSA9ICggZXZlbnQgKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSB4T2Zmc2V0MCArIGV2ZW50LmNsaWVudFggLSB4Q2xpZW50MDtcbiAgICAgICAgdGhpcy5hdXRvbWF0b24uc2VlayggdGhpcy5hdXRvbWF0b24ubGVuZ3RoICogeCAvIHdpZHRoICk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cCA9ICggZXZlbnQgKSA9PiB7XG4gICAgICAgIGlmICggaXNQbGF5aW5nMCApIHtcbiAgICAgICAgICB0aGlzLmF1dG9tYXRvbi5wbGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWVraW5nID0gZmFsc2U7XG5cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBtb3ZlICk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIHVwICk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdmUgKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIHVwICk7XG4gICAgfSxcblxuICAgIHVuZG8oKSB7XG4gICAgICBpZiAoIHRoaXMuYXV0b21hdG9uLmdldFVuZG9EZXNjKCkgKSB7XG4gICAgICAgIHRoaXMuYXV0b21hdG9uLnVuZG8oKTtcbiAgICAgICAgdGhpcy5jYW50VW5kb1RoaXMgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYW50VW5kb1RoaXMgKys7XG4gICAgICAgIGlmICggMTAgPT09IHRoaXMuY2FudFVuZG9UaGlzICkge1xuICAgICAgICAgIHdpbmRvdy5vcGVuKCAnaHR0cHM6Ly95b3V0dS5iZS9ielk3SjBYbGUwOCcsICdfYmxhbmsnICk7XG4gICAgICAgICAgdGhpcy5jYW50VW5kb1RoaXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVtaXQoICdoaXN0b3J5TW92ZWQnICk7XG4gICAgfSxcblxuICAgIHJlZG8oKSB7XG4gICAgICB0aGlzLmF1dG9tYXRvbi5yZWRvKCk7XG5cbiAgICAgIHRoaXMuJGVtaXQoICdoaXN0b3J5TW92ZWQnICk7XG4gICAgfSxcblxuICAgIHNhdmUoKSB7XG4gICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICd0ZXh0YXJlYScgKTtcbiAgICAgIGVsLnZhbHVlID0gdGhpcy5hdXRvbWF0b24uc2F2ZSgpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggZWwgKTtcbiAgICAgIGVsLnNlbGVjdCgpO1xuICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoICdjb3B5JyApO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCggZWwgKTtcblxuICAgICAgdGhpcy5zYXZlVGV4dCA9ICdDb3BpZWQhJztcbiAgICAgIHNldFRpbWVvdXQoICgpID0+IHtcbiAgICAgICAgdGhpcy5zYXZlVGV4dCA9ICdDb3B5IGN1cnJlbnQgc3RhdGUgYXMgSlNPTic7XG4gICAgICB9LCAzMDAwICk7XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCBcIi4vY29sb3JzLnNjc3NcIjtcblxuLnJvb3Qge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcblxuICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazQ7XG5cbiAgLnJvdyB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGhlaWdodDogY2FsYyggMTAwJSAtIDAuMjVlbSApO1xuICAgIG1hcmdpbjogMC4xMjVlbTtcblxuICAgICYucm93LWNlbnRlciB7XG4gICAgICB3aWR0aDogY2FsYyggMTAwJSAtIDAuMjVlbSApO1xuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cbiAgICAmLnJvdy1sZWZ0IHsgbGVmdDogMC4xMjVlbTsgfVxuICAgICYucm93LXJpZ2h0IHsgcmlnaHQ6IDAuMTI1ZW07IH1cblxuICAgICYgPiAqIHtcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHZlcnRpY2FsLWFsaWduOiBib3R0b207XG4gICAgICBtYXJnaW46IDAgMC4xMjVlbTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5cbiAgICAubG9nb2JveCB7XG4gICAgICBjb2xvcjogJGNvbG9yLWZvcmU7XG4gICAgICBvcGFjaXR5OiAwLjU7XG5cbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgJjpob3ZlciB7IG9wYWNpdHk6IDAuODsgfVxuXG4gICAgICAubG9nbyB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBoZWlnaHQ6IDYwJTtcbiAgICAgICAgdG9wOiAyMCU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLmJ1dHRvbiB7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgJjpob3ZlciB7IG9wYWNpdHk6IDAuNzsgfVxuICAgIH1cblxuICAgIC50aW1lIHtcbiAgICAgIHdpZHRoOiA4ZW07XG5cbiAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICB0ZXh0LWFsaWduOiByaWdodDtcblxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAqIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIC5jdXJyZW50IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBmb250LXNpemU6IDAuOGVtO1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDA7XG5cbiAgICAgICAgY29sb3I6ICRjb2xvci1mb3JlO1xuXG4gICAgICB9XG5cbiAgICAgIC5sZW5ndGgge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGZvbnQtc2l6ZTogMC42ZW07XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xuXG4gICAgICAgIGNvbG9yOiAkY29sb3ItZm9yZXN1YjtcbiAgICAgIH1cblxuICAgICAgLmJhciB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvdHRvbTogMC4yNWVtO1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIGhlaWdodDogMnB4O1xuICAgICAgICBtYXJnaW46IDA7XG5cbiAgICAgICAgJi5iYXItYmcgeyBiYWNrZ3JvdW5kOiAkY29sb3ItYmxhY2s7IH1cbiAgICAgICAgJi5iYXItZmcgeyBiYWNrZ3JvdW5kOiAkY29sb3ItZm9yZTsgfVxuICAgICAgfVxuXG4gICAgICAmOmhvdmVyIHtcbiAgICAgICAgLmJhci1mZyB7IGJhY2tncm91bmQ6ICRjb2xvci1hY2NlbnQ7IH1cbiAgICAgIH1cblxuICAgICAgJi5zZWVraW5nIHtcbiAgICAgICAgLmJhci1mZyB7IGJhY2tncm91bmQ6ICRjb2xvci1hY2NlbnQ7IH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc3R5bGU+XG5cbiIsIjx0ZW1wbGF0ZT5cbjxkaXY+XG4gIDxkaXYgY2xhc3M9XCJyb290IGF1dG9tYXRvbiBjb2xvci10aGVtZS1kYXJrXCI+XG4gICAgPEhlYWRlciBjbGFzcz1cImhlYWRlclwiXG4gICAgICA6YXV0b21hdG9uPVwiYXV0b21hdG9uXCJcbiAgICAgIEBoaXN0b3J5TW92ZWQ9XCJvbkhpc3RvcnlNb3ZlZFwiXG4gICAgICBAY29uZmlnU2VsZWN0ZWQ9XCJvbkNvbmZpZ1NlbGVjdGVkXCJcbiAgICAgIEBjb250ZXh0PVwib3BlbkNvbnRleHRNZW51XCJcbiAgICAgIEBsb2dvQ2xpY2tlZD1cImFib3V0QWN0aXZlID0gdHJ1ZVwiXG4gICAgLz5cbiAgICA8UGFyYW1MaXN0IGNsYXNzPVwicGFyYW1saXN0XCJcbiAgICAgIDphdXRvbWF0b249XCJhdXRvbWF0b25cIlxuICAgICAgOnNlbGVjdGVkUGFyYW1OYW1lPVwic2VsZWN0ZWRQYXJhbU5hbWVcIlxuICAgICAgQHNlbGVjdGVkPVwic2VsZWN0UGFyYW0oICRldmVudCApXCJcbiAgICAgIEBjb250ZXh0PVwib3BlbkNvbnRleHRNZW51XCJcbiAgICAvPlxuICAgIDxQcm9wTWVudSBjbGFzcz1cInByb3BtZW51XCJcbiAgICAgIDphdXRvbWF0b249XCJhdXRvbWF0b25cIlxuICAgICAgOnNlbGVjdGVkUGFyYW1OYW1lPVwic2VsZWN0ZWRQYXJhbU5hbWVcIlxuICAgICAgOnNlbGVjdGVkTm9kZUlkcz1cInNlbGVjdGVkTm9kZUlkc1wiXG4gICAgICA6c2VsZWN0ZWRGeElkcz1cInNlbGVjdGVkRnhJZHNcIlxuICAgICAgOmNvbmZpZz1cImNvbmZpZ1wiXG4gICAgICBAY29udGV4dD1cIm9wZW5Db250ZXh0TWVudVwiXG4gICAgLz5cbiAgICA8VGltZWxpbmUgY2xhc3M9XCJ0aW1lbGluZVwiXG4gICAgICA6YXV0b21hdG9uPVwiYXV0b21hdG9uXCJcbiAgICAgIDpzZWxlY3RlZFBhcmFtTmFtZT1cInNlbGVjdGVkUGFyYW1OYW1lXCJcbiAgICAgIDpzZWxlY3RlZE5vZGVJZHM9XCJzZWxlY3RlZE5vZGVJZHNcIlxuICAgICAgOnNlbGVjdGVkRnhJZHM9XCJzZWxlY3RlZEZ4SWRzXCJcbiAgICAgIEBub2RlU2VsZWN0ZWQ9XCJzZWxlY3ROb2RlcyggJGV2ZW50IClcIlxuICAgICAgQGZ4U2VsZWN0ZWQ9XCJzZWxlY3RGeHMoICRldmVudCApXCJcbiAgICAgIEBjb250ZXh0PVwib3BlbkNvbnRleHRNZW51XCJcbiAgICAvPlxuXG4gICAgPEFib3V0IGNsYXNzPVwiYWJvdXRcIlxuICAgICAgdi1pZj1cImFib3V0QWN0aXZlXCJcbiAgICAgIDphdXRvbWF0b249XCJhdXRvbWF0b25cIlxuICAgICAgQGJsdXI9XCJhYm91dEFjdGl2ZSA9IGZhbHNlXCJcbiAgICAvPlxuXG4gICAgPENvbnRleHRNZW51IGNsYXNzPVwiY29udGV4dC1tZW51XCJcbiAgICAgIDphY3RpdmU9XCJjb250ZXh0TWVudUFjdGl2ZVwiXG4gICAgICA6eD1cImNvbnRleHRNZW51WFwiXG4gICAgICA6eT1cImNvbnRleHRNZW51WVwiXG4gICAgICA6Y29tbWFuZHM9XCJjb250ZXh0TWVudUNvbW1hbmRzXCJcbiAgICAgIEBibHVyPVwiY29udGV4dE1lbnVBY3RpdmUgPSBmYWxzZVwiXG4gICAgLz5cbiAgICA8U3RhbGtlciBjbGFzcz1cInN0YWxrZXJcIiAvPlxuICA8L2Rpdj5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuXG48c2NyaXB0PlxuaW1wb3J0IEFib3V0IGZyb20gJy4vYWJvdXQudnVlJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi9oZWFkZXIudnVlJztcbmltcG9ydCBQYXJhbUxpc3QgZnJvbSAnLi9wYXJhbWxpc3QudnVlJztcbmltcG9ydCBQcm9wTWVudSBmcm9tICcuL3Byb3BtZW51LnZ1ZSc7XG5pbXBvcnQgVGltZWxpbmUgZnJvbSAnLi90aW1lbGluZS52dWUnO1xuaW1wb3J0IENvbnRleHRNZW51IGZyb20gJy4vY29udGV4dC1tZW51LnZ1ZSc7XG5pbXBvcnQgU3RhbGtlciBmcm9tICcuL3N0YWxrZXIudnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgQWJvdXQsXG4gICAgSGVhZGVyLFxuICAgIFBhcmFtTGlzdCxcbiAgICBQcm9wTWVudSxcbiAgICBUaW1lbGluZSxcbiAgICBDb250ZXh0TWVudSxcbiAgICBTdGFsa2VyXG4gIH0sXG5cbiAgcHJvcHM6IFsgJ2F1dG9tYXRvbicgXSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhYm91dEFjdGl2ZTogZmFsc2UsXG4gICAgICBzZWxlY3RlZFBhcmFtTmFtZTogbnVsbCxcbiAgICAgIHNlbGVjdGVkTm9kZUlkczogW10sXG4gICAgICBzZWxlY3RlZEZ4SWRzOiBbXSxcbiAgICAgIGNvbmZpZzogJycsXG4gICAgICBjb250ZXh0TWVudUFjdGl2ZTogZmFsc2UsXG4gICAgICBjb250ZXh0TWVudVg6IDAsXG4gICAgICBjb250ZXh0TWVudVk6IDAsXG4gICAgICBjb250ZXh0TWVudUNvbW1hbmRzOiBbXVxuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgc2VsZWN0UGFyYW0oIG5hbWUgKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkUGFyYW1OYW1lID0gbmFtZTtcbiAgICAgIHRoaXMuc2VsZWN0Tm9kZXMoIFtdICk7XG4gICAgICB0aGlzLnNlbGVjdEZ4cyggW10gKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0Tm9kZXMoIGFyciApIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWROb2RlSWRzID0gYXJyO1xuICAgICAgdGhpcy5jb25maWcgPSAnJztcbiAgICB9LFxuXG4gICAgc2VsZWN0RnhzKCBhcnIgKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkRnhJZHMgPSBhcnI7XG4gICAgICB0aGlzLmNvbmZpZyA9ICcnO1xuICAgIH0sXG5cbiAgICBvbkhpc3RvcnlNb3ZlZCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0Tm9kZXMoIFtdICk7XG4gICAgICB0aGlzLnNlbGVjdEZ4cyggW10gKTtcbiAgICB9LFxuXG4gICAgb25Db25maWdTZWxlY3RlZCggY29uZmlnICkge1xuICAgICAgdGhpcy5zZWxlY3ROb2RlcyggW10gKTtcbiAgICAgIHRoaXMuc2VsZWN0RnhzKCBbXSApO1xuICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfSxcblxuICAgIG9wZW5Db250ZXh0TWVudSggZXZlbnQgKSB7XG4gICAgICB0aGlzLmNvbnRleHRNZW51QWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udGV4dE1lbnVYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIHRoaXMuY29udGV4dE1lbnVZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIHRoaXMuY29udGV4dE1lbnVDb21tYW5kcyA9IGV2ZW50LmNvbW1hbmRzO1xuICAgIH1cbiAgfSxcbiAgXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy4kcm9vdC4kb24oICdsb2FkZWQnLCAoKSA9PiB7XG4gICAgICB0aGlzLnNlbGVjdFBhcmFtKCBudWxsICk7XG4gICAgICB0aGlzLnNlbGVjdE5vZGVzKCBbXSApO1xuICAgICAgdGhpcy5zZWxlY3RGeHMoIFtdICk7XG4gICAgICB0aGlzLmNvbmZpZyA9ICcnO1xuICAgIH0gKTtcbiAgfSxcblxuICBiZWZvcmVEZXN0cm95KCkge31cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgdXJsKCdodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9Um9ib3RvOjMwMCw0MDAsNTAwLDcwMCw5MDAnKTtcblxuLmF1dG9tYXRvbiB7XG4gIGZvbnQtZmFtaWx5OiAnUm9ib3RvJywgc2Fucy1zZXJpZjtcbiAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgZm9udC1zaXplOiAxNnB4O1xufVxuPC9zdHlsZT5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCBcIi4vY29sb3JzLnNjc3NcIjtcblxuLnJvb3Qge1xuICB1c2VyLXNlbGVjdDogbm9uZTtcblxuICAkaGVhZGVyLWhlaWdodDogMmVtO1xuICAuaGVhZGVyIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICB0b3A6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAkaGVhZGVyLWhlaWdodDtcbiAgfVxuXG4gICRwYXJhbWxpc3Qtd2lkdGg6IDhlbTtcbiAgLnBhcmFtbGlzdCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGxlZnQ6IDA7XG4gICAgdG9wOiAkaGVhZGVyLWhlaWdodDtcbiAgICB3aWR0aDogJHBhcmFtbGlzdC13aWR0aDtcbiAgICBoZWlnaHQ6IGNhbGMoIDEwMCUgLSAjeyRoZWFkZXItaGVpZ2h0fSApO1xuICB9XG5cbiAgJHByb3BtZW51LXdpZHRoOiAxMmVtO1xuICAucHJvcG1lbnUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMDtcbiAgICB0b3A6ICRoZWFkZXItaGVpZ2h0O1xuICAgIHdpZHRoOiAkcHJvcG1lbnUtd2lkdGg7XG4gICAgaGVpZ2h0OiBjYWxjKCAxMDAlIC0gI3skaGVhZGVyLWhlaWdodH0gKTtcbiAgfVxuXG4gIC50aW1lbGluZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGxlZnQ6ICRwYXJhbWxpc3Qtd2lkdGg7XG4gICAgdG9wOiAkaGVhZGVyLWhlaWdodDtcbiAgICB3aWR0aDogY2FsYyggMTAwJSAtICN7JHBhcmFtbGlzdC13aWR0aCArICRwcm9wbWVudS13aWR0aH0gKTtcbiAgICBoZWlnaHQ6IGNhbGMoIDEwMCUgLSAjeyRoZWFkZXItaGVpZ2h0fSApO1xuICB9XG59XG48L3N0eWxlPlxuXG4iLCI8dGVtcGxhdGU+XG48ZGl2PlxuICA8U2Nyb2xsYWJsZSBjbGFzcz1cInJvb3RcIlxuICAgIGJhcj1cImxlZnRcIlxuICA+XG4gICAgPGRpdiBjbGFzcz1cInBhcmFtXCJcbiAgICAgIHYtZm9yPVwibmFtZSBpbiBhdXRvbWF0b24uZ2V0UGFyYW1OYW1lcygpXCJcbiAgICAgIDprZXk9XCIncGFyYW0nICsgbmFtZVwiXG4gICAgICA6Y2xhc3M9XCJ7IHNlbGVjdGVkOiBuYW1lID09PSBzZWxlY3RlZFBhcmFtTmFtZSB9XCJcbiAgICAgIDpzdGFsa2VyLXRleHQ9XCJuYW1lXCJcbiAgICAgIEBjbGljaz1cIiRlbWl0KCAnc2VsZWN0ZWQnLCBuYW1lIClcIlxuICAgICAgQGNvbnRleHRtZW51LnN0b3AucHJldmVudD1cImNvbnRleHRQYXJhbSggJGV2ZW50LCBuYW1lIClcIlxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJuYW1lXCJcbiAgICAgICAgOnN0YWxrZXItdGV4dD1cIm5hbWVcIlxuICAgICAgPnt7IG5hbWUgfX08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ2YWx1ZVwiXG4gICAgICAgIHYtaWY9XCJhdXRvbWF0b24uZ2V0UGFyYW0oIG5hbWUgKS5pc1VzZWQoKVwiXG4gICAgICAgIDpzdGFsa2VyLXRleHQ9XCJuYW1lXCJcbiAgICAgID57eyBhdXRvbWF0b24uYXV0byggbmFtZSApLnRvRml4ZWQoIDMgKSB9fTwvZGl2PlxuICAgICAgPGltZyBjbGFzcz1cIndhcm5pbmdcIlxuICAgICAgICB2LWlmPVwiIWF1dG9tYXRvbi5nZXRQYXJhbSggbmFtZSApLmlzVXNlZCgpXCJcbiAgICAgICAgOnNyYz1cInJlcXVpcmUoICcuLi9pbWFnZXMvd2FybmluZy5zdmcnIClcIlxuICAgICAgICBzdGFsa2VyLXRleHQ9XCJUaGlzIHBhcmFtIGhhcyBub3QgYmVlbiB1c2VkIHlldFwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICA8L1Njcm9sbGFibGU+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgU2Nyb2xsYWJsZSBmcm9tICcuL3Njcm9sbGFibGUudnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgU2Nyb2xsYWJsZVxuICB9LFxuXG4gIHByb3BzOiBbIFwiYXV0b21hdG9uXCIsIFwic2VsZWN0ZWRQYXJhbU5hbWVcIiBdLFxuXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGNvbnRleHRQYXJhbSggZXZlbnQsIG5hbWUgKSB7XG4gICAgICB0aGlzLiRlbWl0KCAnY29udGV4dCcsIHtcbiAgICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgY29tbWFuZHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0OiAnU2VsZWN0IFBhcmFtJyxcbiAgICAgICAgICAgIGZ1bmM6ICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy4kZW1pdCggJ3NlbGVjdGVkJywgbmFtZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dDogJ1JlbW92ZSBQYXJhbScsXG4gICAgICAgICAgICBmdW5jOiAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYXV0b21hdG9uLnJlbW92ZVBhcmFtKCBuYW1lICk7XG4gICAgICAgICAgICAgIHRoaXMuJGVtaXQoICdzZWxlY3RlZCcsIG51bGwgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0gKTtcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG5AaW1wb3J0IFwiLi9jb2xvcnMuc2Nzc1wiO1xuXG4ucm9vdCB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMDtcbiAgdG9wOiAwO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuXG4gIGJhY2tncm91bmQ6ICRjb2xvci1iYWNrMjtcbiAgY29sb3I6ICRjb2xvci1mb3JlO1xuXG4gIC5wYXJhbSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiBjYWxjKCAxMDAlIC0gNHB4ICk7XG4gICAgaGVpZ2h0OiAxLjI1ZW07XG4gICAgbWFyZ2luOiAycHg7XG5cbiAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazM7XG4gICAgY29sb3I6ICRjb2xvci1mb3Jlc3ViO1xuXG4gICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgJi5zZWxlY3RlZCB7XG4gICAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazQ7XG4gICAgICBjb2xvcjogJGNvbG9yLWZvcmU7XG4gICAgfVxuXG4gICAgLm5hbWUge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgbGVmdDogMC4yZW07XG4gICAgICB0b3A6IDA7XG4gICAgICB3aWR0aDogY2FsYyggMTAwJSAtIDJlbSApO1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcblxuICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgfVxuXG4gICAgLnZhbHVlIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHJpZ2h0OiAwLjJlbTtcbiAgICAgIGJvdHRvbTogMC4xZW07XG5cbiAgICAgIGZvbnQtc2l6ZTogMC42ZW07XG4gICAgICBvcGFjaXR5OiAwLjc7XG5cbiAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIH1cblxuICAgIC53YXJuaW5nIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHJpZ2h0OiAwLjFlbTtcbiAgICAgIGJvdHRvbTogMC4xZW07XG4gICAgICBoZWlnaHQ6IGNhbGMoIDEwMCUgLSAwLjJlbSApO1xuICAgIH1cbiAgfVxufVxuPC9zdHlsZT5cblxuIiwiPHRlbXBsYXRlPlxuPGRpdj5cbiAgPGRpdiBjbGFzcz1cInByb3Bib3hcIj5cbiAgICA8ZGl2IGNsYXNzPVwibmFtZVwiPnt7IG5hbWUgfX08L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ2YWx1ZSBudW1iZXJcIlxuICAgICAgdi1pZj1cInR5cGUgPT09ICdmbG9hdCcgfHwgdHlwZSA9PT0gJ2ludCdcIlxuICAgICAgOmNsYXNzPVwieyByZWFkb25seTogcmVhZG9ubHkgfVwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cInZhbHVlVGV4dFwiXG4gICAgICAgIDpjbGFzcz1cInsgcmVhZG9ubHk6IHJlYWRvbmx5IH1cIlxuICAgICAgICBAbW91c2Vkb3duPVwibk1vdXNlZG93blwiXG4gICAgICA+e3sgdHlwZSA9PT0gJ2ludCcgPyB2YWx1ZSA6IHZhbHVlLnRvRml4ZWQoIDMgKSB9fTwvZGl2PlxuICAgICAgPGlucHV0IGNsYXNzPVwidmFsdWVJbnB1dFwiXG4gICAgICAgIHJlZj1cInZhbHVlSW5wdXRcIlxuICAgICAgICB2LXNob3c9XCJpbnB1dFwiXG4gICAgICAgIEBrZXlkb3duLmVudGVyPVwibkVudGVyXCJcbiAgICAgICAgQGJsdXI9XCJuQmx1clwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInZhbHVlIGJvb2xlYW5cIlxuICAgICAgdi1pZj1cInR5cGUgPT09ICdib29sZWFuJ1wiXG4gICAgICA6Y2xhc3M9XCJ7IHJlYWRvbmx5OiByZWFkb25seSB9XCJcbiAgICAgIEBjbGljaz1cImJUb2dnbGVcIlxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJib29sZWFuQ2hlY2tcIlxuICAgICAgICB2LXNob3c9XCJ2YWx1ZVwiXG4gICAgICA+PC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuY29uc3QgbW91c2VFdmVudHMgPSAoIG1vdmUsIHVwICkgPT4ge1xuICBjb25zdCB1ID0gKCBldmVudCApID0+IHtcbiAgICBpZiAoIHR5cGVvZiB1cCA9PT0gXCJmdW5jdGlvblwiICkgeyB1cCggZXZlbnQgKTsgfSBcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcIm1vdXNlbW92ZVwiLCBtb3ZlICk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibW91c2V1cFwiLCB1ICk7XG4gIH07XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibW91c2Vtb3ZlXCIsIG1vdmUgKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibW91c2V1cFwiLCB1ICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcm9wYm94JyxcblxuICBwcm9wczogW1xuICAgICduYW1lJyxcbiAgICAndmFsdWUnLFxuICAgICd0eXBlJyxcbiAgICAnbWluJyxcbiAgICAnbWF4JyxcbiAgICAncmVhZG9ubHknXG4gIF0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXQ6IGZhbHNlLFxuICAgICAgbGFzdENsaWNrOiAwXG4gICAgfTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgbk1vdXNlZG93biggZXZlbnQgKSB7XG4gICAgICBpZiAoIHRoaXMucmVhZG9ubHkgKSB7IHJldHVybjsgfVxuXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKCBub3cgLSB0aGlzLmxhc3RDbGljayA8IDUwMCApIHsgLy8gZG91YmxlY2xpY2tcbiAgICAgICAgdGhpcy5pbnB1dCA9IHRydWU7XG4gICAgICAgIHRoaXMuJHJlZnMudmFsdWVJbnB1dC52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHNldFRpbWVvdXQoICgpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLnZhbHVlSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICB0aGlzLiRyZWZzLnZhbHVlSW5wdXQuc2VsZWN0KCk7XG4gICAgICAgIH0sIDEwICk7IC8vIPCflKVcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdENsaWNrID0gbm93O1xuXG4gICAgICBjb25zdCB5MCA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBsZXQgbGFzdFkgPSB5MDtcbiAgICAgIGNvbnN0IHYwID0gTnVtYmVyKCB0aGlzLnZhbHVlICk7XG5cbiAgICAgIG1vdXNlRXZlbnRzKCAoIGV2ZW50ICkgPT4ge1xuICAgICAgICBsZXQgdiA9IE51bWJlciggdGhpcy52YWx1ZSApO1xuICAgICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgY29uc3QgZHkgPSBsYXN0WSAtIHk7XG4gICAgICAgIGxhc3RZID0geTtcblxuICAgICAgICBpZiAoIHRoaXMudHlwZSA9PT0gJ2ludCcgKSB7XG4gICAgICAgICAgdiA9IHYwIC0gTWF0aC5mbG9vciggKCB5IC0geTAgKSAvIDEwLjAgKTtcbiAgICAgICAgfSBlbHNlIGlmICggZXZlbnQuc2hpZnRLZXkgKSB7XG4gICAgICAgICAgY29uc3QgZHlBYnMgPSBNYXRoLmFicyggZHkgKTtcbiAgICAgICAgICBjb25zdCBkeVNpZ24gPSBNYXRoLnNpZ24oIGR5ICk7XG4gICAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgZHlBYnM7IGkgKysgKSB7XG4gICAgICAgICAgICBjb25zdCB2QWJzID0gTWF0aC5hYnMoIHYgKTtcbiAgICAgICAgICAgIGNvbnN0IHZTaWduID0gTWF0aC5zaWduKCB2ICsgMUUtNCAqIGR5U2lnbiApO1xuICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBNYXRoLmZsb29yKCBNYXRoLmxvZzEwKCB2QWJzICsgMUUtNCAqIGR5U2lnbiAqIHZTaWduICkgKSAtIDEgLSAoIGV2ZW50LmFsdEtleSA/IDEgOiAwICk7XG4gICAgICAgICAgICB2ICs9IE1hdGgubWF4KCAwLjAwMSwgTWF0aC5wb3coIDEwLjAsIG9yZGVyICkgKSAqIGR5U2lnbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdiArPSBkeSAqICggZXZlbnQuYWx0S2V5ID8gMC4wMDEgOiAwLjAxICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMubWF4ICkgeyB2ID0gTWF0aC5taW4oIHYsIHBhcnNlRmxvYXQoIHRoaXMubWF4ICkgKTsgfVxuICAgICAgICBpZiAoIHRoaXMubWluICkgeyB2ID0gTWF0aC5tYXgoIHYsIHBhcnNlRmxvYXQoIHRoaXMubWluICkgKTsgfVxuICAgICAgICB2ID0gdGhpcy50eXBlID09PSAnaW50JyA/IHYgOiBOdW1iZXIoIHYudG9GaXhlZCggMyApICk7XG4gICAgICAgIHRoaXMuJGVtaXQoICdjaGFuZ2VkJywgdiApO1xuICAgICAgfSwgKCBldmVudCApID0+IHtcbiAgICAgICAgaWYgKCB2MCA9PT0gTnVtYmVyKCB0aGlzLnZhbHVlICkgKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLiRlbWl0KCAnZmluaXNoZWQnLCBbIHYwLCBOdW1iZXIoIHRoaXMudmFsdWUgKSBdICk7XG4gICAgICB9ICk7XG4gICAgfSxcblxuICAgIG5FbnRlciggZXZlbnQgKSB7XG4gICAgICBsZXQgdiA9IHBhcnNlRmxvYXQoIHRoaXMuJHJlZnMudmFsdWVJbnB1dC52YWx1ZSApO1xuICAgICAgaWYgKCB0aGlzLnR5cGUgPT09ICdpbnQnICkgeyB2ID0gTWF0aC5yb3VuZCggdiApOyB9XG4gXG4gICAgICB0aGlzLiRlbWl0KCAnY2hhbmdlZCcsIHYgKTtcbiAgICAgIHRoaXMuJGVtaXQoICdmaW5pc2hlZCcsIFsgTnVtYmVyKCB0aGlzLnZhbHVlICksIHYgXSApO1xuICAgICAgdGhpcy5pbnB1dCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBuQmx1ciggZXZlbnQgKSB7XG4gICAgICB0aGlzLmlucHV0ID0gZmFsc2U7XG4gICAgfSxcblxuICAgIGJUb2dnbGUoIGV2ZW50ICkge1xuICAgICAgaWYgKCB0aGlzLnJlYWRvbmx5ICkgeyByZXR1cm47IH1cblxuICAgICAgY29uc3QgdiA9ICF0aGlzLnZhbHVlO1xuICAgICAgdGhpcy4kZW1pdCggJ2NoYW5nZWQnLCB2ICk7XG4gICAgICB0aGlzLiRlbWl0KCAnZmluaXNoZWQnLCBbICF2LCB2IF0gKTtcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgXCIuL2NvbG9ycy5zY3NzXCI7XG5cbi5wcm9wYm94IHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxLjI1ZW07XG4gIG1hcmdpbi1ib3R0b206IDAuMjVlbTtcblxuICAubmFtZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGxlZnQ6IDA7XG4gICAgdG9wOiAwO1xuICAgIGhlaWdodDogMTAwJTtcblxuICAgIG1hcmdpbi10b3A6IDAuMWVtO1xuICB9XG5cbiAgLnZhbHVlIHtcbiAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazM7XG5cbiAgICAmOmFjdGl2ZTpub3QoLnJlYWRvbmx5KSB7XG4gICAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazE7XG4gICAgfVxuXG4gICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgJi5yZWFkb25seSB7XG4gICAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xuICAgIH1cbiAgfVxuXG4gIC5udW1iZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMDtcbiAgICB0b3A6IDA7XG4gICAgd2lkdGg6IDVlbTtcbiAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAudmFsdWVUZXh0IHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgbWFyZ2luLXRvcDogMC4xZW07XG5cbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcblxuICAgICAgJi5yZWFkb25seSB7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAudmFsdWVJbnB1dCB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgdG9wOiAwO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBib3JkZXI6IG5vbmU7XG4gICAgICBwYWRkaW5nOiAwO1xuXG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazU7XG4gICAgICBjb2xvcjogJGNvbG9yLWZvcmU7XG4gICAgfVxuICB9XG5cbiAgLmJvb2xlYW4ge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMS44NzVlbTtcbiAgICB0b3A6IDA7XG4gICAgd2lkdGg6IDEuMjVlbTtcbiAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAuYm9vbGVhbkNoZWNrIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGxlZnQ6IDIwJTtcbiAgICAgIHRvcDogMjAlO1xuICAgICAgd2lkdGg6IDYwJTtcbiAgICAgIGhlaWdodDogNjAlO1xuICAgICAgXG4gICAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYWNjZW50O1xuXG4gICAgICAmLnJlYWRvbmx5IHtcbiAgICAgICAgYmFja2dyb3VuZDogJGNvbG9yLWdyYXk7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc3R5bGU+IiwiPHRlbXBsYXRlPlxuPGRpdj5cbiAgPFNjcm9sbGFibGUgY2xhc3M9XCJyb290XCJcbiAgICBiYXI9XCJyaWdodFwiXG4gID5cbiAgICA8ZGl2IGNsYXNzPVwicHJvcHNcIlxuICAgICAgdi1pZj1cInNlbGVjdGVkTm9kZVwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+Tm9kZTwvZGl2PlxuICAgICAgPGhyIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICB0eXBlPVwiZmxvYXRcIlxuICAgICAgICBuYW1lPVwiVGltZVwiXG4gICAgICAgIDp2YWx1ZT1cInNlbGVjdGVkTm9kZS50aW1lXCJcbiAgICAgICAgOnJlYWRvbmx5PVwiISggc2VsZWN0ZWROb2RlLmluICYmIHNlbGVjdGVkTm9kZS5vdXQgKVwiXG4gICAgICAgIEBjaGFuZ2VkPVwiXG4gICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlTm9kZSggc2VsZWN0ZWROb2RlSWQsICRldmVudCApXG4gICAgICAgIFwiXG4gICAgICAgIEBmaW5pc2hlZD1cIlxuICAgICAgICAgIGF1dG9tYXRvbi5wdXNoSGlzdG9yeSggJ0NoYW5nZSBOb2RlIFRpbWUnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVOb2RlKCBzZWxlY3RlZE5vZGVJZCwgJGV2ZW50WyAxIF0gKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVOb2RlKCBzZWxlY3RlZE5vZGVJZCwgJGV2ZW50WyAwIF0gKTtcbiAgICAgICAgICB9ICk7XG4gICAgICAgIFwiXG4gICAgICAvPlxuICAgICAgPFByb3Bib3ggY2xhc3M9XCJwcm9wXCJcbiAgICAgICAgdHlwZT1cImZsb2F0XCJcbiAgICAgICAgbmFtZT1cIlZhbHVlXCJcbiAgICAgICAgOnZhbHVlPVwic2VsZWN0ZWROb2RlLnZhbHVlXCJcbiAgICAgICAgQGNoYW5nZWQ9XCJcbiAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVOb2RlKCBzZWxlY3RlZE5vZGVJZCwgdW5kZWZpbmVkLCAkZXZlbnQgKVxuICAgICAgICBcIlxuICAgICAgICBAZmluaXNoZWQ9XCJcbiAgICAgICAgICBhdXRvbWF0b24ucHVzaEhpc3RvcnkoICdDaGFuZ2UgTm9kZSBWYWx1ZScsICgpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZU5vZGUoIHNlbGVjdGVkTm9kZUlkLCB1bmRlZmluZWQsICRldmVudFsgMSBdICk7XG4gICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlTm9kZSggc2VsZWN0ZWROb2RlSWQsIHVuZGVmaW5lZCwgJGV2ZW50WyAwIF0gKTtcbiAgICAgICAgICB9ICk7XG4gICAgICAgIFwiXG4gICAgICAvPlxuICAgICAgPGhyIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICB0eXBlPVwiZmxvYXRcIlxuICAgICAgICBuYW1lPVwiSW4gVGltZVwiXG4gICAgICAgIDp2YWx1ZT1cInNlbGVjdGVkTm9kZS5pbiA/IHNlbGVjdGVkTm9kZS5pbi50aW1lIDogMFwiXG4gICAgICAgIDpyZWFkb25seT1cIiFzZWxlY3RlZE5vZGUuaW5cIlxuICAgICAgICBAY2hhbmdlZD1cIlxuICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZUhhbmRsZSggc2VsZWN0ZWROb2RlSWQsIGZhbHNlLCAkZXZlbnQgKVxuICAgICAgICBcIlxuICAgICAgICBAZmluaXNoZWQ9XCJcbiAgICAgICAgICBhdXRvbWF0b24ucHVzaEhpc3RvcnkoICdDaGFuZ2UgTm9kZSBUaW1lJywgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlSGFuZGxlKCBzZWxlY3RlZE5vZGVJZCwgZmFsc2UsICRldmVudFsgMSBdICk7XG4gICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlSGFuZGxlKCBzZWxlY3RlZE5vZGVJZCwgZmFsc2UsICRldmVudFsgMCBdICk7XG4gICAgICAgICAgfSApO1xuICAgICAgICBcIlxuICAgICAgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIHR5cGU9XCJmbG9hdFwiXG4gICAgICAgIG5hbWU9XCJJbiBWYWx1ZVwiXG4gICAgICAgIDp2YWx1ZT1cInNlbGVjdGVkTm9kZS5pbiA/IHNlbGVjdGVkTm9kZS5pbi52YWx1ZSA6IDBcIlxuICAgICAgICA6cmVhZG9ubHk9XCIhc2VsZWN0ZWROb2RlLmluXCJcbiAgICAgICAgQGNoYW5nZWQ9XCJcbiAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVIYW5kbGUoIHNlbGVjdGVkTm9kZUlkLCBmYWxzZSwgdW5kZWZpbmVkLCAkZXZlbnQgKVxuICAgICAgICBcIlxuICAgICAgICBAZmluaXNoZWQ9XCJcbiAgICAgICAgICBhdXRvbWF0b24ucHVzaEhpc3RvcnkoICdDaGFuZ2UgTm9kZSBWYWx1ZScsICgpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZUhhbmRsZSggc2VsZWN0ZWROb2RlSWQsIGZhbHNlLCB1bmRlZmluZWQsICRldmVudFsgMSBdICk7XG4gICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlSGFuZGxlKCBzZWxlY3RlZE5vZGVJZCwgZmFsc2UsIHVuZGVmaW5lZCwgJGV2ZW50WyAwIF0gKTtcbiAgICAgICAgICB9ICk7XG4gICAgICAgIFwiXG4gICAgICAvPlxuICAgICAgPGhyIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICB0eXBlPVwiZmxvYXRcIlxuICAgICAgICBuYW1lPVwiT3V0IFRpbWVcIlxuICAgICAgICA6dmFsdWU9XCJzZWxlY3RlZE5vZGUub3V0ID8gc2VsZWN0ZWROb2RlLm91dC50aW1lIDogMFwiXG4gICAgICAgIDpyZWFkb25seT1cIiFzZWxlY3RlZE5vZGUub3V0XCJcbiAgICAgICAgQGNoYW5nZWQ9XCJcbiAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVIYW5kbGUoIHNlbGVjdGVkTm9kZUlkLCB0cnVlLCAkZXZlbnQgKVxuICAgICAgICBcIlxuICAgICAgICBAZmluaXNoZWQ9XCJcbiAgICAgICAgICBhdXRvbWF0b24ucHVzaEhpc3RvcnkoICdDaGFuZ2UgTm9kZSBUaW1lJywgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlSGFuZGxlKCBzZWxlY3RlZE5vZGVJZCwgdHJ1ZSwgJGV2ZW50WyAxIF0gKTtcbiAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVIYW5kbGUoIHNlbGVjdGVkTm9kZUlkLCB0cnVlLCAkZXZlbnRbIDAgXSApO1xuICAgICAgICAgIH0gKTtcbiAgICAgICAgXCJcbiAgICAgIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICB0eXBlPVwiZmxvYXRcIlxuICAgICAgICBuYW1lPVwiT3V0IFZhbHVlXCJcbiAgICAgICAgOnZhbHVlPVwic2VsZWN0ZWROb2RlLm91dCA/IHNlbGVjdGVkTm9kZS5vdXQudmFsdWUgOiAwXCJcbiAgICAgICAgOnJlYWRvbmx5PVwiIXNlbGVjdGVkTm9kZS5vdXRcIlxuICAgICAgICBAY2hhbmdlZD1cIlxuICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZUhhbmRsZSggc2VsZWN0ZWROb2RlSWQsIHRydWUsIHVuZGVmaW5lZCwgJGV2ZW50IClcbiAgICAgICAgXCJcbiAgICAgICAgQGZpbmlzaGVkPVwiXG4gICAgICAgICAgYXV0b21hdG9uLnB1c2hIaXN0b3J5KCAnQ2hhbmdlIE5vZGUgVmFsdWUnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLm1vdmVIYW5kbGUoIHNlbGVjdGVkTm9kZUlkLCB0cnVlLCB1bmRlZmluZWQsICRldmVudFsgMSBdICk7XG4gICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlSGFuZGxlKCBzZWxlY3RlZE5vZGVJZCwgdHJ1ZSwgdW5kZWZpbmVkLCAkZXZlbnRbIDAgXSApO1xuICAgICAgICAgIH0gKTtcbiAgICAgICAgXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwicHJvcHNcIlxuICAgICAgdi1pZj1cInNlbGVjdGVkRnhcIlxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPkZ4OiB7eyBhdXRvbWF0b24uZ2V0RnhEZWZpbml0aW9uTmFtZSggc2VsZWN0ZWRGeC5kZWYgKSB9fTwvZGl2PlxuICAgICAgPGhyIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICB0eXBlPVwiZmxvYXRcIlxuICAgICAgICBuYW1lPVwiVGltZVwiXG4gICAgICAgIDp2YWx1ZT1cInNlbGVjdGVkRngudGltZVwiXG4gICAgICAgIEBjaGFuZ2VkPVwiXG4gICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlRngoIHNlbGVjdGVkRnhJZCwgJGV2ZW50IClcbiAgICAgICAgXCJcbiAgICAgICAgQGZpbmlzaGVkPVwiXG4gICAgICAgICAgYXV0b21hdG9uLnB1c2hIaXN0b3J5KCAnTW92ZSBGeCcsICgpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyYW0ubW92ZUZ4KCBzZWxlY3RlZEZ4SWQsICRldmVudFsgMSBdICk7XG4gICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5tb3ZlRngoIHNlbGVjdGVkRnhJZCwgJGV2ZW50WyAwIF0gKTtcbiAgICAgICAgICB9ICk7XG4gICAgICAgIFwiXG4gICAgICAvPlxuICAgICAgPFByb3Bib3ggY2xhc3M9XCJwcm9wXCJcbiAgICAgICAgdHlwZT1cImZsb2F0XCJcbiAgICAgICAgbmFtZT1cIkxlbmd0aFwiXG4gICAgICAgIDp2YWx1ZT1cInNlbGVjdGVkRngubGVuZ3RoXCJcbiAgICAgICAgQGNoYW5nZWQ9XCJcbiAgICAgICAgICBzZWxlY3RlZFBhcmFtLnJlc2l6ZUZ4KCBzZWxlY3RlZEZ4SWQsICRldmVudCApXG4gICAgICAgIFwiXG4gICAgICAgIEBmaW5pc2hlZD1cIlxuICAgICAgICAgIGF1dG9tYXRvbi5wdXNoSGlzdG9yeSggJ01vdmUgRngnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLnJlc2l6ZUZ4KCBzZWxlY3RlZEZ4SWQsICRldmVudFsgMSBdICk7XG4gICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5yZXNpemVGeCggc2VsZWN0ZWRGeElkLCAkZXZlbnRbIDAgXSApO1xuICAgICAgICAgIH0gKTtcbiAgICAgICAgXCJcbiAgICAgIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICB0eXBlPVwiYm9vbGVhblwiXG4gICAgICAgIG5hbWU9XCJCeXBhc3NcIlxuICAgICAgICA6dmFsdWU9XCJzZWxlY3RlZEZ4LmJ5cGFzc1wiXG4gICAgICAgIEBmaW5pc2hlZD1cIlxuICAgICAgICAgIGF1dG9tYXRvbi5wdXNoSGlzdG9yeSggJ1RvZ2dsZSBCeXBhc3MgRngnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RlZFBhcmFtLmJ5cGFzc0Z4KCBzZWxlY3RlZEZ4SWQsICRldmVudFsgMSBdICk7XG4gICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5ieXBhc3NGeCggc2VsZWN0ZWRGeElkLCAkZXZlbnRbIDAgXSApO1xuICAgICAgICAgIH0sIHRydWUgKTtcbiAgICAgICAgXCJcbiAgICAgIC8+XG4gICAgICA8aHIgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIHYtZm9yPVwiKCBwYXJhbSwga2V5ICkgaW4gYXV0b21hdG9uLmdldEZ4RGVmaW5pdGlvblBhcmFtcyggc2VsZWN0ZWRGeC5kZWYgKVwiXG4gICAgICAgIDprZXk9XCInZnhQYXJhbS0nK2tleVwiXG4gICAgICAgIDp0eXBlPVwicGFyYW0udHlwZVwiXG4gICAgICAgIDpuYW1lPVwicGFyYW0ubmFtZSB8fCBrZXlcIlxuICAgICAgICA6dmFsdWU9XCJzZWxlY3RlZEZ4LnBhcmFtc1sga2V5IF1cIlxuICAgICAgICBAY2hhbmdlZD1cIlxuICAgICAgICAgIHNlbGVjdGVkUGFyYW0uY2hhbmdlRnhQYXJhbSggc2VsZWN0ZWRGeElkLCBrZXksICRldmVudCApXG4gICAgICAgIFwiXG4gICAgICAgIEBmaW5pc2hlZD1cIlxuICAgICAgICAgIGF1dG9tYXRvbi5wdXNoSGlzdG9yeSggJ0NoYW5nZSBGeCBQYXJhbScsICgpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFyYW0uY2hhbmdlRnhQYXJhbSggc2VsZWN0ZWRGeElkLCBrZXksICRldmVudFsgMSBdICk7XG4gICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgc2VsZWN0ZWRQYXJhbS5jaGFuZ2VGeFBhcmFtKCBzZWxlY3RlZEZ4SWQsIGtleSwgJGV2ZW50WyAwIF0gKTtcbiAgICAgICAgICB9ICk7XG4gICAgICAgIFwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInByb3BzXCJcbiAgICAgIHYtaWY9XCJjb25maWcgPT09ICdzbmFwJ1wiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+U25hcCBTZXR0aW5nczwvZGl2PlxuICAgICAgPGhyIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICBuYW1lPVwiRW5hYmxlIFNuYXBcIlxuICAgICAgICB0eXBlPVwiYm9vbGVhblwiXG4gICAgICAgIDp2YWx1ZT1cImF1dG9tYXRvbi5ndWlTZXR0aW5ncy5zbmFwQWN0aXZlXCJcbiAgICAgICAgQGNoYW5nZWQ9XCJhdXRvbWF0b24uZ3VpU2V0dGluZ3Muc25hcEFjdGl2ZSA9ICRldmVudFwiXG4gICAgICAvPlxuICAgICAgPFByb3Bib3ggY2xhc3M9XCJwcm9wXCJcbiAgICAgICAgbmFtZT1cIkludGVydmFsIChUaW1lKVwiXG4gICAgICAgIG1pbj1cIjAuMFwiXG4gICAgICAgIHR5cGU9XCJmbG9hdFwiXG4gICAgICAgIDp2YWx1ZT1cImF1dG9tYXRvbi5ndWlTZXR0aW5ncy5zbmFwVGltZVwiXG4gICAgICAgIEBjaGFuZ2VkPVwiYXV0b21hdG9uLmd1aVNldHRpbmdzLnNuYXBUaW1lID0gJGV2ZW50XCJcbiAgICAgIC8+XG4gICAgICA8UHJvcGJveCBjbGFzcz1cInByb3BcIlxuICAgICAgICBuYW1lPVwiSW50ZXJ2YWwgKFZhbHVlKVwiXG4gICAgICAgIG1pbj1cIjAuMFwiXG4gICAgICAgIHR5cGU9XCJmbG9hdFwiXG4gICAgICAgIDp2YWx1ZT1cImF1dG9tYXRvbi5ndWlTZXR0aW5ncy5zbmFwVmFsdWVcIlxuICAgICAgICBAY2hhbmdlZD1cImF1dG9tYXRvbi5ndWlTZXR0aW5ncy5zbmFwVmFsdWUgPSAkZXZlbnRcIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJwcm9wc1wiXG4gICAgICB2LWlmPVwiY29uZmlnID09PSAnZ2VuZXJhbCdcIlxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPkdlbmVyYWwgQ29uZmlnPC9kaXY+XG4gICAgICA8aHIgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIG5hbWU9XCJMZW5ndGhcIlxuICAgICAgICB0eXBlPVwiZmxvYXRcIlxuICAgICAgICBtaW49XCIwXCJcbiAgICAgICAgOnZhbHVlPVwiZ2VuZXJhbENvbmZpZ3MubGVuZ3RoXCJcbiAgICAgICAgQGNoYW5nZWQ9XCJnZW5lcmFsQ29uZmlncy5sZW5ndGggPSAkZXZlbnRcIlxuICAgICAgLz5cbiAgICAgIDxQcm9wYm94IGNsYXNzPVwicHJvcFwiXG4gICAgICAgIG5hbWU9XCJSZXNvbHV0aW9uXCJcbiAgICAgICAgdHlwZT1cImludFwiXG4gICAgICAgIG1pbj1cIjFcIlxuICAgICAgICA6dmFsdWU9XCJnZW5lcmFsQ29uZmlncy5yZXNvbHV0aW9uXCJcbiAgICAgICAgQGNoYW5nZWQ9XCJnZW5lcmFsQ29uZmlncy5yZXNvbHV0aW9uID0gJGV2ZW50XCJcbiAgICAgIC8+XG4gICAgICA8aHIgLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJpbmdcIj5cbiAgICAgICAgVGhpcyBjYW5ub3QgYmUgdW5kb25lIVxuICAgICAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uLWNvbmZpcm1cIlxuICAgICAgICAgIEBjbGljaz1cImNvbmZpcm1HZW5lcmFsQ29uZmlnc1wiXG4gICAgICAgID5BcHBseTwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvU2Nyb2xsYWJsZT5cblxuICA8ZGl2IGNsYXNzPVwibG9nb2JveFwiXG4gICAgdi1pZj1cIiFzZWxlY3RlZE5vZGUgJiYgIXNlbGVjdGVkRnggJiYgIWNvbmZpZ1wiXG4gID5cbiAgICA8aW1nIGNsYXNzPVwibG9nb1wiXG4gICAgICA6c3JjPVwicmVxdWlyZSggJy4uL2ltYWdlcy9hdXRvbWF0b24tYS5zdmcnIClcIlxuICAgIC8+XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IFByb3Bib3ggZnJvbSAnLi9wcm9wYm94LnZ1ZSc7XG5pbXBvcnQgU2Nyb2xsYWJsZSBmcm9tICcuL3Njcm9sbGFibGUudnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJvcG1lbnUnLFxuXG4gIHByb3BzOiBbXG4gICAgJ2F1dG9tYXRvbicsXG4gICAgJ3NlbGVjdGVkUGFyYW1OYW1lJyxcbiAgICAnc2VsZWN0ZWROb2RlSWRzJyxcbiAgICAnc2VsZWN0ZWRGeElkcycsXG4gICAgJ2NvbmZpZydcbiAgXSxcblxuICBjb21wb25lbnRzOiB7XG4gICAgUHJvcGJveCxcbiAgICBTY3JvbGxhYmxlXG4gIH0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2VuZXJhbENvbmZpZ3M6IHtcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICByZXNvbHV0aW9uOiAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBjb25maXJtR2VuZXJhbENvbmZpZ3MoKSB7XG4gICAgICB0aGlzLmF1dG9tYXRvbi5zZXRMZW5ndGgoIHRoaXMuZ2VuZXJhbENvbmZpZ3MubGVuZ3RoICk7XG4gICAgICB0aGlzLmF1dG9tYXRvbi5zZXRSZXNvbHV0aW9uKCB0aGlzLmdlbmVyYWxDb25maWdzLnJlc29sdXRpb24gKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBzZWxlY3RlZFBhcmFtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXV0b21hdG9uLmdldFBhcmFtKCB0aGlzLnNlbGVjdGVkUGFyYW1OYW1lICk7XG4gICAgfSxcblxuICAgIHNlbGVjdGVkTm9kZUlkKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVJZHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gdGhpcy5zZWxlY3RlZE5vZGVJZHNbIDAgXVxuICAgICAgICA6IG51bGxcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHNlbGVjdGVkTm9kZSgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlSWRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHRoaXMuc2VsZWN0ZWRQYXJhbS5kdW1wTm9kZSggdGhpcy5zZWxlY3RlZE5vZGVJZCApXG4gICAgICAgIDogbnVsbFxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0ZWRGeElkKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5zZWxlY3RlZEZ4SWRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHRoaXMuc2VsZWN0ZWRGeElkc1sgMCBdXG4gICAgICAgIDogbnVsbFxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0ZWRGeCgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRGeElkcy5sZW5ndGggPT09IDFcbiAgICAgICAgPyB0aGlzLnNlbGVjdGVkUGFyYW0uZHVtcEZ4KCB0aGlzLnNlbGVjdGVkRnhJZCApXG4gICAgICAgIDogbnVsbFxuICAgICAgKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBjb25maWcoKSB7XG4gICAgICBpZiAoIHRoaXMuY29uZmlnID09PSAnZ2VuZXJhbCcgKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhbENvbmZpZ3MubGVuZ3RoID0gdGhpcy5hdXRvbWF0b24ubGVuZ3RoO1xuICAgICAgICB0aGlzLmdlbmVyYWxDb25maWdzLnJlc29sdXRpb24gPSB0aGlzLmF1dG9tYXRvbi5yZXNvbHV0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbkBpbXBvcnQgXCIuL2NvbG9ycy5zY3NzXCI7XG5cbi5yb290IHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBsZWZ0OiAwO1xuICB0b3A6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG5cbiAgYmFja2dyb3VuZDogJGNvbG9yLWJhY2syO1xuICBjb2xvcjogJGNvbG9yLWZvcmU7XG5cbiAgLnByb3BzIHtcbiAgICBwYWRkaW5nOiAwLjc1ZW0gMS41ZW07XG4gICAgZm9udC1zaXplOiAwLjc1ZW07XG5cbiAgICAudGl0bGUge1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcblxuICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICAgIGNvbG9yOiAkY29sb3ItYWNjZW50O1xuICAgIH1cblxuICAgIGhyIHtcbiAgICAgIGJvcmRlcjogc29saWQgMXB4ICRjb2xvci1iYWNrMztcbiAgICB9XG5cbiAgICAuY2VudGVyaW5nIHtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcblxuICAgICAgLmJ1dHRvbi1jb25maXJtIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB3aWR0aDogNGVtO1xuICAgICAgICBwYWRkaW5nOiAwLjI1ZW07XG5cbiAgICAgICAgYmFja2dyb3VuZDogJGNvbG9yLWJhY2szO1xuXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICAmOmhvdmVyIHsgYmFja2dyb3VuZDogJGNvbG9yLWJhY2sxOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLmxvZ29ib3gge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIHRvcDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcblxuICAgIC5sb2dvIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHdpZHRoOiA4ZW07XG4gICAgICBsZWZ0OiBjYWxjKCA1MCUgLSA0ZW0gKTtcbiAgICAgIHRvcDogY2FsYyggNTAlIC0gNGVtICk7XG5cbiAgICAgIG9wYWNpdHk6IDAuMTtcbiAgICB9XG4gIH1cbn1cbjwvc3R5bGU+XG5cbiIsIjx0ZW1wbGF0ZT5cbjxkaXY+XG4gIDxkaXYgY2xhc3M9XCJyb290XCIgcmVmPVwicm9vdFwiXG4gICAgQHdoZWVsLnN0b3A9XCJvbldoZWVsXCJcbiAgPlxuICAgIDxkaXYgY2xhc3M9XCJpbnNpZGVcIiByZWY9XCJpbnNpZGVcIlxuICAgICAgOnN0eWxlPVwieyB0b3A6IHRvcCArICdweCcgfVwiXG4gICAgPlxuICAgICAgPHNsb3QgLz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYmFyXCJcbiAgICAgIDpzdHlsZT1cIntcbiAgICAgICAgdG9wOiBiYXJUb3AgKyAnJScsXG4gICAgICAgIGhlaWdodDogYmFySGVpZ2h0ICsgJyUnLFxuICAgICAgICBsZWZ0OiBiYXIgPT09ICdsZWZ0JyA/IDAgOiB1bmRlZmluZWQsXG4gICAgICAgIHJpZ2h0OiBiYXIgPT09ICdyaWdodCcgPyAwIDogdW5kZWZpbmVkLFxuICAgICAgICBvcGFjaXR5OiBiYXJPcGFjaXR5XG4gICAgICB9XCJcbiAgICAvPlxuICA8L2Rpdj5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IFtcbiAgICAnYmFyJ1xuICBdLFxuXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGJhck9wYWNpdHk6IDAuMFxuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgb25XaGVlbCggZXZlbnQgKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLnRvcCA9IHRoaXMudG9wIC0gZXZlbnQuZGVsdGFZO1xuXG4gICAgICBjb25zdCBzY3JvbGxNYXggPSB0aGlzLiRyZWZzLmluc2lkZS5jbGllbnRIZWlnaHQgLSB0aGlzLiRyZWZzLnJvb3QuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKCB0aGlzLnRvcCA8IC1zY3JvbGxNYXggKSB7XG4gICAgICAgIGNvbnN0IG92ZXJydW4gPSAtc2Nyb2xsTWF4IC0gdGhpcy50b3A7XG4gICAgICAgIHRoaXMudG9wID0gLXNjcm9sbE1heDtcbiAgICAgIH1cblxuICAgICAgaWYgKCAwIDwgdGhpcy50b3AgKSB7XG4gICAgICAgIGNvbnN0IG92ZXJydW4gPSB0aGlzLnRvcDtcbiAgICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJhckhlaWdodCA9IDEwMC4wICogdGhpcy4kcmVmcy5yb290LmNsaWVudEhlaWdodCAvIHRoaXMuJHJlZnMuaW5zaWRlLmNsaWVudEhlaWdodDtcbiAgICAgIHRoaXMuYmFyVG9wID0gLTEwMC4wICogdGhpcy50b3AgLyB0aGlzLiRyZWZzLmluc2lkZS5jbGllbnRIZWlnaHQ7XG4gICAgICB0aGlzLmJhck9wYWNpdHkgKz0gTWF0aC5taW4oIHRoaXMuYmFyT3BhY2l0eSArIDAuMSAqIE1hdGguYWJzKCBldmVudC5kZWx0YVkgKSwgMS4wICk7XG4gICAgfSxcblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuYmFyT3BhY2l0eSAqPSAwLjk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSggdXBkYXRlICk7XG4gICAgfVxuICAgIHVwZGF0ZSgpO1xuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCBcIi4vY29sb3JzLnNjc3NcIjtcblxuLnJvb3Qge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIG92ZXJmbG93OiBoaWRkZW47XG5cbiAgLmluc2lkZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGxlZnQ6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gIH1cblxuICAuYmFyIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDRweDtcblxuICAgIGJhY2tncm91bmQ6ICRjb2xvci1hY2NlbnQ7XG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICB9XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuPGRpdj5cbiAgPGRpdiBjbGFzcz1cInJvb3RcIlxuICAgIHYtaWY9XCJ0ZXh0XCJcbiAgICA6c3R5bGU9XCJ7XG4gICAgICBsZWZ0OiB0eXBlb2YgbGVmdCA9PT0gJ251bWJlcicgPyBgJHsgbGVmdCB9cHhgIDogdW5kZWZpbmVkLFxuICAgICAgcmlnaHQ6IHR5cGVvZiByaWdodCA9PT0gJ251bWJlcicgPyBgJHsgcmlnaHQgfXB4YCA6IHVuZGVmaW5lZCxcbiAgICAgIHRvcDogdHlwZW9mIHRvcCA9PT0gJ251bWJlcicgPyBgJHsgdG9wIH1weGAgOiB1bmRlZmluZWQsXG4gICAgICBib3R0b206IHR5cGVvZiBib3R0b20gPT09ICdudW1iZXInID8gYCR7IGJvdHRvbSB9cHhgIDogdW5kZWZpbmVkXG4gICAgfVwiXG4gID5cbiAgICB7eyB0ZXh0IH19XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnc3RhbGtlcicsXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgdGV4dDogJydcbiAgICB9O1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBhcHBseVN0YWxrZXJUZXh0KCBlbCApIHtcbiAgICAgIHNldFRpbWVvdXQoICgpID0+IHtcbiAgICAgICAgdGhpcy50ZXh0ID0gZWwuZ2V0QXR0cmlidXRlKCAnc3RhbGtlci10ZXh0JyApO1xuICAgICAgfSwgMTAgKTsgLy8g8J+UpfCflKXwn5Sl8J+UpfCflKXwn5SlXG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCAoIGV2ZW50ICkgPT4ge1xuICAgICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIGNvbnN0IHcgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcblxuICAgICAgY29uc3QgYkxlZnRTaWRlID0gdyAtIDI0MCA8IHg7XG4gICAgICBjb25zdCBiVXBTaWRlID0gaCAtIDQwIDwgeTtcblxuICAgICAgdGhpcy5sZWZ0ID0gYkxlZnRTaWRlID8gbnVsbCA6IHg7XG4gICAgICB0aGlzLnJpZ2h0ID0gYkxlZnRTaWRlID8gKCB3IC0geCApIDogbnVsbDtcbiAgICAgIHRoaXMudG9wID0gYlVwU2lkZSA/IG51bGwgOiB5O1xuICAgICAgdGhpcy5ib3R0b20gPSBiVXBTaWRlID8gKCBoIC0geSApIDogbnVsbDtcblxuICAgICAgdGhpcy5hcHBseVN0YWxrZXJUZXh0KCBldmVudC50YXJnZXQgKTtcbiAgICB9ICk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsICggZXZlbnQgKSA9PiB7XG4gICAgICB0aGlzLmFwcGx5U3RhbGtlclRleHQoIGV2ZW50LnRhcmdldCApO1xuICAgIH0gKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsICggZXZlbnQgKSA9PiB7XG4gICAgICB0aGlzLmFwcGx5U3RhbGtlclRleHQoIGV2ZW50LnRhcmdldCApO1xuICAgIH0gKTtcbiAgfSxcbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxuQGltcG9ydCBcIi4vY29sb3JzLnNjc3NcIjtcblxuLnJvb3Qge1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICBwYWRkaW5nOiAwLjJlbSAwLjRlbTtcbiAgbWFyZ2luOiAxMHB4O1xuICBmb250LXNpemU6IDAuOGVtO1xuXG4gIGJhY2tncm91bmQ6IHJnYmEoIDAsIDAsIDAsIDAuOCApO1xuICBjb2xvcjogJGNvbG9yLWZvcmU7XG4gIGJvcmRlci1yYWRpdXM6IDAuMmVtO1xufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbjxkaXY+XG4gIDxkaXYgY2xhc3M9XCJibHVyLWxheWVyXCJcbiAgICB2LWlmPVwiYWN0aXZlXCJcbiAgICBAbW91c2Vkb3duPVwiYmx1clwiXG4gIC8+XG4gIDxkaXYgY2xhc3M9XCJyb290XCJcbiAgICB2LWlmPVwiYWN0aXZlXCJcbiAgPlxuICAgIDxpbnB1dCBjbGFzcz1cInNlYXJjaC1ib3hcIlxuICAgICAgcmVmPVwic2VhcmNoQm94XCJcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgIHYtbW9kZWw9XCJzZWFyY2hUZXh0XCJcbiAgICAgIHBsYWNlaG9sZGVyPVwiQWRkIGEgZnguLi5cIlxuICAgICAgQGtleWRvd249XCJvblNlYXJjaEJveEtleWRvd25cIlxuICAgIC8+XG4gICAgPFNjcm9sbGFibGUgY2xhc3M9XCJmeC1uYW1lc1wiXG4gICAgICBiYXI9XCJyaWdodFwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cImZ4LW5hbWVcIlxuICAgICAgICB2LWZvcj1cIiggaWQsIGluZGV4ICkgaW4gZnhEZWZzRmlsdGVyZWRcIlxuICAgICAgICA6a2V5PVwiaWRcIlxuICAgICAgICA6Y2xhc3M9XCJ7IHNlbGVjdGVkOiBpbmRleCA9PT0gc2VsZWN0ZWRJbmRleCB9XCJcbiAgICAgICAgOnN0YWxrZXItdGV4dD1cImF1dG9tYXRvbi5nZXRGeERlZmluaXRpb25EZXNjcmlwdGlvbiggaWQgKSB8fCAnKG5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkKSdcIlxuICAgICAgICBAbW91c2Vkb3duPVwic2VsZWN0KCBpZCApXCJcbiAgICAgID5cbiAgICAgICAge3sgaWQgPyBhdXRvbWF0b24uZ2V0RnhEZWZpbml0aW9uTmFtZSggaWQgKSA6ICcoTm8gcmVzdWx0IGZvdW5kKScgfX1cbiAgICAgIDwvZGl2PlxuICAgIDwvU2Nyb2xsYWJsZT5cbiAgPC9kaXY+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgU2Nyb2xsYWJsZSBmcm9tICcuL3Njcm9sbGFibGUudnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczogW1xuICAgICdhdXRvbWF0b24nLFxuICAgICdhY3RpdmUnXG4gIF0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIFNjcm9sbGFibGVcbiAgfSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmeERlZnM6IFtdLFxuICAgICAgc2VhcmNoVGV4dDogJycsXG4gICAgICBzZWxlY3RlZEluZGV4OiAwXG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBmaWx0ZXJEZWYoIGlkICkge1xuICAgICAgY29uc3QgcXVlcmllcyA9IHRoaXMuc2VhcmNoVGV4dC5zcGxpdCggL1xccysvICk7XG4gICAgICBjb25zdCBuYW1lID0gdGhpcy5hdXRvbWF0b24uZ2V0RnhEZWZpbml0aW9uTmFtZSggaWQgKTtcbiAgICAgIHJldHVybiBxdWVyaWVzLmV2ZXJ5KCAoIHF1ZXJ5ICkgPT4gKFxuICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoIHF1ZXJ5LnRvTG93ZXJDYXNlKCkgKSB8fFxuICAgICAgICBpZC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCBxdWVyeS50b0xvd2VyQ2FzZSgpIClcbiAgICAgICkgKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0KCBpZCApIHtcbiAgICAgIGlmICggaWQgPT09ICcnICkgeyB0aGlzLmJsdXIoKTsgcmV0dXJuOyB9XG4gICAgICB0aGlzLiRlbWl0KCAnc2VsZWN0ZWQnLCBpZCApO1xuICAgICAgdGhpcy5meERlZnMuc3BsaWNlKCB0aGlzLmZ4RGVmcy5pbmRleE9mKCBpZCApLCAxICk7XG4gICAgICB0aGlzLmZ4RGVmcy51bnNoaWZ0KCBpZCApO1xuICAgICAgdGhpcy5ibHVyKCk7XG4gICAgfSxcblxuICAgIGJsdXIoKSB7XG4gICAgICB0aGlzLiRlbWl0KCAnYmx1cicgKTtcbiAgICAgIHRoaXMuc2VhcmNoVGV4dCA9ICcnO1xuICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gMDtcbiAgICB9LFxuXG4gICAgb25TZWFyY2hCb3hLZXlkb3duKCBldmVudCApIHtcbiAgICAgIGlmICggZXZlbnQud2hpY2ggPT09IDEzICkgeyAvLyBFbnRlclxuICAgICAgICB0aGlzLnNlbGVjdCggdGhpcy5meERlZnNGaWx0ZXJlZFsgdGhpcy5zZWxlY3RlZEluZGV4IF0gKTtcbiAgICAgIH0gZWxzZSBpZiAoIGV2ZW50LndoaWNoID09PSAyNyApIHsgLy8gRXNjYXBlXG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgfSBlbHNlIGlmICggZXZlbnQud2hpY2ggPT09IDM4ICkgeyAvLyBVcFxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAoIHRoaXMuc2VsZWN0ZWRJbmRleCAtIDEgKyB0aGlzLmZ4RGVmc0ZpbHRlcmVkLmxlbmd0aCApICUgdGhpcy5meERlZnNGaWx0ZXJlZC5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKCBldmVudC53aGljaCA9PT0gNDAgKSB7IC8vIERvd25cbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gKCB0aGlzLnNlbGVjdGVkSW5kZXggKyAxICkgJSB0aGlzLmZ4RGVmc0ZpbHRlcmVkLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5meERlZnMgPSB0aGlzLmF1dG9tYXRvbi5nZXRGeERlZmluaXRpb25JZHMoKTtcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIGZ4RGVmc0ZpbHRlcmVkKCkge1xuICAgICAgdGhpcy5meERlZnMucHVzaChcbiAgICAgICAgLi4udGhpcy5hdXRvbWF0b24uZ2V0RnhEZWZpbml0aW9uSWRzKCkuZmlsdGVyKFxuICAgICAgICAgICggaWQgKSA9PiB0aGlzLmZ4RGVmcy5pbmRleE9mKCBpZCApID09PSAtMVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICBsZXQgYXJyID0gdGhpcy5meERlZnMuZmlsdGVyKCAoIGlkICkgPT4gdGhpcy5maWx0ZXJEZWYoIGlkICkgKTtcbiAgICAgIHJldHVybiBhcnIubGVuZ3RoID09PSAwID8gWyAnJyBdIDogYXJyO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGFjdGl2ZSggdiApIHtcbiAgICAgIGlmICggIXYgKSB7IHJldHVybjsgfVxuICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLnNlYXJjaEJveC5mb2N1cygpO1xuICAgICAgfSwgMTAgKTsgLy8g8J+UpVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbkBpbXBvcnQgXCIuL2NvbG9ycy5zY3NzXCI7XG5cbi5ibHVyLWxheWVyIHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICBsZWZ0OiAwO1xuICB0b3A6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG59XG5cbi5yb290IHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBsZWZ0OiBjYWxjKCA1MCUgLSAxMGVtICk7XG4gIHRvcDogMWVtO1xuICB3aWR0aDogMjBlbTtcbiAgaGVpZ2h0OiBjYWxjKCAxMDAlIC0gMmVtICk7XG4gIG92ZXJmbG93OiBoaWRkZW47XG5cbiAgYmFja2dyb3VuZDogJGNvbG9yLWJhY2sxO1xuICBmb250LXNpemU6IDAuOGVtO1xuXG4gIGZpbHRlcjogZHJvcC1zaGFkb3coIDAgMCAycHggIzAwMDAwMCApO1xuXG4gIC5zZWFyY2gtYm94IHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZm9udC1zaXplOiAxZW07XG4gICAgd2lkdGg6IGNhbGMoIDEwMCUgLSAxMnB4ICk7XG4gICAgbWFyZ2luOiAycHg7XG4gICAgcGFkZGluZzogMnB4IDRweDtcbiAgICBib3JkZXI6IG5vbmU7XG5cbiAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazQ7XG4gICAgY29sb3I6ICRjb2xvci1mb3JlO1xuICB9XG5cbiAgLmZ4LW5hbWVzIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiBjYWxjKCAxMDAlIC0gMWVtIC0gMTJweCApO1xuXG4gICAgLmZ4LW5hbWUge1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgd2lkdGg6IGNhbGMoIDEwMCUgLSAxMnB4ICk7XG4gICAgICBtYXJnaW46IDJweDtcbiAgICAgIHBhZGRpbmc6IDJweCA0cHg7XG4gICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXG4gICAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazI7XG5cbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgJjpob3ZlciB7IGJhY2tncm91bmQ6ICRjb2xvci1iYWNrMzsgfVxuICAgICAgJi5zZWxlY3RlZCB7IGJhY2tncm91bmQ6ICRjb2xvci1iYWNrMzsgfVxuICAgIH1cbiAgfVxufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbjxkaXY+XG4gIDxkaXYgY2xhc3M9XCJyb290XCIgcmVmPVwicm9vdFwiXG4gICAgQHdoZWVsLnByZXZlbnQ9XCJvbldoZWVsXCJcbiAgICBAZHJhZ3N0YXJ0LnByZXZlbnRcbiAgICBAbW91c2Vkb3duLnByZXZlbnQuc3RvcD1cImRyYWdCZ1wiXG4gICAgQGRibGNsaWNrLmxlZnQuc3RvcD1cImNyZWF0ZU5vZGUoIHgydCggJGV2ZW50Lm9mZnNldFggKSwgeTJ2KCAkZXZlbnQub2Zmc2V0WSApIClcIlxuICAgIEBjb250ZXh0bWVudS5zdG9wLnByZXZlbnQ9XCJjb250ZXh0QmdcIlxuICA+XG4gICAgPGRpdiBjbGFzcz1cImhiYXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ2aXNpb25cIlxuICAgICAgICA6c3R5bGU9XCJ7XG4gICAgICAgICAgbGVmdDogYCR7IHQwIC8gYXV0b21hdG9uLmxlbmd0aCAqIHdpZHRoIH1weGAsXG4gICAgICAgICAgd2lkdGg6IGAkeyAoIHQxIC0gdDAgKSAvIGF1dG9tYXRvbi5sZW5ndGggKiB3aWR0aCB9cHhgXG4gICAgICAgIH1cIlxuICAgICAgPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPHN2ZyBjbGFzcz1cInN2Z1wiXG4gICAgICA6d2lkdGg9XCJ3aWR0aFwiXG4gICAgICA6aGVpZ2h0PVwiaGVpZ2h0XCJcbiAgICAgIDp2aWV3Qm94PVwiYDAgMCAke3dpZHRofSAke2hlaWdodH1gXCJcbiAgICA+XG4gICAgICA8bGluZSBjbGFzcz1cImdyaWRcIlxuICAgICAgICB2LWZvcj1cIiggbGluZSwgaW5kZXggKSBpbiBncmlkLnhcIlxuICAgICAgICA6a2V5PVwiJ2dyaWQteCcraW5kZXhcIlxuICAgICAgICA6eDE9XCJsaW5lLnBvc1wiXG4gICAgICAgIDp5MT1cIjBcIlxuICAgICAgICA6eDI9XCJsaW5lLnBvc1wiXG4gICAgICAgIDp5Mj1cImhlaWdodFwiXG4gICAgICAgIDpvcGFjaXR5PVwibGluZS5vcFwiXG4gICAgICAvPlxuICAgICAgPGxpbmUgY2xhc3M9XCJncmlkXCJcbiAgICAgICAgdi1mb3I9XCIoIGxpbmUsIGluZGV4ICkgaW4gZ3JpZC55XCJcbiAgICAgICAgOmtleT1cIidncmlkLXknK2luZGV4XCJcbiAgICAgICAgOngxPVwiMFwiXG4gICAgICAgIDp5MT1cImxpbmUucG9zXCJcbiAgICAgICAgOngyPVwid2lkdGhcIlxuICAgICAgICA6eTI9XCJsaW5lLnBvc1wiXG4gICAgICAgIDpvcGFjaXR5PVwibGluZS5vcFwiXG4gICAgICAvPlxuICAgICAgPHRleHQgY2xhc3M9XCJncmlkLXRleHRcIlxuICAgICAgICB2LWZvcj1cIiggbGluZSwgaW5kZXggKSBpbiBncmlkLnhcIlxuICAgICAgICA6a2V5PVwiJ2dyaWQtdGV4dC14JytpbmRleFwiXG4gICAgICAgIDp4PVwibGluZS5wb3MgKyAyXCJcbiAgICAgICAgOnk9XCJoZWlnaHQgLSAyXCJcbiAgICAgICAgOm9wYWNpdHk9XCJsaW5lLm9wXCJcbiAgICAgID57eyBsaW5lLnZhbC50b0ZpeGVkKCAzICkgfX08L3RleHQ+XG4gICAgICA8dGV4dCBjbGFzcz1cImdyaWQtdGV4dFwiXG4gICAgICAgIHYtZm9yPVwiKCBsaW5lLCBpbmRleCApIGluIGdyaWQueVwiXG4gICAgICAgIDprZXk9XCInZ3JpZC10ZXh0LXknK2luZGV4XCJcbiAgICAgICAgeD1cIjJcIlxuICAgICAgICA6eT1cImxpbmUucG9zIC0gMlwiXG4gICAgICAgIDpvcGFjaXR5PVwibGluZS5vcFwiXG4gICAgICA+e3sgbGluZS52YWwudG9GaXhlZCggMyApIH19PC90ZXh0PlxuXG4gICAgICA8ZyB2LWlmPVwic2VsZWN0ZWRQYXJhbVwiPlxuICAgICAgICA8ZyBjbGFzcz1cImZ4XCJcbiAgICAgICAgICB2LWZvcj1cImZ4IGluIHNlbGVjdGVkUGFyYW0uZHVtcEZ4cygpXCJcbiAgICAgICAgICA6a2V5PVwiZnguJGlkXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxsaW5lIGNsYXNzPVwibGluZVwiXG4gICAgICAgICAgICA6eDE9XCJ0MngoIGZ4LnRpbWUgKVwiXG4gICAgICAgICAgICB5MT1cIjRcIlxuICAgICAgICAgICAgOngyPVwidDJ4KCBmeC50aW1lIClcIlxuICAgICAgICAgICAgOnkyPVwiaGVpZ2h0XCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxsaW5lIGNsYXNzPVwibGluZVwiXG4gICAgICAgICAgICA6eDE9XCJ0MngoIGZ4LnRpbWUgKyBmeC5sZW5ndGggKVwiXG4gICAgICAgICAgICB5MT1cIjRcIlxuICAgICAgICAgICAgOngyPVwidDJ4KCBmeC50aW1lICsgZngubGVuZ3RoIClcIlxuICAgICAgICAgICAgOnkyPVwiaGVpZ2h0XCJcbiAgICAgICAgICAvPlxuXG4gICAgICAgICAgPHJlY3QgY2xhc3M9XCJmaWxsXCJcbiAgICAgICAgICAgIDp4PVwidDJ4KCBmeC50aW1lIClcIlxuICAgICAgICAgICAgeT1cIjBcIlxuICAgICAgICAgICAgOndpZHRoPVwidDJ4KCBmeC50aW1lICsgZngubGVuZ3RoICkgLSB0MngoIGZ4LnRpbWUgKVwiXG4gICAgICAgICAgICA6aGVpZ2h0PVwiaGVpZ2h0XCJcbiAgICAgICAgICAvPlxuXG4gICAgICAgICAgPGcgOnRyYW5zZm9ybT1cIid0cmFuc2xhdGUoMCwnICsgKCAxICsgMTYgKiBmeC5yb3cgKSArICcpJ1wiPlxuICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJib2R5XCJcbiAgICAgICAgICAgICAgOmNsYXNzPVwie1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZEZ4SWRzLnNvbWUoICggaWQgKSA9PiBpZCA9PT0gZnguJGlkICksXG4gICAgICAgICAgICAgICAgYnlwYXNzOiBmeC5ieXBhc3NcbiAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgIDp4PVwidDJ4KCBmeC50aW1lIClcIlxuICAgICAgICAgICAgICA6d2lkdGg9XCJ0MngoIGZ4LnRpbWUgKyBmeC5sZW5ndGggKSAtIHQyeCggZngudGltZSApXCJcbiAgICAgICAgICAgICAgaGVpZ2h0PVwiMTZcIlxuICAgICAgICAgICAgICByeD1cIjVcIlxuICAgICAgICAgICAgICByeT1cIjVcIlxuICAgICAgICAgICAgICBAbW91c2Vkb3duLmxlZnQuc3RvcD1cImdyYWJGeEJvZHkoIGZ4LiRpZCwgJGV2ZW50IClcIlxuICAgICAgICAgICAgICBAZGJsY2xpY2suc3RvcD1cInJlbW92ZUZ4KCBmeC4kaWQgKVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJzaWRlXCJcbiAgICAgICAgICAgICAgOng9XCJ0MngoIGZ4LnRpbWUgKSAtIDFcIlxuICAgICAgICAgICAgICB3aWR0aD1cIjZcIlxuICAgICAgICAgICAgICBoZWlnaHQ9XCIxNlwiXG4gICAgICAgICAgICAgIEBtb3VzZWRvd24ubGVmdC5zdG9wPVwiZ3JhYkZ4TGVmdCggZnguJGlkLCAkZXZlbnQgKVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJzaWRlXCJcbiAgICAgICAgICAgICAgOng9XCJ0MngoIGZ4LnRpbWUgKyBmeC5sZW5ndGggKSAtIDVcIlxuICAgICAgICAgICAgICB3aWR0aD1cIjZcIlxuICAgICAgICAgICAgICBoZWlnaHQ9XCIxNlwiXG4gICAgICAgICAgICAgIEBtb3VzZWRvd24ubGVmdC5zdG9wPVwiZ3JhYkZ4UmlnaHQoIGZ4LiRpZCwgJGV2ZW50IClcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPGNsaXBQYXRoXG4gICAgICAgICAgICAgIDppZD1cIidmeGNsaXAnK2Z4LiRpZFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgICAgOng9XCJ0MngoIGZ4LnRpbWUgKVwiXG4gICAgICAgICAgICAgICAgOndpZHRoPVwidDJ4KCBmeC50aW1lICsgZngubGVuZ3RoICkgLSB0MngoIGZ4LnRpbWUgKVwiXG4gICAgICAgICAgICAgICAgaGVpZ2h0PVwiMTZcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9jbGlwUGF0aD5cbiAgICAgICAgICAgIDxnXG4gICAgICAgICAgICAgIDpjbGlwLXBhdGg9XCIndXJsKCNmeGNsaXAnICsgZnguJGlkICsgJyknXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHRleHQgY2xhc3M9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XCJ7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRGeElkcy5zb21lKCAoIGlkICkgPT4gaWQgPT09IGZ4LiRpZCApLFxuICAgICAgICAgICAgICAgICAgYnlwYXNzOiBmeC5ieXBhc3NcbiAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICA6eD1cInQyeCggZngudGltZSApICsgNFwiXG4gICAgICAgICAgICAgICAgeT1cIjEyXCJcbiAgICAgICAgICAgICAgPnt7IGF1dG9tYXRvbi5nZXRGeERlZmluaXRpb25OYW1lKCBmeC5kZWYgKSB9fTwvdGV4dD5cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvZz5cblxuICAgICAgICA8cG9seWxpbmUgY2xhc3M9XCJncmFwaFwiXG4gICAgICAgICAgdi1pZj1cInNlbGVjdGVkUGFyYW1cIlxuICAgICAgICAgIDpwb2ludHM9XCJncmFwaFBvaW50c1wiXG4gICAgICAgIC8+XG5cbiAgICAgICAgPGxpbmUgY2xhc3M9XCJjdXJyZW50TGluZVwiXG4gICAgICAgICAgOngxPVwidDJ4KCBhdXRvbWF0b24udGltZSApXCJcbiAgICAgICAgICB5MT1cIjBcIlxuICAgICAgICAgIDp4Mj1cInQyeCggYXV0b21hdG9uLnRpbWUgKVwiXG4gICAgICAgICAgOnkyPVwiaGVpZ2h0XCJcbiAgICAgICAgLz5cbiAgICAgICAgPHRleHQgY2xhc3M9XCJjdXJyZW50VGV4dFwiXG4gICAgICAgICAgOng9XCJ0MngoIGF1dG9tYXRvbi50aW1lICkgKyAyXCJcbiAgICAgICAgICA6eT1cImhlaWdodCAtIDJcIlxuICAgICAgICA+e3sgYXV0b21hdG9uLnRpbWUudG9GaXhlZCggMyApIH19PC90ZXh0PlxuICAgICAgICA8Z1xuICAgICAgICAgIHYtaWY9XCJzZWxlY3RlZFBhcmFtXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxsaW5lIGNsYXNzPVwiY3VycmVudExpbmVcIlxuICAgICAgICAgICAgeDE9XCIwXCJcbiAgICAgICAgICAgIDp5MT1cInYyeSggc2VsZWN0ZWRQYXJhbS5nZXRWYWx1ZSgpIClcIlxuICAgICAgICAgICAgOngyPVwid2lkdGhcIlxuICAgICAgICAgICAgOnkyPVwidjJ5KCBzZWxlY3RlZFBhcmFtLmdldFZhbHVlKCkgKVwiXG4gICAgICAgICAgLz5cbiAgICAgICAgICA8dGV4dCBjbGFzcz1cImN1cnJlbnRUZXh0XCJcbiAgICAgICAgICAgIHg9XCIyXCJcbiAgICAgICAgICAgIDp5PVwidjJ5KCBzZWxlY3RlZFBhcmFtLmdldFZhbHVlKCkgKSAtIDJcIlxuICAgICAgICAgID57eyBzZWxlY3RlZFBhcmFtLmdldFZhbHVlKCkudG9GaXhlZCggMyApIH19PC90ZXh0PlxuICAgICAgICAgIDxjaXJjbGUgY2xhc3M9XCJjdXJyZW50UG9pbnRcIlxuICAgICAgICAgICAgcj1cIjVcIlxuICAgICAgICAgICAgOmN4PVwidDJ4KCBhdXRvbWF0b24udGltZSApXCJcbiAgICAgICAgICAgIDpjeT1cInYyeSggc2VsZWN0ZWRQYXJhbS5nZXRWYWx1ZSgpIClcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvZz5cblxuICAgICAgPGcgdi1pZj1cInNlbGVjdGVkUGFyYW1cIj5cbiAgICAgICAgPGcgY2xhc3M9XCJub2RlXCJcbiAgICAgICAgICB2LWZvcj1cIm5vZGUgaW4gc2VsZWN0ZWRQYXJhbS5kdW1wTm9kZXMoKVwiXG4gICAgICAgICAgOmtleT1cIm5vZGUuJGlkXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxnIGNsYXNzPVwiaGFuZGxlXCI+XG4gICAgICAgICAgICA8bGluZSBjbGFzcz1cImxpbmVcIlxuICAgICAgICAgICAgICB2LWlmPVwibm9kZS5pblwiXG4gICAgICAgICAgICAgIDp4MT1cInQyeCggbm9kZS50aW1lIClcIlxuICAgICAgICAgICAgICA6eTE9XCJ2MnkoIG5vZGUudmFsdWUgKVwiXG4gICAgICAgICAgICAgIDp4Mj1cInQyeCggbm9kZS50aW1lICsgbm9kZS5pbi50aW1lIClcIlxuICAgICAgICAgICAgICA6eTI9XCJ2MnkoIG5vZGUudmFsdWUgKyBub2RlLmluLnZhbHVlIClcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxjaXJjbGUgY2xhc3M9XCJjaXJjbGVcIlxuICAgICAgICAgICAgICB2LWlmPVwibm9kZS5pblwiXG4gICAgICAgICAgICAgIHI9XCI0XCJcbiAgICAgICAgICAgICAgOnRyYW5zZm9ybT1cIid0cmFuc2xhdGUoJyArIHQyeCggbm9kZS50aW1lICsgbm9kZS5pbi50aW1lICkgKyAnLCcgKyB2MnkoIG5vZGUudmFsdWUgKyBub2RlLmluLnZhbHVlICkgKyAnKSdcIlxuICAgICAgICAgICAgICBAbW91c2Vkb3duLmxlZnQuc3RvcD1cImdyYWJIYW5kbGUoIG5vZGUuJGlkLCBmYWxzZSwgJGV2ZW50IClcIlxuICAgICAgICAgICAgICBAZGJsY2xpY2suc3RvcD1cInJlbW92ZUhhbmRsZSggbm9kZS4kaWQsIGZhbHNlIClcIlxuICAgICAgICAgICAgLz5cblxuICAgICAgICAgICAgPGxpbmUgY2xhc3M9XCJsaW5lXCJcbiAgICAgICAgICAgICAgdi1pZj1cIm5vZGUub3V0XCJcbiAgICAgICAgICAgICAgOngxPVwidDJ4KCBub2RlLnRpbWUgKVwiXG4gICAgICAgICAgICAgIDp5MT1cInYyeSggbm9kZS52YWx1ZSApXCJcbiAgICAgICAgICAgICAgOngyPVwidDJ4KCBub2RlLnRpbWUgKyBub2RlLm91dC50aW1lIClcIlxuICAgICAgICAgICAgICA6eTI9XCJ2MnkoIG5vZGUudmFsdWUgKyBub2RlLm91dC52YWx1ZSApXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8Y2lyY2xlIGNsYXNzPVwiY2lyY2xlXCJcbiAgICAgICAgICAgICAgdi1pZj1cIm5vZGUub3V0XCJcbiAgICAgICAgICAgICAgcj1cIjRcIlxuICAgICAgICAgICAgICA6dHJhbnNmb3JtPVwiJ3RyYW5zbGF0ZSgnICsgdDJ4KCBub2RlLnRpbWUgKyBub2RlLm91dC50aW1lICkgKyAnLCcgKyB2MnkoIG5vZGUudmFsdWUgKyBub2RlLm91dC52YWx1ZSApICsgJyknXCJcbiAgICAgICAgICAgICAgQG1vdXNlZG93bi5sZWZ0LnN0b3A9XCJncmFiSGFuZGxlKCBub2RlLiRpZCwgdHJ1ZSwgJGV2ZW50IClcIlxuICAgICAgICAgICAgICBAZGJsY2xpY2suc3RvcD1cInJlbW92ZUhhbmRsZSggbm9kZS4kaWQsIHRydWUgKVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZz5cblxuICAgICAgICAgIDxnIGNsYXNzPVwiYm9keVwiXG4gICAgICAgICAgICA6Y2xhc3M9XCJ7IHNlbGVjdGVkOiBzZWxlY3RlZE5vZGVJZHMuc29tZSggKCBpZCApID0+IGlkID09PSBub2RlLiRpZCApIH1cIlxuICAgICAgICAgICAgQGRibGNsaWNrLnN0b3A9XCJyZW1vdmVOb2RlKCBub2RlLiRpZCApXCJcbiAgICAgICAgICAgIEBtb3VzZWRvd24ubGVmdC5zaGlmdC5zdG9wPVwicmVzZXRIYW5kbGVzKCBub2RlLiRpZCApXCJcbiAgICAgICAgICAgIEBtb3VzZWRvd24ubGVmdC5zdG9wPVwiZ3JhYk5vZGUoIG5vZGUuJGlkLCAkZXZlbnQgKVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGNpcmNsZSBjbGFzcz1cImNpcmNsZVwiXG4gICAgICAgICAgICAgIHYtaWY9XCJ2MCA8PSBub2RlLnZhbHVlICYmIG5vZGUudmFsdWUgPD0gdjFcIlxuICAgICAgICAgICAgICA6dHJhbnNmb3JtPVwiJ3RyYW5zbGF0ZSgnICsgdDJ4KCBub2RlLnRpbWUgKSArICcsJyArIHYyeSggbm9kZS52YWx1ZSApICsgJyknXCJcbiAgICAgICAgICAgICAgcj1cIjVcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxwYXRoIGNsYXNzPVwidHJpYW5nbGVcIlxuICAgICAgICAgICAgICB2LWlmPVwibm9kZS52YWx1ZSA8IHYwXCJcbiAgICAgICAgICAgICAgOnRyYW5zZm9ybT1cIid0cmFuc2xhdGUoJyArIHQyeCggbm9kZS50aW1lICkgKyAnLCcgKyBoZWlnaHQgKyAnKSdcIlxuICAgICAgICAgICAgICBkPVwiTSAwIC00IEwgNSAtMTIgTCAtNSAtMTIgelwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPHBhdGggY2xhc3M9XCJ0cmlhbmdsZVwiXG4gICAgICAgICAgICAgIHYtaWY9XCJ2MSA8IG5vZGUudmFsdWVcIlxuICAgICAgICAgICAgICA6dHJhbnNmb3JtPVwiJ3RyYW5zbGF0ZSgnICsgdDJ4KCBub2RlLnRpbWUgKSArICcsMCknXCJcbiAgICAgICAgICAgICAgZD1cIk0gMCA0IEwgLTUgMTIgTCA1IDEyIHpcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvZz5cbiAgICA8L3N2Zz5cblxuICAgIDxGeE1lbnVcbiAgICAgIDphdXRvbWF0b249XCJhdXRvbWF0b25cIlxuICAgICAgOmFjdGl2ZT1cImZ4bWVudUFjdGl2ZVwiXG4gICAgICBAc2VsZWN0ZWQ9XCJjcmVhdGVGeCggZnhtZW51VGltZSwgJGV2ZW50IClcIlxuICAgICAgQGJsdXI9XCJmeG1lbnVBY3RpdmUgPSBmYWxzZVwiXG4gICAgLz5cbiAgPC9kaXY+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgUGFyYW1XaXRoR1VJIGZyb20gJy4uL3BhcmFtLWd1aSc7XG5cbmltcG9ydCBGeE1lbnUgZnJvbSAnLi90aW1lbGluZS1meG1lbnUudnVlJztcblxuY29uc3QgbW91c2VFdmVudHMgPSAoIG1vdmUsIHVwICkgPT4ge1xuICBjb25zdCB1ID0gKCBldmVudCApID0+IHtcbiAgICBpZiAoIHVwICkgeyB1cCggZXZlbnQgKTsgfSBcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcIm1vdXNlbW92ZVwiLCBtb3ZlICk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibW91c2V1cFwiLCB1ICk7XG4gIH07XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibW91c2Vtb3ZlXCIsIG1vdmUgKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibW91c2V1cFwiLCB1ICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBGeE1lbnVcbiAgfSxcblxuICBwcm9wczogW1xuICAgIFwiYXV0b21hdG9uXCIsXG4gICAgXCJzZWxlY3RlZFBhcmFtTmFtZVwiLFxuICAgIFwic2VsZWN0ZWROb2RlSWRzXCIsXG4gICAgXCJzZWxlY3RlZEZ4SWRzXCJcbiAgXSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogMTAwLFxuICAgICAgaGVpZ2h0OiAxMDAsXG5cbiAgICAgIHQwOiAwLjAsXG4gICAgICB0MTogdGhpcy5hdXRvbWF0b24ubGVuZ3RoLFxuICAgICAgdjA6IC0wLjI1LFxuICAgICAgdjE6IDEuMjUsXG5cbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgeDogW10sXG4gICAgICAgIHk6IFtdXG4gICAgICB9LFxuXG4gICAgICBncmFwaFBvaW50czogJycsXG5cbiAgICAgIGZ4bWVudUFjdGl2ZTogZmFsc2UsXG4gICAgICBmeG1lbnVUaW1lOiAwXG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICB1cGRhdGVHcmlkKCkge1xuICAgICAgdGhpcy5ncmlkID0ge1xuICAgICAgICB4OiBbXSxcbiAgICAgICAgeTogW11cbiAgICAgIH07XG5cbiAgICAgIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSAoIHRoaXMudDEgLSB0aGlzLnQwICk7XG4gICAgICAgIGNvbnN0IGxvZ0RlbHRhID0gTWF0aC5sb2cxMCggZGVsdGEgKTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdyggMTAuMCwgTWF0aC5mbG9vciggbG9nRGVsdGEgKSAtIDEuMCApO1xuICAgICAgICBjb25zdCBpbnRydiA9IGxvZ0RlbHRhIC0gTWF0aC5mbG9vciggbG9nRGVsdGEgKTtcbiAgICAgICAgY29uc3QgbnVtID0gTWF0aC5mbG9vciggdGhpcy50MCAvIHNjYWxlICk7XG4gICAgICAgIGNvbnN0IGJlZ2luID0gbnVtICogc2NhbGU7XG4gICAgICAgIGxldCBhY2NlbnQxMCA9IG51bSAtIE1hdGguZmxvb3IoIG51bSAvIDEwICkgKiAxMDtcbiAgICAgICAgbGV0IGFjY2VudDEwMCA9IG51bSAtIE1hdGguZmxvb3IoIG51bSAvIDEwMCApICogMTAwO1xuXG4gICAgICAgIGZvciAoIGxldCB2ID0gYmVnaW47IHYgPCB0aGlzLnQxOyB2ICs9IHNjYWxlICkge1xuICAgICAgICAgIGNvbnN0IG9wID0gKFxuICAgICAgICAgICAgYWNjZW50MTAwID09PSAwID8gMC40IDpcbiAgICAgICAgICAgIGFjY2VudDEwID09PSAwID8gMC40IC0gaW50cnYgKiAwLjMgOlxuICAgICAgICAgICAgMC4xIC0gaW50cnYgKiAwLjNcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICggMC4wIDwgb3AgKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQueC5wdXNoKCB7XG4gICAgICAgICAgICAgIHZhbDogdiArIDFFLTksIC8vIHRyaWNrOiB0byBwcmV2ZW50IC0wLjAwMFxuICAgICAgICAgICAgICBwb3M6IHRoaXMudDJ4KCB2ICksXG4gICAgICAgICAgICAgIG9wOiBvcFxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY2NlbnQxMCA9ICggYWNjZW50MTAgKyAxICkgJSAxMDtcbiAgICAgICAgICBhY2NlbnQxMDAgPSAoIGFjY2VudDEwMCArIDEgKSAlIDEwMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gKCB0aGlzLnYxIC0gdGhpcy52MCApO1xuICAgICAgICBjb25zdCBsb2dEZWx0YSA9IE1hdGgubG9nMTAoIGRlbHRhICk7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coIDEwLjAsIE1hdGguZmxvb3IoIGxvZ0RlbHRhICkgLSAxLjAgKTtcbiAgICAgICAgY29uc3QgaW50cnYgPSBsb2dEZWx0YSAtIE1hdGguZmxvb3IoIGxvZ0RlbHRhICk7XG4gICAgICAgIGNvbnN0IG51bSA9IE1hdGguZmxvb3IoIHRoaXMudjAgLyBzY2FsZSApO1xuICAgICAgICBjb25zdCBiZWdpbiA9IG51bSAqIHNjYWxlO1xuICAgICAgICBsZXQgYWNjZW50MTAgPSBudW0gLSBNYXRoLmZsb29yKCBudW0gLyAxMCApICogMTA7XG4gICAgICAgIGxldCBhY2NlbnQxMDAgPSBudW0gLSBNYXRoLmZsb29yKCBudW0gLyAxMDAgKSAqIDEwMDtcblxuICAgICAgICBmb3IgKCBsZXQgdiA9IGJlZ2luOyB2IDwgdGhpcy52MTsgdiArPSBzY2FsZSApIHtcbiAgICAgICAgICBjb25zdCBvcCA9IChcbiAgICAgICAgICAgIGFjY2VudDEwMCA9PT0gMCA/IDAuNCA6XG4gICAgICAgICAgICBhY2NlbnQxMCA9PT0gMCA/IDAuNCAtIGludHJ2ICogMC4zIDpcbiAgICAgICAgICAgIDAuMSAtIGludHJ2ICogMC4zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIDAuMCA8IG9wICkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLnkucHVzaCgge1xuICAgICAgICAgICAgICB2YWw6IHYgKyAxRS05LCAvLyB0cmljazogdG8gcHJldmVudCAtMC4wMDBcbiAgICAgICAgICAgICAgcG9zOiB0aGlzLnYyeSggdiApLFxuICAgICAgICAgICAgICBvcDogb3BcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWNjZW50MTAgPSAoIGFjY2VudDEwICsgMSApICUgMTA7XG4gICAgICAgICAgYWNjZW50MTAwID0gKCBhY2NlbnQxMDAgKyAxICkgJSAxMDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlR3JhcGgoKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgbGV0IHBvaW50cyA9ICcnO1xuXG4gICAgICBmb3IgKCBsZXQgeCA9IDA7IHggPD0gdGhpcy53aWR0aDsgeCArKyApIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMueDJ0KCB4ICk7XG4gICAgICAgIGNvbnN0IHYgPSBwYXJhbS5nZXRWYWx1ZSggdCApO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy52MnkoIHYgKTtcbiAgICAgICAgcG9pbnRzICs9IHggKyAnICcgKyB5ICsgJyAnO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLmdyYXBoUG9pbnRzID0gcG9pbnRzO1xuICAgIH0sXG4gICAgXG4gICAgeDJ0KCB4ICkge1xuICAgICAgY29uc3QgdSA9IHggLyB0aGlzLndpZHRoO1xuICAgICAgcmV0dXJuIHUgKiAoIHRoaXMudDEgLSB0aGlzLnQwICkgKyB0aGlzLnQwO1xuICAgIH0sXG4gICAgdDJ4KCB0ICkge1xuICAgICAgY29uc3QgdSA9ICggdCAtIHRoaXMudDAgKSAvICggdGhpcy50MSAtIHRoaXMudDAgKTtcbiAgICAgIHJldHVybiB1ICogdGhpcy53aWR0aDtcbiAgICB9LFxuICAgIHkydiggeSApIHtcbiAgICAgIGNvbnN0IHUgPSAxLjAgLSB5IC8gdGhpcy5oZWlnaHQ7XG4gICAgICByZXR1cm4gdSAqICggdGhpcy52MSAtIHRoaXMudjAgKSArIHRoaXMudjA7XG4gICAgfSxcbiAgICB2MnkoIHYgKSB7XG4gICAgICBjb25zdCB1ID0gMS4wIC0gKCB2IC0gdGhpcy52MCApIC8gKCB0aGlzLnYxIC0gdGhpcy52MCApO1xuICAgICAgcmV0dXJuIHUgKiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgdGltZWxpbmUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHggRGVsdGEgb2YgWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeSBEZWx0YSBvZiBZXG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICBtb3ZlVmlldyggZHgsIGR5ICkge1xuICAgICAgbGV0IGR0ID0gdGhpcy54MnQoIDAuMCApIC0gdGhpcy54MnQoIGR4ICk7XG4gICAgICBsZXQgZHYgPSB0aGlzLnkydiggMC4wICkgLSB0aGlzLnkydiggZHkgKTtcblxuICAgICAgZHQgPSBNYXRoLm1pbiggTWF0aC5tYXgoIGR0LCAtdGhpcy50MCApLCB0aGlzLmF1dG9tYXRvbi5sZW5ndGggLSB0aGlzLnQxICk7XG5cbiAgICAgIHRoaXMudDAgKz0gZHQ7IHRoaXMudDEgKz0gZHQ7XG4gICAgICB0aGlzLnYwICs9IGR2OyB0aGlzLnYxICs9IGR2O1xuXG4gICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgIHRoaXMudXBkYXRlR3JhcGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0aGUgdGltZWxpbmUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3QgQ2VudGVyIG9mIFRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3YgQ2VudGVyIG9mIFZcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHggRGVsdGEgb2YgWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeSBEZWx0YSBvZiBZXG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICB6b29tVmlldyggY3QsIGN2LCBkeCwgZHkgKSB7XG4gICAgICBjb25zdCBydCA9ICggY3QgLSB0aGlzLnQwICkgLyAoIHRoaXMudDEgLSB0aGlzLnQwICk7XG4gICAgICBjb25zdCBydiA9ICggY3YgLSB0aGlzLnYwICkgLyAoIHRoaXMudjEgLSB0aGlzLnYwICk7XG5cbiAgICAgIGxldCBkdCA9IHRoaXMudDEgLSB0aGlzLnQwO1xuICAgICAgZHQgKj0gTWF0aC5wb3coICggdGhpcy53aWR0aCArIDEuMCApIC8gdGhpcy53aWR0aCwgZHggKiAyLjAgKTtcbiAgICAgIGR0ID0gTWF0aC5taW4oIE1hdGgubWF4KCBkdCwgMC4wMSApLCAxMDAwLjAgKTtcblxuICAgICAgbGV0IGR2ID0gdGhpcy52MSAtIHRoaXMudjA7XG4gICAgICBkdiAqPSBNYXRoLnBvdyggKCB0aGlzLndpZHRoICsgMS4wICkgLyB0aGlzLndpZHRoLCBkeSAqIDIuMCApO1xuICAgICAgZHYgPSBNYXRoLm1pbiggTWF0aC5tYXgoIGR2LCAwLjAxICksIDEwMDAuMCApO1xuXG4gICAgICB0aGlzLnQwID0gY3QgLSBydCAqIGR0O1xuICAgICAgdGhpcy50MSA9IGN0ICsgKCAxLjAgLSBydCApICogZHQ7XG4gICAgICB0aGlzLnYwID0gY3YgLSBydiAqIGR2O1xuICAgICAgdGhpcy52MSA9IGN2ICsgKCAxLjAgLSBydiApICogZHY7XG5cbiAgICAgIGlmICh0aGlzLnQwIDwgMC4wICkge1xuICAgICAgICB0aGlzLnQxID0gTWF0aC5tYXgoIHRoaXMudDEgLSB0aGlzLnQwLCB0aGlzLnQxICk7XG4gICAgICB9XG4gICAgICBpZiAoIHRoaXMuYXV0b21hdG9uLmxlbmd0aCA8IHRoaXMudDEgKSB7XG4gICAgICAgIHRoaXMudDAgKz0gdGhpcy5hdXRvbWF0b24ubGVuZ3RoIC0gdGhpcy50MTtcbiAgICAgIH1cbiAgICAgIGlmICggdGhpcy50MCA8IDAuMCApIHtcbiAgICAgICAgdGhpcy50MCA9IDAuMDtcbiAgICAgIH1cbiAgICAgIGlmICggdGhpcy5hdXRvbWF0b24ubGVuZ3RoIDwgdGhpcy50MSApIHtcbiAgICAgICAgdGhpcy50MSA9IHRoaXMuYXV0b21hdG9uLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgICB0aGlzLnVwZGF0ZUdyYXBoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5vZGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgVGltZSBwb2ludCB3aGVyZSB5b3Ugd2FudCB0byBjcmVhdGUgYSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHYgVmFsdWUgcG9pbnQgd2hlcmUgeW91IHdhbnQgdG8gY3JlYXRlIGEgbm9kZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAgICovXG4gICAgY3JlYXRlTm9kZSggdCwgdiApIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5zZWxlY3RlZFBhcmFtO1xuICAgICAgaWYgKCAhcGFyYW0gKSB7IHJldHVybjsgfVxuXG4gICAgICBjb25zdCBpZCA9IHBhcmFtLmNyZWF0ZU5vZGUoIHQsIHYgKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBwYXJhbS5kdW1wTm9kZSggaWQgKTtcblxuICAgICAgdGhpcy4kZW1pdCggJ25vZGVTZWxlY3RlZCcsIFsgaWQgXSApO1xuICAgICAgdGhpcy4kZW1pdCggJ2Z4U2VsZWN0ZWQnLCBbXSApO1xuXG4gICAgICB0aGlzLmF1dG9tYXRvbi5wdXNoSGlzdG9yeShcbiAgICAgICAgJ0NyZWF0ZSBOb2RlJyxcbiAgICAgICAgKCkgPT4gcGFyYW0uY3JlYXRlTm9kZUZyb21EYXRhKCBkYXRhICksXG4gICAgICAgICgpID0+IHBhcmFtLnJlbW92ZU5vZGUoIGlkIClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIG5vZGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElkIG9mIG5vZGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgICAqL1xuICAgIHJlbW92ZU5vZGUoIGlkICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnNlbGVjdGVkUGFyYW07XG4gICAgICBpZiAoICFwYXJhbSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBwYXJhbS5kdW1wTm9kZSggaWQgKTtcbiAgICAgIGlmICggISggbm9kZS5pbiAmJiBub2RlLm91dCApICkgeyByZXR1cm47IH1cblxuICAgICAgdGhpcy5hdXRvbWF0b24ucHVzaEhpc3RvcnkoXG4gICAgICAgICdSZW1vdmUgTm9kZScsXG4gICAgICAgICgpID0+IHBhcmFtLnJlbW92ZU5vZGUoIGlkICksXG4gICAgICAgICgpID0+IHBhcmFtLmNyZWF0ZU5vZGVGcm9tRGF0YSggbm9kZSApLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuXG4gICAgICB0aGlzLiRlbWl0KCAnbm9kZVNlbGVjdGVkJywgW10gKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgaGFuZGxlIG9mIGEgbm9kZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSWQgb2Ygbm9kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPdXQgSW5wdXQgaGFuZGxlIGlmIGZhbHNlLCBvdXRwdXQgaGFuZGxlIGlmIHRydWVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgICAqL1xuICAgIHJlbW92ZUhhbmRsZSggaWQsIGlzT3V0ICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnNlbGVjdGVkUGFyYW07XG4gICAgICBpZiAoICFwYXJhbSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBwYXJhbS5kdW1wTm9kZSggaWQgKTtcblxuICAgICAgY29uc3QgdDAgPSBpc091dCA/IG5vZGUub3V0LnRpbWUgOiBub2RlLmluLnRpbWU7XG4gICAgICBjb25zdCB2MCA9IGlzT3V0ID8gbm9kZS5vdXQudmFsdWUgOiBub2RlLmluLnZhbHVlO1xuXG4gICAgICBwYXJhbS5tb3ZlSGFuZGxlKCBpZCwgaXNPdXQsIDAuMCwgMC4wICk7XG5cbiAgICAgIHRoaXMuYXV0b21hdG9uLnB1c2hIaXN0b3J5KFxuICAgICAgICAnUmVtb3ZlIEhhbmRsZScsXG4gICAgICAgICgpID0+IHBhcmFtLm1vdmVIYW5kbGUoIGlkLCBpc091dCwgMC4wLCAwLjAgKSxcbiAgICAgICAgKCkgPT4gcGFyYW0ubW92ZUhhbmRsZSggaWQsIGlzT3V0LCB0MCwgdjAgKSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgaGFuZGxlcyBvZiBhIG5vZGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElkIG9mIG5vZGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgICAqL1xuICAgIHJlc2V0SGFuZGxlcyggaWQgKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHBhcmFtLmR1bXBOb2RlKCBpZCApO1xuXG4gICAgICB0aGlzLmF1dG9tYXRvbi5wdXNoSGlzdG9yeShcbiAgICAgICAgJ1Jlc2V0IEhhbmRsZScsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBwYXJhbS5yZXNldEhhbmRsZSggaWQsIGZhbHNlICk7XG4gICAgICAgICAgcGFyYW0ucmVzZXRIYW5kbGUoIGlkLCB0cnVlICk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBwYXJhbS5tb3ZlSGFuZGxlKCBpZCwgZmFsc2UsIG5vZGUuaW4udGltZSwgbm9kZS5pbi52YWx1ZSApO1xuICAgICAgICAgIHBhcmFtLm1vdmVIYW5kbGUoIGlkLCB0cnVlLCBub2RlLm91dC50aW1lLCBub2RlLm91dC52YWx1ZSApO1xuICAgICAgICB9LFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VzZSBvcGVyYXRpb24gaGVscGVyLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgTW91c2UgZXZlbnQgZnJvbSBtb3VzZWRvd25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBFdmVudCBsaXN0ZW5lciBmb3IgbW91c2Vtb3ZlIC8gbW91c2V1cFxuICAgICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAgICovXG4gICAgZ3JhYkhlbHBlciggZXZlbnQsIGNhbGxiYWNrICkge1xuICAgICAgY29uc3QgeDAgPSBldmVudC5jbGllbnRYO1xuICAgICAgY29uc3QgeTAgPSBldmVudC5jbGllbnRZO1xuICAgICAgY29uc3QgdDAgPSB0aGlzLngydCggeDAgKTtcbiAgICAgIGNvbnN0IHYwID0gdGhpcy55MnYoIHkwICk7XG5cbiAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuXG4gICAgICBjb25zdCBtb3ZlID0gKCBldmVudCApID0+IHtcbiAgICAgICAgY29uc3QgZHQgPSB0aGlzLngydCggZXZlbnQuY2xpZW50WCApIC0gdDA7XG4gICAgICAgIGNvbnN0IGR2ID0gdGhpcy55MnYoIGV2ZW50LmNsaWVudFkgKSAtIHYwO1xuXG4gICAgICAgIG1vdmVkID0gdHJ1ZTtcblxuICAgICAgICBjYWxsYmFjayggZHQsIGR2LCBldmVudCApO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgdXAgPSAoIGV2ZW50ICkgPT4ge1xuICAgICAgICBpZiAoIG1vdmVkICkge1xuICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy54MnQoIGV2ZW50LmNsaWVudFggKSAtIHQwO1xuICAgICAgICAgIGNvbnN0IGR2ID0gdGhpcy55MnYoIGV2ZW50LmNsaWVudFkgKSAtIHYwO1xuXG4gICAgICAgICAgY2FsbGJhY2soIGR0LCBkdiwgZXZlbnQsIHRydWUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgbW92ZSApO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCB1cCApO1xuICAgICAgfTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBtb3ZlICk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCB1cCApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTbmFwIGdpdmVuIHRpbWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVGltZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNuYXBwZWQgdGltZVxuICAgICAqL1xuICAgIHNuYXBUaW1lKCB0aW1lICkge1xuICAgICAgaWYgKCAhdGhpcy5hdXRvbWF0b24uZ3VpU2V0dGluZ3Muc25hcEFjdGl2ZSApIHsgcmV0dXJuIHRpbWU7IH1cblxuICAgICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLmF1dG9tYXRvbi5ndWlTZXR0aW5ncy5zbmFwVGltZTtcbiAgICAgIGNvbnN0IHdpZHRoID0gNS4wIC8gdGhpcy53aWR0aCAqICggdGhpcy50MSAtIHRoaXMudDAgKTtcbiAgICAgIGNvbnN0IG5lYXJlc3QgPSBNYXRoLnJvdW5kKCB0aW1lIC8gaW50ZXJ2YWwgKSAqIGludGVydmFsO1xuICAgICAgcmV0dXJuIE1hdGguYWJzKCB0aW1lIC0gbmVhcmVzdCApIDwgd2lkdGggPyBuZWFyZXN0IDogdGltZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU25hcCBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTbmFwcGVkIHZhbHVlXG4gICAgICovXG4gICAgc25hcFZhbHVlKCB2YWx1ZSApIHtcbiAgICAgIGlmICggIXRoaXMuYXV0b21hdG9uLmd1aVNldHRpbmdzLnNuYXBBY3RpdmUgKSB7IHJldHVybiB2YWx1ZTsgfVxuXG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuYXV0b21hdG9uLmd1aVNldHRpbmdzLnNuYXBWYWx1ZTtcbiAgICAgIGNvbnN0IHdpZHRoID0gNS4wIC8gdGhpcy5oZWlnaHQgKiAoIHRoaXMudjEgLSB0aGlzLnYwICk7XG4gICAgICBjb25zdCBuZWFyZXN0ID0gTWF0aC5yb3VuZCggdmFsdWUgLyBpbnRlcnZhbCApICogaW50ZXJ2YWw7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoIHZhbHVlIC0gbmVhcmVzdCApIDwgd2lkdGggPyBuZWFyZXN0IDogdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyYWIgYSBub2RlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBJZCBvZiBhIG5vZGVcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IE1vdXNlIGV2ZW50XG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICBncmFiTm9kZSggaWQsIGV2ZW50ICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnNlbGVjdGVkUGFyYW07XG4gICAgICBpZiAoICFwYXJhbSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHRoaXMuJGVtaXQoICdub2RlU2VsZWN0ZWQnLCBbIGlkIF0gKTtcbiAgICAgIHRoaXMuJGVtaXQoICdmeFNlbGVjdGVkJywgW10gKTtcblxuICAgICAgY29uc3Qgbm9kZSA9IHBhcmFtLmR1bXBOb2RlKCBpZCApO1xuICAgICAgY29uc3QgdDAgPSBub2RlLnRpbWU7XG4gICAgICBjb25zdCB2MCA9IG5vZGUudmFsdWU7XG5cbiAgICAgIHRoaXMuZ3JhYkhlbHBlciggZXZlbnQsICggZHQsIGR2LCBldmVudCwgaXNVcCApID0+IHtcbiAgICAgICAgbGV0IHQgPSB0MCArIGR0O1xuICAgICAgICBsZXQgdiA9IHYwICsgZHY7XG4gICAgICAgIGlmICggIWV2ZW50LmFsdEtleSApIHtcbiAgICAgICAgICB0ID0gdGhpcy5zbmFwVGltZSggdCApO1xuICAgICAgICAgIHYgPSB0aGlzLnNuYXBWYWx1ZSggdiApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBldmVudC5zaGlmdEtleSApIHsgdiA9IHYwOyB9XG4gICAgICAgIGVsc2UgaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7IHQgPSB0MDsgfVxuXG4gICAgICAgIHBhcmFtLm1vdmVOb2RlKCBpZCwgdCwgdiApO1xuXG4gICAgICAgIGlmICggaXNVcCApIHtcbiAgICAgICAgICB0aGlzLmF1dG9tYXRvbi5wdXNoSGlzdG9yeShcbiAgICAgICAgICAgICdNb3ZlIE5vZGUnLFxuICAgICAgICAgICAgKCkgPT4gcGFyYW0ubW92ZU5vZGUoIGlkLCB0LCB2ICksXG4gICAgICAgICAgICAoKSA9PiBwYXJhbS5tb3ZlTm9kZSggaWQsIHQwLCB2MCApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHcmFiIGEgaGFuZGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBJZCBvZiBhIGhhbmRsZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPdXQgSW5wdXQgaGFuZGxlIGlmIGZhbHNlLCBvdXRwdXQgaGFuZGxlIGlmIHRydWVcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IE1vdXNlIGV2ZW50XG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICBncmFiSGFuZGxlKCBpZCwgaXNPdXQsIGV2ZW50ICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnNlbGVjdGVkUGFyYW07XG4gICAgICBpZiAoICFwYXJhbSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBwYXJhbS5kdW1wTm9kZSggaWQgKTtcbiAgICAgIGNvbnN0IGhhbmRsZSA9IGlzT3V0ID8gbm9kZS5vdXQgOiBub2RlLmluO1xuXG4gICAgICBjb25zdCB0MCA9IGhhbmRsZS50aW1lO1xuICAgICAgY29uc3QgdjAgPSBoYW5kbGUudmFsdWU7XG5cbiAgICAgIGNvbnN0IGxlbjAgPSBNYXRoLnNxcnQoIHQwICogdDAgKyB2MCAqIHYwICk7XG4gICAgICBjb25zdCBudDAgPSB0MCAvIGxlbjA7XG4gICAgICBjb25zdCBudjAgPSB2MCAvIGxlbjA7XG5cbiAgICAgIGNvbnN0IGhhbmRsZU9wID0gaXNPdXQgPyBub2RlLmluIDogbm9kZS5vdXQ7XG4gICAgICBjb25zdCB0T3AwID0gaGFuZGxlT3AgPyBoYW5kbGVPcC50aW1lIDogMC4wO1xuICAgICAgY29uc3Qgdk9wMCA9IGhhbmRsZU9wID8gaGFuZGxlT3AudmFsdWUgOiAwLjA7XG5cbiAgICAgIHRoaXMuZ3JhYkhlbHBlciggZXZlbnQsICggZHQsIGR2LCBldmVudCwgaXNVcCApID0+IHtcbiAgICAgICAgbGV0IHQgPSB0MCArIGR0O1xuICAgICAgICBsZXQgdiA9IHYwICsgZHY7XG4gICAgICAgIGxldCB0T3AgPSB0T3AwO1xuICAgICAgICBsZXQgdk9wID0gdk9wMDtcblxuICAgICAgICBpZiAoIGV2ZW50LnNoaWZ0S2V5ICkge1xuICAgICAgICAgIGNvbnN0IGRvdCA9IHQgKiBudDAgKyB2ICogbnYwO1xuICAgICAgICAgIHQgPSBkb3QgKiBudDA7XG4gICAgICAgICAgdiA9IGRvdCAqIG52MDtcbiAgICAgICAgfSBlbHNlIGlmICggZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5ICkge1xuICAgICAgICAgIHRPcCA9IC10O1xuICAgICAgICAgIHZPcCA9IC12O1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW0ubW92ZUhhbmRsZSggaWQsIGlzT3V0LCB0LCB2ICk7XG4gICAgICAgIHBhcmFtLm1vdmVIYW5kbGUoIGlkLCAhaXNPdXQsIHRPcCwgdk9wICk7XG5cbiAgICAgICAgaWYgKCBpc1VwICkge1xuICAgICAgICAgIHRoaXMuYXV0b21hdG9uLnB1c2hIaXN0b3J5KFxuICAgICAgICAgICAgJ01vdmUgSGFuZGxlJyxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgcGFyYW0ubW92ZUhhbmRsZSggaWQsIGlzT3V0LCB0LCB2ICk7XG4gICAgICAgICAgICAgIHBhcmFtLm1vdmVIYW5kbGUoIGlkLCAhaXNPdXQsIHRPcCwgdk9wICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBwYXJhbS5tb3ZlSGFuZGxlKCBpZCwgaXNPdXQsIHQwLCB2MCApO1xuICAgICAgICAgICAgICBwYXJhbS5tb3ZlSGFuZGxlKCBpZCwgIWlzT3V0LCB0T3AwLCB2T3AwICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPcGVuIGZ4IG1lbnUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgRnggd2lsbCBiZSBjcmVhdGVkIG9uIHRoaXMgdGltZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAgICovXG4gICAgb3BlbkZ4TWVudSggdGltZSApIHtcbiAgICAgIHRoaXMuZnhtZW51QWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZnhtZW51VGltZSA9IHRpbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZ4LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgTW91c2UgZXZlbnQgY29tZXMgZnJvbSBkYmxjbGljayBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgZnggZGVmaW5pdGlvblxuICAgICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAgICovXG4gICAgY3JlYXRlRngoIGV2ZW50LCBuYW1lICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnNlbGVjdGVkUGFyYW07XG4gICAgICBpZiAoICFwYXJhbSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIGNvbnN0IHQgPSB0aGlzLmZ4bWVudVRpbWU7XG4gICAgICBjb25zdCBsID0gTWF0aC5taW4oIDEuMCwgdGhpcy5hdXRvbWF0b24ubGVuZ3RoIC0gdGhpcy5meG1lbnVUaW1lICk7XG4gICAgICBjb25zdCBpZCA9IHBhcmFtLmNyZWF0ZUZ4KCB0LCBsLCBuYW1lICk7XG4gICAgICBjb25zdCBkYXRhID0gcGFyYW0uZHVtcEZ4KCBpZCApO1xuXG4gICAgICBpZiAoICFpZCApIHsgcmV0dXJuOyB9XG4gICAgICB0aGlzLiRlbWl0KCAnbm9kZVNlbGVjdGVkJywgW10gKTtcbiAgICAgIHRoaXMuJGVtaXQoICdmeFNlbGVjdGVkJywgWyBpZCBdICk7XG5cbiAgICAgIHRoaXMuYXV0b21hdG9uLnB1c2hIaXN0b3J5KFxuICAgICAgICAnQ3JlYXRlIEZ4JyxcbiAgICAgICAgKCkgPT4gcGFyYW0uY3JlYXRlRnhGcm9tRGF0YSggZGF0YSApLFxuICAgICAgICAoKSA9PiBwYXJhbS5yZW1vdmVGeCggaWQgKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZnguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElkIG9mIGZ4XG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICByZW1vdmVGeCggaWQgKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuc2VsZWN0ZWRQYXJhbTtcbiAgICAgIGlmICggIXBhcmFtICkgeyByZXR1cm47IH1cblxuICAgICAgY29uc3QgZnggPSBwYXJhbS5kdW1wRngoIGlkICk7XG5cbiAgICAgIHRoaXMuYXV0b21hdG9uLnB1c2hIaXN0b3J5KFxuICAgICAgICAnUmVtb3ZlIEZ4JyxcbiAgICAgICAgKCkgPT4gcGFyYW0ucmVtb3ZlRngoIGlkICksXG4gICAgICAgICgpID0+IHBhcmFtLmNyZWF0ZUZ4RnJvbURhdGEoIGZ4ICksXG4gICAgICAgIHRydWVcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuJGVtaXQoICdmeFNlbGVjdGVkJywgW10gKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR3JhYiBhIGJvZHkgb2YgZnguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElkIG9mIGZ4XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBNb3VzZSBldmVudFxuICAgICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAgICovXG4gICAgZ3JhYkZ4Qm9keSggaWQsIGV2ZW50ICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnNlbGVjdGVkUGFyYW07XG4gICAgICBpZiAoICFwYXJhbSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHRoaXMuJGVtaXQoICdub2RlU2VsZWN0ZWQnLCBbXSApO1xuICAgICAgdGhpcy4kZW1pdCggJ2Z4U2VsZWN0ZWQnLCBbIGlkIF0gKTtcbiAgICAgIFxuICAgICAgY29uc3QgZnggPSBwYXJhbS5kdW1wRngoIGlkICk7XG5cbiAgICAgIGNvbnN0IHQwID0gZngudGltZTtcbiAgICAgIGNvbnN0IHIwID0gZngucm93O1xuXG4gICAgICBjb25zdCB5MCA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICAgIHRoaXMuZ3JhYkhlbHBlciggZXZlbnQsICggZHQsIGR2LCBldmVudCwgaXNVcCApID0+IHtcbiAgICAgICAgY29uc3QgZHkgPSBldmVudC5jbGllbnRZIC0geTA7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IE1hdGgubWluKCBNYXRoLm1heCggcjAgKyBNYXRoLnJvdW5kKCBkeSAvIDE2LjAgKSwgMCApLCBQYXJhbVdpdGhHVUkuRlhfUk9XX01BWCApO1xuXG4gICAgICAgIGxldCB0ID0gdDAgKyBkdDtcbiAgICAgICAgaWYgKCAhZXZlbnQuYWx0S2V5ICkge1xuICAgICAgICAgIHQgPSB0aGlzLnNuYXBUaW1lKCB0ICk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbS5tb3ZlRngoIGlkLCB0ICk7XG4gICAgICAgIHBhcmFtLmNoYW5nZUZ4Um93KCBpZCwgbmV3Um93ICk7XG5cbiAgICAgICAgaWYgKCBpc1VwICkge1xuICAgICAgICAgIHRoaXMuYXV0b21hdG9uLnB1c2hIaXN0b3J5KFxuICAgICAgICAgICAgJ01vdmUgRngnLFxuICAgICAgICAgICAgKCkgPT4gcGFyYW0uZm9yY2VNb3ZlRngoIGlkLCB0LCBuZXdSb3cgKSxcbiAgICAgICAgICAgICgpID0+IHBhcmFtLmZvcmNlTW92ZUZ4KCBpZCwgdDAsIHIwIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9ICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyYWIgYSBsZWZ0IHNpZGUgb2YgZnguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElkIG9mIGZ4XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBNb3VzZSBldmVudFxuICAgICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAgICovXG4gICAgZ3JhYkZ4TGVmdCggaWQsIGV2ZW50ICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnNlbGVjdGVkUGFyYW07XG4gICAgICBpZiAoICFwYXJhbSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHRoaXMuJGVtaXQoICdub2RlU2VsZWN0ZWQnLCBbXSApO1xuICAgICAgdGhpcy4kZW1pdCggJ2Z4U2VsZWN0ZWQnLCBbIGlkIF0gKTtcblxuICAgICAgY29uc3QgZnggPSBwYXJhbS5kdW1wRngoIGlkICk7XG5cbiAgICAgIGNvbnN0IGwwID0gZngubGVuZ3RoO1xuICAgICAgY29uc3QgZW5kMCA9IGZ4LnRpbWUgKyBsMDtcblxuICAgICAgdGhpcy5ncmFiSGVscGVyKCBldmVudCwgKCBkdCwgZHYsIGV2ZW50LCBpc1VwICkgPT4ge1xuICAgICAgICBsZXQgbCA9IGwwIC0gZHQ7XG4gICAgICAgIGlmICggIWV2ZW50LmFsdEtleSApIHtcbiAgICAgICAgICBsID0gdGhpcy5zbmFwVGltZSggbCAtIGVuZDAgKSArIGVuZDA7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbS5yZXNpemVGeEJ5TGVmdCggaWQsIGwgKTtcblxuICAgICAgICBpZiAoIGlzVXAgKSB7XG4gICAgICAgICAgdGhpcy5hdXRvbWF0b24ucHVzaEhpc3RvcnkoXG4gICAgICAgICAgICAnUmVzaXplIEZ4JyxcbiAgICAgICAgICAgICgpID0+IHBhcmFtLnJlc2l6ZUZ4QnlMZWZ0KCBpZCwgbCApLFxuICAgICAgICAgICAgKCkgPT4gcGFyYW0ucmVzaXplRnhCeUxlZnQoIGlkLCBsMCApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHcmFiIGEgcmlnaHQgc2lkZSBvZiBmeC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSWQgb2YgZnhcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IE1vdXNlIGV2ZW50XG4gICAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICAgKi9cbiAgICBncmFiRnhSaWdodCggaWQsIGV2ZW50ICkge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnNlbGVjdGVkUGFyYW07XG4gICAgICBpZiAoICFwYXJhbSApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHRoaXMuJGVtaXQoICdub2RlU2VsZWN0ZWQnLCBbXSApO1xuICAgICAgdGhpcy4kZW1pdCggJ2Z4U2VsZWN0ZWQnLCBbIGlkIF0gKTtcblxuICAgICAgY29uc3QgZnggPSBwYXJhbS5kdW1wRngoIGlkICk7XG5cbiAgICAgIGNvbnN0IGwwID0gZngubGVuZ3RoO1xuICAgICAgY29uc3QgdDAgPSBmeC50aW1lO1xuXG4gICAgICB0aGlzLmdyYWJIZWxwZXIoIGV2ZW50LCAoIGR0LCBkdiwgZXZlbnQsIGlzVXAgKSA9PiB7XG4gICAgICAgIGxldCBsID0gbDAgKyBkdDtcbiAgICAgICAgaWYgKCAhZXZlbnQuYWx0S2V5ICkge1xuICAgICAgICAgIGwgPSB0aGlzLnNuYXBUaW1lKCBsICsgdDAgKSAtIHQwO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW0ucmVzaXplRngoIGlkLCBsICk7XG5cbiAgICAgICAgaWYgKCBpc1VwICkge1xuICAgICAgICAgIHRoaXMuYXV0b21hdG9uLnB1c2hIaXN0b3J5KFxuICAgICAgICAgICAgJ1Jlc2l6ZSBGeCcsXG4gICAgICAgICAgICAoKSA9PiBwYXJhbS5yZXNpemVGeCggaWQsIGwgKSxcbiAgICAgICAgICAgICgpID0+IHBhcmFtLnJlc2l6ZUZ4KCBpZCwgbDAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcbiAgICB9LFxuXG4gICAgZHJhZ0JnKCBldmVudCApIHtcbiAgICAgIGNvbnN0IHQwID0gdGhpcy54MnQoIGV2ZW50Lm9mZnNldFggKTtcbiAgICAgIGNvbnN0IHYwID0gdGhpcy55MnYoIGV2ZW50Lm9mZnNldFkgKTtcbiAgICAgIGNvbnN0IHdoaWNoID0gZXZlbnQud2hpY2g7XG4gICAgICBjb25zdCBzaGlmdEtleSA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgY29uc3QgYWx0S2V5ID0gZXZlbnQuYWx0S2V5O1xuXG4gICAgICBjb25zdCB4MCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICBjb25zdCB5MCA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBsZXQgeFByZXYgPSB4MDtcbiAgICAgIGxldCB5UHJldiA9IHkwO1xuXG4gICAgICBjb25zdCBpc1BsYXlpbmcwID0gdGhpcy5hdXRvbWF0b24uaXNQbGF5aW5nO1xuICAgICAgaWYgKCBhbHRLZXkgKSB7XG4gICAgICAgIHRoaXMuYXV0b21hdG9uLnNlZWsoIHQwICk7XG4gICAgICAgIGlmICggaXNQbGF5aW5nMCApIHtcbiAgICAgICAgICB0aGlzLmF1dG9tYXRvbi5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vdmUgPSAoIGV2ZW50ICkgPT4ge1xuICAgICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGNvbnN0IGR4ID0gZXZlbnQuY2xpZW50WCAtIHhQcmV2O1xuICAgICAgICBjb25zdCBkeSA9IGV2ZW50LmNsaWVudFkgLSB5UHJldjtcblxuICAgICAgICBpZiAoIHdoaWNoID09PSAxICkge1xuICAgICAgICAgIGlmICggYWx0S2V5ICkge1xuICAgICAgICAgICAgdGhpcy5hdXRvbWF0b24uc2VlayggdDAgKyB0aGlzLngydCggeCAtIHgwICkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIHdoaWNoID09PSAyICkge1xuICAgICAgICAgIGlmICggc2hpZnRLZXkgKSB7XG4gICAgICAgICAgICB0aGlzLnpvb21WaWV3KCB0MCwgdjAsIC1keCwgZHkgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVmlldyggZHgsIGR5ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeFByZXYgPSB4O1xuICAgICAgICB5UHJldiA9IHk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cCA9ICggZXZlbnQgKSA9PiB7XG4gICAgICAgIGlmICggYWx0S2V5ICYmIGlzUGxheWluZzAgKSB7XG4gICAgICAgICAgdGhpcy5hdXRvbWF0b24ucGxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBtb3ZlICk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIHVwICk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdmUgKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIHVwICk7XG4gICAgfSxcblxuICAgIGNvbnRleHRCZyggZXZlbnQgKSB7XG4gICAgICBpZiAoICF0aGlzLnNlbGVjdGVkUGFyYW0gKSB7IHJldHVybjsgfVxuXG4gICAgICBjb25zdCB0ID0gdGhpcy54MnQoIGV2ZW50Lm9mZnNldFggKTtcbiAgICAgIGNvbnN0IHYgPSB0aGlzLnkydiggZXZlbnQub2Zmc2V0WSApO1xuXG4gICAgICB0aGlzLiRlbWl0KCAnY29udGV4dCcsIHtcbiAgICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgY29tbWFuZHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0OiAnQWRkIE5vZGUnLFxuICAgICAgICAgICAgZnVuYzogKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmNyZWF0ZU5vZGUoIHQsIHYgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRleHQ6ICdBZGQgRngnLFxuICAgICAgICAgICAgZnVuYzogKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLm9wZW5GeE1lbnUoIHQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0gKTtcbiAgICB9LFxuXG4gICAgb25XaGVlbCggZXZlbnQgKSB7XG4gICAgICBjb25zdCB0MCA9IHRoaXMueDJ0KCBldmVudC5vZmZzZXRYICk7XG4gICAgICBjb25zdCB2MCA9IHRoaXMueTJ2KCBldmVudC5vZmZzZXRZICk7XG5cbiAgICAgIGlmICggZXZlbnQuc2hpZnRLZXkgKSB7IC8vIHpvb20gaG9yaXpvbnRhbGx5XG4gICAgICAgIHRoaXMuem9vbVZpZXcoIHQwLCB2MCwgLWV2ZW50LmRlbHRhWSwgMCApO1xuICAgICAgfSBlbHNlIGlmICggZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5ICkgeyAvLyB6b29tIHZlcnRpY2FsbHlcbiAgICAgICAgdGhpcy56b29tVmlldyggdDAsIHYwLCAwLCAtZXZlbnQuZGVsdGFZICk7XG4gICAgICB9IGVsc2UgeyAvLyBtb3ZlXG4gICAgICAgIHRoaXMubW92ZVZpZXcoIGV2ZW50LmRlbHRhWCwgLWV2ZW50LmRlbHRhWSApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgIHRoaXMudXBkYXRlR3JhcGgoKTtcbiAgICB9LFxuXG4gICAgb25SZXNpemUoKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMuJHJlZnMucm9vdDtcbiAgICAgIHRoaXMud2lkdGggPSBlbC5jbGllbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0IC0gNDtcblxuICAgICAgdGhpcy4kbmV4dFRpY2soICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JhcGgoKTtcbiAgICAgIH0gKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBzZWxlY3RlZFBhcmFtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXV0b21hdG9uLmdldFBhcmFtKCB0aGlzLnNlbGVjdGVkUGFyYW1OYW1lICk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgc2VsZWN0ZWRQYXJhbU5hbWUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUdyYXBoKCk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy4kcm9vdC4kb24oICdsb2FkZWQnLCAoKSA9PiB7XG4gICAgICB0aGlzLnQwID0gMC4wO1xuICAgICAgdGhpcy50MSA9IHRoaXMuYXV0b21hdG9uLmxlbmd0aDtcbiAgICB9ICk7XG5cbiAgICB0aGlzLiRyb290LiRvbiggJ2NoYW5nZWRMZW5ndGgnLCAoKSA9PiB7XG4gICAgICB0aGlzLnQwID0gMC4wO1xuICAgICAgdGhpcy50MSA9IHRoaXMuYXV0b21hdG9uLmxlbmd0aDtcblxuICAgICAgdGhpcy51cGRhdGVHcmFwaCgpO1xuICAgIH0gKTtcblxuICAgIHRoaXMuJHJvb3QuJG9uKCAncG9rZScsICgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlR3JhcGgoKTtcbiAgICB9ICk7XG5cbiAgICB0aGlzLiRuZXh0VGljayggKCkgPT4ge1xuICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIH0gKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUgKTtcbiAgfSxcblxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAncmVzaXplJywgdGhpcy5vblJlc2l6ZSApO1xuICB9LFxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbkBpbXBvcnQgXCIuL2NvbG9ycy5zY3NzXCI7XG5cbi5yb290IHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBsZWZ0OiAwO1xuICB0b3A6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG5cbiAgY29sb3I6ICRjb2xvci1mb3JlO1xuXG4gIC5oYmFyIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICBib3R0b206IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiA0cHg7XG5cbiAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmxhY2s7XG4gICAgXG4gICAgLnZpc2lvbiB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IDA7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcblxuICAgICAgYmFja2dyb3VuZDogJGNvbG9yLWFjY2VudDtcbiAgICB9XG4gIH1cblxuICAuc3ZnIHtcbiAgICBiYWNrZ3JvdW5kOiAkY29sb3ItYmFjazE7XG5cbiAgICBmb250LXNpemU6IDEwcHg7XG5cbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcblxuICAgIC5ncmlkIHtcbiAgICAgIHN0cm9rZTogJGNvbG9yLWZvcmU7XG4gICAgICBzdHJva2Utd2lkdGg6IDE7XG4gICAgfVxuXG4gICAgLmdyaWQtdGV4dCB7XG4gICAgICBmaWxsOiAkY29sb3ItZm9yZTtcbiAgICB9XG5cbiAgICAuZ3JhcGgge1xuICAgICAgZmlsbDogbm9uZTtcbiAgICAgIHN0cm9rZTogJGNvbG9yLWZvcmU7XG4gICAgICBzdHJva2Utd2lkdGg6IDI7XG4gICAgfVxuXG4gICAgLmN1cnJlbnRMaW5lIHtcbiAgICAgIHN0cm9rZTogJGNvbG9yLWFjY2VudDtcbiAgICAgIHN0cm9rZS13aWR0aDogMjtcbiAgICB9XG5cbiAgICAuY3VycmVudFRleHQge1xuICAgICAgZmlsbDogJGNvbG9yLWFjY2VudDtcbiAgICB9XG5cbiAgICAuY3VycmVudFBvaW50IHtcbiAgICAgIGZpbGw6ICRjb2xvci1hY2NlbnQ7XG4gICAgfVxuXG4gICAgLm5vZGUge1xuICAgICAgLmhhbmRsZSB7XG4gICAgICAgIC5saW5lIHtcbiAgICAgICAgICBzdHJva2U6ICRjb2xvci1hY2NlbnQ7XG4gICAgICAgICAgc3Ryb2tlLXdpZHRoOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLmNpcmNsZSB7XG4gICAgICAgICAgZmlsbDogJGNvbG9yLWFjY2VudDtcblxuICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAuYm9keSB7XG4gICAgICAgIGZpbGw6ICRjb2xvci1iYWNrMTtcbiAgICAgICAgc3Ryb2tlOiAkY29sb3ItYWNjZW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDI7XG5cbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICAmLnNlbGVjdGVkIHtcbiAgICAgICAgICBmaWxsOiAkY29sb3ItYWNjZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLmZ4IHtcbiAgICAgIC5saW5lIHtcbiAgICAgICAgc3Ryb2tlOiAkY29sb3ItZng7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMTtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNDtcbiAgICAgIH1cblxuICAgICAgLmZpbGwge1xuICAgICAgICBmaWxsOiAkY29sb3ItZng7XG4gICAgICAgIG9wYWNpdHk6IDAuMTtcbiAgICAgIH1cblxuICAgICAgLmJvZHkge1xuICAgICAgICBmaWxsOiAkY29sb3ItYmFjazE7XG4gICAgICAgIHN0cm9rZTogJGNvbG9yLWZ4O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDI7XG5cbiAgICAgICAgJi5ieXBhc3Mge1xuICAgICAgICAgIGZpbGw6ICRjb2xvci1iYWNrMTtcbiAgICAgICAgICBzdHJva2U6ICRjb2xvci1ncmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgJi5zZWxlY3RlZCB7XG4gICAgICAgICAgZmlsbDogJGNvbG9yLWZ4O1xuICAgICAgICAgIHN0cm9rZTogJGNvbG9yLWJhY2sxO1xuXG4gICAgICAgICAgJi5ieXBhc3Mge1xuICAgICAgICAgICAgZmlsbDogJGNvbG9yLWdyYXk7XG4gICAgICAgICAgICBzdHJva2U6ICRjb2xvci1iYWNrMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgfVxuXG4gICAgICAudGV4dCB7XG4gICAgICAgIGZpbGw6ICRjb2xvci1meDtcbiAgICAgICAgJi5ieXBhc3MgeyBmaWxsOiAkY29sb3ItZ3JheTsgfVxuICAgICAgICAmLnNlbGVjdGVkIHsgZmlsbDogJGNvbG9yLWJhY2sxOyB9XG4gICAgICB9XG5cbiAgICAgIC5zaWRlIHtcbiAgICAgICAgZmlsbDogcmdiYSggMCwgMCwgMCwgMCApO1xuXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgICAgICBjdXJzb3I6IGV3LXJlc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc3R5bGU+XG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJib2R5IHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGZvbnQ6IDUwMCAxMHB4ICdXdC1Qb3NpdGlvbicsIHNhbnMtc2VyaWY7XFxuICBiYWNrZ3JvdW5kOiAjMDAwO1xcbiAgY29sb3I6ICNmZmY7IH1cXG4gIGJvZHkgI2RpdkFjdGl2ZSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgbGVmdDogOHB4O1xcbiAgICBib3R0b206IDI0OHB4OyB9XFxuICBib2R5ICNkaXZNaWRpIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBsZWZ0OiA4cHg7XFxuICAgIGJvdHRvbTogMjQ4cHg7IH1cXG4gIGJvZHkgI2RpdlBhdGgge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHJpZ2h0OiA4cHg7XFxuICAgIGJvdHRvbTogMjQ4cHg7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0OyB9XFxuICBib2R5ICNkaXZBdXRvbWF0b24ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMjQwcHg7IH1cXG4gIGJvZHkgI2NhbnZhcyB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE11dGF0aW9uID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbnZhciBzY2hlZHVsZURyYWluO1xuXG57XG4gIGlmIChNdXRhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSAwO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbihuZXh0VGljayk7XG4gICAgdmFyIGVsZW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBlbGVtZW50LmRhdGEgPSAoY2FsbGVkID0gKytjYWxsZWQgJSAyKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFnbG9iYWwuc2V0SW1tZWRpYXRlICYmIHR5cGVvZiBnbG9iYWwuTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKCk7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBuZXh0VGljaztcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCdkb2N1bWVudCcgaW4gZ2xvYmFsICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgIHZhciBzY3JpcHRFbCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dFRpY2soKTtcblxuICAgICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICBzY3JpcHRFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdEVsKTtcbiAgICAgICAgc2NyaXB0RWwgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2ssIDApO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGRyYWluaW5nO1xudmFyIHF1ZXVlID0gW107XG4vL25hbWVkIG5leHRUaWNrIGZvciBsZXNzIGNvbmZ1c2luZyBzdGFjayB0cmFjZXNcbmZ1bmN0aW9uIG5leHRUaWNrKCkge1xuICBkcmFpbmluZyA9IHRydWU7XG4gIHZhciBpLCBvbGRRdWV1ZTtcbiAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGxlbikge1xuICAgIG9sZFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgb2xkUXVldWVbaV0oKTtcbiAgICB9XG4gICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICB9XG4gIGRyYWluaW5nID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW1tZWRpYXRlO1xuZnVuY3Rpb24gaW1tZWRpYXRlKHRhc2spIHtcbiAgaWYgKHF1ZXVlLnB1c2godGFzaykgPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgc2NoZWR1bGVEcmFpbigpO1xuICB9XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbi8vIHByaXZhdGUgcHJvcGVydHlcbnZhciBfa2V5U3RyID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuXG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGVuY29kaW5nXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzLCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIHZhciBpID0gMCwgbGVuID0gaW5wdXQubGVuZ3RoLCByZW1haW5pbmdCeXRlcyA9IGxlbjtcblxuICAgIHZhciBpc0FycmF5ID0gdXRpbHMuZ2V0VHlwZU9mKGlucHV0KSAhPT0gXCJzdHJpbmdcIjtcbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZW1haW5pbmdCeXRlcyA9IGxlbiAtIGk7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgY2hyMiA9IGkgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrKykgOiAwO1xuICAgICAgICAgICAgY2hyMyA9IGkgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrKykgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICAgICAgY2hyMyA9IGkgPCBsZW4gPyBpbnB1dFtpKytdIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xuICAgICAgICBlbmMzID0gcmVtYWluaW5nQnl0ZXMgPiAxID8gKCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKSA6IDY0O1xuICAgICAgICBlbmM0ID0gcmVtYWluaW5nQnl0ZXMgPiAyID8gKGNocjMgJiA2MykgOiA2NDtcblxuICAgICAgICBvdXRwdXQucHVzaChfa2V5U3RyLmNoYXJBdChlbmMxKSArIF9rZXlTdHIuY2hhckF0KGVuYzIpICsgX2tleVN0ci5jaGFyQXQoZW5jMykgKyBfa2V5U3RyLmNoYXJBdChlbmM0KSk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59O1xuXG4vLyBwdWJsaWMgbWV0aG9kIGZvciBkZWNvZGluZ1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICAgIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIHZhciBpID0gMCwgcmVzdWx0SW5kZXggPSAwO1xuXG4gICAgdmFyIGRhdGFVcmxQcmVmaXggPSBcImRhdGE6XCI7XG5cbiAgICBpZiAoaW5wdXQuc3Vic3RyKDAsIGRhdGFVcmxQcmVmaXgubGVuZ3RoKSA9PT0gZGF0YVVybFByZWZpeCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgY29tbW9uIGVycm9yOiBwZW9wbGUgZ2l2ZSBhIGRhdGEgdXJsXG4gICAgICAgIC8vIChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1IuLi4pIHdpdGggYSB7YmFzZTY0OiB0cnVlfSBhbmRcbiAgICAgICAgLy8gd29uZGVycyB3aHkgdGhpbmdzIGRvbid0IHdvcmsuXG4gICAgICAgIC8vIFdlIGNhbiBkZXRlY3QgdGhhdCB0aGUgc3RyaW5nIGlucHV0IGxvb2tzIGxpa2UgYSBkYXRhIHVybCBidXQgd2VcbiAgICAgICAgLy8gKmNhbid0KiBiZSBzdXJlIGl0IGlzIG9uZTogcmVtb3ZpbmcgZXZlcnl0aGluZyB1cCB0byB0aGUgY29tbWEgd291bGRcbiAgICAgICAgLy8gYmUgdG9vIGRhbmdlcm91cy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgaW5wdXQsIGl0IGxvb2tzIGxpa2UgYSBkYXRhIHVybC5cIik7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgXCJcIik7XG5cbiAgICB2YXIgdG90YWxMZW5ndGggPSBpbnB1dC5sZW5ndGggKiAzIC8gNDtcbiAgICBpZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMSkgPT09IF9rZXlTdHIuY2hhckF0KDY0KSkge1xuICAgICAgICB0b3RhbExlbmd0aC0tO1xuICAgIH1cbiAgICBpZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMikgPT09IF9rZXlTdHIuY2hhckF0KDY0KSkge1xuICAgICAgICB0b3RhbExlbmd0aC0tO1xuICAgIH1cbiAgICBpZiAodG90YWxMZW5ndGggJSAxICE9PSAwKSB7XG4gICAgICAgIC8vIHRvdGFsTGVuZ3RoIGlzIG5vdCBhbiBpbnRlZ2VyLCB0aGUgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGEgdmFsaWRcbiAgICAgICAgLy8gYmFzZTY0IGNvbnRlbnQuIFRoYXQgY2FuIGhhcHBlbiBpZjpcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgaXMgbm90IGEgYmFzZTY0IGNvbnRlbnRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgaXMgKmFsbW9zdCogYSBiYXNlNjQgY29udGVudCwgd2l0aCBhIGV4dHJhIGNoYXJzIGF0IHRoZVxuICAgICAgICAvLyAgIGJlZ2lubmluZyBvciBhdCB0aGUgZW5kXG4gICAgICAgIC8vIC0gdGhlIGlucHV0IHVzZXMgYSBiYXNlNjQgdmFyaWFudCAoYmFzZTY0dXJsIGZvciBleGFtcGxlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgYmFkIGNvbnRlbnQgbGVuZ3RoLlwiKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dDtcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBBcnJheSh0b3RhbExlbmd0aHwwKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuXG4gICAgICAgIGVuYzEgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMyID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMyA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuXG4gICAgICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuICAgICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICAgIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG5cbiAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMTtcblxuICAgICAgICBpZiAoZW5jMyAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XG4gICAgICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIzO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFXb3JrZXInKTtcbnZhciBEYXRhTGVuZ3RoUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUnKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vQ3JjMzJQcm9iZScpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZScpO1xuXG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbXByZXNzZWQgb2JqZWN0LCB3aXRoIGV2ZXJ5dGhpbmcgbmVlZGVkIHRvIGRlY29tcHJlc3MgaXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBjb21wcmVzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHVuY29tcHJlc3NlZFNpemUgdGhlIHNpemUgb2YgdGhlIGRhdGEgYWZ0ZXIgZGVjb21wcmVzc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjcmMzMiB0aGUgY3JjMzIgb2YgdGhlIGRlY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXByZXNzaW9uIHRoZSB0eXBlIG9mIGNvbXByZXNzaW9uLCBzZWUgbGliL2NvbXByZXNzaW9ucy5qcy5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIENvbXByZXNzZWRPYmplY3QoY29tcHJlc3NlZFNpemUsIHVuY29tcHJlc3NlZFNpemUsIGNyYzMyLCBjb21wcmVzc2lvbiwgZGF0YSkge1xuICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSBjb21wcmVzc2VkU2l6ZTtcbiAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSB1bmNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMuY3JjMzIgPSBjcmMzMjtcbiAgICB0aGlzLmNvbXByZXNzaW9uID0gY29tcHJlc3Npb247XG4gICAgdGhpcy5jb21wcmVzc2VkQ29udGVudCA9IGRhdGE7XG59XG5cbkNvbXByZXNzZWRPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdvcmtlciB0byBnZXQgdGhlIHVuY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29udGVudFdvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgLnBpcGUodGhpcy5jb21wcmVzc2lvbi51bmNvbXByZXNzV29ya2VyKCkpXG4gICAgICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJkYXRhX2xlbmd0aFwiKSk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB3b3JrZXIub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYodGhpcy5zdHJlYW1JbmZvWydkYXRhX2xlbmd0aCddICE9PSB0aGF0LnVuY29tcHJlc3NlZFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiB1bmNvbXByZXNzZWQgZGF0YSBzaXplIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdvcmtlciB0byBnZXQgdGhlIGNvbXByZXNzZWQgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIGdldENvbXByZXNzZWRXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVdvcmtlcihleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUodGhpcy5jb21wcmVzc2VkQ29udGVudCkpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzZWRTaXplXCIsIHRoaXMuY29tcHJlc3NlZFNpemUpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcInVuY29tcHJlc3NlZFNpemVcIiwgdGhpcy51bmNvbXByZXNzZWRTaXplKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCB0aGlzLmNyYzMyKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCB0aGlzLmNvbXByZXNzaW9uKVxuICAgICAgICA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGFpbiB0aGUgZ2l2ZW4gd29ya2VyIHdpdGggb3RoZXIgd29ya2VycyB0byBjb21wcmVzcyB0aGUgY29udGVudCB3aXRoIHRoZVxuICogZ2l2ZW4gY29tcHJlc2lvbi5cbiAqIEBwYXJhbSB7R2VuZXJpY1dvcmtlcn0gdW5jb21wcmVzc2VkV29ya2VyIHRoZSB3b3JrZXIgdG8gcGlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSBuZXcgd29ya2VyIGNvbXByZXNzaW5nIHRoZSBjb250ZW50LlxuICovXG5Db21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20gPSBmdW5jdGlvbiAodW5jb21wcmVzc2VkV29ya2VyLCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIHVuY29tcHJlc3NlZFdvcmtlclxuICAgIC5waXBlKG5ldyBDcmMzMlByb2JlKCkpXG4gICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcInVuY29tcHJlc3NlZFNpemVcIikpXG4gICAgLnBpcGUoY29tcHJlc3Npb24uY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb25PcHRpb25zKSlcbiAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwiY29tcHJlc3NlZFNpemVcIikpXG4gICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3Npb25cIiwgY29tcHJlc3Npb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wcmVzc2VkT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG5leHBvcnRzLlNUT1JFID0ge1xuICAgIG1hZ2ljOiBcIlxceDAwXFx4MDBcIixcbiAgICBjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uIChjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgY29tcHJlc3Npb25cIik7XG4gICAgfSxcbiAgICB1bmNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBkZWNvbXByZXNzaW9uXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkRFRkxBVEUgPSByZXF1aXJlKCcuL2ZsYXRlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi96bGliL2NyYzMyLmpzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICAgIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gICAgZm9yKHZhciBuID0wOyBuIDwgMjU2OyBuKyspe1xuICAgICAgICBjID0gbjtcbiAgICAgICAgZm9yKHZhciBrID0wOyBrIDwgODsgaysrKXtcbiAgICAgICAgICAgIGMgPSAoKGMmMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlW25dID0gYztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNyYzMyIG9mIGEgc3RyaW5nLlxuICogVGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgdGhlIGZ1bmN0aW9uIGNyYzMyLCBidXQgZm9yIHN0cmluZ3MuIFVzaW5nIHRoZVxuICogc2FtZSBmdW5jdGlvbiBmb3IgdGhlIHR3byB1c2UgY2FzZXMgbGVhZHMgdG8gaG9ycmlibGUgcGVyZm9ybWFuY2VzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNyYyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGNyYy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgY3JjMzIgY29tcHV0YXRpb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb21wdXRlZCBjcmMzMi5cbiAqL1xuZnVuY3Rpb24gY3JjMzJzdHIoY3JjLCBzdHIsIGxlbiwgcG9zKSB7XG4gICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuO1xuXG4gICAgY3JjID0gY3JjIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmMzMndyYXBwZXIoaW5wdXQsIGNyYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIgfHwgIWlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheSA9IHV0aWxzLmdldFR5cGVPZihpbnB1dCkgIT09IFwic3RyaW5nXCI7XG5cbiAgICBpZihpc0FycmF5KSB7XG4gICAgICAgIHJldHVybiBjcmMzMihjcmN8MCwgaW5wdXQsIGlucHV0Lmxlbmd0aCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyc3RyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuZXhwb3J0cy5iYXNlNjQgPSBmYWxzZTtcbmV4cG9ydHMuYmluYXJ5ID0gZmFsc2U7XG5leHBvcnRzLmRpciA9IGZhbHNlO1xuZXhwb3J0cy5jcmVhdGVGb2xkZXJzID0gdHJ1ZTtcbmV4cG9ydHMuZGF0ZSA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb25PcHRpb25zID0gbnVsbDtcbmV4cG9ydHMuY29tbWVudCA9IG51bGw7XG5leHBvcnRzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG5leHBvcnRzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiIsIi8qIGdsb2JhbCBQcm9taXNlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIGxvYWQgdGhlIGdsb2JhbCBvYmplY3QgZmlyc3Q6XG4vLyAtIGl0IHNob3VsZCBiZSBiZXR0ZXIgaW50ZWdyYXRlZCBpbiB0aGUgc3lzdGVtICh1bmhhbmRsZWRSZWplY3Rpb24gaW4gbm9kZSlcbi8vIC0gdGhlIGVudmlyb25tZW50IG1heSBoYXZlIGEgY3VzdG9tIFByb21pc2UgaW1wbGVtZW50YXRpb24gKHNlZSB6b25lLmpzKVxudmFyIEVTNlByb21pc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgRVM2UHJvbWlzZSA9IFByb21pc2U7XG59IGVsc2Uge1xuICAgIEVTNlByb21pc2UgPSByZXF1aXJlKFwibGllXCIpO1xufVxuXG4vKipcbiAqIExldCB0aGUgdXNlciB1c2UvY2hhbmdlIHNvbWUgaW1wbGVtZW50YXRpb25zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQcm9taXNlOiBFUzZQcm9taXNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFVTRV9UWVBFREFSUkFZID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxudmFyIHBha28gPSByZXF1aXJlKFwicGFrb1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxudmFyIEFSUkFZX1RZUEUgPSBVU0VfVFlQRURBUlJBWSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuXG5leHBvcnRzLm1hZ2ljID0gXCJcXHgwOFxceDAwXCI7XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRoYXQgdXNlcyBwYWtvIHRvIGluZmxhdGUvZGVmbGF0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0aGUgbmFtZSBvZiB0aGUgcGFrbyBmdW5jdGlvbiB0byBjYWxsIDogZWl0aGVyIFwiRGVmbGF0ZVwiIG9yIFwiSW5mbGF0ZVwiLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gKGRlKWNvbXByZXNzaW5nLlxuICovXG5mdW5jdGlvbiBGbGF0ZVdvcmtlcihhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJGbGF0ZVdvcmtlci9cIiArIGFjdGlvbik7XG5cbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbiAgICB0aGlzLl9wYWtvQWN0aW9uID0gYWN0aW9uO1xuICAgIHRoaXMuX3Bha29PcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB0aGUgYG1ldGFgIG9iamVjdCBmcm9tIHRoZSBsYXN0IGNodW5rIHJlY2VpdmVkXG4gICAgLy8gdGhpcyBhbGxvdyB0aGlzIHdvcmtlciB0byBwYXNzIGFyb3VuZCBtZXRhZGF0YVxuICAgIHRoaXMubWV0YSA9IHt9O1xufVxuXG51dGlscy5pbmhlcml0cyhGbGF0ZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5tZXRhID0gY2h1bmsubWV0YTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaCh1dGlscy50cmFuc2Zvcm1UbyhBUlJBWV9UWVBFLCBjaHVuay5kYXRhKSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2goW10sIHRydWUpO1xufTtcbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3Bha28gPSBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIF9wYWtvIG9iamVjdC5cbiAqIFRPRE86IGxhenktbG9hZGluZyB0aGlzIG9iamVjdCBpc24ndCB0aGUgYmVzdCBzb2x1dGlvbiBidXQgaXQncyB0aGVcbiAqIHF1aWNrZXN0LiBUaGUgYmVzdCBzb2x1dGlvbiBpcyB0byBsYXp5LWxvYWQgdGhlIHdvcmtlciBsaXN0LiBTZWUgYWxzbyB0aGVcbiAqIGlzc3VlICM0NDYuXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5fY3JlYXRlUGFrbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYWtvID0gbmV3IHBha29bdGhpcy5fcGFrb0FjdGlvbl0oe1xuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIGxldmVsOiB0aGlzLl9wYWtvT3B0aW9ucy5sZXZlbCB8fCAtMSAvLyBkZWZhdWx0IGNvbXByZXNzaW9uXG4gICAgfSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3Bha28ub25EYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDogc2VsZi5tZXRhXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5leHBvcnRzLmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJEZWZsYXRlXCIsIGNvbXByZXNzaW9uT3B0aW9ucyk7XG59O1xuZXhwb3J0cy51bmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJJbmZsYXRlXCIsIHt9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4uL3V0ZjgnKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgc2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIHN0cmluZyBpbiBoZXhhZGVjaW1hbC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjIHRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xudmFyIGRlY1RvSGV4ID0gZnVuY3Rpb24oZGVjLCBieXRlcykge1xuICAgIHZhciBoZXggPSBcIlwiLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICAgIGhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyAmIDB4ZmYpO1xuICAgICAgICBkZWMgPSBkZWMgPj4+IDg7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBVTklYIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1bml4UGVybWlzc2lvbnMgdGhlIHVuaXggcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE0NzA1L3RoZS16aXAtZm9ybWF0cy1leHRlcm5hbC1maWxlLWF0dHJpYnV0ZSA6XG4gKlxuICogVFRUVHNzdHJ3eHJ3eHJ3eDAwMDAwMDAwMDBBRFZTSFJcbiAqIF5eXl5fX19fX19fX19fX19fX19fX19fX19fX19fX19fIGZpbGUgdHlwZSwgc2VlIHppcGluZm8uYyAoVU5YXyopXG4gKiAgICAgXl5eX19fX19fX19fX19fX19fX19fX19fX19fXyBzZXR1aWQsIHNldGdpZCwgc3RpY2t5XG4gKiAgICAgICAgXl5eXl5eXl5eX19fX19fX19fX19fX19fXyBwZXJtaXNzaW9uc1xuICogICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5fX19fX18gbm90IHVzZWQgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl4gRE9TIGF0dHJpYnV0ZSBiaXRzIDogQXJjaGl2ZSwgRGlyZWN0b3J5LCBWb2x1bWUgbGFiZWwsIFN5c3RlbSBmaWxlLCBIaWRkZW4sIFJlYWQgb25seVxuICovXG52YXIgZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uICh1bml4UGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gdW5peFBlcm1pc3Npb25zO1xuICAgIGlmICghdW5peFBlcm1pc3Npb25zKSB7XG4gICAgICAgIC8vIEkgY2FuJ3QgdXNlIG9jdGFsIHZhbHVlcyBpbiBzdHJpY3QgbW9kZSwgaGVuY2UgdGhlIGhleGEuXG4gICAgICAgIC8vICAwNDA3NzUgPT4gMHg0MWZkXG4gICAgICAgIC8vIDAxMDA2NjQgPT4gMHg4MWI0XG4gICAgICAgIHJlc3VsdCA9IGlzRGlyID8gMHg0MWZkIDogMHg4MWI0O1xuICAgIH1cbiAgICByZXR1cm4gKHJlc3VsdCAmIDB4RkZGRikgPDwgMTY7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBET1MgcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IGRvc1Blcm1pc3Npb25zIHRoZSBkb3MgcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBCaXQgMCAgICAgUmVhZC1Pbmx5XG4gKiBCaXQgMSAgICAgSGlkZGVuXG4gKiBCaXQgMiAgICAgU3lzdGVtXG4gKiBCaXQgMyAgICAgVm9sdW1lIExhYmVsXG4gKiBCaXQgNCAgICAgRGlyZWN0b3J5XG4gKiBCaXQgNSAgICAgQXJjaGl2ZVxuICovXG52YXIgZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKGRvc1Blcm1pc3Npb25zLCBpc0Rpcikge1xuXG4gICAgLy8gdGhlIGRpciBmbGFnIGlzIGFscmVhZHkgc2V0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuIChkb3NQZXJtaXNzaW9ucyB8fCAwKSAgJiAweDNGO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgdmFyaW91cyBwYXJ0cyB1c2VkIGluIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZpbmFsIHppcCBmaWxlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIGhhc2ggd2l0aCBpbmZvcm1hdGlvbnMgYWJvdXQgdGhlIGNvbXByZXNzZWQgZmlsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtZWRDb250ZW50IGlzIHRoZSBjb250ZW50IHN0cmVhbWVkID9cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtaW5nRW5kZWQgaXMgdGhlIHN0cmVhbSBmaW5pc2hlZCA/XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHRoZSBjdXJyZW50IG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhdGZvcm0gbGV0J3MgcHJldGVuZCB3ZSBhcmUgdGhpcyBwbGF0Zm9ybSAoY2hhbmdlIHBsYXRmb3JtIGRlcGVuZGVudHMgZmllbGRzKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgZmlsZSBuYW1lIC8gY29tbWVudC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHppcCBwYXJ0cy5cbiAqL1xudmFyIGdlbmVyYXRlWmlwUGFydHMgPSBmdW5jdGlvbihzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHN0cmVhbWluZ0VuZGVkLCBvZmZzZXQsIHBsYXRmb3JtLCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIHZhciBmaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLFxuICAgIGNvbXByZXNzaW9uID0gc3RyZWFtSW5mb1snY29tcHJlc3Npb24nXSxcbiAgICB1c2VDdXN0b21FbmNvZGluZyA9IGVuY29kZUZpbGVOYW1lICE9PSB1dGY4LnV0ZjhlbmNvZGUsXG4gICAgZW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoZmlsZS5uYW1lKSksXG4gICAgdXRmRW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdXRmOC51dGY4ZW5jb2RlKGZpbGUubmFtZSkpLFxuICAgIGNvbW1lbnQgPSBmaWxlLmNvbW1lbnQsXG4gICAgZW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShjb21tZW50KSksXG4gICAgdXRmRW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoY29tbWVudCkpLFxuICAgIHVzZVVURjhGb3JGaWxlTmFtZSA9IHV0ZkVuY29kZWRGaWxlTmFtZS5sZW5ndGggIT09IGZpbGUubmFtZS5sZW5ndGgsXG4gICAgdXNlVVRGOEZvckNvbW1lbnQgPSB1dGZFbmNvZGVkQ29tbWVudC5sZW5ndGggIT09IGNvbW1lbnQubGVuZ3RoLFxuICAgIGRvc1RpbWUsXG4gICAgZG9zRGF0ZSxcbiAgICBleHRyYUZpZWxkcyA9IFwiXCIsXG4gICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID0gXCJcIixcbiAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIGRpciA9IGZpbGUuZGlyLFxuICAgIGRhdGUgPSBmaWxlLmRhdGU7XG5cblxuICAgIHZhciBkYXRhSW5mbyA9IHtcbiAgICAgICAgY3JjMzIgOiAwLFxuICAgICAgICBjb21wcmVzc2VkU2l6ZSA6IDAsXG4gICAgICAgIHVuY29tcHJlc3NlZFNpemUgOiAwXG4gICAgfTtcblxuICAgIC8vIGlmIHRoZSBjb250ZW50IGlzIHN0cmVhbWVkLCB0aGUgc2l6ZXMvY3JjMzIgYXJlIG9ubHkgYXZhaWxhYmxlIEFGVEVSXG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgIGlmICghc3RyZWFtZWRDb250ZW50IHx8IHN0cmVhbWluZ0VuZGVkKSB7XG4gICAgICAgIGRhdGFJbmZvLmNyYzMyID0gc3RyZWFtSW5mb1snY3JjMzInXTtcbiAgICAgICAgZGF0YUluZm8uY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWydjb21wcmVzc2VkU2l6ZSddO1xuICAgICAgICBkYXRhSW5mby51bmNvbXByZXNzZWRTaXplID0gc3RyZWFtSW5mb1sndW5jb21wcmVzc2VkU2l6ZSddO1xuICAgIH1cblxuICAgIHZhciBiaXRmbGFnID0gMDtcbiAgICBpZiAoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIC8vIEJpdCAzOiB0aGUgc2l6ZXMvY3JjMzIgYXJlIHNldCB0byB6ZXJvIGluIHRoZSBsb2NhbCBoZWFkZXIuXG4gICAgICAgIC8vIFRoZSBjb3JyZWN0IHZhbHVlcyBhcmUgcHV0IGluIHRoZSBkYXRhIGRlc2NyaXB0b3IgaW1tZWRpYXRlbHlcbiAgICAgICAgLy8gZm9sbG93aW5nIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gICAgICAgIGJpdGZsYWcgfD0gMHgwMDA4O1xuICAgIH1cbiAgICBpZiAoIXVzZUN1c3RvbUVuY29kaW5nICYmICh1c2VVVEY4Rm9yRmlsZU5hbWUgfHwgdXNlVVRGOEZvckNvbW1lbnQpKSB7XG4gICAgICAgIC8vIEJpdCAxMTogTGFuZ3VhZ2UgZW5jb2RpbmcgZmxhZyAoRUZTKS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDA4MDA7XG4gICAgfVxuXG5cbiAgICB2YXIgZXh0RmlsZUF0dHIgPSAwO1xuICAgIHZhciB2ZXJzaW9uTWFkZUJ5ID0gMDtcbiAgICBpZiAoZGlyKSB7XG4gICAgICAgIC8vIGRvcyBvciB1bml4LCB3ZSBzZXQgdGhlIGRvcyBkaXIgZmxhZ1xuICAgICAgICBleHRGaWxlQXR0ciB8PSAweDAwMDEwO1xuICAgIH1cbiAgICBpZihwbGF0Zm9ybSA9PT0gXCJVTklYXCIpIHtcbiAgICAgICAgdmVyc2lvbk1hZGVCeSA9IDB4MDMxRTsgLy8gVU5JWCwgdmVyc2lvbiAzLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0cihmaWxlLnVuaXhQZXJtaXNzaW9ucywgZGlyKTtcbiAgICB9IGVsc2UgeyAvLyBET1Mgb3Igb3RoZXIsIGZhbGxiYWNrIHRvIERPU1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMDE0OyAvLyBET1MsIHZlcnNpb24gMi4wXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IGdlbmVyYXRlRG9zRXh0ZXJuYWxGaWxlQXR0cihmaWxlLmRvc1Blcm1pc3Npb25zLCBkaXIpO1xuICAgIH1cblxuICAgIC8vIGRhdGVcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNTIvMTMuaHRtbFxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC82NS8xNi5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY2LzE2Lmh0bWxcblxuICAgIGRvc1RpbWUgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNjtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIDw8IDU7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgfCBkYXRlLmdldFVUQ1NlY29uZHMoKSAvIDI7XG5cbiAgICBkb3NEYXRlID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpIC0gMTk4MDtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSA8PCA0O1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIHwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDU7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCBkYXRlLmdldFVUQ0RhdGUoKTtcblxuICAgIGlmICh1c2VVVEY4Rm9yRmlsZU5hbWUpIHtcbiAgICAgICAgLy8gc2V0IHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuIHVuemlwIG5lZWRzIGF0IGxlYXN0IG9uZSBleHRyYVxuICAgICAgICAvLyBmaWVsZCB0byBjb3JyZWN0bHkgaGFuZGxlIHVuaWNvZGUgcGF0aCwgc28gdXNpbmcgdGhlIHBhdGggaXMgYXMgZ29vZFxuICAgICAgICAvLyBhcyBhbnkgb3RoZXIgaW5mb3JtYXRpb24uIFRoaXMgY291bGQgaW1wcm92ZSB0aGUgc2l0dWF0aW9uIHdpdGhcbiAgICAgICAgLy8gb3RoZXIgYXJjaGl2ZSBtYW5hZ2VycyB0b28uXG4gICAgICAgIC8vIFRoaXMgZmllbGQgaXMgdXN1YWxseSB1c2VkIHdpdGhvdXQgdGhlIHV0ZjggZmxhZywgd2l0aCBhIG5vblxuICAgICAgICAvLyB1bmljb2RlIHBhdGggaW4gdGhlIGhlYWRlciAod2lucmFyLCB3aW56aXApLiBUaGlzIGhlbHBzIChhIGJpdClcbiAgICAgICAgLy8gd2l0aCB0aGUgbWVzc3kgV2luZG93cycgZGVmYXVsdCBjb21wcmVzc2VkIGZvbGRlcnMgZmVhdHVyZSBidXRcbiAgICAgICAgLy8gYnJlYWtzIG9uIHA3emlwIHdoaWNoIGRvZXNuJ3Qgc2VlayB0aGUgdW5pY29kZSBwYXRoIGV4dHJhIGZpZWxkLlxuICAgICAgICAvLyBTbyBmb3Igbm93LCBVVEYtOCBldmVyeXdoZXJlICFcbiAgICAgICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID1cbiAgICAgICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgICAgIGRlY1RvSGV4KDEsIDEpICtcbiAgICAgICAgICAgIC8vIE5hbWVDUkMzMlxuICAgICAgICAgICAgZGVjVG9IZXgoY3JjMzIoZW5jb2RlZEZpbGVOYW1lKSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRGaWxlTmFtZTtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NzBcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlUGF0aEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgaWYodXNlVVRGOEZvckNvbW1lbnQpIHtcblxuICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gQ29tbWVudENSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkQ29tbWVudCksIDQpICtcbiAgICAgICAgICAgIC8vIFVuaWNvZGVOYW1lXG4gICAgICAgICAgICB1dGZFbmNvZGVkQ29tbWVudDtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NjNcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlQ29tbWVudEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlciA9IFwiXCI7XG5cbiAgICAvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG4gICAgaGVhZGVyICs9IFwiXFx4MEFcXHgwMFwiO1xuICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgIGhlYWRlciArPSBkZWNUb0hleChiaXRmbGFnLCAyKTtcbiAgICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICBoZWFkZXIgKz0gY29tcHJlc3Npb24ubWFnaWM7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSB0aW1lXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc1RpbWUsIDIpO1xuICAgIC8vIGxhc3QgbW9kIGZpbGUgZGF0ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkb3NEYXRlLCAyKTtcbiAgICAvLyBjcmMtMzJcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8uY3JjMzIsIDQpO1xuICAgIC8vIGNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gdW5jb21wcmVzc2VkIHNpemVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8udW5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gZmlsZSBuYW1lIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChlbmNvZGVkRmlsZU5hbWUubGVuZ3RoLCAyKTtcbiAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZXh0cmFGaWVsZHMubGVuZ3RoLCAyKTtcblxuXG4gICAgdmFyIGZpbGVSZWNvcmQgPSBzaWduYXR1cmUuTE9DQUxfRklMRV9IRUFERVIgKyBoZWFkZXIgKyBlbmNvZGVkRmlsZU5hbWUgKyBleHRyYUZpZWxkcztcblxuICAgIHZhciBkaXJSZWNvcmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9GSUxFX0hFQURFUiArXG4gICAgICAgIC8vIHZlcnNpb24gbWFkZSBieSAoMDA6IERPUylcbiAgICAgICAgZGVjVG9IZXgodmVyc2lvbk1hZGVCeSwgMikgK1xuICAgICAgICAvLyBmaWxlIGhlYWRlciAoY29tbW9uIHRvIGZpbGUgYW5kIGNlbnRyYWwgZGlyZWN0b3J5KVxuICAgICAgICBoZWFkZXIgK1xuICAgICAgICAvLyBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyBkaXNrIG51bWJlciBzdGFydFxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlcyBUT0RPXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gICAgICAgIGRlY1RvSGV4KGV4dEZpbGVBdHRyLCA0KSArXG4gICAgICAgIC8vIHJlbGF0aXZlIG9mZnNldCBvZiBsb2NhbCBoZWFkZXJcbiAgICAgICAgZGVjVG9IZXgob2Zmc2V0LCA0KSArXG4gICAgICAgIC8vIGZpbGUgbmFtZVxuICAgICAgICBlbmNvZGVkRmlsZU5hbWUgK1xuICAgICAgICAvLyBleHRyYSBmaWVsZFxuICAgICAgICBleHRyYUZpZWxkcyArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVSZWNvcmQ6IGZpbGVSZWNvcmQsXG4gICAgICAgIGRpclJlY29yZDogZGlyUmVjb3JkXG4gICAgfTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIEVPQ0QgcmVjb3JkLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVudHJpZXNDb3VudCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRyYWxEaXJMZW5ndGggdGhlIGxlbmd0aCAoaW4gYnl0ZXMpIG9mIHRoZSBjZW50cmFsIGRpci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGxvY2FsIGRpci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSB6aXAgZmlsZSBjb21tZW50IGFzIGEgYmluYXJ5IHN0cmluZy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZUZpbGVOYW1lIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgdGhlIGNvbW1lbnQuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBFT0NEIHJlY29yZC5cbiAqL1xudmFyIGdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCA9IGZ1bmN0aW9uIChlbnRyaWVzQ291bnQsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCBjb21tZW50LCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIHZhciBkaXJFbmQgPSBcIlwiO1xuICAgIHZhciBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKTtcblxuICAgIC8vIGVuZCBvZiBjZW50cmFsIGRpciBzaWduYXR1cmVcbiAgICBkaXJFbmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoaXMgZGlza1xuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIG51bWJlciBvZiB0aGUgZGlzayB3aXRoIHRoZSBzdGFydCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3Rvcnkgb24gdGhpcyBkaXNrXG4gICAgICAgIGRlY1RvSGV4KGVudHJpZXNDb3VudCwgMikgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHNpemUgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5ICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChjZW50cmFsRGlyTGVuZ3RoLCA0KSArXG4gICAgICAgIC8vIG9mZnNldCBvZiBzdGFydCBvZiBjZW50cmFsIGRpcmVjdG9yeSB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YXJ0aW5nIGRpc2sgbnVtYmVyXG4gICAgICAgIGRlY1RvSGV4KGxvY2FsRGlyTGVuZ3RoLCA0KSArXG4gICAgICAgIC8vIC5aSVAgZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICBkZWNUb0hleChlbmNvZGVkQ29tbWVudC5sZW5ndGgsIDIpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnRcbiAgICAgICAgZW5jb2RlZENvbW1lbnQ7XG5cbiAgICByZXR1cm4gZGlyRW5kO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBkYXRhIGRlc2NyaXB0b3JzIGZvciBhIGZpbGUgZW50cnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgaGFzaCBnZW5lcmF0ZWQgYnkgYSB3b3JrZXIsIGNvbnRhaW5pbmcgaW5mb3JtYXRpb25zXG4gKiBvbiB0aGUgZmlsZSBlbnRyeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGRhdGEgZGVzY3JpcHRvcnMuXG4gKi9cbnZhciBnZW5lcmF0ZURhdGFEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBcIlwiO1xuICAgIGRlc2NyaXB0b3IgPSBzaWduYXR1cmUuREFUQV9ERVNDUklQVE9SICtcbiAgICAgICAgLy8gY3JjLTMyICAgICAgICAgICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bJ2NyYzMyJ10sIDQpICtcbiAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bJ2NvbXByZXNzZWRTaXplJ10sIDQpICtcbiAgICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bJ3VuY29tcHJlc3NlZFNpemUnXSwgNCk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cblxuLyoqXG4gKiBBIHdvcmtlciB0byBjb25jYXRlbmF0ZSBvdGhlciB3b3JrZXJzIHRvIGNyZWF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1GaWxlcyBgdHJ1ZWAgdG8gc3RyZWFtIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlcyxcbiAqIGBmYWxzZWAgdG8gYWNjdW11bGF0ZSBpdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSB0aGUgcGxhdGZvcm0gdG8gdXNlLCBcIlVOSVhcIiBvciBcIkRPU1wiLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAqL1xuZnVuY3Rpb24gWmlwRmlsZVdvcmtlcihzdHJlYW1GaWxlcywgY29tbWVudCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiWmlwRmlsZVdvcmtlclwiKTtcbiAgICAvLyBUaGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gc28gZmFyLiBUaGlzIGRvZXNuJ3QgY291bnQgYWNjdW11bGF0ZWQgY2h1bmtzLlxuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgICAvLyBUaGUgY29tbWVudCBvZiB0aGUgemlwIGZpbGVcbiAgICB0aGlzLnppcENvbW1lbnQgPSBjb21tZW50O1xuICAgIC8vIFRoZSBwbGF0Zm9ybSBcImdlbmVyYXRpbmdcIiB0aGUgemlwIGZpbGUuXG4gICAgdGhpcy56aXBQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgIC8vIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgZmlsZSBuYW1lcyBhbmQgY29tbWVudHMuXG4gICAgdGhpcy5lbmNvZGVGaWxlTmFtZSA9IGVuY29kZUZpbGVOYW1lO1xuICAgIC8vIFNob3VsZCB3ZSBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzID9cbiAgICB0aGlzLnN0cmVhbUZpbGVzID0gc3RyZWFtRmlsZXM7XG4gICAgLy8gSWYgYHN0cmVhbUZpbGVzYCBpcyBmYWxzZSwgd2Ugd2lsbCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgLy8gZmlsZXMgdG8gY2FsY3VsYXRlIHNpemVzIC8gY3JjMzIgKGFuZCB3cml0ZSB0aGVtICpiZWZvcmUqIHRoZSBjb250ZW50KS5cbiAgICAvLyBUaGlzIGJvb2xlYW4gaW5kaWNhdGVzIGlmIHdlIGFyZSBhY2N1bXVsYXRpbmcgY2h1bmtzIChpdCB3aWxsIGNoYW5nZSBhIGxvdFxuICAgIC8vIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhpcyB3b3JrZXIpLlxuICAgIHRoaXMuYWNjdW11bGF0ZSA9IGZhbHNlO1xuICAgIC8vIFRoZSBidWZmZXIgcmVjZWl2aW5nIGNodW5rcyB3aGVuIGFjY3VtdWxhdGluZyBjb250ZW50LlxuICAgIHRoaXMuY29udGVudEJ1ZmZlciA9IFtdO1xuICAgIC8vIFRoZSBsaXN0IG9mIGdlbmVyYXRlZCBkaXJlY3RvcnkgcmVjb3Jkcy5cbiAgICB0aGlzLmRpclJlY29yZHMgPSBbXTtcbiAgICAvLyBUaGUgb2Zmc2V0IChpbiBieXRlcykgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB6aXAgZmlsZSBmb3IgdGhlIGN1cnJlbnQgc291cmNlLlxuICAgIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCA9IDA7XG4gICAgLy8gVGhlIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgemlwIGZpbGUuXG4gICAgdGhpcy5lbnRyaWVzQ291bnQgPSAwO1xuICAgIC8vIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGN1cnJlbnRseSBiZWluZyBhZGRlZCwgbnVsbCB3aGVuIGhhbmRsaW5nIHRoZSBlbmQgb2YgdGhlIHppcCBmaWxlLlxuICAgIC8vIFVzZWQgZm9yIHRoZSBlbWl0ZWQgbWV0YWRhdGEuXG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG5cblxuXG4gICAgdGhpcy5fc291cmNlcyA9IFtdO1xufVxudXRpbHMuaW5oZXJpdHMoWmlwRmlsZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnB1c2hcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgdmFyIGN1cnJlbnRGaWxlUGVyY2VudCA9IGNodW5rLm1ldGEucGVyY2VudCB8fCAwO1xuICAgIHZhciBlbnRyaWVzQ291bnQgPSB0aGlzLmVudHJpZXNDb3VudDtcbiAgICB2YXIgcmVtYWluaW5nRmlsZXMgPSB0aGlzLl9zb3VyY2VzLmxlbmd0aDtcblxuICAgIGlmKHRoaXMuYWNjdW11bGF0ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnRCdWZmZXIucHVzaChjaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ieXRlc1dyaXR0ZW4gKz0gY2h1bmsuZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGRhdGEgOiBjaHVuay5kYXRhLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZSA6IHRoaXMuY3VycmVudEZpbGUsXG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IGVudHJpZXNDb3VudCA/IChjdXJyZW50RmlsZVBlcmNlbnQgKyAxMDAgKiAoZW50cmllc0NvdW50IC0gcmVtYWluaW5nRmlsZXMgLSAxKSkgLyBlbnRyaWVzQ291bnQgOiAxMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIHN0YXJ0ZWQgYSBuZXcgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIG5ldyBzb3VyY2UuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLm9wZW5lZFNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IHN0cmVhbUluZm9bJ2ZpbGUnXS5uYW1lO1xuXG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bJ2ZpbGUnXS5kaXI7XG5cbiAgICAvLyBkb24ndCBzdHJlYW0gZm9sZGVycyAoYmVjYXVzZSB0aGV5IGRvbid0IGhhdmUgYW55IGNvbnRlbnQpXG4gICAgaWYoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZW5lcmF0ZVppcFBhcnRzKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgZmFsc2UsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogcmVjb3JkLmZpbGVSZWNvcmQsXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgd2hvbGUgZmlsZSBiZWZvcmUgcHVzaGluZyBhbnl0aGluZ1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlIHdvcmtlciBmaW5pc2hlZCBhIHNvdXJjZSAoYW4gb3RoZXIgd29ya2VyKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBzdHJlYW1JbmZvIG9iamVjdCBmcm9tIHRoZSBmaW5pc2hlZCBzb3VyY2UuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmNsb3NlZFNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bJ2ZpbGUnXS5kaXI7XG4gICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCB0cnVlLCB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQsIHRoaXMuemlwUGxhdGZvcm0sIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5kaXJSZWNvcmRzLnB1c2gocmVjb3JkLmRpclJlY29yZCk7XG4gICAgaWYoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIC8vIGFmdGVyIHRoZSBzdHJlYW1lZCBmaWxlLCB3ZSBwdXQgZGF0YSBkZXNjcmlwdG9yc1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzKHN0cmVhbUluZm8pLFxuICAgICAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgd2Fzbid0IHN0cmVhbWVkLCB3ZSBuZWVkIHRvIHB1c2ggZXZlcnl0aGluZyBub3dcbiAgICAgICAgLy8gZmlyc3QgdGhlIGZpbGUgcmVjb3JkLCB0aGVuIHRoZSBjb250ZW50XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogcmVjb3JkLmZpbGVSZWNvcmQsXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKHRoaXMuY29udGVudEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmNvbnRlbnRCdWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBsb2NhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRpclJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiB0aGlzLmRpclJlY29yZHNbaV0sXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGNlbnRyYWxEaXJMZW5ndGggPSB0aGlzLmJ5dGVzV3JpdHRlbiAtIGxvY2FsRGlyTGVuZ3RoO1xuXG4gICAgdmFyIGRpckVuZCA9IGdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCh0aGlzLmRpclJlY29yZHMubGVuZ3RoLCBjZW50cmFsRGlyTGVuZ3RoLCBsb2NhbERpckxlbmd0aCwgdGhpcy56aXBDb21tZW50LCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBkaXJFbmQsXG4gICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIG5leHQgc291cmNlIHRvIGJlIHJlYWQuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnByZXBhcmVOZXh0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLl9zb3VyY2VzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuZWRTb3VyY2UodGhpcy5wcmV2aW91cy5zdHJlYW1JbmZvKTtcbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cy5yZXN1bWUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZWdpc3RlclByZXZpb3VzXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnJlZ2lzdGVyUHJldmlvdXMgPSBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICB0aGlzLl9zb3VyY2VzLnB1c2gocHJldmlvdXMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHByZXZpb3VzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICB9KTtcbiAgICBwcmV2aW91cy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmNsb3NlZFNvdXJjZShzZWxmLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgICAgICBpZihzZWxmLl9zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZXN1bWVcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmIHRoaXMuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZU5leHRTb3VyY2UoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdGhpcy5wcmV2aW91cyAmJiAhdGhpcy5fc291cmNlcy5sZW5ndGggJiYgIXRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZXJyb3JcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzb3VyY2VzW2ldLmVycm9yKGUpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIHRoZSBgZXJyb3JgIGV4cGxvZGVkLCBub3RoaW5nIHRvIGRvXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5sb2NrXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUubG9jay5jYWxsKHRoaXMpO1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb3VyY2VzW2ldLmxvY2soKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFppcEZpbGVXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21wcmVzc2lvbnMgPSByZXF1aXJlKCcuLi9jb21wcmVzc2lvbnMnKTtcbnZhciBaaXBGaWxlV29ya2VyID0gcmVxdWlyZSgnLi9aaXBGaWxlV29ya2VyJyk7XG5cbi8qKlxuICogRmluZCB0aGUgY29tcHJlc3Npb24gdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVDb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gZGVmaW5lZCBhdCB0aGUgZmlsZSBsZXZlbCwgaWYgYW55LlxuICogQHBhcmFtIHtTdHJpbmd9IHppcENvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBsb2FkKCkgbGV2ZWwuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICovXG52YXIgZ2V0Q29tcHJlc3Npb24gPSBmdW5jdGlvbiAoZmlsZUNvbXByZXNzaW9uLCB6aXBDb21wcmVzc2lvbikge1xuXG4gICAgdmFyIGNvbXByZXNzaW9uTmFtZSA9IGZpbGVDb21wcmVzc2lvbiB8fCB6aXBDb21wcmVzc2lvbjtcbiAgICB2YXIgY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbnNbY29tcHJlc3Npb25OYW1lXTtcbiAgICBpZiAoIWNvbXByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjb21wcmVzc2lvbk5hbWUgKyBcIiBpcyBub3QgYSB2YWxpZCBjb21wcmVzc2lvbiBtZXRob2QgIVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXByZXNzaW9uO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB3b3JrZXIgdG8gZ2VuZXJhdGUgYSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7SlNaaXB9IHppcCB0aGUgSlNaaXAgaW5zdGFuY2UgYXQgdGhlIHJpZ2h0IHJvb3QgbGV2ZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgY29tbWVudCB0byB1c2UuXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVXb3JrZXIgPSBmdW5jdGlvbiAoemlwLCBvcHRpb25zLCBjb21tZW50KSB7XG5cbiAgICB2YXIgemlwRmlsZVdvcmtlciA9IG5ldyBaaXBGaWxlV29ya2VyKG9wdGlvbnMuc3RyZWFtRmlsZXMsIGNvbW1lbnQsIG9wdGlvbnMucGxhdGZvcm0sIG9wdGlvbnMuZW5jb2RlRmlsZU5hbWUpO1xuICAgIHZhciBlbnRyaWVzQ291bnQgPSAwO1xuICAgIHRyeSB7XG5cbiAgICAgICAgemlwLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgZW50cmllc0NvdW50Kys7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbihmaWxlLm9wdGlvbnMuY29tcHJlc3Npb24sIG9wdGlvbnMuY29tcHJlc3Npb24pO1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uT3B0aW9ucyA9IGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwgb3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgZGlyID0gZmlsZS5kaXIsIGRhdGUgPSBmaWxlLmRhdGU7XG5cbiAgICAgICAgICAgIGZpbGUuX2NvbXByZXNzV29ya2VyKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpXG4gICAgICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJmaWxlXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lIDogcmVsYXRpdmVQYXRoLFxuICAgICAgICAgICAgICAgIGRpciA6IGRpcixcbiAgICAgICAgICAgICAgICBkYXRlIDogZGF0ZSxcbiAgICAgICAgICAgICAgICBjb21tZW50IDogZmlsZS5jb21tZW50IHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zIDogZmlsZS51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBmaWxlLmRvc1Blcm1pc3Npb25zXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnBpcGUoemlwRmlsZVdvcmtlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB6aXBGaWxlV29ya2VyLmVudHJpZXNDb3VudCA9IGVudHJpZXNDb3VudDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZXJyb3IoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHppcEZpbGVXb3JrZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIGEgb2YgemlwIGZpbGUgaW4ganNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBKU1ppcCgpIHtcbiAgICAvLyBpZiB0aGlzIGNvbnN0cnVjdG9yIGlzwqB1c2VkIHdpdGhvdXTCoGBuZXdgLCBpdMKgYWRkcyBgbmV3YCBiZWZvcmXCoGl0c2VsZjpcbiAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBKU1ppcCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKU1ppcCgpO1xuICAgIH1cblxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbnN0cnVjdG9yIHdpdGggcGFyYW1ldGVycyBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9XG5cbiAgICAvLyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgOlxuICAgIC8vIHtcbiAgICAvLyAgIFwiZm9sZGVyL1wiIDogey4uLn0sXG4gICAgLy8gICBcImZvbGRlci9kYXRhLnR4dFwiIDogey4uLn1cbiAgICAvLyB9XG4gICAgdGhpcy5maWxlcyA9IHt9O1xuXG4gICAgdGhpcy5jb21tZW50ID0gbnVsbDtcblxuICAgIC8vIFdoZXJlIHdlIGFyZSBpbiB0aGUgaGllcmFyY2h5XG4gICAgdGhpcy5yb290ID0gXCJcIjtcbiAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdPYmogPSBuZXcgSlNaaXAoKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbaV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IHRoaXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9O1xufVxuSlNaaXAucHJvdG90eXBlID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcbkpTWmlwLnByb3RvdHlwZS5sb2FkQXN5bmMgPSByZXF1aXJlKCcuL2xvYWQnKTtcbkpTWmlwLnN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbkpTWmlwLmRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vLyBUT0RPIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzIHZlcnNpb24sXG4vLyBhIHJlcXVpcmUoJ3BhY2thZ2UuanNvbicpLnZlcnNpb24gZG9lc24ndCB3b3JrIHdpdGggd2VicGFjaywgc2VlICMzMjdcbkpTWmlwLnZlcnNpb24gPSBcIjMuMS41XCI7XG5cbkpTWmlwLmxvYWRBc3luYyA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBKU1ppcCgpLmxvYWRBc3luYyhjb250ZW50LCBvcHRpb25zKTtcbn07XG5cbkpTWmlwLmV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG5tb2R1bGUuZXhwb3J0cyA9IEpTWmlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIFppcEVudHJpZXMgPSByZXF1aXJlKCcuL3ppcEVudHJpZXMnKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vQ3JjMzJQcm9iZScpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG5cbi8qKlxuICogQ2hlY2sgdGhlIENSQzMyIG9mIGFuIGVudHJ5LlxuICogQHBhcmFtIHtaaXBFbnRyeX0gemlwRW50cnkgdGhlIHppcCBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRW50cnlDUkMzMih6aXBFbnRyeSkge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB6aXBFbnRyeS5kZWNvbXByZXNzZWQuZ2V0Q29udGVudFdvcmtlcigpLnBpcGUobmV3IENyYzMyUHJvYmUoKSk7XG4gICAgICAgIHdvcmtlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod29ya2VyLnN0cmVhbUluZm8uY3JjMzIgIT09IHppcEVudHJ5LmRlY29tcHJlc3NlZC5jcmMzMikge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogQ1JDMzIgbWlzbWF0Y2hcIikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN1bWUoKTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHppcCA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgICAgIGNoZWNrQ1JDMzI6IGZhbHNlLFxuICAgICAgICBvcHRpbWl6ZWRCaW5hcnlTdHJpbmc6IGZhbHNlLFxuICAgICAgICBjcmVhdGVGb2xkZXJzOiBmYWxzZSxcbiAgICAgICAgZGVjb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGRlY29kZVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSlNaaXAgY2FuJ3QgYWNjZXB0IGEgc3RyZWFtIHdoZW4gbG9hZGluZyBhIHppcCBmaWxlLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLnByZXBhcmVDb250ZW50KFwidGhlIGxvYWRlZCB6aXAgZmlsZVwiLCBkYXRhLCB0cnVlLCBvcHRpb25zLm9wdGltaXplZEJpbmFyeVN0cmluZywgb3B0aW9ucy5iYXNlNjQpXG4gICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgemlwRW50cmllcyA9IG5ldyBaaXBFbnRyaWVzKG9wdGlvbnMpO1xuICAgICAgICB6aXBFbnRyaWVzLmxvYWQoZGF0YSk7XG4gICAgICAgIHJldHVybiB6aXBFbnRyaWVzO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gY2hlY2tDUkMzMih6aXBFbnRyaWVzKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoemlwRW50cmllcyldO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBpZiAob3B0aW9ucy5jaGVja0NSQzMyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjaGVja0VudHJ5Q1JDMzIoZmlsZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gYWRkRmlsZXMocmVzdWx0cykge1xuICAgICAgICB2YXIgemlwRW50cmllcyA9IHJlc3VsdHMuc2hpZnQoKTtcbiAgICAgICAgdmFyIGZpbGVzID0gemlwRW50cmllcy5maWxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZmlsZXNbaV07XG4gICAgICAgICAgICB6aXAuZmlsZShpbnB1dC5maWxlTmFtZVN0ciwgaW5wdXQuZGVjb21wcmVzc2VkLCB7XG4gICAgICAgICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRlOiBpbnB1dC5kYXRlLFxuICAgICAgICAgICAgICAgIGRpcjogaW5wdXQuZGlyLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBpbnB1dC5maWxlQ29tbWVudFN0ci5sZW5ndGggPyBpbnB1dC5maWxlQ29tbWVudFN0ciA6IG51bGwsXG4gICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zIDogaW5wdXQudW5peFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgIGRvc1Blcm1pc3Npb25zIDogaW5wdXQuZG9zUGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgY3JlYXRlRm9sZGVyczogb3B0aW9ucy5jcmVhdGVGb2xkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoemlwRW50cmllcy56aXBDb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgemlwLmNvbW1lbnQgPSB6aXBFbnRyaWVzLnppcENvbW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gemlwO1xuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgdXNlIGEgbm9kZWpzIHN0cmVhbSBhcyBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSBlbnRyeSBmb3IgdGhpcyBzdHJlYW0uXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihmaWxlbmFtZSwgc3RyZWFtKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiTm9kZWpzIHN0cmVhbSBpbnB1dCBhZGFwdGVyIGZvciBcIiArIGZpbGVuYW1lKTtcbiAgICB0aGlzLl91cHN0cmVhbUVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYmluZFN0cmVhbShzdHJlYW0pO1xufVxuXG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIHN0cmVhbSBhbmQgYmluZCB0aGUgY2FsbGJhY2tzIG9uIGl0LlxuICogRG8gdGhpcyBBU0FQIG9uIG5vZGUgMC4xMCAhIEEgbGF6eSBiaW5kaW5nIGRvZXNuJ3QgYWx3YXlzIHdvcmsuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIHRoZSBub2RlanMgc3RyZWFtIHRvIHVzZS5cbiAqL1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5fYmluZFN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIHN0cmVhbVxuICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICBkYXRhOiBjaHVuayxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZihzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlZEVycm9yID0gZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3Vwc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnBhdXNlLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9zdHJlYW0ucGF1c2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX3Vwc3RyZWFtRW5kZWQpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGU7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLCBSZWFkYWJsZSk7XG5cbi8qKlxuKiBBIG5vZGVqcyBzdHJlYW0gdXNpbmcgYSB3b3JrZXIgYXMgc291cmNlLlxuKiBAc2VlIHRoZSBTb3VyY2VXcmFwcGVyIGluIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbFxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtTdHJlYW1IZWxwZXJ9IGhlbHBlciB0aGUgaGVscGVyIHdyYXBwaW5nIHRoZSB3b3JrZXJcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG5vZGVqcyBzdHJlYW0gb3B0aW9uc1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIoaGVscGVyLCBvcHRpb25zLCB1cGRhdGVDYikge1xuICAgIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5faGVscGVyID0gaGVscGVyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGhlbHBlci5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnB1c2goZGF0YSkpIHtcbiAgICAgICAgICAgIHNlbGYuX2hlbHBlci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHVwZGF0ZUNiKSB7XG4gICAgICAgICAgICB1cGRhdGVDYihtZXRhKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSlcbiAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgfSk7XG59XG5cblxuTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9oZWxwZXIucmVzdW1lKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhpcyBpcyBydW5uaW5nIGluIE5vZGVqcywgd2lsbCBiZSB1bmRlZmluZWQgaW4gYSBicm93c2VyLlxuICAgICAqIEluIGEgYnJvd3NlciwgYnJvd3NlcmlmeSB3b24ndCBpbmNsdWRlIHRoaXMgZmlsZSBhbmQgdGhlIHdob2xlIG1vZHVsZVxuICAgICAqIHdpbGwgYmUgcmVzb2x2ZWQgYW4gZW1wdHkgb2JqZWN0LlxuICAgICAqL1xuICAgIGlzTm9kZSA6IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vZGVqcyBCdWZmZXIgZnJvbSBhbiBleGlzdGluZyBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRoZSBkYXRhIHRvIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gYSBuZXcgQnVmZmVyLlxuICAgICAqL1xuICAgIG5ld0J1ZmZlckZyb206IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICAgIC8vIFhYWCBXZSBjYW4ndCB1c2UgYEJ1ZmZlci5mcm9tYCB3aGljaCBjb21lcyBmcm9tIGBVaW50OEFycmF5LmZyb21gXG4gICAgICAgIC8vIGluIG5vZGVqcyB2NCAoPCB2LjQuNSkuIEl0J3Mgbm90IHRoZSBleHBlY3RlZCBpbXBsZW1lbnRhdGlvbiAoYW5kXG4gICAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBzaWduYXR1cmUpLlxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84MDUzXG4gICAgICAgIC8vIEEgY29uZGl0aW9uIG9uIG5vZGVqcycgdmVyc2lvbiB3b24ndCBzb2x2ZSB0aGUgaXNzdWUgYXMgd2UgZG9uJ3RcbiAgICAgICAgLy8gY29udHJvbCB0aGUgQnVmZmVyIHBvbHlmaWxscyB0aGF0IG1heSBvciBtYXkgbm90IGJlIHVzZWQuXG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub2RlanMgQnVmZmVyIHdpdGggdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gc2l6ZSB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gYSBuZXcgQnVmZmVyLlxuICAgICAqL1xuICAgIGFsbG9jQnVmZmVyOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICBpZiAoQnVmZmVyLmFsbG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgb3V0IGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgQnVmZmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNCdWZmZXIgOiBmdW5jdGlvbihiKXtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgICB9LFxuXG4gICAgaXNTdHJlYW0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoub24gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5wYXVzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnJlc3VtZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZSgnLi9zdHJlYW0vU3RyZWFtSGVscGVyJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIFppcE9iamVjdCA9IHJlcXVpcmUoJy4vemlwT2JqZWN0Jyk7XG52YXIgZ2VuZXJhdGUgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZVwiKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoXCIuL25vZGVqc1V0aWxzXCIpO1xudmFyIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciA9IHJlcXVpcmUoXCIuL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXJcIik7XG5cblxuLyoqXG4gKiBBZGQgYSBmaWxlIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbE9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIGZpbGVcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG5ldyBmaWxlLlxuICovXG52YXIgZmlsZUFkZCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgIC8vIGJlIHN1cmUgc3ViIGZvbGRlcnMgZXhpc3RcbiAgICB2YXIgZGF0YVR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSksXG4gICAgICAgIHBhcmVudDtcblxuXG4gICAgLypcbiAgICAgKiBDb3JyZWN0IG9wdGlvbnMuXG4gICAgICovXG5cbiAgICB2YXIgbyA9IHV0aWxzLmV4dGVuZChvcmlnaW5hbE9wdGlvbnMgfHwge30sIGRlZmF1bHRzKTtcbiAgICBvLmRhdGUgPSBvLmRhdGUgfHwgbmV3IERhdGUoKTtcbiAgICBpZiAoby5jb21wcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gby5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygby51bml4UGVybWlzc2lvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgby51bml4UGVybWlzc2lvbnMgPSBwYXJzZUludChvLnVuaXhQZXJtaXNzaW9ucywgOCk7XG4gICAgfVxuXG4gICAgLy8gVU5YX0lGRElSICAwMDQwMDAwIHNlZSB6aXBpbmZvLmNcbiAgICBpZiAoby51bml4UGVybWlzc2lvbnMgJiYgKG8udW5peFBlcm1pc3Npb25zICYgMHg0MDAwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuICAgIC8vIEJpdCA0ICAgIERpcmVjdG9yeVxuICAgIGlmIChvLmRvc1Blcm1pc3Npb25zICYmIChvLmRvc1Blcm1pc3Npb25zICYgMHgwMDEwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG8uZGlyKSB7XG4gICAgICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG4gICAgfVxuICAgIGlmIChvLmNyZWF0ZUZvbGRlcnMgJiYgKHBhcmVudCA9IHBhcmVudEZvbGRlcihuYW1lKSkpIHtcbiAgICAgICAgZm9sZGVyQWRkLmNhbGwodGhpcywgcGFyZW50LCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gZGF0YVR5cGUgPT09IFwic3RyaW5nXCIgJiYgby5iaW5hcnkgPT09IGZhbHNlICYmIG8uYmFzZTY0ID09PSBmYWxzZTtcbiAgICBpZiAoIW9yaWdpbmFsT3B0aW9ucyB8fCB0eXBlb2Ygb3JpZ2luYWxPcHRpb25zLmJpbmFyeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvLmJpbmFyeSA9ICFpc1VuaWNvZGVTdHJpbmc7XG4gICAgfVxuXG5cbiAgICB2YXIgaXNDb21wcmVzc2VkRW1wdHkgPSAoZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpICYmIGRhdGEudW5jb21wcmVzc2VkU2l6ZSA9PT0gMDtcblxuICAgIGlmIChpc0NvbXByZXNzZWRFbXB0eSB8fCBvLmRpciB8fCAhZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvLmJhc2U2NCA9IGZhbHNlO1xuICAgICAgICBvLmJpbmFyeSA9IHRydWU7XG4gICAgICAgIGRhdGEgPSBcIlwiO1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gXCJTVE9SRVwiO1xuICAgICAgICBkYXRhVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGNvbnRlbnQgdG8gZml0LlxuICAgICAqL1xuXG4gICAgdmFyIHppcE9iamVjdENvbnRlbnQgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCB8fCBkYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gbmV3IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihuYW1lLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gdXRpbHMucHJlcGFyZUNvbnRlbnQobmFtZSwgZGF0YSwgby5iaW5hcnksIG8ub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvLmJhc2U2NCk7XG4gICAgfVxuXG4gICAgdmFyIG9iamVjdCA9IG5ldyBaaXBPYmplY3QobmFtZSwgemlwT2JqZWN0Q29udGVudCwgbyk7XG4gICAgdGhpcy5maWxlc1tuYW1lXSA9IG9iamVjdDtcbiAgICAvKlxuICAgIFRPRE86IHdlIGNhbid0IHRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIHdlIGhhdmUgYXN5bmMgcHJvbWlzZXNcbiAgICAod2UgY2FuIGhhdmUgYSBwcm9taXNlIG9mIGEgRGF0ZSgpIGZvciBleGFtcGxlKSBidXQgcmV0dXJuaW5nIGFcbiAgICBwcm9taXNlIGlzIHVzZWxlc3MgYmVjYXVzZSBmaWxlKG5hbWUsIGRhdGEpIHJldHVybnMgdGhlIEpTWmlwXG4gICAgb2JqZWN0IGZvciBjaGFpbmluZy4gU2hvdWxkIHdlIGJyZWFrIHRoYXQgdG8gYWxsb3cgdGhlIHVzZXJcbiAgICB0byBjYXRjaCB0aGUgZXJyb3IgP1xuXG4gICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBPYmplY3RDb250ZW50KVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcbiAgICAqL1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBwYXJlbnQgZm9sZGVyIG9mIHRoZSBwYXRoLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIHVzZVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcGFyZW50IGZvbGRlciwgb3IgXCJcIlxuICovXG52YXIgcGFyZW50Rm9sZGVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICByZXR1cm4gKGxhc3RTbGFzaCA+IDApID8gcGF0aC5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoKSA6IFwiXCI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGggd2l0aCBhIHNsYXNoIGF0IHRoZSBlbmQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwYXRoIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAqL1xudmFyIGZvcmNlVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAvLyBDaGVjayB0aGUgbmFtZSBlbmRzIHdpdGggYSAvXG4gICAgaWYgKHBhdGguc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoICs9IFwiL1wiOyAvLyBJRSBkb2Vzbid0IGxpa2Ugc3Vic3RyKC0xKVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG5cbi8qKlxuICogQWRkIGEgKHN1YikgZm9sZGVyIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZm9sZGVyJ3MgbmFtZVxuICogQHBhcmFtIHtib29sZWFuPX0gW2NyZWF0ZUZvbGRlcnNdIElmIHRydWUsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIHN1YlxuICogIGZvbGRlcnMuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZvbGRlci5cbiAqL1xudmFyIGZvbGRlckFkZCA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUZvbGRlcnMpIHtcbiAgICBjcmVhdGVGb2xkZXJzID0gKHR5cGVvZiBjcmVhdGVGb2xkZXJzICE9PSAndW5kZWZpbmVkJykgPyBjcmVhdGVGb2xkZXJzIDogZGVmYXVsdHMuY3JlYXRlRm9sZGVycztcblxuICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG5cbiAgICAvLyBEb2VzIHRoaXMgZm9sZGVyIGFscmVhZHkgZXhpc3Q/XG4gICAgaWYgKCF0aGlzLmZpbGVzW25hbWVdKSB7XG4gICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBudWxsLCB7XG4gICAgICAgICAgICBkaXI6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBjcmVhdGVGb2xkZXJzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maWxlc1tuYW1lXTtcbn07XG5cbi8qKlxuKiBDcm9zcy13aW5kb3csIGNyb3NzLU5vZGUtY29udGV4dCByZWd1bGFyIGV4cHJlc3Npb24gZGV0ZWN0aW9uXG4qIEBwYXJhbSAge09iamVjdH0gIG9iamVjdCBBbnl0aGluZ1xuKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcmVndWxhciBleHByZXNzaW9uLFxuKiBmYWxzZSBvdGhlcndpc2VcbiovXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG59XG5cbi8vIHJldHVybiB0aGUgYWN0dWFsIHByb3RvdHlwZSBvZiBKU1ppcFxudmFyIG91dCA9IHtcbiAgICAvKipcbiAgICAgKiBAc2VlIGxvYWRBc3luY1xuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggZW50cnkgYXQgdGhpcyBmb2xkZXIgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lLCByZWxhdGl2ZVBhdGgsIGZpbGU7XG4gICAgICAgIGZvciAoZmlsZW5hbWUgaW4gdGhpcy5maWxlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbZmlsZW5hbWVdO1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gZmlsZW5hbWUuc2xpY2UodGhpcy5yb290Lmxlbmd0aCwgZmlsZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGggJiYgZmlsZW5hbWUuc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCkgPT09IHRoaXMucm9vdCkgeyAvLyB0aGUgZmlsZSBpcyBpbiB0aGUgY3VycmVudCByb290XG4gICAgICAgICAgICAgICAgY2IocmVsYXRpdmVQYXRoLCBmaWxlKTsgLy8gVE9ETyByZXZlcnNlIHRoZSBwYXJhbWV0ZXJzID8gbmVlZCB0byBiZSBjbGVhbiBBTkQgY29uc2lzdGVudCB3aXRoIHRoZSBmaWx0ZXIgc2VhcmNoIGZuLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG5lc3RlZCBmaWxlcy9mb2xkZXJzIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWFyY2ggdGhlIHByZWRpY2F0ZSB0byB1c2UgOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG1hdGNoaW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZpbHRlcjogZnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoKHJlbGF0aXZlUGF0aCwgZW50cnkpKSB7IC8vIHRoZSBmaWxlIG1hdGNoZXMgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmaWxlIHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfFJlZ0V4cH0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBhZGQgKGlmIGRhdGEgaXMgZGVmaW5lZCksXG4gICAgICogdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZmluZCAoaWYgbm8gZGF0YSkgb3IgYSByZWdleCB0byBtYXRjaCBmaWxlcy5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhICBUaGUgZmlsZSBkYXRhLCBlaXRoZXIgcmF3IG9yIGJhc2U2NCBlbmNvZGVkXG4gICAgICogQHBhcmFtICAge09iamVjdH0gbyAgICAgRmlsZSBvcHRpb25zXG4gICAgICogQHJldHVybiAge0pTWmlwfE9iamVjdHxBcnJheX0gdGhpcyBKU1ppcCBvYmplY3QgKHdoZW4gYWRkaW5nIGEgZmlsZSksXG4gICAgICogYSBmaWxlICh3aGVuIHNlYXJjaGluZyBieSBzdHJpbmcpIG9yIGFuIGFycmF5IG9mIGZpbGVzICh3aGVuIHNlYXJjaGluZyBieSByZWdleCkuXG4gICAgICovXG4gICAgZmlsZTogZnVuY3Rpb24obmFtZSwgZGF0YSwgbykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzUmVnRXhwKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWZpbGUuZGlyICYmIHJlZ2V4cC50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gdGV4dFxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmZpbGVzW3RoaXMucm9vdCArIG5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgIW9iai5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgOiB3ZSBoYXZlIGRhdGEgIVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgZGF0YSwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGRpcmVjdG9yeSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfFJlZ0V4cH0gYXJnIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgdG8gYWRkLCBvciBhIHJlZ2V4IHRvIHNlYXJjaCBmb2xkZXJzLlxuICAgICAqIEByZXR1cm4gIHtKU1ppcH0gYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBkaXJlY3RvcnkgYXMgdGhlIHJvb3QsIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbWF0Y2hpbmcgZm9sZGVycy5cbiAgICAgKi9cbiAgICBmb2xkZXI6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZWdFeHAoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmRpciAmJiBhcmcudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlLCBuYW1lIGlzIGEgbmV3IGZvbGRlclxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucm9vdCArIGFyZztcbiAgICAgICAgdmFyIG5ld0ZvbGRlciA9IGZvbGRlckFkZC5jYWxsKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIC8vIEFsbG93IGNoYWluaW5nIGJ5IHJldHVybmluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGlzIGZvbGRlciBhcyB0aGUgcm9vdFxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXQucm9vdCA9IG5ld0ZvbGRlci5uYW1lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmaWxlLCBvciBhIGRpcmVjdG9yeSBhbmQgYWxsIHN1Yi1maWxlcywgZnJvbSB0aGUgemlwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybiB7SlNaaXB9IHRoaXMgSlNaaXAgb2JqZWN0XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnJvb3QgKyBuYW1lO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGZvbGRlcnNcbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZSAmJiAhZmlsZS5kaXIpIHtcbiAgICAgICAgICAgIC8vIGZpbGVcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbWF5YmUgYSBmb2xkZXIsIGRlbGV0ZSByZWN1cnNpdmVseVxuICAgICAgICAgICAgdmFyIGtpZHMgPSB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5uYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoKSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBraWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNba2lkc1tpXS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xVaW50OEFycmF5fEFycmF5QnVmZmVyfEJ1ZmZlcnxCbG9ifSB0aGUgemlwIGZpbGVcbiAgICAgKi9cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzIGFuIGludGVybmFsIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIHN0cmVhbWVkIHppcCBmaWxlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW06IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciB3b3JrZXIsIG9wdHMgPSB7fTtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgb3B0cyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICAgIHN0cmVhbUZpbGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29tcHJlc3Npb246IFwiU1RPUkVcIixcbiAgICAgICAgICAgICAgY29tcHJlc3Npb25PcHRpb25zIDogbnVsbCxcbiAgICAgICAgICAgICAgdHlwZTogXCJcIixcbiAgICAgICAgICAgICAgcGxhdGZvcm06IFwiRE9TXCIsXG4gICAgICAgICAgICAgIGNvbW1lbnQ6IG51bGwsXG4gICAgICAgICAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vemlwJyxcbiAgICAgICAgICAgICAgZW5jb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGVuY29kZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb3B0cy50eXBlID0gb3B0cy50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgb3B0cy5jb21wcmVzc2lvbiA9IG9wdHMuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIC8vIFwiYmluYXJ5c3RyaW5nXCIgaXMgcHJlZmVyZWQgYnV0IHRoZSBpbnRlcm5hbHMgdXNlIFwic3RyaW5nXCIuXG4gICAgICAgICAgaWYob3B0cy50eXBlID09PSBcImJpbmFyeXN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRzLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb3B0cy50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChvcHRzLnR5cGUpO1xuXG4gICAgICAgICAgLy8gYWNjZXB0IG5vZGVqcyBgcHJvY2Vzcy5wbGF0Zm9ybWBcbiAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdsaW51eCcgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ3N1bm9zJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJVTklYXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIkRPU1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb21tZW50ID0gb3B0cy5jb21tZW50IHx8IHRoaXMuY29tbWVudCB8fCBcIlwiO1xuICAgICAgICAgIHdvcmtlciA9IGdlbmVyYXRlLmdlbmVyYXRlV29ya2VyKHRoaXMsIG9wdHMsIGNvbW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB3b3JrZXIuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcih3b3JrZXIsIG9wdHMudHlwZSB8fCBcInN0cmluZ1wiLCBvcHRzLm1pbWVUeXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFzeW5jOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLmFjY3VtdWxhdGUob25VcGRhdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlTm9kZVN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBcIm5vZGVidWZmZXJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBvdXQ7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgYnkgbW9kdWxlIGJ1bmRsZXJzIChicm93c2VyaWZ5L3dlYnBhY2svZXRjKSB3aGVuXG4gKiBpbmNsdWRpbmcgYSBzdHJlYW0gaW1wbGVtZW50YXRpb24uIFdlIHVzZSBcInJlYWRhYmxlLXN0cmVhbVwiIHRvIGdldCBhXG4gKiBjb25zaXN0ZW50IGJlaGF2aW9yIGJldHdlZW4gbm9kZWpzIHZlcnNpb25zIGJ1dCBidW5kbGVycyBvZnRlbiBoYXZlIGEgc2hpbVxuICogZm9yIFwic3RyZWFtXCIuIFVzaW5nIHRoaXMgc2hpbSBncmVhdGx5IGltcHJvdmUgdGhlIGNvbXBhdGliaWxpdHkgYW5kIGdyZWF0bHlcbiAqIHJlZHVjZSB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgYnVuZGxlIChvbmx5IG9uZSBzdHJlYW0gaW1wbGVtZW50YXRpb24sIG5vdFxuICogdHdvKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBEYXRhUmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRkYXRhW2ldID0gZGF0YVtpXSAmIDB4RkY7XG5cdH1cbn1cbnV0aWxzLmluaGVyaXRzKEFycmF5UmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy56ZXJvICsgaV07XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSA0OyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09PSBzaWcwICYmIHRoaXMuZGF0YVtpICsgMV0gPT09IHNpZzEgJiYgdGhpcy5kYXRhW2kgKyAyXSA9PT0gc2lnMiAmJiB0aGlzLmRhdGFbaSArIDNdID09PSBzaWczKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpLFxuICAgICAgICBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnMCA9PT0gZGF0YVswXSAmJiBzaWcxID09PSBkYXRhWzFdICYmIHNpZzIgPT09IGRhdGFbMl0gJiYgc2lnMyA9PT0gZGF0YVszXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIERhdGFSZWFkZXIoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7IC8vIHR5cGUgOiBzZWUgaW1wbGVtZW50YXRpb25cbiAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMuemVybyA9IDA7XG59XG5EYXRhUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBvZmZzZXQgd2lsbCBub3QgZ28gdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0IHRoZSBhZGRpdGlvbmFsIG9mZnNldCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrT2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KHRoaXMuaW5kZXggKyBvZmZzZXQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHdpbGwgbm90IGJlIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0luZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy56ZXJvICsgbmV3SW5kZXggfHwgbmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmQgb2YgZGF0YSByZWFjaGVkIChkYXRhIGxlbmd0aCA9IFwiICsgdGhpcy5sZW5ndGggKyBcIiwgYXNrZWQgaW5kZXggPSBcIiArIChuZXdJbmRleCkgKyBcIikuIENvcnJ1cHRlZCB6aXAgP1wiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXggVGhlIG5ldyBpbmRleC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2V0SW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleChuZXdJbmRleCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXdJbmRleDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNraXAgdGhlIG5leHQgbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNraXA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLmluZGV4ICsgbik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSB0aGUgaW5kZXggdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYSBieXRlLlxuICAgICAqL1xuICAgIGJ5dGVBdDogZnVuY3Rpb24oaSkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgbnVtYmVyIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyLlxuICAgICAqL1xuICAgIHJlYWRJbnQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmluZGV4ICsgc2l6ZSAtIDE7IGkgPj0gdGhpcy5pbmRleDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpICsgdGhpcy5ieXRlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHN0cmluZyB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLnJlYWREYXRhKHNpemUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSB3aXRob3V0IGNvbnZlcnNpb24sIDxzaXplPiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcmF3IGRhdGEsIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxuICAgICAqL1xuICAgIHJlYWREYXRhOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGxhc3Qgb2NjdXJlbmNlIG9mIGEgemlwIHNpZ25hdHVyZSAoNCBieXRlcykuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgc2lnbmF0dXJlIHRvIGZpbmQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJlbmNlLCAtMSBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgbGFzdEluZGV4T2ZTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBzaWduYXR1cmUgKDQgYnl0ZXMpIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBjb21wYXJlIGl0IHdpdGggc2lnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWcgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBtYXRjaGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVhZEFuZENoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihzaWcpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IGRhdGUuXG4gICAgICogQHJldHVybiB7RGF0ZX0gdGhlIGRhdGUuXG4gICAgICovXG4gICAgcmVhZERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9zdGltZSA9IHRoaXMucmVhZEludCg0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKFxuICAgICAgICAoKGRvc3RpbWUgPj4gMjUpICYgMHg3ZikgKyAxOTgwLCAvLyB5ZWFyXG4gICAgICAgICgoZG9zdGltZSA+PiAyMSkgJiAweDBmKSAtIDEsIC8vIG1vbnRoXG4gICAgICAgIChkb3N0aW1lID4+IDE2KSAmIDB4MWYsIC8vIGRheVxuICAgICAgICAoZG9zdGltZSA+PiAxMSkgJiAweDFmLCAvLyBob3VyXG4gICAgICAgIChkb3N0aW1lID4+IDUpICYgMHgzZiwgLy8gbWludXRlXG4gICAgICAgIChkb3N0aW1lICYgMHgxZikgPDwgMSkpOyAvLyBzZWNvbmRcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL1VpbnQ4QXJyYXlSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIE5vZGVCdWZmZXJSZWFkZXIoZGF0YSkge1xuICAgIFVpbnQ4QXJyYXlSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKE5vZGVCdWZmZXJSZWFkZXIsIFVpbnQ4QXJyYXlSZWFkZXIpO1xuXG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5Ob2RlQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gTm9kZUJ1ZmZlclJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBEYXRhUmVhZGVyID0gcmVxdWlyZSgnLi9EYXRhUmVhZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBTdHJpbmdSZWFkZXIoZGF0YSkge1xuICAgIERhdGFSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKFN0cmluZ1JlYWRlciwgRGF0YVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5ieXRlQXRcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5ieXRlQXQgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMuemVybyArIGkpO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmxhc3RJbmRleE9mKHNpZykgLSB0aGlzLnplcm87XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnID09PSBkYXRhO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICAvLyB0aGlzIHdpbGwgd29yayBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRoZSBcIiYgMHhmZlwiIG1hc2suXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL0FycmF5UmVhZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBVaW50OEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoVWludDhBcnJheVJlYWRlciwgQXJyYXlSZWFkZXIpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuVWludDhBcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIC8vIGluIElFMTAsIHdoZW4gdXNpbmcgc3ViYXJyYXkoaWR4LCBpZHgpLCB3ZSBnZXQgdGhlIGFycmF5IFsweDAwXSBpbnN0ZWFkIG9mIFtdLlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi4vc3VwcG9ydCcpO1xudmFyIEFycmF5UmVhZGVyID0gcmVxdWlyZSgnLi9BcnJheVJlYWRlcicpO1xudmFyIFN0cmluZ1JlYWRlciA9IHJlcXVpcmUoJy4vU3RyaW5nUmVhZGVyJyk7XG52YXIgTm9kZUJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4vTm9kZUJ1ZmZlclJlYWRlcicpO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL1VpbnQ4QXJyYXlSZWFkZXInKTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWFkZXIgYWRhcHRlZCB0byB0aGUgZGF0YS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhIHRvIHJlYWQuXG4gKiBAcmV0dXJuIHtEYXRhUmVhZGVyfSB0aGUgZGF0YSByZWFkZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKTtcbiAgICB1dGlscy5jaGVja1N1cHBvcnQodHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgIXN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1JlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZUJ1ZmZlclJlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXlSZWFkZXIodXRpbHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5XCIsIGRhdGEpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5leHBvcnRzLkxPQ0FMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAzXFx4MDRcIjtcbmV4cG9ydHMuQ0VOVFJBTF9GSUxFX0hFQURFUiA9IFwiUEtcXHgwMVxceDAyXCI7XG5leHBvcnRzLkNFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNVxceDA2XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IgPSBcIlBLXFx4MDZcXHgwN1wiO1xuZXhwb3J0cy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQgPSBcIlBLXFx4MDZcXHgwNlwiO1xuZXhwb3J0cy5EQVRBX0RFU0NSSVBUT1IgPSBcIlBLXFx4MDdcXHgwOFwiO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjb252ZXJ0IGNodW5rcyB0byBhIHNwZWNpZmllZCB0eXBlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzdFR5cGUgdGhlIGRlc3RpbmF0aW9uIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIENvbnZlcnRXb3JrZXIoZGVzdFR5cGUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDb252ZXJ0V29ya2VyIHRvIFwiICsgZGVzdFR5cGUpO1xuICAgIHRoaXMuZGVzdFR5cGUgPSBkZXN0VHlwZTtcbn1cbnV0aWxzLmluaGVyaXRzKENvbnZlcnRXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ29udmVydFdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IHV0aWxzLnRyYW5zZm9ybVRvKHRoaXMuZGVzdFR5cGUsIGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29udmVydFdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNhbGN1bGF0ZSB0aGUgY3JjMzIgb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENyYzMyUHJvYmUoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiQ3JjMzJQcm9iZVwiKTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKFwiY3JjMzJcIiwgMCk7XG59XG51dGlscy5pbmhlcml0cyhDcmMzMlByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkNyYzMyUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMuc3RyZWFtSW5mby5jcmMzMiA9IGNyYzMyKGNodW5rLmRhdGEsIHRoaXMuc3RyZWFtSW5mby5jcmMzMiB8fCAwKTtcbiAgICB0aGlzLnB1c2goY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ3JjMzJQcm9iZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgdGhlIG5hbWUgdXNlZCB0byBleHBvc2UgdGhlIGxlbmd0aFxuICovXG5mdW5jdGlvbiBEYXRhTGVuZ3RoUHJvYmUocHJvcE5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhTGVuZ3RoUHJvYmUgZm9yIFwiICsgcHJvcE5hbWUpO1xuICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKHByb3BOYW1lLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKERhdGFMZW5ndGhQcm9iZSwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5EYXRhTGVuZ3RoUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmKGNodW5rKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gfHwgMDtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvW3RoaXMucHJvcE5hbWVdID0gbGVuZ3RoICsgY2h1bmsuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuay5jYWxsKHRoaXMsIGNodW5rKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFMZW5ndGhQcm9iZTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLy8gdGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBjaHVua3Ncbi8vIFRPRE8gZXhwb3NlIHRoaXMgYXMgYSBwdWJsaWMgdmFyaWFibGVcbnZhciBERUZBVUxUX0JMT0NLX1NJWkUgPSAxNiAqIDEwMjQ7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCByZWFkcyBhIGNvbnRlbnQgYW5kIGVtaXRzIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQcm9taXNlfSBkYXRhUCB0aGUgcHJvbWlzZSBvZiB0aGUgZGF0YSB0byBzcGxpdFxuICovXG5mdW5jdGlvbiBEYXRhV29ya2VyKGRhdGFQKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRGF0YVdvcmtlclwiKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kYXRhSXNSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMubWF4ID0gMDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG5cbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICBkYXRhUC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuZGF0YUlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLm1heCA9IGRhdGEgJiYgZGF0YS5sZW5ndGggfHwgMDtcbiAgICAgICAgc2VsZi50eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgICAgICBpZighc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdGlja0FuZFJlcGVhdCgpO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbn1cblxudXRpbHMuaW5oZXJpdHMoRGF0YVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyk7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RpY2tTY2hlZHVsZWQgJiYgdGhpcy5kYXRhSXNSZWFkeSkge1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBhIHRpY2sgYSBzY2hlZHVsZSBhbiBvdGhlciBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLl90aWNrQW5kUmVwZWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGljaygpO1xuICAgIGlmKCF0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlYWQgYW5kIHB1c2ggYSBjaHVuay5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2l6ZSA9IERFRkFVTFRfQkxPQ0tfU0laRTtcbiAgICB2YXIgZGF0YSA9IG51bGwsIG5leHRJbmRleCA9IE1hdGgubWluKHRoaXMubWF4LCB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgLy8gRU9GXG4gICAgICAgIHJldHVybiB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhLnN1YnN0cmluZyh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgOiB0aGlzLm1heCA/IHRoaXMuaW5kZXggLyB0aGlzLm1heCAqIDEwMCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhV29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCBwYXNzaW5nIGNodW5rcyB0byB0aGUgbmV4dCBvbmUuIFRoaXMgaXMgbGlrZVxuICogYSBub2RlanMgc3RyZWFtIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXMuIE9uIHRoZSBnb29kIHNpZGUgOlxuICogLSBpdCB3b3JrcyBvbiBJRSA2LTkgd2l0aG91dCBhbnkgaXNzdWUgLyBwb2x5ZmlsbFxuICogLSBpdCB3ZWlnaHRzIGxlc3MgdGhhbiB0aGUgZnVsbCBkZXBlbmRlbmNpZXMgYnVuZGxlZCB3aXRoIGJyb3dzZXJpZnlcbiAqIC0gaXQgZm9yd2FyZHMgZXJyb3JzIChubyBuZWVkIHRvIGRlY2xhcmUgYW4gZXJyb3IgaGFuZGxlciBFVkVSWVdIRVJFKVxuICpcbiAqIEEgY2h1bmsgaXMgYW4gb2JqZWN0IHdpdGggMiBhdHRyaWJ1dGVzIDogYG1ldGFgIGFuZCBgZGF0YWAuIFRoZSBmb3JtZXIgaXMgYW5cbiAqIG9iamVjdCBjb250YWluaW5nIGFueXRoaW5nIChgcGVyY2VudGAgZm9yIGV4YW1wbGUpLCBzZWUgZWFjaCB3b3JrZXIgZm9yIG1vcmVcbiAqIGRldGFpbHMuIFRoZSBsYXR0ZXIgaXMgdGhlIHJlYWwgZGF0YSAoU3RyaW5nLCBVaW50OEFycmF5LCBldGMpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHN0cmVhbSAobWFpbmx5IHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqL1xuZnVuY3Rpb24gR2VuZXJpY1dvcmtlcihuYW1lKSB7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIHdvcmtlclxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJkZWZhdWx0XCI7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgYWJvdXQgdGhlIHdvcmtlcnMgY2hhaW5cbiAgICB0aGlzLnN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyBhbiBlcnJvciB3aGljaCBoYXBwZW5lZCB3aGVuIHRoZSB3b3JrZXIgd2FzIHBhdXNlZFxuICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBudWxsO1xuICAgIC8vIGFuIG9iamVjdCBjb250YWluaW5nIG1ldGFkYXRhIHRvIGJlIG1lcmdlZCBieSB0aGlzIHdvcmtlciBpbnRvIHRoZSBnZW5lcmFsIG1ldGFkYXRhXG4gICAgdGhpcy5leHRyYVN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgcGF1c2VkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCAoYW5kIHNob3VsZCBub3QgZG8gYW55dGhpbmcpLCBmYWxzZSBvdGhlcndpc2VcbiAgICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgbG9ja2VkIHRvIHByZXZlbnQgZnVydGhlciBzdHJ1Y3R1cmUgdXBkYXRlcyAocGlwZSksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAvLyB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgICAnZGF0YSc6W10sXG4gICAgICAgICdlbmQnOltdLFxuICAgICAgICAnZXJyb3InOltdXG4gICAgfTtcbiAgICAvLyB0aGUgcHJldmlvdXMgd29ya2VyLCBpZiBhbnlcbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cblxuR2VuZXJpY1dvcmtlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogUHVzaCBhIGNodW5rIHRvIHRoZSBuZXh0IHdvcmtlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwdXNoXG4gICAgICovXG4gICAgcHVzaCA6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGNodW5rKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlbmQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5VcCgpO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmQgdGhlIHN0cmVhbSB3aXRoIGFuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGUgdGhlIGVycm9yIHdoaWNoIGNhdXNlZCB0aGUgcHJlbWF0dXJlIGVuZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBlbmRlZCB0aGUgd29ya2VyIHdpdGggYW4gZXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlcnJvciA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG5cbiAgICAgICAgICAgIC8vIGluIHRoZSB3b3JrZXJzIGNoYWluIGV4cGxvZGVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNoYWluLFxuICAgICAgICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IHdpbGwgZ28gZG93bndhcmQgYnV0IHdlIGFsc28gbmVlZCB0byBub3RpZnlcbiAgICAgICAgICAgIC8vIHdvcmtlcnMgdXB3YXJkIHRoYXQgdGhlcmUgaGFzIGJlZW4gYW4gZXJyb3IuXG4gICAgICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayBvbiBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2xlYW4gYW55IHJlZmVyZW5jZXMgd2hlbiBhIHdvcmtlciBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgY2xlYW5VcCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvID0gdGhpcy5nZW5lcmF0ZWRFcnJvciA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50LiBUaGlzIHdpbGwgY2FsbCByZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggdGhlIHByb3ZpZGVkIGFyZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyB0aGUgYXJndW1lbnQgdG8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICAgKi9cbiAgICBlbWl0IDogZnVuY3Rpb24gKG5hbWUsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzW25hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdW2ldLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhaW4gYSB3b3JrZXIgd2l0aCBhbiBvdGhlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gbmV4dCB0aGUgd29ya2VyIHJlY2VpdmluZyBldmVudHMgZnJvbSB0aGUgY3VycmVudCBvbmUuXG4gICAgICogQHJldHVybiB7d29ya2VyfSB0aGUgbmV4dCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHBpcGUgOiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gbmV4dC5yZWdpc3RlclByZXZpb3VzKHRoaXMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBgcGlwZWAgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgICAgKiBVc2luZyBhbiBBUEkgd2l0aCBgcGlwZShuZXh0KWAgaXMgdmVyeSBlYXN5LlxuICAgICAqIEltcGxlbWVudGluZyB0aGUgQVBJIHdpdGggdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIG5leHQgb25lIHJlZ2lzdGVyaW5nXG4gICAgICogYSBzb3VyY2UgaXMgZWFzaWVyLCBzZWUgdGhlIFppcEZpbGVXb3JrZXIuXG4gICAgICogQHBhcmFtIHtXb3JrZXJ9IHByZXZpb3VzIHRoZSBwcmV2aW91cyB3b3JrZXIsIHNlbmRpbmcgZXZlbnRzIHRvIHRoaXMgb25lXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUHJldmlvdXMgOiBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHJlYW0gJ1wiICsgdGhpcyArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hhcmluZyB0aGUgc3RyZWFtSW5mby4uLlxuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSBwcmV2aW91cy5zdHJlYW1JbmZvO1xuICAgICAgICAvLyAuLi4gYW5kIGFkZGluZyBvdXIgb3duIGJpdHNcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9ICBwcmV2aW91cztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcmV2aW91cy5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldmlvdXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIHN0cmVhbSBzbyBpdCBkb2Vzbid0IHNlbmQgZXZlbnRzIGFueW1vcmUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcGF1c2VkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwYXVzZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcblxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgYSBwYXVzZWQgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIHJlc3VtZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoIXRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIHRydWUsIHRoZSB3b3JrZXIgdHJpZWQgdG8gcmVzdW1lIGJ1dCBmYWlsZWRcbiAgICAgICAgdmFyIHdpdGhFcnJvciA9IGZhbHNlO1xuICAgICAgICBpZih0aGlzLmdlbmVyYXRlZEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKHRoaXMuZ2VuZXJhdGVkRXJyb3IpO1xuICAgICAgICAgICAgd2l0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICF3aXRoRXJyb3I7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGbHVzaCBhbnkgcmVtYWluaW5nIGJ5dGVzIGFzIHRoZSBzdHJlYW0gaXMgZW5kaW5nLlxuICAgICAqL1xuICAgIGZsdXNoIDogZnVuY3Rpb24gKCkge30sXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIGNodW5rLiBUaGlzIGlzIHVzdWFsbHkgdGhlIG1ldGhvZCBvdmVycmlkZGVuLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaHVuayB0aGUgY2h1bmsgdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQ2h1bmsgOiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEga2V5L3ZhbHVlIHRvIGJlIGFkZGVkIGluIHRoZSB3b3JrZXJzIGNoYWluIHN0cmVhbUluZm8gb25jZSBhY3RpdmF0ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IHRvIHVzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0aGUgYXNzb2NpYXRlZCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1dvcmtlcn0gdGhlIGN1cnJlbnQgd29ya2VyIGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICB3aXRoU3RyZWFtSW5mbyA6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGlzIHdvcmtlcidzIHN0cmVhbUluZm8gaW50byB0aGUgY2hhaW4ncyBzdHJlYW1JbmZvLlxuICAgICAqL1xuICAgIG1lcmdlU3RyZWFtSW5mbyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gdGhpcy5leHRyYVN0cmVhbUluZm8pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5leHRyYVN0cmVhbUluZm8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdHJlYW1JbmZvW2tleV0gPSB0aGlzLmV4dHJhU3RyZWFtSW5mb1trZXldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIHN0cmVhbSB0byBwcmV2ZW50IGZ1cnRoZXIgdXBkYXRlcyBvbiB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLCBhbGwgY2FsbHMgdG8gcGlwZSB3aWxsIGZhaWwuXG4gICAgICovXG4gICAgbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0xvY2tlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLmxvY2soKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByZXR0eSBwcmludCB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lID0gXCJXb3JrZXIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cyArIFwiIC0+IFwiICsgbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyaWNXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgQ29udmVydFdvcmtlciA9IHJlcXVpcmUoJy4vQ29udmVydFdvcmtlcicpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuLi9iYXNlNjQnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4uL3N1cHBvcnRcIik7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vZXh0ZXJuYWxcIik7XG5cbnZhciBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gbnVsbDtcbmlmIChzdXBwb3J0Lm5vZGVzdHJlYW0pIHtcbiAgICB0cnkge1xuICAgICAgICBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gcmVxdWlyZSgnLi4vbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXInKTtcbiAgICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIGZpbmFsIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBkYXRhLiBJZiB0aGUgdXNlciB3YW50cyBhIEJsb2IgZm9yXG4gKiBleGFtcGxlLCBpdCdzIGVhc2llciB0byB3b3JrIHdpdGggYW4gVThpbnRBcnJheSBhbmQgZmluYWxseSBkbyB0aGVcbiAqIEFycmF5QnVmZmVyL0Jsb2IgY29udmVyc2lvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBuYW1lIG9mIHRoZSBmaW5hbCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xVaW50OEFycmF5fEJ1ZmZlcn0gY29udGVudCB0aGUgY29udGVudCB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBjb250ZW50LCBpZiBhcHBsaWNhYmxlLlxuICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8QnVmZmVyfEJsb2J9IHRoZSBjb250ZW50IGluIHRoZSByaWdodCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVppcE91dHB1dCh0eXBlLCBjb250ZW50LCBtaW1lVHlwZSkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJibG9iXCIgOlxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm5ld0Jsb2IodXRpbHMudHJhbnNmb3JtVG8oXCJhcnJheWJ1ZmZlclwiLCBjb250ZW50KSwgbWltZVR5cGUpO1xuICAgICAgICBjYXNlIFwiYmFzZTY0XCIgOlxuICAgICAgICAgICAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoY29udGVudCk7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKHR5cGUsIGNvbnRlbnQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbiBhcnJheSBvZiBkYXRhIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGRhdGEgaW4gdGhlIGdpdmVuIGFycmF5LlxuICogQHBhcmFtIHtBcnJheX0gZGF0YUFycmF5IHRoZSBhcnJheSBjb250YWluaW5nIHRoZSBkYXRhIGNodW5rcyB0byBjb25jYXRlbmF0ZVxuICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgY29uY2F0ZW5hdGVkIGRhdGFcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGFza2VkIHR5cGUgaXMgdW5zdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gY29uY2F0ICh0eXBlLCBkYXRhQXJyYXkpIHtcbiAgICB2YXIgaSwgaW5kZXggPSAwLCByZXMgPSBudWxsLCB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgfVxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBkYXRhQXJyYXkuam9pbihcIlwiKTtcbiAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBkYXRhQXJyYXkpO1xuICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgcmVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldChkYXRhQXJyYXlbaV0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBkYXRhQXJyYXlbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgY2FzZSBcIm5vZGVidWZmZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGRhdGFBcnJheSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25jYXQgOiB1bnN1cHBvcnRlZCB0eXBlICdcIiAgKyB0eXBlICsgXCInXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICogY29tcGxldGUgYmxvY2suXG4gKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgdG8gdXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2FsbGJhY2sgYSBjYWxsYmFjayBjYWxsZWQgb24gZWFjaCB1cGRhdGUuIENhbGxlZFxuICogd2l0aCBvbmUgYXJnIDpcbiAqIC0gdGhlIG1ldGFkYXRhIGxpbmtlZCB0byB0aGUgdXBkYXRlIHJlY2VpdmVkLlxuICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlKGhlbHBlciwgdXBkYXRlQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGNodW5rVHlwZSA9IGhlbHBlci5faW50ZXJuYWxUeXBlLFxuICAgICAgICAgICAgcmVzdWx0VHlwZSA9IGhlbHBlci5fb3V0cHV0VHlwZSxcbiAgICAgICAgICAgIG1pbWVUeXBlID0gaGVscGVyLl9taW1lVHlwZTtcbiAgICAgICAgaGVscGVyXG4gICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhLCBtZXRhKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2FsbGJhY2sobWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm1aaXBPdXRwdXQocmVzdWx0VHlwZSwgY29uY2F0KGNodW5rVHlwZSwgZGF0YUFycmF5KSwgbWltZVR5cGUpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFuIGhlbHBlciB0byBlYXNpbHkgdXNlIHdvcmtlcnMgb3V0c2lkZSBvZiBKU1ppcC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXb3JrZXJ9IHdvcmtlciB0aGUgd29ya2VyIHRvIHdyYXBcbiAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXRUeXBlIHRoZSB0eXBlIG9mIGRhdGEgZXhwZWN0ZWQgYnkgdGhlIHVzZVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIFN0cmVhbUhlbHBlcih3b3JrZXIsIG91dHB1dFR5cGUsIG1pbWVUeXBlKSB7XG4gICAgdmFyIGludGVybmFsVHlwZSA9IG91dHB1dFR5cGU7XG4gICAgc3dpdGNoKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGUgPSBcInVpbnQ4YXJyYXlcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIGludGVybmFsVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgaW50ZXJuYWxseVxuICAgICAgICB0aGlzLl9pbnRlcm5hbFR5cGUgPSBpbnRlcm5hbFR5cGU7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgdG8gb3V0cHV0IHJlc3VsdHNcbiAgICAgICAgdGhpcy5fb3V0cHV0VHlwZSA9IG91dHB1dFR5cGU7XG4gICAgICAgIC8vIHRoZSBtaW1lIHR5cGVcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KGludGVybmFsVHlwZSk7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlci5waXBlKG5ldyBDb252ZXJ0V29ya2VyKGludGVybmFsVHlwZSkpO1xuICAgICAgICAvLyB0aGUgbGFzdCB3b3JrZXJzIGNhbiBiZSByZXdpcmVkIHdpdGhvdXQgaXNzdWVzIGJ1dCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHByZXZlbnQgYW55IHVwZGF0ZXMgb24gcHJldmlvdXMgd29ya2Vycy5cbiAgICAgICAgd29ya2VyLmxvY2soKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgdGhpcy5fd29ya2VyLmVycm9yKGUpO1xuICAgIH1cbn1cblxuU3RyZWFtSGVscGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICAgICAqIGNvbXBsZXRlIGJsb2NrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICAgICAqL1xuICAgIGFjY3VtdWxhdGUgOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGUodGhpcywgdXBkYXRlQ2IpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgb24gYW4gZXZlbnQgdHJpZ2dlcmVkIG9uIGEgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgb24gOiBmdW5jdGlvbiAoZXZ0LCBmbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYoZXZ0ID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChzZWxmLCBjaHVuay5kYXRhLCBjaHVuay5tZXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmRlbGF5KGZuLCBhcmd1bWVudHMsIHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fd29ya2VyLnJlc3VtZSwgW10sIHRoaXMuX3dvcmtlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl93b3JrZXIucGF1c2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBub2RlanMgc3RyZWFtIGZvciB0aGlzIGhlbHBlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXJ9IHRoZSBub2RlanMgc3RyZWFtLlxuICAgICAqL1xuICAgIHRvTm9kZWpzU3RyZWFtIDogZnVuY3Rpb24gKHVwZGF0ZUNiKSB7XG4gICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChcIm5vZGVzdHJlYW1cIik7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRUeXBlICE9PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHN0cmVhbSBjb250YWluaW5nIGJsb2IvYXJyYXlidWZmZXIvdWludDhhcnJheS9zdHJpbmdcbiAgICAgICAgICAgIC8vIGlzIHN0cmFuZ2UgYW5kIEkgZG9uJ3Qga25vdyBpZiBpdCB3b3VsZCBiZSB1c2VmdWwuXG4gICAgICAgICAgICAvLyBJIHlvdSBmaW5kIHRoaXMgY29tbWVudCBhbmQgaGF2ZSBhIGdvb2QgdXNlY2FzZSwgcGxlYXNlIG9wZW4gYVxuICAgICAgICAgICAgLy8gYnVnIHJlcG9ydCAhXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fb3V0cHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBtZXRob2RcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIodGhpcywge1xuICAgICAgICAgICAgb2JqZWN0TW9kZSA6IHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiXG4gICAgICAgIH0sIHVwZGF0ZUNiKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmJhc2U2NCA9IHRydWU7XG5leHBvcnRzLmFycmF5ID0gdHJ1ZTtcbmV4cG9ydHMuc3RyaW5nID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXlidWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnRzLm5vZGVidWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gY29udGFpbnMgdHJ1ZSBpZiBKU1ppcCBjYW4gcmVhZC9nZW5lcmF0ZSBVaW50OEFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG5leHBvcnRzLnVpbnQ4YXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xufVxuZWxzZSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB0cnkge1xuICAgICAgICBleHBvcnRzLmJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwge1xuICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi96aXBcIlxuICAgICAgICB9KS5zaXplID09PSAwO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChidWZmZXIpO1xuICAgICAgICAgICAgZXhwb3J0cy5ibG9iID0gYnVpbGRlci5nZXRCbG9iKCdhcHBsaWNhdGlvbi96aXAnKS5zaXplID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudHJ5IHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSAhIXJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlO1xufSBjYXRjaChlKSB7XG4gICAgZXhwb3J0cy5ub2Rlc3RyZWFtID0gZmFsc2U7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqc1V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi91dGlscy9zdHJpbmdzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaT0wOyBpPDI1NjsgaSsrKSB7XG4gIF91dGY4bGVuW2ldID0gKGkgPj0gMjUyID8gNiA6IGkgPj0gMjQ4ID8gNSA6IGkgPj0gMjQwID8gNCA6IGkgPj0gMjI0ID8gMyA6IGkgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XT1fdXRmOGxlblsyNTRdPTE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxudmFyIHN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICAgIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICAgICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcysxIDwgc3RyX2xlbikpIHtcbiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MrMSk7XG4gICAgICAgICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgICAgbV9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICAgIH1cblxuICAgIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmX2xlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVmID0gbmV3IEFycmF5KGJ1Zl9sZW4pO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnRcbiAgICBmb3IgKGk9MCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG52YXIgdXRmOGJvcmRlciA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7XG4gICAgdmFyIHBvcztcblxuICAgIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICAgIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAgIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICAgIHBvcyA9IG1heC0xO1xuICAgIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gICAgLy8gRnVja3VwIC0gdmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAgIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICAgIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAgIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyB2dWZmZXIgaXMgdG9vIHNtYWxsLFxuICAgIC8vIHJldHVybiBtYXggdG9vLlxuICAgIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbnZhciBidWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBzdHIsIGksIG91dCwgYywgY19sZW47XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gICAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gICAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuKjIpO1xuXG4gICAgZm9yIChvdXQ9MCwgaT0wOyBpPGxlbjspIHtcbiAgICAgICAgYyA9IGJ1ZltpKytdO1xuICAgICAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgICAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbi0xOyBjb250aW51ZTsgfVxuXG4gICAgICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgICAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICAgICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICAgICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgICAgICAgIGNfbGVuLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNocmlua0J1Zih1dGYxNmJ1Ziwgb3V0KVxuICAgIGlmICh1dGYxNmJ1Zi5sZW5ndGggIT09IG91dCkge1xuICAgICAgICBpZih1dGYxNmJ1Zi5zdWJhcnJheSkge1xuICAgICAgICAgICAgdXRmMTZidWYgPSB1dGYxNmJ1Zi5zdWJhcnJheSgwLCBvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRmMTZidWYubGVuZ3RoID0gb3V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRmMTZidWYpO1xuICAgIHJldHVybiB1dGlscy5hcHBseUZyb21DaGFyQ29kZSh1dGYxNmJ1Zik7XG59O1xuXG5cbi8vIFRoYXQncyBhbGwgZm9yIHRoZSBwYWtvIGZ1bmN0aW9ucy5cblxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGphdmFzY3JpcHQgc3RyaW5nIGludG8gYW4gYXJyYXkgKHR5cGVkIGlmIHBvc3NpYmxlKSBvZiBieXRlcyxcbiAqIFVURi04IGVuY29kZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gKiBAcmV0dXJuIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIFVURi04IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnRzLnV0ZjhlbmNvZGUgPSBmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cikge1xuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oc3RyLCBcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmcyYnVmKHN0cik7XG59O1xuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgYnl0ZXMgYXJyYXkgKG9yIGEgcmVwcmVzZW50YXRpb24pIHJlcHJlc2VudGluZyBhbiBVVEYtOCBlbmNvZGVkXG4gKiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgc3RyaW5nLlxuICogQHBhcmFtIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gYnVmIHRoZSBkYXRhIGRlIGRlY29kZVxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGRlY29kZSA9IGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnVmKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8oXCJub2RlYnVmZmVyXCIsIGJ1ZikudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbiAgICB9XG5cbiAgICBidWYgPSB1dGlscy50cmFuc2Zvcm1UbyhzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgYnVmKTtcblxuICAgIHJldHVybiBidWYyc3RyaW5nKGJ1Zik7XG59O1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGRlY29kZSB1dGY4IGVuY29kZWQgYmluYXJ5IGNodW5rcyBpbnRvIHN0cmluZyBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRmOERlY29kZVdvcmtlcigpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJ1dGYtOCBkZWNvZGVcIik7XG4gICAgLy8gdGhlIGxhc3QgYnl0ZXMgaWYgYSBjaHVuayBkaWRuJ3QgZW5kIHdpdGggYSBjb21wbGV0ZSBjb2RlcG9pbnQuXG4gICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG59XG51dGlscy5pbmhlcml0cyhVdGY4RGVjb2RlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgdmFyIGRhdGEgPSB1dGlscy50cmFuc2Zvcm1UbyhzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgY2h1bmsuZGF0YSk7XG5cbiAgICAvLyAxc3Qgc3RlcCwgcmUtdXNlIHdoYXQncyBsZWZ0IG9mIHRoZSBwcmV2aW91cyBjaHVua1xuICAgIGlmICh0aGlzLmxlZnRPdmVyICYmIHRoaXMubGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocHJldmlvdXNEYXRhLmxlbmd0aCArIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGRhdGEuc2V0KHRoaXMubGVmdE92ZXIsIDApO1xuICAgICAgICAgICAgZGF0YS5zZXQocHJldmlvdXNEYXRhLCB0aGlzLmxlZnRPdmVyLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5sZWZ0T3Zlci5jb25jYXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG5leHRCb3VuZGFyeSA9IHV0Zjhib3JkZXIoZGF0YSk7XG4gICAgdmFyIHVzYWJsZURhdGEgPSBkYXRhO1xuICAgIGlmIChuZXh0Qm91bmRhcnkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgICAgIHVzYWJsZURhdGEgPSBkYXRhLnN1YmFycmF5KDAsIG5leHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmxlZnRPdmVyID0gZGF0YS5zdWJhcnJheShuZXh0Qm91bmRhcnksIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVzYWJsZURhdGEgPSBkYXRhLnNsaWNlKDAsIG5leHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmxlZnRPdmVyID0gZGF0YS5zbGljZShuZXh0Qm91bmRhcnksIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodXNhYmxlRGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5VdGY4RGVjb2RlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZih0aGlzLmxlZnRPdmVyICYmIHRoaXMubGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZGVjb2RlKHRoaXMubGVmdE92ZXIpLFxuICAgICAgICAgICAgbWV0YSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG59O1xuZXhwb3J0cy5VdGY4RGVjb2RlV29ya2VyID0gVXRmOERlY29kZVdvcmtlcjtcblxuLyoqXG4gKiBBIHdvcmtlciB0byBlbmRjb2RlIHN0cmluZyBjaHVua3MgaW50byB1dGY4IGVuY29kZWQgYmluYXJ5IGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RW5jb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGVuY29kZVwiKTtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhFbmNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOEVuY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGVuY29kZShjaHVuay5kYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5leHBvcnRzLlV0ZjhFbmNvZGVXb3JrZXIgPSBVdGY4RW5jb2RlV29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqc1V0aWxzJyk7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnY29yZS1qcy9saWJyYXJ5L2ZuL3NldC1pbW1lZGlhdGUnKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xuXG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0aGF0IHBhc3MgYXMgYSBcImJpbmFyeSBzdHJpbmdcIjogaXQgc2hvdWxkIHJlcHJlc2VudCBhIGJ5dGVcbiAqIGFycmF5IGJ1dCBtYXkgaGF2ZSA+IDI1NSBjaGFyIGNvZGVzLiBCZSBzdXJlIHRvIHRha2Ugb25seSB0aGUgZmlyc3QgYnl0ZVxuICogYW5kIHJldHVybnMgdGhlIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheX0gdGhlIHN0cmluZyBpbiBhIGJpbmFyeSBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZzJiaW5hcnkoc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgcmVzdWx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYmxvYiB3aXRoIHRoZSBnaXZlbiBjb250ZW50IGFuZCB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfSBwYXJ0IHRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgYmxvYi4gRE8gTk9UIHVzZVxuICogYW4gVWludDhBcnJheSBiZWNhdXNlIHRoZSBzdG9jayBicm93c2VyIG9mIGFuZHJvaWQgNCB3b24ndCBhY2NlcHQgaXQgKGl0XG4gKiB3aWxsIGJlIHNpbGVudGx5IGNvbnZlcnRlZCB0byBhIHN0cmluZywgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpLlxuICpcbiAqIFVzZSBvbmx5IE9ORSBwYXJ0IHRvIGJ1aWxkIHRoZSBibG9iIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW4gSUUxMSAvIEVkZ2U6XG4gKiB3aGVuIGEgbGFyZ2UgYW1vdW50IG9mIEFycmF5IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBCbG9iLCB0aGUgYW1vdW50IG9mXG4gKiBtZW1vcnkgY29uc3VtZWQgaXMgbmVhcmx5IDEwMCB0aW1lcyB0aGUgb3JpZ2luYWwgZGF0YSBhbW91bnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgYmxvYi5cbiAqIEByZXR1cm4ge0Jsb2J9IHRoZSBjcmVhdGVkIGJsb2IuXG4gKi9cbmV4cG9ydHMubmV3QmxvYiA9IGZ1bmN0aW9uKHBhcnQsIHR5cGUpIHtcbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChcImJsb2JcIik7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBCbG9iIGNvbnN0cnVjdG9yXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbcGFydF0sIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQsIGJyb3dzZXIgb25seSwgb2xkIHdheVxuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmdldEJsb2IodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gd2VsbCwgZnVjayA/IVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogY2FuJ3QgY29uc3RydWN0IHRoZSBCbG9iLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2FtZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogRmlsbCBpbiBhbiBhcnJheSB3aXRoIGEgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byBmaWxsIGluICh3aWxsIGJlIG11dGF0ZWQpLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBbiBoZWxwZXIgZm9yIHRoZSBmdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAqIFRoaXMgY29udGFpbnMgc3RhdGljIGluZm9ybWF0aW9ucyBhbmQgZnVuY3Rpb25zIHRoYXRcbiAqIGNhbiBiZSBvcHRpbWl6ZWQgYnkgdGhlIGJyb3dzZXIgSklUIGNvbXBpbGVyLlxuICovXG52YXIgYXJyYXlUb1N0cmluZ0hlbHBlciA9IHtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgaW50IGludG8gYSBzdHJpbmcsIGNodW5rIGJ5IGNodW5rLlxuICAgICAqIFNlZSB0aGUgcGVyZm9ybWFuY2VzIG5vdGVzIG9uIGFycmF5TGlrZVRvU3RyaW5nLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGFycmF5LlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gY2h1bmsgdGhlIGNodW5rIHNpemUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBjaHVuayBpcyB0b28gYmlnIGZvciB0aGUgc3RhY2suXG4gICAgICovXG4gICAgc3RyaW5naWZ5QnlDaHVuazogZnVuY3Rpb24oYXJyYXksIHR5cGUsIGNodW5rKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgayA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgLy8gc2hvcnRjdXRcbiAgICAgICAgaWYgKGxlbiA8PSBjaHVuaykge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhcnJheVwiIHx8IHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheS5zbGljZShrLCBNYXRoLm1pbihrICsgY2h1bmssIGxlbikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnN1YmFycmF5KGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgKz0gY2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsbCBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAqIFRoaXMgaXMgdGhlIG5haXZlIGltcGxlbWVudGF0aW9uLCB3aGljaCBnZW5lcmF0ZSBBIExPVCBvZiBpbnRlcm1lZGlhdGUgc3RyaW5nLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgd2hlbiBldmVyeXRoaW5nIGVsc2UgZmFpbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNoYXI6IGZ1bmN0aW9uKGFycmF5KXtcbiAgICAgICAgdmFyIHJlc3VsdFN0ciA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRTdHI7XG4gICAgfSxcbiAgICBhcHBseUNhbkJlVXNlZCA6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgaWYgdGhlIGJyb3dzZXIgYWNjZXB0cyB0byB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBVaW50OEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB1aW50OGFycmF5IDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQudWludDhhcnJheSAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIG5vZGVqcyBCdWZmZXIuXG4gICAgICAgICAqL1xuICAgICAgICBub2RlYnVmZmVyIDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5vZGVqc1V0aWxzLmFsbG9jQnVmZmVyKDEpKS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpXG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZyhhcnJheSkge1xuICAgIC8vIFBlcmZvcm1hbmNlcyBub3RlcyA6XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KSBpcyB0aGUgZmFzdGVzdCwgc2VlXG4gICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbnZlcnRpbmctYS11aW50OGFycmF5LXRvLWEtc3RyaW5nLzJcbiAgICAvLyBidXQgdGhlIHN0YWNrIGlzIGxpbWl0ZWQgKGFuZCB3ZSBjYW4gZ2V0IGh1Z2UgYXJyYXlzICEpLlxuICAgIC8vXG4gICAgLy8gcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pOyBnZW5lcmF0ZSB0b28gbWFueSBzdHJpbmdzICFcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBpcyBpbnNwaXJlZCBieSBodHRwOi8vanNwZXJmLmNvbS9hcnJheWJ1ZmZlci10by1zdHJpbmctYXBwbHktcGVyZm9ybWFuY2UvMlxuICAgIC8vIFRPRE8gOiB3ZSBub3cgaGF2ZSB3b3JrZXJzIHRoYXQgc3BsaXQgdGhlIHdvcmsuIERvIHdlIHN0aWxsIG5lZWQgdGhhdCA/XG4gICAgdmFyIGNodW5rID0gNjU1MzYsXG4gICAgICAgIHR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihhcnJheSksXG4gICAgICAgIGNhblVzZUFwcGx5ID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50OGFycmF5XCIpIHtcbiAgICAgICAgY2FuVXNlQXBwbHkgPSBhcnJheVRvU3RyaW5nSGVscGVyLmFwcGx5Q2FuQmVVc2VkLnVpbnQ4YXJyYXk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQubm9kZWJ1ZmZlcjtcbiAgICB9XG5cbiAgICBpZiAoY2FuVXNlQXBwbHkpIHtcbiAgICAgICAgd2hpbGUgKGNodW5rID4gMSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNodW5rKGFycmF5LCB0eXBlLCBjaHVuayk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBNYXRoLmZsb29yKGNodW5rIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBubyBhcHBseSBvciBjaHVuayBlcnJvciA6IHNsb3cgYW5kIHBhaW5mdWwgYWxnb3JpdGhtXG4gICAgLy8gZGVmYXVsdCBicm93c2VyIG9uIGFuZHJvaWQgNC4qXG4gICAgcmV0dXJuIGFycmF5VG9TdHJpbmdIZWxwZXIuc3RyaW5naWZ5QnlDaGFyKGFycmF5KTtcbn1cblxuZXhwb3J0cy5hcHBseUZyb21DaGFyQ29kZSA9IGFycmF5TGlrZVRvU3RyaW5nO1xuXG5cbi8qKlxuICogQ29weSB0aGUgZGF0YSBmcm9tIGFuIGFycmF5LWxpa2UgdG8gYW4gb3RoZXIgYXJyYXktbGlrZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5RnJvbSB0aGUgb3JpZ2luIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlUbyB0aGUgZGVzdGluYXRpb24gYXJyYXkgd2hpY2ggd2lsbCBiZSBtdXRhdGVkLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGRlc3RpbmF0aW9uIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb0FycmF5TGlrZShhcnJheUZyb20sIGFycmF5VG8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5RnJvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVRvW2ldID0gYXJyYXlGcm9tW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlUbztcbn1cblxuLy8gYSBtYXRyaXggY29udGFpbmluZyBmdW5jdGlvbnMgdG8gdHJhbnNmb3JtIGV2ZXJ5dGhpbmcgaW50byBldmVyeXRoaW5nLlxudmFyIHRyYW5zZm9ybSA9IHt9O1xuXG4vLyBzdHJpbmcgdG8gP1xudHJhbnNmb3JtW1wic3RyaW5nXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGlkZW50aXR5LFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJzdHJpbmdcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5vZGVqc1V0aWxzLmFsbG9jQnVmZmVyKGlucHV0Lmxlbmd0aCkpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5IHRvID9cbnRyYW5zZm9ybVtcImFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKG5ldyBVaW50OEFycmF5KGlucHV0KSkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oaW5wdXQpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5YnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcImFycmF5YnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb1N0cmluZyhuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH0sXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UobmV3IFVpbnQ4QXJyYXkoaW5wdXQpLCBuZXcgQXJyYXkoaW5wdXQuYnl0ZUxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBpZGVudGl0eSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH1cbn07XG5cbi8vIHVpbnQ4YXJyYXkgdG8gP1xudHJhbnNmb3JtW1widWludDhhcnJheVwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGlkZW50aXR5LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gbm9kZWJ1ZmZlciB0byA/XG50cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdW1widWludDhhcnJheVwiXShpbnB1dCkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogaWRlbnRpdHlcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGlucHV0IGludG8gYW55IHR5cGUuXG4gKiBUaGUgc3VwcG9ydGVkIG91dHB1dCB0eXBlIGFyZSA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBub2RlYnVmZmVyLlxuICogSWYgbm8gb3V0cHV0IHR5cGUgaXMgc3BlY2lmaWVkLCB0aGUgdW5tb2RpZmllZCBpbnB1dCB3aWxsIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIG91dHB1dCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGlucHV0IHRoZSBpbnB1dCB0byBjb252ZXJ0LlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIG91dHB1dCB0eXBlLlxuICovXG5leHBvcnRzLnRyYW5zZm9ybVRvID0gZnVuY3Rpb24ob3V0cHV0VHlwZSwgaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCwgbnVsbCwgZXRjXG4gICAgICAgIC8vIGFuIGVtcHR5IHN0cmluZyB3b24ndCBoYXJtLlxuICAgICAgICBpbnB1dCA9IFwiXCI7XG4gICAgfVxuICAgIGlmICghb3V0cHV0VHlwZSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGV4cG9ydHMuY2hlY2tTdXBwb3J0KG91dHB1dFR5cGUpO1xuICAgIHZhciBpbnB1dFR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihpbnB1dCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVtpbnB1dFR5cGVdW291dHB1dFR5cGVdKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgdGhlIGlucHV0LlxuICogVGhlIHR5cGUgd2lsbCBiZSBpbiBhIGZvcm1hdCB2YWxpZCBmb3IgSlNaaXAudXRpbHMudHJhbnNmb3JtVG8gOiBzdHJpbmcsIGFycmF5LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCB0aGUgaW5wdXQgdG8gaWRlbnRpZnkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSAobG93ZXJjYXNlKSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0cy5nZXRUeXBlT2YgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBub2RlanNVdGlscy5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIFwibm9kZWJ1ZmZlclwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5ICYmIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gXCJ1aW50OGFycmF5XCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LmFycmF5YnVmZmVyICYmIGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlidWZmZXJcIjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgdHlwZS5cbiAqL1xuZXhwb3J0cy5jaGVja1N1cHBvcnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHN1cHBvcnRlZCA9IHN1cHBvcnRbdHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBwbGF0Zm9ybVwiKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLk1BWF9WQUxVRV8xNkJJVFMgPSA2NTUzNTtcbmV4cG9ydHMuTUFYX1ZBTFVFXzMyQklUUyA9IC0xOyAvLyB3ZWxsLCBcIlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcIiBpcyBwYXJzZWQgYXMgLTFcblxuLyoqXG4gKiBQcmV0dGlmeSBhIHN0cmluZyByZWFkIGFzIGJpbmFyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBwcmV0dGlmeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gYSBwcmV0dHkgc3RyaW5nLlxuICovXG5leHBvcnRzLnByZXR0eSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciByZXMgPSAnJyxcbiAgICAgICAgY29kZSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgKHN0ciB8fCBcIlwiKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJlcyArPSAnXFxcXHgnICsgKGNvZGUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyBjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBEZWZlciB0aGUgY2FsbCBvZiBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgYXN5bmNocm9ub3VzbHkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gZ2l2ZSB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmV4cG9ydHMuZGVsYXkgPSBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgc2VsZikge1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHNlbGYgfHwgbnVsbCwgYXJncyB8fCBbXSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEV4dGVuZHMgYSBwcm90b3R5cGUgd2l0aCBhbiBvdGhlciwgd2l0aG91dCBjYWxsaW5nIGEgY29uc3RydWN0b3Igd2l0aFxuICogc2lkZSBlZmZlY3RzLiBJbnNwaXJlZCBieSBub2RlanMnIGB1dGlscy5pbmhlcml0c2BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN0b3IgdGhlIGNvbnN0cnVjdG9yIHRvIGF1Z21lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ3RvciB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIHRvIHVzZVxuICovXG5leHBvcnRzLmluaGVyaXRzID0gZnVuY3Rpb24gKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIHZhciBPYmogPSBmdW5jdGlvbigpIHt9O1xuICAgIE9iai5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IE9iaigpO1xufTtcblxuLyoqXG4gKiBNZXJnZSB0aGUgb2JqZWN0cyBwYXNzZWQgYXMgcGFyYW1ldGVycyBpbnRvIGEgbmV3IG9uZS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgQWxsIG9iamVjdHMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCB3aXRoIHRoZSBkYXRhIG9mIHRoZSBvdGhlcnMuXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBpLCBhdHRyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgLy8gYXJndW1lbnRzIGlzIG5vdCBlbnVtZXJhYmxlIGluIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgZm9yIChhdHRyIGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXS5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiB0eXBlb2YgcmVzdWx0W2F0dHJdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2F0dHJdID0gYXJndW1lbnRzW2ldW2F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhcmJpdHJhcnkgY29udGVudCBpbnRvIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGEgbmFtZSBmb3IgdGhlIGNvbnRlbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YSB0aGUgY29udGVudCB0byBwcm9jZXNzLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSB0cnVlIGlmIHRoZSBjb250ZW50IGlzIG5vdCBhbiB1bmljb2RlIHN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSBpc09wdGltaXplZEJpbmFyeVN0cmluZyB0cnVlIGlmIHRoZSBzdHJpbmcgY29udGVudCBvbmx5IGhhcyBvbmUgYnl0ZSBwZXIgY2hhcmFjdGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0Jhc2U2NCB0cnVlIGlmIHRoZSBzdHJpbmcgY29udGVudCBpcyBlbmNvZGVkIHdpdGggYmFzZTY0LlxuICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIGluIGEgZm9ybWF0IHVzYWJsZSBieSBKU1ppcC5cbiAqL1xuZXhwb3J0cy5wcmVwYXJlQ29udGVudCA9IGZ1bmN0aW9uKG5hbWUsIGlucHV0RGF0YSwgaXNCaW5hcnksIGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nLCBpc0Jhc2U2NCkge1xuXG4gICAgLy8gaWYgaW5wdXREYXRhIGlzIGFscmVhZHkgYSBwcm9taXNlLCB0aGlzIGZsYXR0ZW4gaXQuXG4gICAgdmFyIHByb21pc2UgPSBleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoaW5wdXREYXRhKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB2YXIgaXNCbG9iID0gc3VwcG9ydC5ibG9iICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBbJ1tvYmplY3QgRmlsZV0nLCAnW29iamVjdCBCbG9iXSddLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSAhPT0gLTEpO1xuXG4gICAgICAgIGlmIChpc0Jsb2IgJiYgdHlwZW9mIEZpbGVSZWFkZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgZGF0YVR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihkYXRhKTtcblxuICAgICAgICBpZiAoIWRhdGFUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFwiQ2FuJ3QgcmVhZCB0aGUgZGF0YSBvZiAnXCIgKyBuYW1lICsgXCInLiBJcyBpdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW4gYSBzdXBwb3J0ZWQgSmF2YVNjcmlwdCB0eXBlIChTdHJpbmcsIEJsb2IsIEFycmF5QnVmZmVyLCBldGMpID9cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIDogaXQncyB3YXkgZWFzaWVyIHRvIHdvcmsgd2l0aCBVaW50OEFycmF5IHRoYW4gd2l0aCBBcnJheUJ1ZmZlclxuICAgICAgICBpZiAoZGF0YVR5cGUgPT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgICAgICAgZGF0YSA9IGV4cG9ydHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNCYXNlNjQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYmFzZTY0LmRlY29kZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkQmluYXJ5U3RyaW5nID09PSB0cnVlIG1lYW5zIHRoYXQgdGhlIGZpbGUgaGFzIGFscmVhZHkgYmVlbiBmaWx0ZXJlZCB3aXRoIGEgMHhGRiBtYXNrXG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzdHJpbmcsIG5vdCBpbiBhIGJhc2U2NCBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlIHN1cmUgdGhhdCB0aGlzIGlzIGEgY29ycmVjdCBcImJpbmFyeSBzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gc3RyaW5nMmJpbmFyeShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlYWRlckZvciA9IHJlcXVpcmUoJy4vcmVhZGVyL3JlYWRlckZvcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHNpZyA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgWmlwRW50cnkgPSByZXF1aXJlKCcuL3ppcEVudHJ5Jyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbi8vICBjbGFzcyBaaXBFbnRyaWVzIHt7e1xuLyoqXG4gKiBBbGwgdGhlIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyaWVzKGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5maWxlcyA9IFtdO1xuICAgIHRoaXMubG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucztcbn1cblppcEVudHJpZXMucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHJlYWRlciBpcyBvbiB0aGUgc3BlY2lmaWVkIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgYW4gb3RoZXIgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGNoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihleHBlY3RlZFNpZ25hdHVyZSkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShleHBlY3RlZFNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLmluZGV4IC09IDQ7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiB1bmV4cGVjdGVkIHNpZ25hdHVyZSBcIiArIFwiKFwiICsgdXRpbHMucHJldHR5KHNpZ25hdHVyZSkgKyBcIiwgZXhwZWN0ZWQgXCIgKyB1dGlscy5wcmV0dHkoZXhwZWN0ZWRTaWduYXR1cmUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGlzIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXNrZWRJbmRleCB0aGUgaW5kZXggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkU2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgdG8gZXhwZWN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyBoZXJlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNTaWduYXR1cmU6IGZ1bmN0aW9uKGFza2VkSW5kZXgsIGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLnJlYWRlci5pbmRleDtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoYXNrZWRJbmRleCk7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2lnbmF0dXJlID09PSBleHBlY3RlZFNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoY3VycmVudEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZEJsb2NrRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIHRoaXMuemlwQ29tbWVudExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIC8vIHdhcm5pbmcgOiB0aGUgZW5jb2RpbmcgZGVwZW5kcyBvZiB0aGUgc3lzdGVtIGxvY2FsZVxuICAgICAgICAvLyBPbiBhIGxpbnV4IG1hY2hpbmUgd2l0aCBMQU5HPWVuX1VTLnV0ZjgsIHRoaXMgZmllbGQgaXMgdXRmOCBlbmNvZGVkLlxuICAgICAgICAvLyBPbiBhIHdpbmRvd3MgbWFjaGluZSwgdGhpcyBmaWVsZCBpcyBlbmNvZGVkIHdpdGggdGhlIGxvY2FsaXplZCB3aW5kb3dzIGNvZGUgcGFnZS5cbiAgICAgICAgdmFyIHppcENvbW1lbnQgPSB0aGlzLnJlYWRlci5yZWFkRGF0YSh0aGlzLnppcENvbW1lbnRMZW5ndGgpO1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIC8vIFRvIGdldCBjb25zaXN0ZW50IGJlaGF2aW9yIHdpdGggdGhlIGdlbmVyYXRpb24gcGFydCwgd2Ugd2lsbCBhc3N1bWUgdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIHV0ZjggZW5jb2RlZCB1bmxlc3Mgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAgICAgICAgdmFyIGRlY29kZUNvbnRlbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHppcENvbW1lbnQpO1xuICAgICAgICB0aGlzLnppcENvbW1lbnQgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGRlY29kZUNvbnRlbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBaaXAgNjQgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICogTm90IG1lcmdlZCB3aXRoIHRoZSBtZXRob2QgcmVhZEVuZE9mQ2VudHJhbCA6XG4gICAgICogVGhlIGVuZCBvZiBjZW50cmFsIGNhbiBjb2V4aXN0IHdpdGggaXRzIFppcDY0IGJyb3RoZXIsXG4gICAgICogSSBkb24ndCB3YW50IHRvIHJlYWQgdGhlIHdyb25nIG51bWJlciBvZiBieXRlcyAhXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMucmVhZGVyLnNraXAoNCk7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk1hZGVCeSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHMgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcblxuICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGEgPSB7fTtcbiAgICAgICAgdmFyIGV4dHJhRGF0YVNpemUgPSB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSAtIDQ0LFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZXh0cmFEYXRhU2l6ZSkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlID0gdGhpcy5yZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGFbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yLlxuICAgICAqL1xuICAgIHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlza1dpdGhaaXA2NENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuZGlza3NDb3VudCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIGlmICh0aGlzLmRpc2tzQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aS12b2x1bWVzIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgbG9jYWwgZmlsZXMsIGJhc2VkIG9uIHRoZSBvZmZzZXQgcmVhZCBpbiB0aGUgY2VudHJhbCBwYXJ0LlxuICAgICAqL1xuICAgIHJlYWRMb2NhbEZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGZpbGU7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGZpbGUubG9jYWxIZWFkZXJPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuICAgICAgICAgICAgZmlsZS5yZWFkTG9jYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlVVRGOCgpO1xuICAgICAgICAgICAgZmlsZS5wcm9jZXNzQXR0cmlidXRlcygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbERpcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWxlO1xuXG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMuY2VudHJhbERpck9mZnNldCk7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRklMRV9IRUFERVIpKSB7XG4gICAgICAgICAgICBmaWxlID0gbmV3IFppcEVudHJ5KHtcbiAgICAgICAgICAgICAgICB6aXA2NDogdGhpcy56aXA2NFxuICAgICAgICAgICAgfSwgdGhpcy5sb2FkT3B0aW9ucyk7XG4gICAgICAgICAgICBmaWxlLnJlYWRDZW50cmFsUGFydCh0aGlzLnJlYWRlcik7XG4gICAgICAgICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jZW50cmFsRGlyUmVjb3JkcyAhPT0gdGhpcy5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSAwICYmIHRoaXMuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZXhwZWN0ZWQgc29tZSByZWNvcmRzIGJ1dCBjb3VsZG4ndCBmaW5kIEFOWS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHJlYWxseSBzdXNwaWNpb3VzLCBhcyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIG9yIGJ1ZzogZXhwZWN0ZWQgXCIgKyB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICsgXCIgcmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290IFwiICsgdGhpcy5maWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBzb21lIHJlY29yZHMgYnV0IG5vdCBhbGwuXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGlzIHdyb25nIGJ1dCB3ZSBnb3Qgc29tZXRoaW5nIGZvciB0aGUgdXNlcjogbm8gZXJyb3IgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJleHBlY3RlZFwiLCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzLCBcInJlY29yZHMgaW4gY2VudHJhbCBkaXIsIGdvdFwiLCB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRlbnQgaXMgYSB0cnVuY2F0ZWQgemlwIG9yIGNvbXBsZXRlIGdhcmJhZ2UuXG4gICAgICAgICAgICAvLyBBIFwiTE9DQUxfRklMRV9IRUFERVJcIiBpcyBub3QgcmVxdWlyZWQgYXQgdGhlIGJlZ2lubmluZyAoYXV0b1xuICAgICAgICAgICAgLy8gZXh0cmFjdGlibGUgemlwIGZvciBleGFtcGxlKSBidXQgaXQgY2FuIGdpdmUgYSBnb29kIGhpbnQuXG4gICAgICAgICAgICAvLyBJZiBhbiBhamF4IHJlcXVlc3Qgd2FzIHVzZWQgd2l0aG91dCByZXNwb25zZVR5cGUsIHdlIHdpbGwgYWxzb1xuICAgICAgICAgICAgLy8gZ2V0IHVucmVhZGFibGUgZGF0YS5cbiAgICAgICAgICAgIHZhciBpc0dhcmJhZ2UgPSAhdGhpcy5pc1NpZ25hdHVyZSgwLCBzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuXG4gICAgICAgICAgICBpZiAoaXNHYXJiYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgOiBpcyB0aGlzIGEgemlwIGZpbGUgPyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYgaXQgaXMsIHNlZSBodHRwczovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vaG93dG8vcmVhZF96aXAuaHRtbFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChvZmZzZXQpO1xuICAgICAgICB2YXIgZW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICB0aGlzLnJlYWRCbG9ja0VuZE9mQ2VudHJhbCgpO1xuXG5cbiAgICAgICAgLyogZXh0cmFjdCBmcm9tIHRoZSB6aXAgc3BlYyA6XG4gICAgICAgICAgICA0KSAgSWYgb25lIG9mIHRoZSBmaWVsZHMgaW4gdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIHJlY29yZCBpcyB0b28gc21hbGwgdG8gaG9sZCByZXF1aXJlZCBkYXRhLCB0aGUgZmllbGRcbiAgICAgICAgICAgICAgICBzaG91bGQgYmUgc2V0IHRvIC0xICgweEZGRkYgb3IgMHhGRkZGRkZGRikgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFpJUDY0IGZvcm1hdCByZWNvcmQgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgICAgICA1KSAgVGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yIHJlY29yZCBtdXN0XG4gICAgICAgICAgICAgICAgcmVzaWRlIG9uIHRoZSBzYW1lIGRpc2sgd2hlbiBzcGxpdHRpbmcgb3Igc3Bhbm5pbmdcbiAgICAgICAgICAgICAgICBhbiBhcmNoaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlciA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHMgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUyB8fCB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuemlwNjQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgV2FybmluZyA6IHRoZSB6aXA2NCBleHRlbnNpb24gaXMgc3VwcG9ydGVkLCBidXQgT05MWSBpZiB0aGUgNjRiaXRzIGludGVnZXIgcmVhZCBmcm9tXG4gICAgICAgICAgICB0aGUgemlwIGZpbGUgY2FuIGZpdCBpbnRvIGEgMzJiaXRzIGludGVnZXIuIFRoaXMgY2Fubm90IGJlIHNvbHZlZCA6IEphdmFTY3JpcHQgcmVwcmVzZW50c1xuICAgICAgICAgICAgYWxsIG51bWJlcnMgYXMgNjQtYml0IGRvdWJsZSBwcmVjaXNpb24gSUVFRSA3NTQgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy5cbiAgICAgICAgICAgIFNvLCB3ZSBoYXZlIDUzYml0cyBmb3IgaW50ZWdlcnMgYW5kIGJpdHdpc2Ugb3BlcmF0aW9ucyB0cmVhdCBldmVyeXRoaW5nIGFzIDMyYml0cy5cbiAgICAgICAgICAgIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9CaXR3aXNlX09wZXJhdG9yc1xuICAgICAgICAgICAgYW5kIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvZmlsZXMvRUNNQS1TVC9FQ01BLTI2Mi5wZGYgc2VjdGlvbiA4LjVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGZvciBhIHppcDY0IEVPQ0QgbG9jYXRvclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKTtcbiAgICAgICAgICAgIHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yKCk7XG5cbiAgICAgICAgICAgIC8vIG5vdyB0aGUgemlwNjQgRU9DRCByZWNvcmRcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1NpZ25hdHVyZSh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIsIHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IG5vdCB3aGVyZSBleHBlY3RlZC5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpcik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5jZW50cmFsRGlyT2Zmc2V0ICsgdGhpcy5jZW50cmFsRGlyU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuemlwNjQpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ICs9IDIwOyAvLyBlbmQgb2YgY2VudHJhbCBkaXIgNjQgbG9jYXRvclxuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMTIgLyogc2hvdWxkIG5vdCBpbmNsdWRlIHRoZSBsZWFkaW5nIDEyIGJ5dGVzICovICsgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGVuZE9mQ2VudHJhbERpck9mZnNldCAtIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0O1xuXG4gICAgICAgIGlmIChleHRyYUJ5dGVzID4gMCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGV4dHJhQnl0ZXMsIFwiZXh0cmEgYnl0ZXMgYXQgYmVnaW5uaW5nIG9yIHdpdGhpbiB6aXBmaWxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTaWduYXR1cmUoZW5kT2ZDZW50cmFsRGlyT2Zmc2V0LCBzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb2Zmc2V0cyBzZWVtIHdyb25nLCBidXQgd2UgaGF2ZSBzb21ldGhpbmcgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gICAgICAgICAgICAgICAgLy8gU2/igKYgd2Uga2VlcCBpdC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9mZnNldCBpcyB3cm9uZywgdXBkYXRlIHRoZSBcInplcm9cIiBvZiB0aGUgcmVhZGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGlmIGRhdGEgaGFzIGJlZW4gcHJlcGVuZGVkIChjcnggZmlsZXMgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIuemVybyA9IGV4dHJhQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IG1pc3NpbmcgXCIgKyBNYXRoLmFicyhleHRyYUJ5dGVzKSArIFwiIGJ5dGVzLlwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlYWRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlckZvcihkYXRhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgYSB6aXAgZmlsZSBhbmQgY3JlYXRlIFppcEVudHJpZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGJpbmFyeSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgemlwIGZpbGUuXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnByZXBhcmVSZWFkZXIoZGF0YSk7XG4gICAgICAgIHRoaXMucmVhZEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB0aGlzLnJlYWRDZW50cmFsRGlyKCk7XG4gICAgICAgIHRoaXMucmVhZExvY2FsRmlsZXMoKTtcbiAgICB9XG59O1xuLy8gfX19IGVuZCBvZiBaaXBFbnRyaWVzXG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJpZXM7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZSgnLi9yZWFkZXIvcmVhZGVyRm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIGNyYzMyZm4gPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4vY29tcHJlc3Npb25zJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuXG52YXIgTUFERV9CWV9ET1MgPSAweDAwO1xudmFyIE1BREVfQllfVU5JWCA9IDB4MDM7XG5cbi8qKlxuICogRmluZCBhIGNvbXByZXNzaW9uIHJlZ2lzdGVyZWQgaW4gSlNaaXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcHJlc3Npb25NZXRob2QgdGhlIG1ldGhvZCBtYWdpYyB0byBmaW5kLlxuICogQHJldHVybiB7T2JqZWN0fG51bGx9IHRoZSBKU1ppcCBjb21wcmVzc2lvbiBvYmplY3QsIG51bGwgaWYgbm9uZSBmb3VuZC5cbiAqL1xudmFyIGZpbmRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgZm9yICh2YXIgbWV0aG9kIGluIGNvbXByZXNzaW9ucykge1xuICAgICAgICBpZiAoIWNvbXByZXNzaW9ucy5oYXNPd25Qcm9wZXJ0eShtZXRob2QpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Npb25zW21ldGhvZF0ubWFnaWMgPT09IGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3Npb25zW21ldGhvZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBjbGFzcyBaaXBFbnRyeSB7e3tcbi8qKlxuICogQW4gZW50cnkgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9mIHRoZSBjdXJyZW50IGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyeShvcHRpb25zLCBsb2FkT3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cnkucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VuY3J5cHRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDAwMSkgPT09IDB4MDAwMTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBoYXMgdXRmLTggZmlsZW5hbWUvY29tbWVudC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlbmFtZS9jb21tZW50IGlzIGluIHV0Zi04LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdXNlVVRGODogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxMSBpcyBzZXRcbiAgICAgICAgcmV0dXJuICh0aGlzLmJpdEZsYWcgJiAweDA4MDApID09PSAweDA4MDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uLCBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoO1xuXG4gICAgICAgIC8vIHdlIGFscmVhZHkga25vdyBldmVyeXRoaW5nIGZyb20gdGhlIGNlbnRyYWwgZGlyICFcbiAgICAgICAgLy8gSWYgdGhlIGNlbnRyYWwgZGlyIGRhdGEgYXJlIGZhbHNlLCB3ZSBhcmUgZG9vbWVkLlxuICAgICAgICAvLyBPbiB0aGUgYnJpZ2h0IHNpZGUsIHRoZSBsb2NhbCBwYXJ0IGlzIHNjYXJ5ICA6IHppcDY0LCBkYXRhIGRlc2NyaXB0b3JzLCBib3RoLCBldGMuXG4gICAgICAgIC8vIFRoZSBsZXNzIGRhdGEgd2UgZ2V0IGhlcmUsIHRoZSBtb3JlIHJlbGlhYmxlIHRoaXMgc2hvdWxkIGJlLlxuICAgICAgICAvLyBMZXQncyBza2lwIHRoZSB3aG9sZSBoZWFkZXIgYW5kIGRhc2ggdG8gdGhlIGRhdGEgIVxuICAgICAgICByZWFkZXIuc2tpcCgyMik7XG4gICAgICAgIC8vIGluIHNvbWUgemlwIGNyZWF0ZWQgb24gd2luZG93cywgdGhlIGZpbGVuYW1lIHN0b3JlZCBpbiB0aGUgY2VudHJhbCBkaXIgY29udGFpbnMgXFwgaW5zdGVhZCBvZiAvLlxuICAgICAgICAvLyBTdHJhbmdlbHksIHRoZSBmaWxlbmFtZSBoZXJlIGlzIE9LLlxuICAgICAgICAvLyBJIHdvdWxkIGxvdmUgdG8gdHJlYXQgdGhlc2UgemlwIGZpbGVzIGFzIGNvcnJ1cHRlZCAoc2VlIGh0dHA6Ly93d3cuaW5mby16aXAub3JnL0ZBUS5odG1sI2JhY2tzbGFzaGVzXG4gICAgICAgIC8vIG9yIEFQUE5PVEUjNC40LjE3LjEsIFwiQWxsIHNsYXNoZXMgTVVTVCBiZSBmb3J3YXJkIHNsYXNoZXMgJy8nXCIpIGJ1dCB0aGVyZSBhcmUgYSBsb3Qgb2YgYmFkIHppcCBnZW5lcmF0b3JzLi4uXG4gICAgICAgIC8vIFNlYXJjaCBcInVuemlwIG1pc21hdGNoaW5nIFwibG9jYWxcIiBmaWxlbmFtZSBjb250aW51aW5nIHdpdGggXCJjZW50cmFsXCIgZmlsZW5hbWUgdmVyc2lvblwiIG9uXG4gICAgICAgIC8vIHRoZSBpbnRlcm5ldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSSB0aGluayBJIHNlZSB0aGUgbG9naWMgaGVyZSA6IHRoZSBjZW50cmFsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGRpc3BsYXlcbiAgICAgICAgLy8gY29udGVudCBhbmQgdGhlIGxvY2FsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGV4dHJhY3QgdGhlIGZpbGVzLiBNaXhpbmcgLyBhbmQgXFxcbiAgICAgICAgLy8gbWF5IGJlIHVzZWQgdG8gZGlzcGxheSBcXCB0byB3aW5kb3dzIHVzZXJzIGFuZCB1c2UgLyB3aGVuIGV4dHJhY3RpbmcgdGhlIGZpbGVzLlxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGlzIGxlYWQgYWxzbyB0byBzb21lIGlzc3VlcyA6IGh0dHA6Ly9zZWNsaXN0cy5vcmcvZnVsbGRpc2Nsb3N1cmUvMjAwOS9TZXAvMzk0XG4gICAgICAgIHRoaXMuZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgbG9jYWxFeHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpOyAvLyBjYW4ndCBiZSBzdXJlIHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgY2VudHJhbCBkaXJcbiAgICAgICAgLy8gdGhlIGZpbGVOYW1lIGlzIHN0b3JlZCBhcyBiaW5hcnkgZGF0YSwgdGhlIGhhbmRsZVVURjggbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoZSBlbmNvZGluZy5cbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgcmVhZGVyLnNraXAobG9jYWxFeHRyYUZpZWxkc0xlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyBvciBjb3JydXB0ZWQgemlwIDogZGlkbid0IGdldCBlbm91Z2ggaW5mb3JtYXRpb25zIGZyb20gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IFwiICsgXCIoY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHVuY29tcHJlc3NlZFNpemUgPT09IC0xKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXByZXNzaW9uID0gZmluZENvbXByZXNzaW9uKHRoaXMuY29tcHJlc3Npb25NZXRob2QpO1xuICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IG51bGwpIHsgLy8gbm8gY29tcHJlc3Npb24gZm91bmRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBjb21wcmVzc2lvbiBcIiArIHV0aWxzLnByZXR0eSh0aGlzLmNvbXByZXNzaW9uTWV0aG9kKSArIFwiIHVua25vd24gKGlubmVyIGZpbGUgOiBcIiArIHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHRoaXMuZmlsZU5hbWUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb21wcmVzc2VkID0gbmV3IENvbXByZXNzZWRPYmplY3QodGhpcy5jb21wcmVzc2VkU2l6ZSwgdGhpcy51bmNvbXByZXNzZWRTaXplLCB0aGlzLmNyYzMyLCBjb21wcmVzc2lvbiwgcmVhZGVyLnJlYWREYXRhKHRoaXMuY29tcHJlc3NlZFNpemUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB0aGlzLnZlcnNpb25NYWRlQnkgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgcmVhZGVyLnNraXAoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmJpdEZsYWcgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbk1ldGhvZCA9IHJlYWRlci5yZWFkU3RyaW5nKDIpO1xuICAgICAgICB0aGlzLmRhdGUgPSByZWFkZXIucmVhZERhdGUoKTtcbiAgICAgICAgdGhpcy5jcmMzMiA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB2YXIgZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5leHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmZpbGVDb21tZW50TGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlclN0YXJ0ID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IHJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRW5jcnlwdGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRlZCB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aWxsIGJlIHJlYWQgaW4gdGhlIGxvY2FsIHBhcnQsIHNlZSB0aGUgY29tbWVudHMgdGhlcmVcbiAgICAgICAgcmVhZGVyLnNraXAoZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICB0aGlzLnJlYWRFeHRyYUZpZWxkcyhyZWFkZXIpO1xuICAgICAgICB0aGlzLnBhcnNlWklQNjRFeHRyYUZpZWxkKHJlYWRlcik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnQgPSByZWFkZXIucmVhZERhdGEodGhpcy5maWxlQ29tbWVudExlbmd0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMgYW5kIGdldCB0aGUgdW5peC9kb3MgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgcHJvY2Vzc0F0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiAgICAgICAgdmFyIG1hZGVCeSA9IHRoaXMudmVyc2lvbk1hZGVCeSA+PiA4O1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhlIERPUyBkaXJlY3RvcnkgZmxhZyBzZXQuXG4gICAgICAgIC8vIFdlIGxvb2sgZm9yIGl0IGluIHRoZSBET1MgYW5kIFVOSVggcGVybWlzc2lvbnNcbiAgICAgICAgLy8gYnV0IHNvbWUgdW5rbm93biBwbGF0Zm9ybSBjb3VsZCBzZXQgaXQgYXMgYSBjb21wYXRpYmlsaXR5IGZsYWcuXG4gICAgICAgIHRoaXMuZGlyID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgwMDEwID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9ET1MpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IDYgYml0cyAoMCB0byA1KVxuICAgICAgICAgICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyAmIDB4M0Y7XG4gICAgICAgIH1cblxuICAgICAgICBpZihtYWRlQnkgPT09IE1BREVfQllfVU5JWCkge1xuICAgICAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSAodGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID4+IDE2KSAmIDB4RkZGRjtcbiAgICAgICAgICAgIC8vIHRoZSBvY3RhbCBwZXJtaXNzaW9ucyBhcmUgaW4gKHRoaXMudW5peFBlcm1pc3Npb25zICYgMHgwMUZGKS50b1N0cmluZyg4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhaWwgc2FmZSA6IGlmIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC8gaXQgcHJvYmFibHkgbWVhbnMgYSBmb2xkZXJcbiAgICAgICAgaWYgKCF0aGlzLmRpciAmJiB0aGlzLmZpbGVOYW1lU3RyLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICB0aGlzLmRpciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIFpJUDY0IGV4dHJhIGZpZWxkIGFuZCBtZXJnZSB0aGUgaW5mbyBpbiB0aGUgY3VycmVudCBaaXBFbnRyeS5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICBwYXJzZVpJUDY0RXh0cmFGaWVsZDogZnVuY3Rpb24ocmVhZGVyKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3VsZCBiZSBzb21ldGhpbmcsIHByZXBhcmluZyB0aGUgZXh0cmEgcmVhZGVyXG4gICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0udmFsdWUpO1xuXG4gICAgICAgIC8vIEkgcmVhbGx5IGhvcGUgdGhhdCB0aGVzZSA2NGJpdHMgaW50ZWdlciBjYW4gZml0IGluIDMyIGJpdHMgaW50ZWdlciwgYmVjYXVzZSBqc1xuICAgICAgICAvLyB3b24ndCBsZXQgdXMgaGF2ZSBtb3JlLlxuICAgICAgICBpZiAodGhpcy51bmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NhbEhlYWRlck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZEV4dHJhRmllbGRzOiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IHJlYWRlci5pbmRleCArIHRoaXMuZXh0cmFGaWVsZHNMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYUZpZWxkcykge1xuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHJlYWRlci5pbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSByZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHNbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSBhbiBVVEY4IHRyYW5zZm9ybWF0aW9uIGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBoYW5kbGVVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlY29kZVBhcmFtVHlwZSA9IHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICBpZiAodGhpcy51c2VVVEY4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdXRmOC51dGY4ZGVjb2RlKHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVwYXRoID0gdGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoKCk7XG4gICAgICAgICAgICBpZiAodXBhdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdXBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFTQ0lJIHRleHQgb3IgdW5zdXBwb3J0ZWQgY29kZSBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lQnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZmlsZU5hbWVCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdWNvbW1lbnQgPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh1Y29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1Y29tbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudEJ5dGVBcnJheSA9ICB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGNvbW1lbnRCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgcGF0aCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIHBhdGgsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBhdGhGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg3MDc1XTtcbiAgICAgICAgaWYgKHVwYXRoRmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1cGF0aEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgZmlsZW5hbWUgY2hhbmdlZCwgdGhpcyBmaWVsZCBpcyBvdXQgb2YgZGF0ZS5cbiAgICAgICAgICAgIGlmIChjcmMzMmZuKHRoaXMuZmlsZU5hbWUpICE9PSBleHRyYVJlYWRlci5yZWFkSW50KDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dGY4LnV0ZjhkZWNvZGUoZXh0cmFSZWFkZXIucmVhZERhdGEodXBhdGhGaWVsZC5sZW5ndGggLSA1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgY29tbWVudCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIGNvbW1lbnQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWNvbW1lbnRGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg2Mzc1XTtcbiAgICAgICAgaWYgKHVjb21tZW50RmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1Y29tbWVudEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgY29tbWVudCBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlQ29tbWVudCkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1Y29tbWVudEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBaaXBFbnRyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbUhlbHBlciA9IHJlcXVpcmUoJy4vc3RyZWFtL1N0cmVhbUhlbHBlcicpO1xudmFyIERhdGFXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKCcuL2NvbXByZXNzZWRPYmplY3QnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgc2ltcGxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBmaWxlIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICovXG52YXIgWmlwT2JqZWN0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kaXIgPSBvcHRpb25zLmRpcjtcbiAgICB0aGlzLmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0aW9ucy5jb21tZW50O1xuICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gb3B0aW9ucy51bml4UGVybWlzc2lvbnM7XG4gICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG9wdGlvbnMuZG9zUGVybWlzc2lvbnM7XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9kYXRhQmluYXJ5ID0gb3B0aW9ucy5iaW5hcnk7XG4gICAgLy8ga2VlcCBvbmx5IHRoZSBjb21wcmVzc2lvblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgY29tcHJlc3Npb24gOiBvcHRpb25zLmNvbXByZXNzaW9uLFxuICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9uc1xuICAgIH07XG59O1xuXG5aaXBPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnRlcm5hbCBzdHJlYW0gZm9yIHRoZSBjb250ZW50IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHJldHVybiBTdHJlYW1IZWxwZXIgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgYXNrVW5pY29kZVN0cmluZyA9IG91dHB1dFR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3V0cHV0VHlwZSA9PT0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBpZiAob3V0cHV0VHlwZSA9PT0gXCJiaW5hcnlzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb21wcmVzc1dvcmtlcigpO1xuXG4gICAgICAgICAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gIXRoaXMuX2RhdGFCaW5hcnk7XG5cbiAgICAgICAgICAgIGlmIChpc1VuaWNvZGVTdHJpbmcgJiYgIWFza1VuaWNvZGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShuZXcgdXRmOC5VdGY4RW5jb2RlV29ya2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1VuaWNvZGVTdHJpbmcgJiYgYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhEZWNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IoZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcihyZXN1bHQsIG91dHB1dFR5cGUsIFwiXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBjb250ZW50IGluIHRoZSBhc2tlZCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBvZiB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSkuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgYXMgYSBub2RlanMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gU3RyZWFtIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgbm9kZVN0cmVhbTogZnVuY3Rpb24gKHR5cGUsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKHR5cGUgfHwgXCJub2RlYnVmZmVyXCIpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY29tcHJlc3NpbmcuXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfY29tcHJlc3NXb3JrZXI6IGZ1bmN0aW9uIChjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0ICYmXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvbXByZXNzaW9uLm1hZ2ljID09PSBjb21wcmVzc2lvbi5tYWdpY1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbXByZXNzZWRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG4gICAgICAgICAgICBpZighdGhpcy5fZGF0YUJpbmFyeSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ29tcHJlc3NlZE9iamVjdC5jcmVhdGVXb3JrZXJGcm9tKHJlc3VsdCwgY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHdvcmtlciBmb3IgdGhlIGRlY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfZGVjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRDb250ZW50V29ya2VyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIEdlbmVyaWNXb3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHJlbW92ZWRNZXRob2RzID0gW1wiYXNUZXh0XCIsIFwiYXNCaW5hcnlcIiwgXCJhc05vZGVCdWZmZXJcIiwgXCJhc1VpbnQ4QXJyYXlcIiwgXCJhc0FycmF5QnVmZmVyXCJdO1xudmFyIHJlbW92ZWRGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbn07XG5cbmZvcih2YXIgaSA9IDA7IGkgPCByZW1vdmVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIFppcE9iamVjdC5wcm90b3R5cGVbcmVtb3ZlZE1ldGhvZHNbaV1dID0gcmVtb3ZlZEZuO1xufVxubW9kdWxlLmV4cG9ydHMgPSBaaXBPYmplY3Q7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLnNldEltbWVkaWF0ZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuMy4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xyXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcclxufSk7IiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTsiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBpbW1lZGlhdGUgPSByZXF1aXJlKCdpbW1lZGlhdGUnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIElOVEVSTkFMKCkge31cblxudmFyIGhhbmRsZXJzID0ge307XG5cbnZhciBSRUpFQ1RFRCA9IFsnUkVKRUNURUQnXTtcbnZhciBGVUxGSUxMRUQgPSBbJ0ZVTEZJTExFRCddO1xudmFyIFBFTkRJTkcgPSBbJ1BFTkRJTkcnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm91dGNvbWUgPSB2b2lkIDA7XG4gIGlmIChyZXNvbHZlciAhPT0gSU5URVJOQUwpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUodGhpcywgcmVzb2x2ZXIpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBGVUxGSUxMRUQgfHxcbiAgICB0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoSU5URVJOQUwpO1xuICBpZiAodGhpcy5zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHZhciByZXNvbHZlciA9IHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCA/IG9uRnVsZmlsbGVkIDogb25SZWplY3RlZDtcbiAgICB1bndyYXAocHJvbWlzZSwgcmVzb2x2ZXIsIHRoaXMub3V0Y29tZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKG5ldyBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcbmZ1bmN0aW9uIFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IG9uRnVsZmlsbGVkO1xuICAgIHRoaXMuY2FsbEZ1bGZpbGxlZCA9IHRoaXMub3RoZXJDYWxsRnVsZmlsbGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25SZWplY3RlZCA9IG9uUmVqZWN0ZWQ7XG4gICAgdGhpcy5jYWxsUmVqZWN0ZWQgPSB0aGlzLm90aGVyQ2FsbFJlamVjdGVkO1xuICB9XG59XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaGFuZGxlcnMucmVzb2x2ZSh0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLm90aGVyQ2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uRnVsZmlsbGVkLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5jYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaGFuZGxlcnMucmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdW53cmFwKHRoaXMucHJvbWlzZSwgdGhpcy5vblJlamVjdGVkLCB2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiB1bndyYXAocHJvbWlzZSwgZnVuYywgdmFsdWUpIHtcbiAgaW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVyblZhbHVlID0gZnVuYyh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlKTtcbiAgICB9XG4gICAgaWYgKHJldHVyblZhbHVlID09PSBwcm9taXNlKSB7XG4gICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgbmV3IFR5cGVFcnJvcignQ2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXR1cm5WYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuaGFuZGxlcnMucmVzb2x2ZSA9IGZ1bmN0aW9uIChzZWxmLCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goZ2V0VGhlbiwgdmFsdWUpO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIHJldHVybiBoYW5kbGVycy5yZWplY3Qoc2VsZiwgcmVzdWx0LnZhbHVlKTtcbiAgfVxuICB2YXIgdGhlbmFibGUgPSByZXN1bHQudmFsdWU7XG5cbiAgaWYgKHRoZW5hYmxlKSB7XG4gICAgc2FmZWx5UmVzb2x2ZVRoZW5hYmxlKHNlbGYsIHRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnN0YXRlID0gRlVMRklMTEVEO1xuICAgIHNlbGYub3V0Y29tZSA9IHZhbHVlO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IHNlbGYucXVldWUubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgIHNlbGYucXVldWVbaV0uY2FsbEZ1bGZpbGxlZCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufTtcbmhhbmRsZXJzLnJlamVjdCA9IGZ1bmN0aW9uIChzZWxmLCBlcnJvcikge1xuICBzZWxmLnN0YXRlID0gUkVKRUNURUQ7XG4gIHNlbGYub3V0Y29tZSA9IGVycm9yO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBzZWxmLnF1ZXVlW2ldLmNhbGxSZWplY3RlZChlcnJvcik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAvLyBNYWtlIHN1cmUgd2Ugb25seSBhY2Nlc3MgdGhlIGFjY2Vzc29yIG9uY2UgYXMgcmVxdWlyZWQgYnkgdGhlIHNwZWNcbiAgdmFyIHRoZW4gPSBvYmogJiYgb2JqLnRoZW47XG4gIGlmIChvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFwcHlUaGVuKCkge1xuICAgICAgdGhlbi5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpIHtcbiAgLy8gRWl0aGVyIGZ1bGZpbGwsIHJlamVjdCBvciByZWplY3Qgd2l0aCBlcnJvclxuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uRXJyb3IodmFsdWUpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgaGFuZGxlcnMucmVqZWN0KHNlbGYsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3VjY2Vzcyh2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvVW53cmFwKCkge1xuICAgIHRoZW5hYmxlKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godHJ5VG9VbndyYXApO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIG9uRXJyb3IocmVzdWx0LnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlDYXRjaChmdW5jLCB2YWx1ZSkge1xuICB2YXIgb3V0ID0ge307XG4gIHRyeSB7XG4gICAgb3V0LnZhbHVlID0gZnVuYyh2YWx1ZSk7XG4gICAgb3V0LnN0YXR1cyA9ICdzdWNjZXNzJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIG91dC5zdGF0dXMgPSAnZXJyb3InO1xuICAgIG91dC52YWx1ZSA9IGU7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuUHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcnMucmVzb2x2ZShuZXcgdGhpcyhJTlRFUk5BTCksIHZhbHVlKTtcbn1cblxuUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG59XG5cblByb21pc2UuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgdmFyIHJlc29sdmVkID0gMDtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGFsbFJlc29sdmVyKGl0ZXJhYmxlW2ldLCBpKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbiAgZnVuY3Rpb24gYWxsUmVzb2x2ZXIodmFsdWUsIGkpIHtcbiAgICBzZWxmLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZUZyb21BbGwsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiByZXNvbHZlRnJvbUFsbChvdXRWYWx1ZSkge1xuICAgICAgdmFsdWVzW2ldID0gb3V0VmFsdWU7XG4gICAgICBpZiAoKytyZXNvbHZlZCA9PT0gbGVuICYmICFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5Qcm9taXNlLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcmFibGUpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcmVzb2x2ZXIoaXRlcmFibGVbaV0pO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiByZXNvbHZlcih2YWx1ZSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiLy8gVG9wIGxldmVsIGZpbGUgaXMganVzdCBhIG1peGluIG9mIHN1Ym1vZHVsZXMgJiBjb25zdGFudHNcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICA9IHJlcXVpcmUoJy4vbGliL3V0aWxzL2NvbW1vbicpLmFzc2lnbjtcblxudmFyIGRlZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2RlZmxhdGUnKTtcbnZhciBpbmZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9pbmZsYXRlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9saWIvemxpYi9jb25zdGFudHMnKTtcblxudmFyIHBha28gPSB7fTtcblxuYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFrbztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgnLi96bGliL2RlZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xuXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG5cbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pICBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkgcmV0dXJuIG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cblxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICB2YXIgZGljdDtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tEZWZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogYXJyYXkgZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9tb2RlKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IFpfRklOSVNIIHx8IF9tb2RlID09PSBaX1NZTkNfRkxVU0gpKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IFpfU1RSRUFNX0VORCk7XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBaX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBaX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKFpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgZGF0YSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xuZXhwb3J0cy5nemlwID0gZ3ppcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIGMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xudmFyIEdaaGVhZGVyICAgICA9IHJlcXVpcmUoJy4vemxpYi9nemhlYWRlcicpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAwLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpO1xuXG4gIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tJbmZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgZGVjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjtcbiAgdmFyIGRpY3Q7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgICAgaWYgKHR5cGVvZiBkaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShkaWN0aW9uYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3QgPSBkaWN0aW9uYXJ5O1xuICAgICAgfVxuXG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkge1xuICAgICAgc3RhdHVzID0gYy5aX09LO1xuICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSB7IHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7IH1cblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGVuIG5vIG1vcmUgaW5wdXQgZGF0YSwgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaW50ZXJuYWwgaW5mbGF0ZSBidWZmZXJzXG4gICAgLy8gYXJlIGZsdXNoZWQuIFRoZSBvbmx5IHdheSB0byBkbyBpdCB3aGVuIGF2YWlsX291dCA9IDAgLSBydW4gb25lIG1vcmVcbiAgICAvLyBpbmZsYXRlIHBhc3MuIEJ1dCBpZiBvdXRwdXQgZGF0YSBub3QgZXhpc3RzLCBpbmZsYXRlIHJldHVybiBaX0JVRl9FUlJPUi5cbiAgICAvLyBIZXJlIHdlIHNldCBmbGFnIHRvIHByb2Nlc3MgdGhpcyBlcnJvciBwcm9wZXJseS5cbiAgICAvL1xuICAgIC8vIE5PVEUuIERlZmxhdGUgZG9lcyBub3QgcmV0dXJuIGVycm9yIGluIHRoaXMgY2FzZSBhbmQgZG9lcyBub3QgbmVlZHMgc3VjaFxuICAgIC8vIGxvZ2ljLlxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTtcblxuICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkge1xuICAgIF9tb2RlID0gYy5aX0ZJTklTSDtcbiAgfVxuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChjLlpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gR2x1ZSAmIGNvbnZlcnQgaGVyZSwgdW50aWwgd2UgdGVhY2ggcGFrbyB0byBzZW5kXG4gICAgICAvLyB1dGY4IGFsaWduZWQgc3RyaW5ncyB0byBvbkRhdGFcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBpbnB1dCA9IHBha28uZGVmbGF0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xuZXhwb3J0cy51bmd6aXAgID0gaW5mbGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyB1c2UgZmFsbGJhY2sgZm9yIGJpZyBhcnJheXMgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3dcbiAgaWYgKGxlbiA8IDY1NTM3KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgcztcbiAgdmFyIHN0ciwgbjtcbiAgdmFyIHdyYXA7XG4gIHZhciBhdmFpbDtcbiAgdmFyIG5leHQ7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHRtcERpY3Q7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcbiAgd3JhcCA9IHMud3JhcDtcblxuICBpZiAod3JhcCA9PT0gMiB8fCAod3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSkgfHwgcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiB3aGVuIHVzaW5nIHpsaWIgd3JhcHBlcnMsIGNvbXB1dGUgQWRsZXItMzIgZm9yIHByb3ZpZGVkIGRpY3Rpb25hcnkgKi9cbiAgaWYgKHdyYXAgPT09IDEpIHtcbiAgICAvKiBhZGxlcjMyKHN0cm0tPmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIHRtcERpY3QgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSk7XG4gICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgc3RyID0gcy5zdHJzdGFydDtcbiAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7XG4gICAgZG8ge1xuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5kZWZsYXRlSW5pdCA9IGRlZmxhdGVJbml0O1xuZXhwb3J0cy5kZWZsYXRlSW5pdDIgPSBkZWZsYXRlSW5pdDI7XG5leHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0S2VlcCA9IGRlZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmRlZmxhdGVTZXRIZWFkZXIgPSBkZWZsYXRlU2V0SGVhZGVyO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZUVuZCA9IGRlZmxhdGVFbmQ7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVJbmZvID0gJ3Bha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xuZXhwb3J0cy5kZWZsYXRlQ29weSA9IGRlZmxhdGVDb3B5O1xuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbmV4cG9ydHMuZGVmbGF0ZVByaW1lID0gZGVmbGF0ZVByaW1lO1xuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHWmhlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiIsImxldCBnZW5DdWJlID0gKCBfcHJvcHMgKSA9PiB7XG4gIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHtcbiAgICBzaXplOiAxLjBcbiAgfSwgX3Byb3BzICk7XG5cbiAgbGV0IHBvcyA9IFtdO1xuICBsZXQgbm9yID0gW107XG4gIGxldCBpbmQgPSBbXTtcblxuICBjb25zdCBTID0gcHJvcHMuc2l6ZTtcblxuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuICAgIGxldCBwID0gW1xuICAgICAgWyAtUywgLVMsICBTIF0sXG4gICAgICBbICBTLCAtUywgIFMgXSxcbiAgICAgIFsgLVMsICBTLCAgUyBdLFxuICAgICAgWyAgUywgIFMsICBTIF1cbiAgICBdO1xuICAgIGxldCBuID0gW1xuICAgICAgWyAwLCAwLCAxIF0sXG4gICAgICBbIDAsIDAsIDEgXSxcbiAgICAgIFsgMCwgMCwgMSBdLFxuICAgICAgWyAwLCAwLCAxIF1cbiAgICBdO1xuICAgIGxldCBpZCA9IFtcbiAgICAgIDAsIDEsIDMsXG4gICAgICAwLCAzLCAyXG4gICAgXS5tYXAoICggdiApID0+IHYgKyBpICogNCApO1xuXG4gICAgaWYgKCBpICE9PSAwICkge1xuICAgICAgbGV0IGZ1bmMgPSAoIHYgKSA9PiB7XG4gICAgICAgIGlmICggaSA8IDQgKSB7XG4gICAgICAgICAgbGV0IHQgPSBpICogTWF0aC5QSSAvIDIuMDtcbiAgICAgICAgICBsZXQgeCA9IHZbIDAgXTtcbiAgICAgICAgICBsZXQgeiA9IHZbIDIgXTtcbiAgICAgICAgICB2WyAwIF0gPSBNYXRoLmNvcyggdCApICogeCAtIE1hdGguc2luKCB0ICkgKiB6O1xuICAgICAgICAgIHZbIDIgXSA9IE1hdGguc2luKCB0ICkgKiB4ICsgTWF0aC5jb3MoIHQgKSAqIHo7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHQgPSAoIGkgLSAwLjUgKSAqIE1hdGguUEk7XG4gICAgICAgICAgbGV0IHkgPSB2WyAxIF07XG4gICAgICAgICAgbGV0IHogPSB2WyAyIF07XG4gICAgICAgICAgdlsgMSBdID0gTWF0aC5jb3MoIHQgKSAqIHkgLSBNYXRoLnNpbiggdCApICogejtcbiAgICAgICAgICB2WyAyIF0gPSBNYXRoLnNpbiggdCApICogeSArIE1hdGguY29zKCB0ICkgKiB6O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwLm1hcCggZnVuYyApO1xuICAgICAgbi5tYXAoIGZ1bmMgKTtcbiAgICB9XG5cbiAgICBwLm1hcCggKCB2ICkgPT4gcG9zLnB1c2goIC4uLnYgKSApO1xuICAgIG4ubWFwKCAoIHYgKSA9PiBub3IucHVzaCggLi4udiApICk7XG4gICAgaW5kLnB1c2goIC4uLmlkICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgbm9ybWFsOiBub3IsXG4gICAgaW5kZXg6IGluZFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5DdWJlOyIsImxldCBnZW5PY3RhaGVkcm9uID0gKCBfcHJvcHMgKSA9PiB7XG4gIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oIHtcbiAgICBkaXY6IDEuMFxuICB9LCBfcHJvcHMgKTtcblxuICBsZXQgZGl2ID0gcGFyc2VJbnQoIE1hdGgubWF4KCAwLCBwcm9wcy5kaXYgKSApO1xuXG4gIGxldCBwb3MgPSBbXTtcbiAgbGV0IG5vciA9IFtdO1xuICBsZXQgaW5kID0gW107XG5cbiAgZm9yICggbGV0IGlpID0gMDsgaWkgPCAyOyBpaSArKyApIHtcbiAgICBmb3IgKCBsZXQgaXEgPSAwOyBpcSA8IDQ7IGlxICsrICkge1xuICAgICAgZm9yICggbGV0IGl5ID0gMDsgaXkgPCBkaXYgKyAxOyBpeSArKyApIHtcbiAgICAgICAgZm9yICggbGV0IGl4ID0gMDsgaXggPCBpeSArIDE7IGl4ICsrICkge1xuICAgICAgICAgIGxldCBsYXQwID0gKCBpaSAqIDIuMCArIGl5IC8gKCBkaXYgKyAxICkgKSAqIE1hdGguUEkgLyAyLjA7XG4gICAgICAgICAgbGV0IGxhdDEgPSAoIGlpICogMi4wICsgKCBpeSArIDEgKSAvICggZGl2ICsgMSApICkgKiBNYXRoLlBJIC8gMi4wO1xuXG4gICAgICAgICAgbGV0IGxvbjAgPSAoIGlpICogMi4wIC0gMS4wICkgKiAoICggaXggLSAxICkgLyBNYXRoLm1heCggMSwgaXkgKSArIGlxICkgKiBNYXRoLlBJIC8gMi4wO1xuICAgICAgICAgIGxldCBsb24xID0gKCBpaSAqIDIuMCAtIDEuMCApICogKCBpeCAvICggaXkgKyAxICkgKyBpcSApICogTWF0aC5QSSAvIDIuMDtcbiAgICAgICAgICBsZXQgbG9uMiA9ICggaWkgKiAyLjAgLSAxLjAgKSAqICggaXggLyBNYXRoLm1heCggMSwgaXkgKSArIGlxICkgKiBNYXRoLlBJIC8gMi4wO1xuICAgICAgICAgIGxldCBsb24zID0gKCBpaSAqIDIuMCAtIDEuMCApICogKCAoIGl4ICsgMSApIC8gKCBpeSArIDEgKSArIGlxICkgKiBNYXRoLlBJIC8gMi4wO1xuXG4gICAgICAgICAgaWYgKCBpeCAhPT0gMCApIHtcbiAgICAgICAgICAgIGluZC5wdXNoKFxuICAgICAgICAgICAgICBwb3MubGVuZ3RoIC8gMyxcbiAgICAgICAgICAgICAgcG9zLmxlbmd0aCAvIDMgKyAxLFxuICAgICAgICAgICAgICBwb3MubGVuZ3RoIC8gMyArIDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCB4MSA9IE1hdGguc2luKCBsYXQwICkgKiBNYXRoLmNvcyggbG9uMCApO1xuICAgICAgICAgICAgbGV0IHkxID0gTWF0aC5jb3MoIGxhdDAgKTtcbiAgICAgICAgICAgIGxldCB6MSA9IE1hdGguc2luKCBsYXQwICkgKiBNYXRoLnNpbiggbG9uMCApO1xuXG4gICAgICAgICAgICBsZXQgeDIgPSBNYXRoLnNpbiggbGF0MSApICogTWF0aC5jb3MoIGxvbjEgKTtcbiAgICAgICAgICAgIGxldCB5MiA9IE1hdGguY29zKCBsYXQxICk7XG4gICAgICAgICAgICBsZXQgejIgPSBNYXRoLnNpbiggbGF0MSApICogTWF0aC5zaW4oIGxvbjEgKTtcblxuICAgICAgICAgICAgbGV0IHgzID0gTWF0aC5zaW4oIGxhdDAgKSAqIE1hdGguY29zKCBsb24yICk7XG4gICAgICAgICAgICBsZXQgeTMgPSBNYXRoLmNvcyggbGF0MCApO1xuICAgICAgICAgICAgbGV0IHozID0gTWF0aC5zaW4oIGxhdDAgKSAqIE1hdGguc2luKCBsb24yICk7XG5cbiAgICAgICAgICAgIHBvcy5wdXNoKFxuICAgICAgICAgICAgICB4MSwgeTEsIHoxLFxuICAgICAgICAgICAgICB4MiwgeTIsIHoyLFxuICAgICAgICAgICAgICB4MywgeTMsIHozXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCB4ID0geDEgKyB4MiArIHgzO1xuICAgICAgICAgICAgICBsZXQgeSA9IHkxICsgeTIgKyB5MztcbiAgICAgICAgICAgICAgbGV0IHogPSB6MSArIHoyICsgejM7XG4gICAgICAgICAgICAgIGxldCBsID0gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcblxuICAgICAgICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuICAgICAgICAgICAgICAgIG5vci5wdXNoKFxuICAgICAgICAgICAgICAgICAgeCAvIGwsXG4gICAgICAgICAgICAgICAgICB5IC8gbCxcbiAgICAgICAgICAgICAgICAgIHogLyBsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGluZC5wdXNoKFxuICAgICAgICAgICAgICBwb3MubGVuZ3RoIC8gMyxcbiAgICAgICAgICAgICAgcG9zLmxlbmd0aCAvIDMgKyAxLFxuICAgICAgICAgICAgICBwb3MubGVuZ3RoIC8gMyArIDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCB4MSA9IE1hdGguc2luKCBsYXQwICkgKiBNYXRoLmNvcyggbG9uMiApO1xuICAgICAgICAgICAgbGV0IHkxID0gTWF0aC5jb3MoIGxhdDAgKTtcbiAgICAgICAgICAgIGxldCB6MSA9IE1hdGguc2luKCBsYXQwICkgKiBNYXRoLnNpbiggbG9uMiApO1xuXG4gICAgICAgICAgICBsZXQgeDIgPSBNYXRoLnNpbiggbGF0MSApICogTWF0aC5jb3MoIGxvbjEgKTtcbiAgICAgICAgICAgIGxldCB5MiA9IE1hdGguY29zKCBsYXQxICk7XG4gICAgICAgICAgICBsZXQgejIgPSBNYXRoLnNpbiggbGF0MSApICogTWF0aC5zaW4oIGxvbjEgKTtcblxuICAgICAgICAgICAgbGV0IHgzID0gTWF0aC5zaW4oIGxhdDEgKSAqIE1hdGguY29zKCBsb24zICk7XG4gICAgICAgICAgICBsZXQgeTMgPSBNYXRoLmNvcyggbGF0MSApO1xuICAgICAgICAgICAgbGV0IHozID0gTWF0aC5zaW4oIGxhdDEgKSAqIE1hdGguc2luKCBsb24zICk7XG5cbiAgICAgICAgICAgIHBvcy5wdXNoKFxuICAgICAgICAgICAgICB4MSwgeTEsIHoxLFxuICAgICAgICAgICAgICB4MiwgeTIsIHoyLFxuICAgICAgICAgICAgICB4MywgeTMsIHozXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCB4ID0geDEgKyB4MiArIHgzO1xuICAgICAgICAgICAgICBsZXQgeSA9IHkxICsgeTIgKyB5MztcbiAgICAgICAgICAgICAgbGV0IHogPSB6MSArIHoyICsgejM7XG4gICAgICAgICAgICAgIGxldCBsID0gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcblxuICAgICAgICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuICAgICAgICAgICAgICAgIG5vci5wdXNoKFxuICAgICAgICAgICAgICAgICAgeCAvIGwsXG4gICAgICAgICAgICAgICAgICB5IC8gbCxcbiAgICAgICAgICAgICAgICAgIHogLyBsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvcyxcbiAgICBub3JtYWw6IG5vcixcbiAgICBpbmRleDogaW5kXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbk9jdGFoZWRyb247IiwiY29uc3QgSlNaaXAgPSByZXF1aXJlKCAnanN6aXAnICk7XG5cbmNvbnN0IENhbnZhc1NhdmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciggY2FudmFzICkge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuXG4gICAgdGhpcy5xdWV1ZVNhdmUgPSBmYWxzZTtcbiAgICB0aGlzLnppcCA9IG5ldyBKU1ppcCgpO1xuICAgIHRoaXMuYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2EnICk7XG5cbiAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuICAgIHRoaXMuaW5Qcm9ncmVzcyA9IDA7XG4gIH1cblxuICBjYXB0dXJlKCkge1xuICAgIGlmICggdGhpcy5xdWV1ZVNhdmUgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCAnWW91IGFscmVhZHkgcXVldWVkIHNhdmUgY29tbWFuZCEgRnVydGhlciBjYXB0dXJlcyBhcmUgaWdub3JlZC4nICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZW5hbWUgPSAoICcwMDAwJyArIHRoaXMuZnJhbWVDb3VudCApLnNsaWNlKCAtNSApICsgJy5wbmcnO1xuXG4gICAgdGhpcy5mcmFtZUNvdW50ICsrO1xuICAgIHRoaXMuaW5Qcm9ncmVzcyArKztcblxuICAgIHRoaXMuY2FudmFzLnRvQmxvYiggKCBibG9iICkgPT4ge1xuICAgICAgdGhpcy56aXAuZmlsZSggZmlsZW5hbWUsIGJsb2IgKTtcbiAgICAgIHRoaXMuaW5Qcm9ncmVzcyAtLTtcbiAgICAgIHRoaXMuX19kb25lKCk7XG4gICAgfSApO1xuICB9XG5cbiAgc2F2ZSgpIHtcbiAgICB0aGlzLnF1ZXVlU2F2ZSA9IHRydWU7XG4gICAgdGhpcy5fX2RvbmUoKTtcbiAgfVxuXG4gIF9fZG9uZSgpIHtcbiAgICBpZiAoIHRoaXMucXVldWVTYXZlICYmIHRoaXMuaW5Qcm9ncmVzcyA9PT0gMCApIHtcbiAgICAgIHRoaXMuemlwLmdlbmVyYXRlQXN5bmMoIHsgdHlwZTogJ2Jsb2InIH0gKS50aGVuKCAoIGJsb2IgKSA9PiB7XG4gICAgICAgIHRoaXMuYW5jaG9yLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCggYmxvYiApO1xuICAgICAgICB0aGlzLmFuY2hvci5kb3dubG9hZCA9ICdjYW52YXNTYXZlci0nICsgRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5hbmNob3IuY2xpY2soKTtcblxuICAgICAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnF1ZXVlU2F2ZSA9IGZhbHNlO1xuICAgICAgfSApO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNTYXZlcjsiLCJpbXBvcnQgUGF0aCBmcm9tICcuL2dsY2F0LXBhdGgnO1xuXG5sZXQgcmVxdWlyZWRGaWVsZHMgPSAoIG9iamVjdCwgbmFuaXRoZWZ1Y2ssIGZpZWxkcyApID0+IHtcbiAgZmllbGRzLm1hcCggKCBmaWVsZCApID0+IHtcbiAgICBpZiAoIHR5cGVvZiBvYmplY3RbIGZpZWxkIF0gPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgdGhyb3cgJ0dMQ2F0LVBhdGg6ICcgKyBmaWVsZCArICcgaXMgcmVxdWlyZWQgZm9yICcgKyBuYW5pdGhlZnVjaztcbiAgICB9XG4gIH0gKTtcbn07XG5cbmxldCBQYXRoR1VJID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoIGdsQ2F0LCBwYXJhbXMgKSB7XG4gICAgc3VwZXIoIGdsQ2F0LCBwYXJhbXMgKTtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgcmVxdWlyZWRGaWVsZHMoIHBhcmFtcywgJ3BhcmFtcycsIFtcbiAgICAgICdjYW52YXMnLFxuICAgICAgJ2VsJ1xuICAgIF0gKTtcblxuICAgIGl0Lmd1aSA9IHsgcGFyZW50OiBpdC5wYXJhbXMuZWwgfTtcblxuICAgIGl0Lmd1aS5pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3NwYW4nICk7XG4gICAgaXQuZ3VpLnBhcmVudC5hcHBlbmRDaGlsZCggaXQuZ3VpLmluZm8gKTtcblxuICAgIGl0Lmd1aS5yYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbnB1dCcgKTtcbiAgICBpdC5ndWkucmFuZ2UudHlwZSA9ICdyYW5nZSc7XG4gICAgaXQuZ3VpLnJhbmdlLm1pbiA9IDA7XG4gICAgaXQuZ3VpLnJhbmdlLm1heCA9IDA7XG4gICAgaXQuZ3VpLnJhbmdlLnN0ZXAgPSAxO1xuICAgIGl0Lmd1aS5wYXJlbnQuYXBwZW5kQ2hpbGQoIGl0Lmd1aS5yYW5nZSApO1xuXG4gICAgaXQuZGF0ZUxpc3QgPSBuZXcgQXJyYXkoIDMwICkuZmlsbCggMCApO1xuICAgIGl0LmRhdGVMaXN0SW5kZXggPSAwO1xuICAgIGl0LnRvdGFsRnJhbWVzID0gMDtcbiAgICBpdC5mcHMgPSAwO1xuICAgIGl0LmN1cnJlbnRJbmRleCA9IDA7XG4gICAgaXQudmlld05hbWUgPSAnJztcbiAgICBpdC52aWV3SW5kZXggPSAwO1xuXG4gICAgbGV0IGdsID0gZ2xDYXQuZ2w7XG4gICAgbGV0IHZib1F1YWQgPSBnbENhdC5jcmVhdGVWZXJ0ZXhidWZmZXIoIG5ldyBGbG9hdDMyQXJyYXkoIFsgLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDEgXSApICk7XG4gICAgaXQuYWRkKCB7XG4gICAgICBfX1BhdGhHdWlSZXR1cm46IHtcbiAgICAgICAgd2lkdGg6IGl0LnBhcmFtcy5jYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogaXQucGFyYW1zLmNhbnZhcy5oZWlnaHQsXG4gICAgICAgIHZlcnQ6ICdhdHRyaWJ1dGUgdmVjMiBwO3ZvaWQgbWFpbigpe2dsX1Bvc2l0aW9uPXZlYzQocCwwLDEpO30nLFxuICAgICAgICBmcmFnOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gdmVjMiByO3VuaWZvcm0gc2FtcGxlcjJEIHM7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRChzLGdsX0ZyYWdDb29yZC54eS9yKTt9JyxcbiAgICAgICAgYmxlbmQ6IFsgZ2wuT05FLCBnbC5PTkUgXSxcbiAgICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMS4wIF0sXG4gICAgICAgIGZ1bmM6ICggX3AsIHBhcmFtcyApID0+IHtcbiAgICAgICAgICBnbC52aWV3cG9ydCggMCwgMCwgaXQucGFyYW1zLmNhbnZhcy53aWR0aCwgaXQucGFyYW1zLmNhbnZhcy5oZWlnaHQgKTtcbiAgICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncicsIFsgaXQucGFyYW1zLmNhbnZhcy53aWR0aCwgaXQucGFyYW1zLmNhbnZhcy5oZWlnaHQgXSApO1xuXG4gICAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3MnLCBwYXJhbXMuaW5wdXQsIDAgKTtcbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0gKTtcbiAgfVxuXG4gIGJlZ2luKCkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBpdC5jdXJyZW50SW5kZXggPSAwO1xuICB9XG5cbiAgZW5kKCkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBpdC5ndWkucmFuZ2UubWF4ID0gTWF0aC5tYXgoIGl0Lmd1aS5yYW5nZS5tYXgsIGl0LmN1cnJlbnRJbmRleCApO1xuICAgIGl0LmN1cnJlbnRJbmRleCA9IDA7XG5cbiAgICBsZXQgbm93ID0gK25ldyBEYXRlKCkgKiAxRS0zO1xuICAgIGl0LmRhdGVMaXN0WyBpdC5kYXRlTGlzdEluZGV4IF0gPSBub3c7XG4gICAgaXQuZGF0ZUxpc3RJbmRleCA9ICggaXQuZGF0ZUxpc3RJbmRleCArIDEgKSAlIGl0LmRhdGVMaXN0Lmxlbmd0aDtcbiAgICBpdC5mcHMgPSAoXG4gICAgICAoIGl0LmRhdGVMaXN0Lmxlbmd0aCAtIDEgKVxuICAgICAgLyAoIG5vdyAtIGl0LmRhdGVMaXN0WyBpdC5kYXRlTGlzdEluZGV4IF0gKVxuICAgICkudG9GaXhlZCggMSApO1xuXG4gICAgaXQudG90YWxGcmFtZXMgKys7XG5cbiAgICBpdC5ndWkuaW5mby5pbm5lclRleHQgPSAoXG4gICAgICAnUGF0aDogJyArIGl0LnZpZXdOYW1lICsgJyAoJyArIGl0LnZpZXdJbmRleCArICcpXFxuJ1xuICAgICAgKyBpdC5mcHMgKyAnIEZQU1xcbidcbiAgICAgICsgaXQudG90YWxGcmFtZXMgKyAnIGZyYW1lc1xcbidcbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCBuYW1lLCBwYXJhbXMgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIGl0LmN1cnJlbnRJbmRleCArKztcbiAgICBsZXQgdmlldyA9IHBhcnNlSW50KCBpdC5ndWkucmFuZ2UudmFsdWUgKTtcblxuICAgIGlmICggaXQuY3VycmVudEluZGV4IDw9IHZpZXcgfHwgdmlldyA9PT0gMCApIHtcbiAgICAgIGl0LnZpZXdOYW1lID0gdmlldyA9PT0gMCA/ICcqRnVsbConIDogbmFtZTtcbiAgICAgIGl0LnZpZXdJbmRleCA9IGl0LmN1cnJlbnRJbmRleDtcblxuICAgICAgc3VwZXIucmVuZGVyKCBuYW1lLCBwYXJhbXMgKTtcblxuICAgICAgaWYgKCBpdC5jdXJyZW50SW5kZXggPT09IHZpZXcgKSB7XG4gICAgICAgIGxldCB0ID0gKFxuICAgICAgICAgICggcGFyYW1zICYmIHBhcmFtcy50YXJnZXQgKVxuICAgICAgICAgICAgPyBwYXJhbXMudGFyZ2V0XG4gICAgICAgICAgICA6IGl0LnBhdGhzWyBuYW1lIF0uZnJhbWVidWZmZXJcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIHQgJiYgdC5mcmFtZWJ1ZmZlciApIHtcbiAgICAgICAgICBsZXQgaSA9IHQudGV4dHVyZXMgPyB0LnRleHR1cmVzWyAwIF0gOiB0LnRleHR1cmU7XG4gICAgICAgICAgaWYgKCBpdC5wYXJhbXMuc3RyZXRjaCApIHtcbiAgICAgICAgICAgIHN1cGVyLnJlbmRlciggJ19fUGF0aEd1aVJldHVybicsIHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBQYXRoR1VJLm51bGxGYixcbiAgICAgICAgICAgICAgaW5wdXQ6IGksXG4gICAgICAgICAgICAgIHdpZHRoOiBpdC5wYXJhbXMuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGl0LnBhcmFtcy5jYW52YXMuaGVpZ2h0XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0LnBhcmFtcy5jYW52YXMud2lkdGggPSAoIHBhcmFtcyA/IHBhcmFtcy53aWR0aCA6IDAgKSB8fCBpdC5wYXRoc1sgbmFtZSBdLndpZHRoIHx8IGl0LnBhcmFtcy53aWR0aDtcbiAgICAgICAgICAgIGl0LnBhcmFtcy5jYW52YXMuaGVpZ2h0ID0gKCBwYXJhbXMgPyBwYXJhbXMuaGVpZ2h0IDogMCApIHx8IGl0LnBhdGhzWyBuYW1lIF0uaGVpZ2h0IHx8IGl0LnBhcmFtcy5oZWlnaHQ7XG4gICAgICAgICAgICBzdXBlci5yZW5kZXIoICdfX1BhdGhHdWlSZXR1cm4nLCB7XG4gICAgICAgICAgICAgIHRhcmdldDogUGF0aEdVSS5udWxsRmIsXG4gICAgICAgICAgICAgIGlucHV0OiBpXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQYXRoR1VJOyIsImxldCByZXF1aXJlZEZpZWxkcyA9ICggb2JqZWN0LCBuYW5pdGhlZnVjaywgZmllbGRzICkgPT4ge1xuICBmaWVsZHMubWFwKCAoIGZpZWxkICkgPT4ge1xuICAgIGlmICggdHlwZW9mIG9iamVjdFsgZmllbGQgXSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICB0aHJvdyAnR0xDYXQtUGF0aDogJyArIGZpZWxkICsgJyBpcyByZXF1aXJlZCBmb3IgJyArIG5hbml0aGVmdWNrO1xuICAgIH1cbiAgfSApO1xufTtcblxubGV0IFBhdGggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCBnbENhdCwgcGFyYW1zICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBpdC5nbENhdCA9IGdsQ2F0O1xuICAgIGl0LmdsID0gZ2xDYXQuZ2w7XG5cbiAgICBpdC5wYXRocyA9IHt9O1xuICAgIGl0Lmdsb2JhbEZ1bmMgPSAoKSA9PiB7fTtcbiAgICBpdC5wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIH1cblxuICBhZGQoIHBhdGhzICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBmb3IgKCBsZXQgbmFtZSBpbiBwYXRocyApIHtcbiAgICAgIGxldCBwYXRoID0gcGF0aHNbIG5hbWUgXTtcbiAgICAgIHJlcXVpcmVkRmllbGRzKCBwYXRoLCAncGF0aCBvYmplY3QnLCBbXG4gICAgICAgICd2ZXJ0JyxcbiAgICAgICAgJ2ZyYWcnXG4gICAgICBdICk7XG4gICAgICBpdC5wYXRoc1sgbmFtZSBdID0gcGF0aDtcblxuICAgICAgaWYgKCB0eXBlb2YgcGF0aC5kZXB0aFRlc3QgPT09ICd1bmRlZmluZWQnICkgeyBwYXRoLmRlcHRoVGVzdCA9IHRydWU7IH1cbiAgICAgIGlmICggdHlwZW9mIHBhdGguZGVwdGhXcml0ZSA9PT0gJ3VuZGVmaW5lZCcgKSB7IHBhdGguZGVwdGhXcml0ZSA9IHRydWU7IH1cbiAgICAgIGlmICggdHlwZW9mIHBhdGguYmxlbmQgPT09ICd1bmRlZmluZWQnICkgeyBwYXRoLmJsZW5kID0gWyBpdC5nbC5TUkNfQUxQSEEsIGl0LmdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXTsgfVxuICAgICAgaWYgKCB0eXBlb2YgcGF0aC5jdWxsID09PSAndW5kZWZpbmVkJyApIHsgcGF0aC5jdWxsID0gdHJ1ZTsgfVxuXG4gICAgICBpZiAoIHBhdGguZnJhbWVidWZmZXIgKSB7XG4gICAgICAgIGlmICggcGF0aC5kcmF3YnVmZmVycyApIHtcbiAgICAgICAgICBwYXRoLmZyYW1lYnVmZmVyID0gaXQuZ2xDYXQuY3JlYXRlRHJhd0J1ZmZlcnMoIHBhdGgud2lkdGgsIHBhdGguaGVpZ2h0LCBwYXRoLmRyYXdidWZmZXJzICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHBhdGguZmxvYXQgKSB7XG4gICAgICAgICAgcGF0aC5mcmFtZWJ1ZmZlciA9IGl0LmdsQ2F0LmNyZWF0ZUZsb2F0RnJhbWVidWZmZXIoIHBhdGgud2lkdGgsIHBhdGguaGVpZ2h0ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5mcmFtZWJ1ZmZlciA9IGl0LmdsQ2F0LmNyZWF0ZUZyYW1lYnVmZmVyKCBwYXRoLndpZHRoLCBwYXRoLmhlaWdodCApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwYXRoLmZpbHRlciApIHtcbiAgICAgICAgICBpdC5nbENhdC50ZXh0dXJlRmlsdGVyKCBwYXRoLmZyYW1lYnVmZmVyLnRleHR1cmUsIHBhdGguZmlsdGVyICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBwYXRoLndyYXAgKSB7XG4gICAgICAgICAgaXQuZ2xDYXQudGV4dHVyZVdyYXAoIHBhdGguZnJhbWVidWZmZXIudGV4dHVyZSwgcGF0aC53cmFwICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGF0aC5wcm9ncmFtID0gaXQuZ2xDYXQuY3JlYXRlUHJvZ3JhbSggcGF0aC52ZXJ0LCBwYXRoLmZyYWcgKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoIG5hbWUsIHBhcmFtcyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgbGV0IHBhdGggPSBpdC5wYXRoc1sgbmFtZSBdO1xuICAgIGlmICggIXBhdGggKSB7IHRocm93ICdHTENhdC1QYXRoOiBUaGUgcGF0aCBjYWxsZWQgJyArIG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkISc7IH1cblxuICAgIGlmICggIXBhcmFtcyApIHsgcGFyYW1zID0ge307IH1cbiAgICBwYXJhbXMuZnJhbWVidWZmZXIgPSB0eXBlb2YgcGFyYW1zLnRhcmdldCAhPT0gJ3VuZGVmaW5lZCcgPyBwYXJhbXMudGFyZ2V0LmZyYW1lYnVmZmVyIDogcGF0aC5mcmFtZWJ1ZmZlciA/IHBhdGguZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgOiBudWxsO1xuXG4gICAgbGV0IHdpZHRoID0gcGFyYW1zLndpZHRoIHx8IHBhdGgud2lkdGg7XG4gICAgbGV0IGhlaWdodCA9IHBhcmFtcy5oZWlnaHQgfHwgcGF0aC5oZWlnaHQ7XG5cbiAgICBpZiAoICF3aWR0aCB8fCAhaGVpZ2h0ICkge1xuICAgICAgdGhyb3cgJ0dMQ2F0LVBhdGg6IHdpZHRoIG9yIGhlaWdodCBpcyBpbnZhbGlkJztcbiAgICB9XG5cbiAgICBpdC5nbC52aWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuICAgIGl0LmdsQ2F0LnVzZVByb2dyYW0oIHBhdGgucHJvZ3JhbSApO1xuICAgIHBhdGguY3VsbCA/IGl0LmdsLmVuYWJsZSggaXQuZ2wuQ1VMTF9GQUNFICkgOiBpdC5nbC5kaXNhYmxlKCBpdC5nbC5DVUxMX0ZBQ0UgKTtcbiAgICBpdC5nbC5iaW5kRnJhbWVidWZmZXIoIGl0LmdsLkZSQU1FQlVGRkVSLCBwYXJhbXMuZnJhbWVidWZmZXIgKTtcbiAgICBpZiAoIGl0LnBhcmFtcy5kcmF3YnVmZmVycyApIHtcbiAgICAgIGl0LmdsQ2F0LmRyYXdCdWZmZXJzKCBwYXRoLmRyYXdidWZmZXJzID8gcGF0aC5kcmF3YnVmZmVycyA6IHBhcmFtcy5mcmFtZWJ1ZmZlciA9PT0gbnVsbCA/IFsgaXQuZ2wuQkFDSyBdIDogWyBpdC5nbC5DT0xPUl9BVFRBQ0hNRU5UMCBdICk7XG4gICAgfVxuICAgIGl0LmdsLmJsZW5kRnVuYyggLi4ucGF0aC5ibGVuZCApO1xuICAgIGlmICggcGF0aC5jbGVhciApIHsgaXQuZ2xDYXQuY2xlYXIoIC4uLnBhdGguY2xlYXIgKTsgfVxuICAgIHBhdGguZGVwdGhUZXN0ID8gaXQuZ2wuZW5hYmxlKCBpdC5nbC5ERVBUSF9URVNUICkgOiBpdC5nbC5kaXNhYmxlKCBpdC5nbC5ERVBUSF9URVNUICk7XG4gICAgcGF0aC5kZXB0aFdyaXRlID8gaXQuZ2wuZGVwdGhNYXNrKCB0cnVlICkgOiBpdC5nbC5kZXB0aE1hc2soIGZhbHNlICk7XG5cbiAgICBpdC5nbENhdC51bmlmb3JtMmZ2KCAncmVzb2x1dGlvbicsIFsgd2lkdGgsIGhlaWdodCBdICk7XG4gICAgaXQuZ2xvYmFsRnVuYyggcGF0aCwgcGFyYW1zICk7XG5cbiAgICBpZiAoIHBhdGguZnVuYyApIHsgcGF0aC5mdW5jKCBwYXRoLCBwYXJhbXMgKTsgfVxuICB9XG5cbiAgcmVwbGFjZVByb2dyYW0oIG5hbWUsIHZlcnQsIGZyYWcgKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aHNbIG5hbWUgXTtcbiAgICBpZiAoICFwYXRoICkgeyB0aHJvdyAnR0xDYXQtUGF0aDogVGhlIHBhdGggY2FsbGVkICcgKyBuYW1lICsgJyBpcyBub3QgZGVmaW5lZCEnOyB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJldlByb2dyYW0gPSBwYXRoLnByb2dyYW07XG4gICAgICBjb25zdCBuZXdQcm9ncmFtID0gdGhpcy5nbENhdC5jcmVhdGVQcm9ncmFtKCB2ZXJ0LCBmcmFnICk7XG4gICAgICBpZiAoIG5ld1Byb2dyYW0gKSB7XG4gICAgICAgIHBhdGgucHJvZ3JhbSA9IG5ld1Byb2dyYW07XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSggcHJldlByb2dyYW0ucHJvZ3JhbSApO1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlciggcHJldlByb2dyYW0udmVydCApO1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlciggcHJldlByb2dyYW0uZnJhZyApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgY29uc29sZS5lcnJvciggZSApO1xuICAgIH1cbiAgfVxuXG4gIHJlc2l6ZSggbmFtZSwgd2lkdGgsIGhlaWdodCApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgbGV0IHBhdGggPSBpdC5wYXRoc1sgbmFtZSBdO1xuXG4gICAgcGF0aC53aWR0aCA9IHdpZHRoO1xuICAgIHBhdGguaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgaWYgKCBwYXRoLmZyYW1lYnVmZmVyICkge1xuICAgICAgaWYgKCBpdC5wYXJhbXMuZHJhd2J1ZmZlcnMgJiYgcGF0aC5kcmF3YnVmZmVycyApIHtcbiAgICAgICAgcGF0aC5mcmFtZWJ1ZmZlciA9IGl0LmdsQ2F0LmNyZWF0ZURyYXdCdWZmZXJzKCBwYXRoLndpZHRoLCBwYXRoLmhlaWdodCwgcGF0aC5kcmF3YnVmZmVycyApO1xuICAgICAgfSBlbHNlIGlmICggcGF0aC5mbG9hdCApIHtcbiAgICAgICAgaXQuZ2xDYXQucmVzaXplRmxvYXRGcmFtZWJ1ZmZlciggcGF0aC5mcmFtZWJ1ZmZlciwgcGF0aC53aWR0aCwgcGF0aC5oZWlnaHQgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0LmdsQ2F0LnJlc2l6ZUZyYW1lYnVmZmVyKCBwYXRoLmZyYW1lYnVmZmVyLCBwYXRoLndpZHRoLCBwYXRoLmhlaWdodCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICggdHlwZW9mIHBhdGgub25yZXNpemUgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICBwYXRoLm9ucmVzaXplKCBwYXRoLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgfVxuICB9XG5cbiAgc2V0R2xvYmFsRnVuYyggZnVuYyApIHsgdGhpcy5nbG9iYWxGdW5jID0gZnVuYzsgfVxuXG4gIGZiKCBuYW1lICkge1xuICAgIGlmICggIXRoaXMucGF0aHNbIG5hbWUgXSApIHsgdGhyb3cgJ2dsY2F0LXBhdGguZmI6IHBhdGggY2FsbGVkICcgKyBuYW1lICsgJyBpcyBub3QgZGVmaW5lZCc7IH1cbiAgICBpZiAoICF0aGlzLnBhdGhzWyBuYW1lIF0uZnJhbWVidWZmZXIgKSB7IHRocm93ICdnbGNhdC1wYXRoLmZiOiB0aGVyZSBpcyBubyBmcmFtZWJ1ZmZlciBmb3IgdGhlIHBhdGggJyArIG5hbWU7IH1cblxuICAgIHJldHVybiB0aGlzLnBhdGhzWyBuYW1lIF0uZnJhbWVidWZmZXI7XG4gIH1cbn07XG5cblBhdGgubnVsbEZiID0geyBmcmFtZWJ1ZmZlcjogbnVsbCB9O1xuXG5leHBvcnQgZGVmYXVsdCBQYXRoOyIsIi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gR0xDYXRQcm9ncmFtXG4gKiBAcHJvcGVydHkge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbVxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLEdMaW50fFdlYkdMVW5pZm9ybUxvY2F0aW9uPn0gbG9jYXRpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHTENhdEZyYW1lYnVmZmVyXG4gKiBAcHJvcGVydHkge1dlYkdMRnJhbWVidWZmZXJ9IGZyYW1lYnVmZmVyXG4gKiBAcHJvcGVydHkge1dlYkdMUmVuZGVyYnVmZmVyfSBkZXB0aFxuICogQHByb3BlcnR5IHtXZWJHTFRleHR1cmV9IHRleHR1cmVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdMQ2F0RHJhd0J1ZmZlcnNcbiAqIEBwcm9wZXJ0eSB7V2ViR0xGcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXJcbiAqIEBwcm9wZXJ0eSB7V2ViR0xSZW5kZXJidWZmZXJ9IGRlcHRoXG4gKiBAcHJvcGVydHkge1dlYkdMVGV4dHVyZVtdfSB0ZXh0dXJlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0ltYWdlQml0bWFwfEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IFBpeGVsYWJsZVxuICovXG5cbi8qKlxuICogV2ViR0wgd3JhcHBlciB3aXRoIGxvdHMgb2YgcmVzcGVjdCB0byB0aGUgb3JpZ2luYWwgQVBJLCBzdGFycmluZyBGTVNfQ2F0LlxuICovXG5jb25zdCBHTENhdCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBHTENhdCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IF9nbCBPcmlnaW5hbCBXZWJHTCBjb250ZXh0XG4gICAqL1xuICBjb25zdHJ1Y3RvciggX2dsICkge1xuICAgIHRoaXMuZ2wgPSBfZ2w7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG4gICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcbiAgICBnbC5lbmFibGUoIGdsLkJMRU5EICk7XG4gICAgZ2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW4gZXh0ZW5zaW9ucy4gIFxuICAgICAqIEtleXMgYXJlIGV4dGVuc2lvbiBuYW1lLCBhbmQgdmFsdWVzIGFyZSBleHRlbnNpb24gb2JqZWN0LlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLFdlYkdMRXh0ZW5zaW9uPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fX2V4dGVuc2lvbnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnRseSB1c2luZyBwcm9ncmFtLlxuICAgICAqIEB0eXBlIHtXZWJHTFByb2dyYW19XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX19jdXJyZW50UHJvZ3JhbSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbmV3IG9yIGV4aXN0aW5nIGV4dGVuc2lvbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBOYW1lIG9mIHRoZSBleHRlbnNpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBbX3Rocm93PWZhbHNlXSBJZiB0aGlzIGlzIHRydWUsIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93ZWQgd2hlbiBpdCBpcyBmYWlsZWQgdG8gZ2V0IGV4dGVuc2lvblxuICAgKiBAcmV0dXJucyB7V2ViR0xFeHRlbnNpb259IEV4dGVuc2lvbiBvYmplY3RcbiAgICovXG4gIGdldEV4dGVuc2lvbiggX25hbWUsIF90aHJvdyApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBpZiAoIHR5cGVvZiBfbmFtZSA9PT0gJ29iamVjdCcgJiYgX25hbWUuaXNBcnJheSgpICkge1xuICAgICAgcmV0dXJuIF9uYW1lLmV2ZXJ5KCAoIG5hbWUgKSA9PiB0aGlzLmdldEV4dGVuc2lvbiggbmFtZSwgX3Rocm93ICkgKTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgX25hbWUgPT09ICdzdHJpbmcnICkge1xuICAgICAgaWYgKCB0aGlzLl9fZXh0ZW5zaW9uc1sgX25hbWUgXSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19leHRlbnNpb25zWyBfbmFtZSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2V4dGVuc2lvbnNbIF9uYW1lIF0gPSBnbC5nZXRFeHRlbnNpb24oIF9uYW1lICk7XG4gICAgICAgIGlmICggdGhpcy5fX2V4dGVuc2lvbnNbIF9uYW1lIF0gKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19leHRlbnNpb25zWyBfbmFtZSBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICggX3Rocm93ICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnVGhlIGV4dGVuc2lvbiBcIicgKyBfbmFtZSArICdcIiBpcyBub3Qgc3VwcG9ydGVkJyApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoICdHTENhdC5nZXRFeHRlbnNpb246IF9uYW1lIG11c3QgYmUgc3RyaW5nIG9yIGFycmF5JyApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgR0xDYXQgcHJvZ3JhbSBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfdmVydCBHTFNMIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gX2ZyYWcgR0xTTCBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbX29uRXJyb3JdIFdpbGwgYmUgY2FsbGVkIGlmIGNvbXBpbGUvbGluayBlcnJvciBpcyBvY2N1cnJlZFxuICAgKiBAcmV0dXJucyB7R0xDYXRQcm9ncmFtfSBDcmVhdGVkIHByb2dyYW1cbiAgICovXG4gIGNyZWF0ZVByb2dyYW0oIF92ZXJ0LCBfZnJhZywgX29uRXJyb3IgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgbGV0IGVycm9yO1xuICAgIGlmICggdHlwZW9mIF9vbkVycm9yID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgZXJyb3IgPSBfb25FcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IgPSAoIF9zdHIgKSA9PiB7IHRocm93IG5ldyBFcnJvciggX3N0ciApOyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHZlcnQgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoIHZlcnQsIF92ZXJ0ICk7XG4gICAgZ2wuY29tcGlsZVNoYWRlciggdmVydCApO1xuICAgIGlmICggIWdsLmdldFNoYWRlclBhcmFtZXRlciggdmVydCwgZ2wuQ09NUElMRV9TVEFUVVMgKSApIHtcbiAgICAgIGVycm9yKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCB2ZXJ0ICkgKTtcbiAgICAgIGdsLmRlbGV0ZVNoYWRlciggdmVydCApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZnJhZyA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG4gICAgZ2wuc2hhZGVyU291cmNlKCBmcmFnLCBfZnJhZyApO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoIGZyYWcgKTtcbiAgICBpZiAoICFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIGZyYWcsIGdsLkNPTVBJTEVfU1RBVFVTICkgKSB7XG4gICAgICBlcnJvciggZ2wuZ2V0U2hhZGVySW5mb0xvZyggZnJhZyApICk7XG4gICAgICBnbC5kZWxldGVTaGFkZXIoIHZlcnQgKTtcbiAgICAgIGdsLmRlbGV0ZVNoYWRlciggZnJhZyApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnQgKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWcgKTtcbiAgICBnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuICAgIGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMgKSApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnQ6IHZlcnQsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIHByb2dyYW06IHByb2dyYW0sXG4gICAgICAgIGxvY2F0aW9uczoge31cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCBnbC5nZXRQcm9ncmFtSW5mb0xvZyggcHJvZ3JhbSApICk7XG4gICAgICBnbC5kZWxldGVTaGFkZXIoIHZlcnQgKTtcbiAgICAgIGdsLmRlbGV0ZVNoYWRlciggZnJhZyApO1xuICAgICAgZ2wuZGVsZXRlUHJvZ3JhbSggcHJvZ3JhbSApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpdHkgYSBwcm9ncmFtIHRvIHVzZS5cbiAgICogQHBhcmFtIHtHTENhdFByb2dyYW19IF9wcm9ncmFtIFByb2dyYW0geW91IHdhbnQgdG8gdXNlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICB1c2VQcm9ncmFtKCBfcHJvZ3JhbSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC51c2VQcm9ncmFtKCBfcHJvZ3JhbS5wcm9ncmFtICk7XG4gICAgdGhpcy5fX2N1cnJlbnRQcm9ncmFtID0gX3Byb2dyYW07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHZlcnRleCBidWZmZXIuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBfc291cmNlIFNvdXJjZSBvZiB0aGUgZGF0YVxuICAgKiBAcmV0dXJucyB7V2ViR0xCdWZmZXJ9IEdlbmVyYXRlZCB2ZXJ0ZXggYnVmZmVyXG4gICAqL1xuICBjcmVhdGVWZXJ0ZXhidWZmZXIoIF9zb3VyY2UgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICBpZiAoIF9zb3VyY2UgKSB7IHRoaXMuc2V0VmVydGV4YnVmZmVyKCBidWZmZXIsIF9zb3VyY2UgKTsgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IGRhdGEgaW50byBhIHZlcnRleCBidWZmZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xCdWZmZXJ9IF90YXJnZXQgVGFyZ2V0IHZlcnRleCBidWZmZXJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IF9zb3VyY2UgU291cmNlIG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSB7R0xlbnVtfSBbX3VzYWdlPWdsLlNUQVRJQ19EUkFXXSBVc2FnZSBvZiB0aGUgYnVmZmVyXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBzZXRWZXJ0ZXhidWZmZXIoIF90YXJnZXQsIF9zb3VyY2UsIF91c2FnZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCB1c2FnZSA9IF91c2FnZSB8fCBnbC5TVEFUSUNfRFJBVztcblxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgX3RhcmdldCApO1xuICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgX3NvdXJjZSwgdXNhZ2UgKTtcbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIG51bGwgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5kZXggYnVmZmVyLlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gX3NvdXJjZSBTb3VyY2Ugb2YgdGhlIGRhdGFcbiAgICogQHJldHVybnMge1dlYkdMQnVmZmVyfSBHZW5lcmF0ZWQgaW5kZXggYnVmZmVyXG4gICAqL1xuICBjcmVhdGVJbmRleGJ1ZmZlciggX3NvdXJjZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIGlmICggX3NvdXJjZSApIHsgdGhpcy5zZXRJbmRleGJ1ZmZlciggYnVmZmVyLCBfc291cmNlICk7IH1cblxuICAgIHJldHVybiBidWZmZXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG5ldyBkYXRhIGludG8gYSBpbmRleCBidWZmZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xCdWZmZXJ9IF90YXJnZXQgVGFyZ2V0IGluZGV4IGJ1ZmZlclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gX3NvdXJjZSBTb3VyY2Ugb2YgdGhlIGRhdGFcbiAgICogQHBhcmFtIHtHTGVudW19IFtfdXNhZ2U9Z2wuU1RBVElDX0RSQVddIFVzYWdlIG9mIHRoZSBidWZmZXJcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHNldEluZGV4YnVmZmVyKCBfdGFyZ2V0LCBfc291cmNlLCBfdXNhZ2UgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgdXNhZ2UgPSBfdXNhZ2UgfHwgZ2wuU1RBVElDX0RSQVc7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgX3RhcmdldCApO1xuICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBfc291cmNlLCB1c2FnZSApO1xuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxvY2F0aW9uIGZvciBnaXZlbiBhdHRyaWJ1dGUgdmFyaWFibGUgbmFtZSBmb3IgY3VycmVudCBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHZhcmlhYmxlXG4gICAqIEByZXR1cm5zIHtHTGludH0gTG9jYXRpb24gb2YgdGhlIGF0dHJpYnV0ZSB2YXJpYWJsZVxuICAgKi9cbiAgZ2V0QXR0cmliTG9jYXRpb24oIF9uYW1lICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGxldCBsb2NhdGlvbjtcbiAgICBpZiAoIHRoaXMuX19jdXJyZW50UHJvZ3JhbS5sb2NhdGlvbnNbIF9uYW1lIF0gKSB7XG4gICAgICBsb2NhdGlvbiA9IHRoaXMuX19jdXJyZW50UHJvZ3JhbS5sb2NhdGlvbnNbIF9uYW1lIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHRoaXMuX19jdXJyZW50UHJvZ3JhbS5wcm9ncmFtLCBfbmFtZSApO1xuICAgICAgdGhpcy5fX2N1cnJlbnRQcm9ncmFtLmxvY2F0aW9uc1sgX25hbWUgXSA9IGxvY2F0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYW4gdmVydGV4IGJ1ZmZlciBhcyBhdHRyaWJ1dGUgdmFyaWFibGUgdG8gdGhlIGN1cnJlbnQgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB2YXJpYWJsZVxuICAgKiBAcGFyYW0ge1dlYkdMQnVmZmVyfSBfYnVmZmVyIFZlcnRleCBidWZmZXJcbiAgICogQHBhcmFtIHtHTGludH0gX3NpemUgTnVtYmVyIG9mIGNvbXBvbmVudHMgcGVyIHZlcnRleC4gTXVzdCBiZSAxLCAyLCAzIG9yIDRcbiAgICogQHBhcmFtIHtHTGVudW19IFtfdHlwZT1nbC5GTE9BVF0gRGF0YSB0eXBlIG9mIGVhY2ggY29tcG9uZW50XG4gICAqIEBwYXJhbSB7R0xzaXplaX0gW19zdHJpZGU9MF0gU3RyaWRlIGluIGJ5dGVzXG4gICAqIEBwYXJhbSB7R0xpbnRwdHJ9IFtfb2Zmc2V0PTBdIE9mZnNldCBpbiBieXRlc1xuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgYXR0cmlidXRlKCBfbmFtZSwgX2J1ZmZlciwgX3NpemUsIF90eXBlLCBfc3RyaWRlLCBfb2Zmc2V0ICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nZXRBdHRyaWJMb2NhdGlvbiggX25hbWUgKTtcbiAgICBpZiAoIGxvY2F0aW9uID09PSAtMSApIHsgcmV0dXJuOyB9XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIF9idWZmZXIgKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggbG9jYXRpb24gKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBsb2NhdGlvbiwgX3NpemUsIF90eXBlIHx8IGdsLkZMT0FULCBmYWxzZSwgX3N0cmlkZSB8fCAwLCBfb2Zmc2V0IHx8IDAgKTtcblxuICAgIGNvbnN0IGV4dCA9IHRoaXMuZ2V0RXh0ZW5zaW9uKCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcbiAgICBpZiAoIGV4dCApIHtcbiAgICAgIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGxvY2F0aW9uLCAwICk7XG4gICAgfVxuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCBudWxsICk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGFuIHZlcnRleCBidWZmZXIgYXMgYXR0cmlidXRlIHZhcmlhYmxlIHRvIHRoZSBjdXJyZW50IHByb2dyYW0uICBcbiAgICogQ2FuIHNldCBkaXZpc29yIGF0IDR0aCBhcmd1bWVudCBmb3IgdXNlIG9mIGluc3RhbmNpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdmFyaWFibGVcbiAgICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gX2J1ZmZlciBWZXJ0ZXggYnVmZmVyXG4gICAqIEBwYXJhbSB7R0xpbnR9IF9zaXplIE51bWJlciBvZiBjb21wb25lbnRzIHBlciB2ZXJ0ZXguIE11c3QgYmUgMSwgMiwgMyBvciA0XG4gICAqIEBwYXJhbSB7R0x1aW50fSBfZGl2IERpdmlzb3Igb2YgdGhlIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0ge0dMZW51bX0gW190eXBlPWdsLkZMT0FUXSBEYXRhIHR5cGUgb2YgZWFjaCBjb21wb25lbnRcbiAgICogQHBhcmFtIHtHTHNpemVpfSBbX3N0cmlkZT0wXSBTdHJpZGUgaW4gYnl0ZXNcbiAgICogQHBhcmFtIHtHTGludHB0cn0gW19vZmZzZXQ9MF0gT2Zmc2V0IGluIGJ5dGVzXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBhdHRyaWJ1dGVEaXZpc29yKCBfbmFtZSwgX2J1ZmZlciwgX3NpemUsIF9kaXYsIF90eXBlLCBfc3RyaWRlLCBfb2Zmc2V0ICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMuZ2V0RXh0ZW5zaW9uKCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycsIHRydWUgKTtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nZXRBdHRyaWJMb2NhdGlvbiggX25hbWUgKTtcbiAgICBpZiAoIGxvY2F0aW9uID09PSAtMSApIHsgcmV0dXJuOyB9XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIF9idWZmZXIgKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggbG9jYXRpb24gKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBsb2NhdGlvbiwgX3NpemUsIF90eXBlIHx8IGdsLkZMT0FULCBmYWxzZSwgX3N0cmlkZSB8fCAwLCBfb2Zmc2V0IHx8IDAgKTtcblxuICAgIGNvbnN0IGV4dCA9IHRoaXMuZ2V0RXh0ZW5zaW9uKCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcbiAgICBpZiAoIGV4dCApIHtcbiAgICAgIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGxvY2F0aW9uLCBfZGl2ICk7XG4gICAgfVxuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCBudWxsICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxvY2F0aW9uIGZvciBnaXZlbiB1bmlmb3JtIHZhcmlhYmxlIG5hbWUgZm9yIGN1cnJlbnQgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0gdmFyaWFibGVcbiAgICogQHJldHVybnMge1dlYkdMVW5pZm9ybUxvY2F0aW9ufSBMb2NhdGlvbiBvZiB0aGUgdW5pZm9ybSB2YXJpYWJsZVxuICAgKi9cbiAgZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBsZXQgbG9jYXRpb247XG5cbiAgICBpZiAoIHR5cGVvZiB0aGlzLl9fY3VycmVudFByb2dyYW0ubG9jYXRpb25zWyBfbmFtZSBdICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIGxvY2F0aW9uID0gdGhpcy5fX2N1cnJlbnRQcm9ncmFtLmxvY2F0aW9uc1sgX25hbWUgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHRoaXMuX19jdXJyZW50UHJvZ3JhbS5wcm9ncmFtLCBfbmFtZSApO1xuICAgICAgdGhpcy5fX2N1cnJlbnRQcm9ncmFtLmxvY2F0aW9uc1sgX25hbWUgXSA9IGxvY2F0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYW4gdW5pZm9ybSB2YXJpYWJsZS4gIFxuICAgKiBGaW5hbGx5LCBsYXppbmVzcyB3b24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfdHlwZSBUeXBlIG9mIHRoZSB1bmlmb3JtIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfdmFsdWUgVmFsdWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVuaWZvcm0oIF90eXBlLCBfbmFtZSwgX3ZhbHVlICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICk7XG4gICAgZ2xbICd1bmlmb3JtJyArIF90eXBlIF0oIGxvY2F0aW9uLCBfdmFsdWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYW4gYGludGAgdHlwZSB1bmlmb3JtIHZhcmlhYmxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybSB2YXJpYWJsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gX3ZhbHVlIGBpbnRgIHZhbHVlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICB1bmlmb3JtMWkoIF9uYW1lLCBfdmFsdWUgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcbiAgICBnbC51bmlmb3JtMWkoIGxvY2F0aW9uLCBfdmFsdWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYSBgZmxvYXRgIHR5cGUgdW5pZm9ybSB2YXJpYWJsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0gdmFyaWFibGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IF92YWx1ZSBgZmxvYXRgIHZhbHVlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICB1bmlmb3JtMWYoIF9uYW1lLCBfdmFsdWUgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcbiAgICBnbC51bmlmb3JtMWYoIGxvY2F0aW9uLCBfdmFsdWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYW4gYXJyYXkgb2YgYHZlYzJgIHR5cGUgdW5pZm9ybSB2YXJpYWJsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0gdmFyaWFibGVcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8bnVtYmVyW119IF92YWx1ZSBBcnJheSBvZiBgdmVjMmAgdmFsdWVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVuaWZvcm0yZnYoIF9uYW1lLCBfdmFsdWUgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcbiAgICBnbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgX3ZhbHVlICk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGFuIGFycmF5IG9mIGB2ZWMzYCB0eXBlIHVuaWZvcm0gdmFyaWFibGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fG51bWJlcltdfSBfdmFsdWUgQXJyYXkgb2YgYHZlYzNgIHZhbHVlXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICB1bmlmb3JtM2Z2KCBfbmFtZSwgX3ZhbHVlICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICk7XG4gICAgZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIF92YWx1ZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhbiBhcnJheSBvZiBgdmVjNGAgdHlwZSB1bmlmb3JtIHZhcmlhYmxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gX25hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybSB2YXJpYWJsZVxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxudW1iZXJbXX0gX3ZhbHVlIEFycmF5IG9mIGB2ZWM0YCB2YWx1ZVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdW5pZm9ybTRmdiggX25hbWUsIF92YWx1ZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuICAgIGdsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCBfdmFsdWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYW4gYXJyYXkgb2YgYG1hdDRgIHR5cGUgdW5pZm9ybSB2YXJpYWJsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0gdmFyaWFibGVcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8bnVtYmVyW119IF92YWx1ZSBBcnJheSBvZiBgbWF0NGAgdmFsdWVcbiAgICogQHBhcmFtIHtHTGJvb2xlYW59IFtfdHJhbnNwb3NlPWZhbHNlXSBTcGVjaWZ5IHdoZXRoZXIgdG8gdHJhbnNwb3NlIHRoZSBtYXRyaXhcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVuaWZvcm1NYXRyaXg0ZnYoIF9uYW1lLCBfdmFsdWUsIF90cmFuc3Bvc2UgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgX3RyYW5zcG9zZSB8fCBmYWxzZSwgX3ZhbHVlICk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGEgYHNhbXBsZXIyRGAgdHlwZSB1bmlmb3JtIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfbmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtIHRleHR1cmVcbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IF90ZXh0dXJlIFRleHR1cmUgb2JqZWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfbnVtYmVyIFNwZWNpZnkgYSB0ZXh0dXJlIHVuaXQsIGluIGludGVnZXJcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHVuaWZvcm1UZXh0dXJlKCBfbmFtZSwgX3RleHR1cmUsIF9udW1iZXIgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCArIF9udW1iZXIgKTtcbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcbiAgICBnbC51bmlmb3JtMWkoIGxvY2F0aW9uLCBfbnVtYmVyICk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGEgYHNhbXBsZXJDdWJlYCB0eXBlIHVuaWZvcm0gdGV4dHVyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IF9uYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0gdGV4dHVyZVxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gX3RleHR1cmUgVGV4dHVyZSBvYmplY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IF9udW1iZXIgU3BlY2lmeSBhIHRleHR1cmUgdW5pdCwgaW4gaW50ZWdlclxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgdW5pZm9ybUN1YmVtYXAoIF9uYW1lLCBfdGV4dHVyZSwgX251bWJlciApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICsgX251bWJlciApO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBfdGV4dHVyZSApO1xuICAgIGdsLnVuaWZvcm0xaSggbG9jYXRpb24sIF9udW1iZXIgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0ZXh0dXJlIG9iamVjdC5cbiAgICogQHJldHVybnMge1dlYkdMVGV4dHVyZX0gVGV4dHVyZSBvYmplY3RcbiAgICovXG4gIGNyZWF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgaG93IHRvIGZpbHRlciB0aGUgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IF90ZXh0dXJlIFRleHR1cmUgb2JqZWN0XG4gICAqIEBwYXJhbSB7R0xlbnVtfSBfZmlsdGVyIFRleHR1cmUgZmlsdGVyXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICB0ZXh0dXJlRmlsdGVyKCBfdGV4dHVyZSwgX2ZpbHRlciApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIF9maWx0ZXIgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIF9maWx0ZXIgKTtcbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgaG93IHRvIHdyYXAgdGhlIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBfdGV4dHVyZSBUZXh0dXJlIG9iamVjdFxuICAgKiBAcGFyYW0ge0dMZW51bX0gX2ZpbHRlciBXcmFwcGluZyBmdW5jdGlvbiBmb3IgdGhlIHRleHR1cmVcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHRleHR1cmVXcmFwKCBfdGV4dHVyZSwgX3dyYXAgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIF90ZXh0dXJlICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIF93cmFwICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIF93cmFwICk7XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IGRhdGEgaW50byBhIHRleHR1cmUgb2JqZWN0LiAgXG4gICAqIFRoaXMgZnVuY3Rpb24gdXNlcyBpbWFnZSBkYXRhLiBJZiB5b3Ugd2FudCB0byBzb3VyY2UgYFVpbnQ4QXJyYXlgLCB1c2UgYEdMQ2F0LnNldFRleHR1cmVGcm9tQXJyYXkoKWAgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IF90ZXh0dXJlIFRleHR1cmUgb2JqZWN0XG4gICAqIEBwYXJhbSB7UGl4ZWxhYmxlfSBfc291cmNlIFNvdXJjZSBpbWFnZSBvZiB0aGUgcGl4ZWwgZGF0YVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgc2V0VGV4dHVyZSggX3RleHR1cmUsIF9zb3VyY2UgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIF90ZXh0dXJlICk7XG4gICAgZ2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgX3NvdXJjZSApO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG5ldyBkYXRhIGludG8gYSB0ZXh0dXJlIG9iamVjdC4gIFxuICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYFVpbnQ4QXJyYXlgLiBJZiB5b3Ugd2FudCB0byBzb3VyY2UgaW1hZ2UgZGF0YSwgdXNlIGBHTENhdC5zZXRUZXh0dXJlKClgIGluc3RlYWQuICBcbiAgICogT3IgeW91IHdhbnQgdG8gdXNlIGZsb2F0IHRleHR1cmU/IFRyeSB0aGlzOiBgR0xDYXQuc2V0VGV4dHVyZUZyb21GbG9hdEFycmF5KClgXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBfdGV4dHVyZSBUZXh0dXJlIG9iamVjdFxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF93aWR0aCBXaWR0aCBvZiB0aGUgdGV4dHVyZVxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF9oZWlnaHQgSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gX3NvdXJjZSBTb3VyY2UgYnVmZmVyIG9mIHRoZSBwaXhlbCBkYXRhXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICBzZXRUZXh0dXJlRnJvbUFycmF5KCBfdGV4dHVyZSwgX3dpZHRoLCBfaGVpZ2h0LCBfc291cmNlICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfdGV4dHVyZSApO1xuICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbmV3IFVpbnQ4QXJyYXkoIF9zb3VyY2UgKSApO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG5ldyBkYXRhIGludG8gYSB0ZXh0dXJlIG9iamVjdC4gIFxuICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYEZsb2F0MzJBcnJheWAuICBcbiAgICogSWYgeW91IGNhbid0IGdyYWIgYE9FU190ZXh0dXJlX2Zsb2F0YCBleHRlbnNpb24gaGVyZSwgeW91IHdpbGwgZGllIGF0IHRoaXMgcG9pbnQuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBfdGV4dHVyZSBUZXh0dXJlIG9iamVjdFxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF93aWR0aCBXaWR0aCBvZiB0aGUgdGV4dHVyZVxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF9oZWlnaHQgSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBfc291cmNlIFNvdXJjZSBidWZmZXIgb2YgdGhlIHBpeGVsIGRhdGFcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHNldFRleHR1cmVGcm9tRmxvYXRBcnJheSggX3RleHR1cmUsIF93aWR0aCwgX2hlaWdodCwgX3NvdXJjZSApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICB0aGlzLmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0JywgdHJ1ZSApO1xuXG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIF90ZXh0dXJlICk7XG4gICAgZ2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3dpZHRoLCBfaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbmV3IEZsb2F0MzJBcnJheSggX3NvdXJjZSApICk7XG4gICAgaWYgKCAhdGhpcy5nZXRFeHRlbnNpb24oICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgKSB7IHRoaXMudGV4dHVyZUZpbHRlciggX3RleHR1cmUsIGdsLk5FQVJFU1QgKTsgfVxuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG4gIH1cblxuICAvKipcbiAgICogQ29weSBwaXhlbHMgZnJvbSBjdXJyZW50IGZyYW1lYnVmZmVyIHRvIGdpdmVuIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBfdGV4dHVyZSBUYXJnZXQgdGV4dHVyZSBvYmplY3RcbiAgICogQHBhcmFtIHtHTHNpemVpfSBfd2lkdGggV2lkdGggb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHtHTHNpemVpfSBfaGVpZ2h0IEhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgY29weVRleHR1cmUoIF90ZXh0dXJlLCBfd2lkdGgsIF9oZWlnaHQgKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIF90ZXh0dXJlICk7XG4gICAgZ2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDAsIDAsIF93aWR0aCwgX2hlaWdodCwgMCApO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY3ViZW1hcCB0ZXh0dXJlIG9iamVjdC5cbiAgICogQHBhcmFtIHtQaXhlbGFibGVbXX0gX2FycmF5T2ZJbWFnZSBBcnJheSBvZiBpYW1nZXMuIE9yZGVyOiBgWCtgLCBgWC1gLCBgWStgLCBgWS1gLCBgWitgLCBgWi1gXG4gICAqIEByZXR1cm5zIHtXZWJHTFRleHR1cmV9IFRleHR1cmUgb2JqZWN0XG4gICAqL1xuICBjcmVhdGVDdWJlbWFwKCBfYXJyYXlPZkltYWdlICkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSApO1xuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBfYXJyYXlPZkltYWdlWyBpIF0gKTtcbiAgICB9XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUiApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZnJhbWVidWZmZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF93aWR0aCBXaWR0aCBvZiB0aGUgZnJhbWVidWZmZXJcbiAgICogQHBhcmFtIHtHTHNpemVpfSBfaGVpZ2h0IEhlaWdodCBvZiB0aGUgZnJhbWVidWZmZXJcbiAgICogQHJldHVybnMge0dMQ2F0RnJhbWVidWZmZXJ9IEZyYW1lYnVmZmVyIG9iamVjdFxuICAgKi9cbiAgY3JlYXRlRnJhbWVidWZmZXIoIF93aWR0aCwgX2hlaWdodCApIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IHt9O1xuICAgIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlciApO1xuXG4gICAgZnJhbWVidWZmZXIuZGVwdGggPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIGZyYW1lYnVmZmVyLmRlcHRoICk7XG4gICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgX3dpZHRoLCBfaGVpZ2h0ICk7XG4gICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGZyYW1lYnVmZmVyLmRlcHRoICk7XG5cbiAgICBmcmFtZWJ1ZmZlci50ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIGZyYW1lYnVmZmVyLnRleHR1cmUgKTtcbiAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgZnJhbWVidWZmZXIudGV4dHVyZSwgMCApO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuICAgIHJldHVybiBmcmFtZWJ1ZmZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemUgYSBmcmFtZWJ1ZmZlciBvYmplY3QuXG4gICAqIEBwYXJhbSB7R0xDYXRGcmFtZWJ1ZmZlcn0gRnJhbWVidWZmZXIgb2JqZWN0XG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX3dpZHRoIFdpZHRoIG9mIHRoZSBmcmFtZWJ1ZmZlclxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF9oZWlnaHQgSGVpZ2h0IG9mIHRoZSBmcmFtZWJ1ZmZlclxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgcmVzaXplRnJhbWVidWZmZXIoIF9mcmFtZWJ1ZmZlciwgX3dpZHRoLCBfaGVpZ2h0ICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG4gICAgbGV0IGdsID0gaXQuZ2w7XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBfZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgKTtcblxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgX2ZyYW1lYnVmZmVyLmRlcHRoICk7XG4gICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgX3dpZHRoLCBfaGVpZ2h0ICk7XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XG5cbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX2ZyYW1lYnVmZmVyLnRleHR1cmUgKTtcbiAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZyYW1lYnVmZmVyIG9iamVjdCwgYnV0IEZsb2F0MzIgb25lLlxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF93aWR0aCBXaWR0aCBvZiB0aGUgZnJhbWVidWZmZXJcbiAgICogQHBhcmFtIHtHTHNpemVpfSBfaGVpZ2h0IEhlaWdodCBvZiB0aGUgZnJhbWVidWZmZXJcbiAgICogQHJldHVybnMge0dMQ2F0RnJhbWVidWZmZXJ9IEZyYW1lYnVmZmVyIG9iamVjdFxuICAgKi9cbiAgY3JlYXRlRmxvYXRGcmFtZWJ1ZmZlciggX3dpZHRoLCBfaGVpZ2h0ICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG4gICAgbGV0IGdsID0gaXQuZ2w7XG5cbiAgICBpdC5nZXRFeHRlbnNpb24oICdPRVNfdGV4dHVyZV9mbG9hdCcsIHRydWUgKTtcblxuICAgIGxldCBmcmFtZWJ1ZmZlciA9IHt9O1xuICAgIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlciApO1xuXG4gICAgZnJhbWVidWZmZXIuZGVwdGggPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIGZyYW1lYnVmZmVyLmRlcHRoICk7XG4gICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgX3dpZHRoLCBfaGVpZ2h0ICk7XG4gICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGZyYW1lYnVmZmVyLmRlcHRoICk7XG5cbiAgICBmcmFtZWJ1ZmZlci50ZXh0dXJlID0gaXQuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBmcmFtZWJ1ZmZlci50ZXh0dXJlICk7XG4gICAgZ2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3dpZHRoLCBfaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCApO1xuICAgIGlmICggIWl0LmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSApIHsgaXQudGV4dHVyZUZpbHRlciggZnJhbWVidWZmZXIudGV4dHVyZSwgZ2wuTkVBUkVTVCApOyB9XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGZyYW1lYnVmZmVyLnRleHR1cmUsIDAgKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cbiAgICByZXR1cm4gZnJhbWVidWZmZXI7XG4gIH1cblxuICAvKipcbiAgICogUmVzaXplIGEgZmxvYXQgZnJhbWVidWZmZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0ge0dMQ2F0RnJhbWVidWZmZXJ9IEZyYW1lYnVmZmVyIG9iamVjdFxuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF93aWR0aCBXaWR0aCBvZiB0aGUgZnJhbWVidWZmZXJcbiAgICogQHBhcmFtIHtHTHNpemVpfSBfaGVpZ2h0IEhlaWdodCBvZiB0aGUgZnJhbWVidWZmZXJcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIHJlc2l6ZUZsb2F0RnJhbWVidWZmZXIoIF9mcmFtZWJ1ZmZlciwgX3dpZHRoLCBfaGVpZ2h0ICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG4gICAgbGV0IGdsID0gaXQuZ2w7XG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBfZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgKTtcblxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgX2ZyYW1lYnVmZmVyLmRlcHRoICk7XG4gICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgX3dpZHRoLCBfaGVpZ2h0ICk7XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XG5cbiAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX2ZyYW1lYnVmZmVyLnRleHR1cmUgKTtcbiAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsICk7XG4gICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkcmF3IGJ1ZmZlcnMgb2JqZWN0LiAgXG4gICAqIElmIHlvdSBjYW4ndCBncmFiIGBXRUJHTF9kcmF3X2J1ZmZlcnNgIGV4dGVuc2lvbiwgeW91IHdpbGwgZGllIGluc3RhbnRseS4gIFxuICAgKiBGb3JtYXQgb2YgaXRzIHRleHR1cmVzIHdpbGwgYmUgRmxvYXQzMi5cbiAgICogQHBhcmFtIHtHTHNpemVpfSBfd2lkdGggV2lkdGggb2YgdGhlIGRyYXcgYnVmZmVyc1xuICAgKiBAcGFyYW0ge0dMc2l6ZWl9IF9oZWlnaHQgSGVpZ2h0IG9mIHRoZSBkcmF3IGJ1ZmZlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFNwZWNpZnkgaG93IG1hbnkgdGV4dHVyZXMgaXQgaGFzXG4gICAqIEByZXR1cm5zIHtHTENhdERyYXdCdWZmZXJzfSBEcmF3IGJ1ZmZlcnMgb2JqZWN0XG4gICAqL1xuICBjcmVhdGVEcmF3QnVmZmVycyggX3dpZHRoLCBfaGVpZ2h0LCBfbnVtRHJhd0J1ZmZlcnMgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcbiAgICBsZXQgZ2wgPSBpdC5nbDtcblxuICAgIGl0LmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0JywgdHJ1ZSApO1xuICAgIGxldCBleHQgPSBpdC5nZXRFeHRlbnNpb24oICdXRUJHTF9kcmF3X2J1ZmZlcnMnLCB0cnVlICk7XG5cbiAgICBpZiAoIGV4dC5NQVhfRFJBV19CVUZGRVJTX1dFQkdMIDwgX251bURyYXdCdWZmZXJzICkge1xuICAgICAgdGhyb3cgJ2NyZWF0ZURyYXdCdWZmZXJzOiBNQVhfRFJBV19CVUZGRVJTX1dFQkdMIGlzICcgKyBleHQuTUFYX0RSQVdfQlVGRkVSU19XRUJHTDtcbiAgICB9XG5cbiAgICBsZXQgZHJhd2J1ZmZlcnMgPSB7fTtcbiAgICBkcmF3YnVmZmVycy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgZHJhd2J1ZmZlcnMuZnJhbWVidWZmZXIgKTtcblxuICAgIGRyYXdidWZmZXJzLmRlcHRoID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBkcmF3YnVmZmVycy5kZXB0aCApO1xuICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIF93aWR0aCwgX2hlaWdodCApO1xuICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBkcmF3YnVmZmVycy5kZXB0aCApO1xuXG4gICAgZHJhd2J1ZmZlcnMudGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBfbnVtRHJhd0J1ZmZlcnM7IGkgKysgKSB7XG4gICAgICBkcmF3YnVmZmVycy50ZXh0dXJlc1sgaSBdID0gaXQuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIGRyYXdidWZmZXJzLnRleHR1cmVzWyBpIF0gKTtcbiAgICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwgKTtcbiAgICAgIGlmICggIWl0LmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSApIHsgaXQudGV4dHVyZUZpbHRlciggZHJhd2J1ZmZlcnMudGV4dHVyZXNbIGkgXSwgZ2wuTkVBUkVTVCApOyB9XG4gICAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggZ2wuRlJBTUVCVUZGRVIsIGV4dC5DT0xPUl9BVFRBQ0hNRU5UMF9XRUJHTCArIGksIGdsLlRFWFRVUkVfMkQsIGRyYXdidWZmZXJzLnRleHR1cmVzWyBpIF0sIDAgKTtcbiAgICB9XG5cbiAgICBsZXQgc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggZ2wuRlJBTUVCVUZGRVIgKTtcbiAgICBpZiAoIHN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUgKSB7XG4gICAgICB0aHJvdyAnY3JlYXRlRHJhd0J1ZmZlcnM6IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoIGdsLkZSQU1FQlVGRkVSICkgcmV0dXJucyAnICsgc3RhdHVzO1xuICAgIH1cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cbiAgICByZXR1cm4gZHJhd2J1ZmZlcnM7XG4gIH1cblxuICAvKipcbiAgICogUmVzaXplIGEgZHJhdyBidWZmZXJzIG9iamVjdC5cbiAgICogQHBhcmFtIHtHTENhdERyYXdCdWZmZXJzfSBEcmF3IGJ1ZmZlcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7R0xzaXplaX0gX3dpZHRoIFdpZHRoIG9mIHRoZSBkcmF3IGJ1ZmZlcnNcbiAgICogQHBhcmFtIHtHTHNpemVpfSBfaGVpZ2h0IEhlaWdodCBvZiB0aGUgZHJhdyBidWZmZXJzXG4gICAqIEByZXR1cm5zIHt2b2lkfSB2b2lkXG4gICAqL1xuICByZXNpemVEcmF3QnVmZmVycyggX2ZyYW1lYnVmZmVyLCBfd2lkdGgsIF9oZWlnaHQgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcbiAgICBsZXQgZ2wgPSBpdC5nbDtcblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIF9mcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlciApO1xuXG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBfZnJhbWVidWZmZXIuZGVwdGggKTtcbiAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBfd2lkdGgsIF9oZWlnaHQgKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IF9mcmFtZWJ1ZmZlci50ZXh0dXJlcy5sZW5ndGg7IGkgKysgKSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX2ZyYW1lYnVmZmVyLnRleHR1cmVzWyBpIF0gKTtcbiAgICAgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwgKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG4gICAgfVxuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBiZWZvcmUgeW91IGFyZSBnb2luZyB0byB1c2UgZHJhdyBidWZmZXJzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gU3BlY2lmeSBob3cgbWFueSBkcmF3IGJ1ZmZlcnMgeW91IGFyZSBnb2luZyB0byB1c2VcbiAgICogQHJldHVybnMge3ZvaWR9IHZvaWRcbiAgICovXG4gIGRyYXdCdWZmZXJzKCBfbnVtRHJhd0J1ZmZlcnMgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcbiAgICBsZXQgZ2wgPSBpdC5nbDtcblxuICAgIGxldCBleHQgPSBpdC5nZXRFeHRlbnNpb24oICdXRUJHTF9kcmF3X2J1ZmZlcnMnLCB0cnVlICk7XG5cbiAgICBsZXQgYXJyYXkgPSBbXTtcbiAgICBpZiAoIHR5cGVvZiBfbnVtRHJhd0J1ZmZlcnMgPT09ICdudW1iZXInICkge1xuICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgX251bURyYXdCdWZmZXJzOyBpICsrICkge1xuICAgICAgICBhcnJheS5wdXNoKCBleHQuQ09MT1JfQVRUQUNITUVOVDBfV0VCR0wgKyBpICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5ID0gYXJyYXkuY29uY2F0KCBfbnVtRHJhd0J1ZmZlcnMgKTtcbiAgICB9XG4gICAgZXh0LmRyYXdCdWZmZXJzV0VCR0woIGFycmF5ICk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgY3VycmVudCBmcmFtZWJ1ZmZlci5cbiAgICogQHBhcmFtIHtHTGNsYW1wZn0gW19yPTAuMF0gUmVkIGFtb3VudCBvZiBjbGVhcmluZyBjb2xvclxuICAgKiBAcGFyYW0ge0dMY2xhbXBmfSBbX2c9MC4wXSBHcmVlbiBhbW91bnQgb2YgY2xlYXJpbmcgY29sb3JcbiAgICogQHBhcmFtIHtHTGNsYW1wZn0gW19iPTAuMF0gQmx1ZSBhbW91bnQgb2YgY2xlYXJpbmcgY29sb3JcbiAgICogQHBhcmFtIHtHTGNsYW1wZn0gW19hPTEuMF0gQWxwaGEgYW1vdW50IG9mIGNsZWFyaW5nIGNvbG9yXG4gICAqIEBwYXJhbSB7R0xjbGFtcGZ9IFtfZGVwdGg9MS4wXSBDbGVhcmluZyBkZXB0aFxuICAgKiBAcmV0dXJucyB7dm9pZH0gdm9pZFxuICAgKi9cbiAgY2xlYXIoIF9yLCBfZywgX2IsIF9hLCBfZGVwdGggKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcbiAgICBsZXQgZ2wgPSBpdC5nbDtcblxuICAgIGxldCByID0gX3IgfHwgMC4wO1xuICAgIGxldCBnID0gX2cgfHwgMC4wO1xuICAgIGxldCBiID0gX2IgfHwgMC4wO1xuICAgIGxldCBhID0gdHlwZW9mIF9hID09PSAnbnVtYmVyJyA/IF9hIDogMS4wO1xuICAgIGxldCBkZXB0aCA9IHR5cGVvZiBfZGVwdGggPT09ICdudW1iZXInID8gX2RlcHRoIDogMS4wO1xuXG4gICAgZ2wuY2xlYXJDb2xvciggciwgZywgYiwgYSApO1xuICAgIGdsLmNsZWFyRGVwdGgoIGRlcHRoICk7XG4gICAgZ2wuY2xlYXIoIGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUICk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdMQ2F0OyIsIi8vIOOBq+OCg+ODvOOCk1xuXG5jb25zdCBNYXRoQ2F0ID0ge307XG5cbi8qKlxuICogQWRkIHR3byB2ZWNzLlxuICogQHBhcmFtIHtudW1iZXJbXX0gYSB2ZWNOXG4gKiBAcGFyYW0ge251bWJlcltdfSBiIHZlY05cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gdmVjTiwgYGEgKyBiYFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0LnZlY0FkZCA9ICggYSwgYiApID0+IGEubWFwKCAoIGUsIGkgKSA9PiBlICsgYlsgaSBdICk7XG5cbi8qKlxuICogU3Vic3RyYWN0IGEgdmVjIGZyb20gYW4gYW5vdGhlciB2ZWMuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhIHZlY05cbiAqIEBwYXJhbSB7bnVtYmVyW119IGIgdmVjTlxuICogQHJldHVybnMge251bWJlcltdfSB2ZWNOLCBgYSAtIGJgXG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQudmVjU3ViID0gKCBhLCBiICkgPT4gYS5tYXAoICggZSwgaSApID0+IGUgLSBiWyBpIF0gKTtcblxuXG4vKipcbiAqIE11bHRpcGx5IHR3byB2ZWNzLlxuICogQHBhcmFtIHtudW1iZXJbXX0gYSB2ZWNOXG4gKiBAcGFyYW0ge251bWJlcltdfSBiIHZlY05cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gdmVjTiwgYGEgKiBiYFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0LnZlY011bCA9ICggYSwgYiApID0+IGEubWFwKCAoIGUsIGkgKSA9PiBlIC0gYlsgaSBdICk7XG5cbi8qKlxuICogUmV0dXJuIGEgY3Jvc3Mgb2YgdHdvIHZlYzNzLlxuICogQHBhcmFtIHtudW1iZXJbXX0gYSB2ZWMzXG4gKiBAcGFyYW0ge251bWJlcltdfSBiIHZlYzNcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gdmVjMywgY3Jvc3MgcHJvZHVjdCBvZiBgYWAgYW5kIGBiYFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0LnZlYzNDcm9zcyA9ICggYSwgYiApID0+IFtcbiAgYVsgMSBdICogYlsgMiBdIC0gYVsgMiBdICogYlsgMSBdLFxuICBhWyAyIF0gKiBiWyAwIF0gLSBhWyAwIF0gKiBiWyAyIF0sXG4gIGFbIDAgXSAqIGJbIDEgXSAtIGFbIDEgXSAqIGJbIDAgXVxuXTtcblxuLyoqXG4gKiBTY2FsZSBhIHZlYyBieSBzY2FsYXIuXG4gKiBAcGFyYW0ge251bWJlcn0gcyBzY2FsYXJcbiAqIEBwYXJhbSB7bnVtYmVyW119IHYgdmVjTlxuICogQHJldHVybnMge251bWJlcltdfSB2ZWNOLCBgcyAqIHZgXG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQudmVjU2NhbGUgPSAoIHMsIHYgKSA9PiB2Lm1hcCggKCBlICkgPT4gZSAqIHMgKTtcblxuLyoqXG4gKiBEb3QgdHdvIHZlY3RvcnMuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhIHZlY05cbiAqIEBwYXJhbSB7bnVtYmVyW119IGIgdmVjTlxuICogQHJldHVybnMge251bWJlcltdfSB2ZWNOLCBEb3Qgb2YgYGFgIGFuZCBgYmBcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC52ZWNEb3QgPSAoIGEsIGIgKSA9PiBhLnJlZHVjZSggKCBwLCBlLCBpICkgPT4gcCArIGUgKiBiWyBpIF0sIDAuMCApO1xuXG4vKipcbiAqIFJldHVybiBsZW5ndGggb2YgYSB2ZWMuXG4gKiBAcGFyYW0ge251bWJlcltdfSB2IHZlY05cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHNjYWxhciwgbGVuZ3RoIG9mIGB2YFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0LnZlY0xlbmd0aCA9ICggdiApID0+IE1hdGguc3FydCggdi5yZWR1Y2UoICggcCwgYyApID0+IHAgKyBjICogYywgMC4wICkgKTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMuXG4gKiBAcGFyYW0ge251bWJlcltdfSB2IHZlY05cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gdmVjLCBub3JtYWxpemVkIGB2YFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0LnZlY05vcm1hbGl6ZSA9ICggdiApID0+IE1hdGhDYXQudmVjU2NhbGUoIDEuMCAvIE1hdGhDYXQudmVjTGVuZ3RoKCB2ICksIHYgKTtcblxuLyoqXG4gKiBNdWx0aXBseSB0d28gcXVhdHMuXG4gKiBAcGFyYW0ge251bWJlcltdfSBxIHF1YXRcbiAqIEBwYXJhbSB7bnVtYmVyW119IHIgcXVhdFxuICogQHJldHVybnMge251bWJlcltdfSBxdWF0LCBwcm9kdWN0IG9mIGBhYCBhbmQgYGJgXG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQucXVhdE11bCA9ICggcSwgciApID0+IFtcbiAgcVsgMyBdICogclsgMCBdICsgcVsgMCBdICogclsgMyBdICsgcVsgMSBdICogclsgMiBdIC0gcVsgMiBdICogclsgMSBdLFxuICBxWyAzIF0gKiByWyAxIF0gLSBxWyAwIF0gKiByWyAyIF0gKyBxWyAxIF0gKiByWyAzIF0gKyBxWyAyIF0gKiByWyAwIF0sXG4gIHFbIDMgXSAqIHJbIDIgXSArIHFbIDAgXSAqIHJbIDEgXSAtIHFbIDEgXSAqIHJbIDAgXSArIHFbIDIgXSAqIHJbIDMgXSxcbiAgcVsgMyBdICogclsgMyBdIC0gcVsgMCBdICogclsgMCBdIC0gcVsgMSBdICogclsgMSBdIC0gcVsgMiBdICogclsgMiBdXG5dO1xuXG4vKipcbiAqIEludmVyc2UgYSBxdWF0LlxuICogQHBhcmFtIHtudW1iZXJbXX0gcSBxdWF0XG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHF1YXQsIGAtcWBcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5xdWF0SW52ID0gKCBxICkgPT4gWyAtcVsgMCBdLCAtcVsgMSBdLCAtcVsgMiBdLCBxWyAzIF0gXTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWMzIHVzaW5nIG9uZSBxdWF0LlxuICogQHBhcmFtIHtudW1iZXJbXX0gdiB2ZWMzXG4gKiBAcGFyYW0ge251bWJlcltdfSBxIHF1YXRcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gdmVjMywgcm90YXRlZCB2ZWN0b3JcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5yb3RhdGVWZWNCeVF1YXQgPSAoIHYsIHEgKSA9PiB7XG4gIGNvbnN0IHAgPSBbIHZbIDAgXSwgdlsgMSBdLCB2WyAyIF0sIDAuMCBdO1xuICBjb25zdCByID0gTWF0aENhdC5xdWF0SW52KCBxICk7XG4gIGNvbnN0IHJlcyA9IE1hdGhDYXQucXVhdE11bCggTWF0aENhdC5xdWF0TXVsKCBxLCBwICksIHIgKTtcbiAgcmV0dXJuIFsgcmVzWyAwIF0sIHJlc1sgMSBdLCByZXNbIDIgXSBdO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHF1YXQgaW50byBtYXQ0LlxuICogQHBhcmFtIHtudW1iZXJbXX0gcSBxdWF0XG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG1hdDQsIHJvdGF0aW9uIG1hdHJpeCBtYWRlIGZyb20gcXVhdFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0LnF1YXRUb01hdDQgPSAoIHEgKSA9PiB7XG4gIGNvbnN0IHggPSBNYXRoQ2F0LnJvdGF0ZVZlY0J5UXVhdCggWyAxLjAsIDAuMCwgMC4wIF0sIHEgKTtcbiAgY29uc3QgeSA9IE1hdGhDYXQucm90YXRlVmVjQnlRdWF0KCBbIDAuMCwgMS4wLCAwLjAgXSwgcSApO1xuICBjb25zdCB6ID0gTWF0aENhdC5yb3RhdGVWZWNCeVF1YXQoIFsgMC4wLCAwLjAsIDEuMCBdLCBxICk7XG5cbiAgcmV0dXJuIFtcbiAgICB4WyAwIF0sIHlbIDAgXSwgelsgMCBdLCAwLjAsXG4gICAgeFsgMSBdLCB5WyAxIF0sIHpbIDEgXSwgMC4wLFxuICAgIHhbIDIgXSwgeVsgMiBdLCB6WyAyIF0sIDAuMCxcbiAgICAwLjAsIDAuMCwgMC4wLCAxLjBcbiAgXTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgcXVhdCBmcm9tIGFuZ2xlIGFuZCBheGlzLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIHNjYWxhciwgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFuXG4gKiBAcGFyYW0ge251bWJlcltdfSBheGlzIHZlYzMsIFJvdGF0aW9uIGF4aXNcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gcXVhdCwgR2VuZXJhdGVkIHF1YXRlcm5pb25cbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5xdWF0QW5nbGVBeGlzID0gKCBhbmdsZSwgYXhpcyApID0+IHtcbiAgY29uc3QgaGEgPSBhbmdsZSAvIDIuMDtcbiAgY29uc3Qgc2hhID0gTWF0aC5zaW4oIGhhICk7XG4gIHJldHVybiBbXG4gICAgYXhpc1sgMCBdICogc2hhLFxuICAgIGF4aXNbIDEgXSAqIHNoYSxcbiAgICBheGlzWyAyIF0gKiBzaGEsXG4gICAgTWF0aC5jb3MoIGhhIClcbiAgXTtcbn07XG5cbi8qKlxuICogQXBwbHkgdHdvIG1hdDRzLlxuICogQHBhcmFtIHtudW1iZXJbXX0gYSBtYXQ0XG4gKiBAcGFyYW0ge251bWJlcltdfSBiIG1hdDRcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWF0NCwgQXBwbGllZCBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0QXBwbHkgPSAoIGEsIGIgKSA9PiB7XG4gIHJldHVybiBbXG4gICAgYVsgMCBdICogYlsgMCBdICsgYVsgNCBdICogYlsgMSBdICsgYVsgOCBdICogYlsgMiBdICsgYVsgMTIgXSAqIGJbIDMgXSxcbiAgICBhWyAxIF0gKiBiWyAwIF0gKyBhWyA1IF0gKiBiWyAxIF0gKyBhWyA5IF0gKiBiWyAyIF0gKyBhWyAxMyBdICogYlsgMyBdLFxuICAgIGFbIDIgXSAqIGJbIDAgXSArIGFbIDYgXSAqIGJbIDEgXSArIGFbIDEwIF0gKiBiWyAyIF0gKyBhWyAxNCBdICogYlsgMyBdLFxuICAgIGFbIDMgXSAqIGJbIDAgXSArIGFbIDcgXSAqIGJbIDEgXSArIGFbIDExIF0gKiBiWyAyIF0gKyBhWyAxNSBdICogYlsgMyBdLFxuXG4gICAgYVsgMCBdICogYlsgNCBdICsgYVsgNCBdICogYlsgNSBdICsgYVsgOCBdICogYlsgNiBdICsgYVsgMTIgXSAqIGJbIDcgXSxcbiAgICBhWyAxIF0gKiBiWyA0IF0gKyBhWyA1IF0gKiBiWyA1IF0gKyBhWyA5IF0gKiBiWyA2IF0gKyBhWyAxMyBdICogYlsgNyBdLFxuICAgIGFbIDIgXSAqIGJbIDQgXSArIGFbIDYgXSAqIGJbIDUgXSArIGFbIDEwIF0gKiBiWyA2IF0gKyBhWyAxNCBdICogYlsgNyBdLFxuICAgIGFbIDMgXSAqIGJbIDQgXSArIGFbIDcgXSAqIGJbIDUgXSArIGFbIDExIF0gKiBiWyA2IF0gKyBhWyAxNSBdICogYlsgNyBdLFxuXG4gICAgYVsgMCBdICogYlsgOCBdICsgYVsgNCBdICogYlsgOSBdICsgYVsgOCBdICogYlsgMTAgXSArIGFbIDEyIF0gKiBiWyAxMSBdLFxuICAgIGFbIDEgXSAqIGJbIDggXSArIGFbIDUgXSAqIGJbIDkgXSArIGFbIDkgXSAqIGJbIDEwIF0gKyBhWyAxMyBdICogYlsgMTEgXSxcbiAgICBhWyAyIF0gKiBiWyA4IF0gKyBhWyA2IF0gKiBiWyA5IF0gKyBhWyAxMCBdICogYlsgMTAgXSArIGFbIDE0IF0gKiBiWyAxMSBdLFxuICAgIGFbIDMgXSAqIGJbIDggXSArIGFbIDcgXSAqIGJbIDkgXSArIGFbIDExIF0gKiBiWyAxMCBdICsgYVsgMTUgXSAqIGJbIDExIF0sXG5cbiAgICBhWyAwIF0gKiBiWyAxMiBdICsgYVsgNCBdICogYlsgMTMgXSArIGFbIDggXSAqIGJbIDE0IF0gKyBhWyAxMiBdICogYlsgMTUgXSxcbiAgICBhWyAxIF0gKiBiWyAxMiBdICsgYVsgNSBdICogYlsgMTMgXSArIGFbIDkgXSAqIGJbIDE0IF0gKyBhWyAxMyBdICogYlsgMTUgXSxcbiAgICBhWyAyIF0gKiBiWyAxMiBdICsgYVsgNiBdICogYlsgMTMgXSArIGFbIDEwIF0gKiBiWyAxNCBdICsgYVsgMTQgXSAqIGJbIDE1IF0sXG4gICAgYVsgMyBdICogYlsgMTIgXSArIGFbIDcgXSAqIGJbIDEzIF0gKyBhWyAxMSBdICogYlsgMTQgXSArIGFbIDE1IF0gKiBiWyAxNSBdXG4gIF07XG59O1xuXG4vKipcbiAqIEludmVydCBhIG1hdDQuXG4gKiBAcGFyYW0ge251bWJlcltdfSBtIG1hdDRcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWF0NCwgSW52ZXJ0ZWQgbWF0cml4XG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQubWF0NEludmVyc2UgPSAoIG0gKSA9PiB7XG4gIGNvbnN0XG4gICAgYTAwID0gbVsgIDAgXSwgYTAxID0gbVsgIDEgXSwgYTAyID0gbVsgIDIgXSwgYTAzID0gbVsgIDMgXSxcbiAgICBhMTAgPSBtWyAgNCBdLCBhMTEgPSBtWyAgNSBdLCBhMTIgPSBtWyAgNiBdLCBhMTMgPSBtWyAgNyBdLFxuICAgIGEyMCA9IG1bICA4IF0sIGEyMSA9IG1bICA5IF0sIGEyMiA9IG1bIDEwIF0sIGEyMyA9IG1bIDExIF0sXG4gICAgYTMwID0gbVsgMTIgXSwgYTMxID0gbVsgMTMgXSwgYTMyID0gbVsgMTQgXSwgYTMzID0gbVsgMTUgXSxcbiAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLCAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSwgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLCAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSwgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICByZXR1cm4gTWF0aENhdC52ZWNTY2FsZSggMS4wIC8gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2LCBbXG4gICAgYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5LFxuICAgIGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSxcbiAgICBhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMsXG4gICAgYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzLFxuICAgIGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNyxcbiAgICBhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcsXG4gICAgYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxLFxuICAgIGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSxcbiAgICBhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYsXG4gICAgYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2LFxuICAgIGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCxcbiAgICBhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDAsXG4gICAgYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2LFxuICAgIGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNixcbiAgICBhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDAsXG4gICAgYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwXG4gIF0gKTtcbn07XG5cbi8qKlxuICogQXBwbHkgYSBtYXQ0IHRvIGEgdmVjNC5cbiAqIEBwYXJhbSB7bnVtYmVyW119IG0gbWF0NFxuICogQHBhcmFtIHtudW1iZXJbXX0gdiB2ZWM0XG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHZlYzQsIEFwcGxpZWQgdmVjdG9yXG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQubWF0NEFwcGx5VG9WZWM0ID0gKCBtLCB2ICkgPT4ge1xuICByZXR1cm4gW1xuICAgIG1bIDAgXSAqIHZbIDAgXSArIG1bIDQgXSAqIHZbIDEgXSArIG1bIDggXSAqIHZbIDIgXSArIG1bIDEyIF0gKiB2WyAzIF0sXG4gICAgbVsgMSBdICogdlsgMCBdICsgbVsgNSBdICogdlsgMSBdICsgbVsgOSBdICogdlsgMiBdICsgbVsgMTMgXSAqIHZbIDMgXSxcbiAgICBtWyAyIF0gKiB2WyAwIF0gKyBtWyA2IF0gKiB2WyAxIF0gKyBtWyAxMCBdICogdlsgMiBdICsgbVsgMTQgXSAqIHZbIDMgXSxcbiAgICBtWyAzIF0gKiB2WyAwIF0gKyBtWyA3IF0gKiB2WyAxIF0gKyBtWyAxMSBdICogdlsgMiBdICsgbVsgMTUgXSAqIHZbIDMgXVxuICBdO1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgYSBtYXQ0LlxuICogQHBhcmFtIHtudW1iZXJbXX0gbSBtYXQ0XG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG1hdDQsIFRyYW5zcG9zZWQgbWF0cml4XG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQubWF0NFRyYW5zcG9zZSA9ICggbSApID0+IFtcbiAgbVsgMCBdLCBtWyA0IF0sIG1bIDggXSwgbVsgMTIgXSxcbiAgbVsgMSBdLCBtWyA1IF0sIG1bIDkgXSwgbVsgMTMgXSxcbiAgbVsgMiBdLCBtWyA2IF0sIG1bIDEwIF0sIG1bIDE0IF0sXG4gIG1bIDMgXSwgbVsgNyBdLCBtWyAxMSBdLCBtWyAxNSBdXG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFuIGluZGVudGl0eSBtYXQ0LlxuICogQHJldHVybnMge251bWJlcltdfSBtYXQ0LCBJZGVudGl0eSBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0SWRlbnRpdHkgPSAoKSA9PiBbIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEgXTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIDNkIHRyYW5zbGF0ZSBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcltdfSB2IHZlYzMsIFRyYW5zbGF0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG1hdDQsIEdlbmVyYXRlZCBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0VHJhbnNsYXRlID0gKCB2ICkgPT4gW1xuICAxLCAwLCAwLCAwLFxuICAwLCAxLCAwLCAwLFxuICAwLCAwLCAxLCAwLFxuICB2WyAwIF0sIHZbIDEgXSwgdlsgMiBdLCAxXG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgM2Qgc2NhbGUgbWF0cml4LiAgXG4gKiBTZWUgYWxzbzoge0BsaW5rIE1hdGhDYXQjbWF0NFNjYWxlWFlafVxuICogQHBhcmFtIHtudW1iZXJbXX0gdiB2ZWMzLCBTY2FsaW5nXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG1hdDQsIEdlbmVyYXRlZCBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0U2NhbGUgPSAoIHYgKSA9PiBbXG4gIHZbIDAgXSwgMCwgMCwgMCxcbiAgMCwgdlsgMSBdLCAwLCAwLFxuICAwLCAwLCB2WyAyIF0sIDAsXG4gIDAsIDAsIDAsIDFcbl07XG5cbi8qKlxuICogR2VuZXJhdGUgYSAzZCBzY2FsZSBtYXRyaXguICBcbiAqIFNlZSBhbHNvOiB7QGxpbmsgTWF0aENhdCNtYXQ0U2NhbGV9XG4gKiBAcGFyYW0ge251bWJlcltdfSBzIHNjYWxhciwgU2NhbGluZ1xuICogQHJldHVybnMge251bWJlcltdfSBtYXQ0LCBHZW5lcmF0ZWQgbWF0cml4XG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQubWF0NFNjYWxlWFlaID0gKCBzICkgPT4gW1xuICBzLCAwLCAwLCAwLFxuICAwLCBzLCAwLCAwLFxuICAwLCAwLCBzLCAwLFxuICAwLCAwLCAwLCAxXG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgM2Qgcm90YXRpb24gbWF0cml4LiAgXG4gKiAyZCByb3RhdGlvbiBhcm91bmQgeCBheGlzLlxuICogQHBhcmFtIHtudW1iZXJbXX0gdCBzY2FsYXIsIFJvdGF0aW9uIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gbWF0NCwgR2VuZXJhdGVkIG1hdHJpeFxuICogQHN0YXRpY1xuICovXG5NYXRoQ2F0Lm1hdDRSb3RhdGVYID0gKCB0ICkgPT4gW1xuICAxLCAwLCAwLCAwLFxuICAwLCBNYXRoLmNvcyggdCApLCAtTWF0aC5zaW4oIHQgKSwgMCxcbiAgMCwgTWF0aC5zaW4oIHQgKSwgTWF0aC5jb3MoIHQgKSwgMCxcbiAgMCwgMCwgMCwgMVxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIDNkIHJvdGF0aW9uIG1hdHJpeC4gIFxuICogMmQgcm90YXRpb24gYXJvdW5kIHkgYXhpcy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IHQgc2NhbGFyLCBSb3RhdGlvbiBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG1hdDQsIEdlbmVyYXRlZCBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0Um90YXRlWSA9ICggdCApID0+IFtcbiAgTWF0aC5jb3MoIHQgKSwgMCwgTWF0aC5zaW4oIHQgKSwgMCxcbiAgMCwgMSwgMCwgMCxcbiAgLU1hdGguc2luKCB0ICksIDAsIE1hdGguY29zKCB0ICksIDAsXG4gIDAsIDAsIDAsIDFcbl07XG5cbi8qKlxuICogR2VuZXJhdGUgYSAzZCByb3RhdGlvbiBtYXRyaXguICBcbiAqIDJkIHJvdGF0aW9uIGFyb3VuZCB6IGF4aXMuXG4gKiBAcGFyYW0ge251bWJlcltdfSB0IHNjYWxhciwgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge251bWJlcltdfSBtYXQ0LCBHZW5lcmF0ZWQgbWF0cml4XG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQubWF0NFJvdGF0ZVogPSAoIHQgKSA9PiBbXG4gIE1hdGguY29zKCB0ICksIC1NYXRoLnNpbiggdCApLCAwLCAwLFxuICBNYXRoLnNpbiggdCApLCBNYXRoLmNvcyggdCApLCAwLCAwLFxuICAwLCAwLCAxLCAwLFxuICAwLCAwLCAwLCAxXG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgXCJMb29rQXRcIiB2aWV3IG1hdHJpeC5cbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvcyB2ZWMzLCBQb3NpdGlvblxuICogQHBhcmFtIHtudW1iZXJbXX0gdGFyIHZlYzMsIFRhcmdldFxuICogQHBhcmFtIHtudW1iZXJbXX0gW2Fpcj1bIDAuMCwgMS4wLCAwLjAgXV0gdmVjMywgVXAgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gW3JvdD0wLjBdIHNjYWxhciwgUm9sbC4geWVhaGhoaCBJIHRoaW5rIHN1Y2ggbG9va0F0IGdlbmVyYXRvciBzaG91bGQgaGF2ZSByb2xsIHBhcmFtZXRlclxuICogQHJldHVybnMge251bWJlcltdfSBtYXQ0LCBHZW5lcmF0ZWQgbWF0cml4XG4gKiBAc3RhdGljXG4gKi9cbk1hdGhDYXQubWF0NExvb2tBdCA9ICggcG9zLCB0YXIsIGFpciwgcm90ICkgPT4ge1xuICBjb25zdCBkaXIgPSBNYXRoQ2F0LnZlY05vcm1hbGl6ZSggTWF0aENhdC52ZWNTdWIoIHRhciwgcG9zICkgKTtcbiAgbGV0IHNpZCA9IE1hdGhDYXQudmVjTm9ybWFsaXplKCBNYXRoQ2F0LnZlYzNDcm9zcyggZGlyLCBhaXIgfHwgWyAwLjAsIDEuMCwgMC4wIF0gKSApO1xuICBsZXQgdG9wID0gTWF0aENhdC52ZWMzQ3Jvc3MoIHNpZCwgZGlyICk7XG4gIHNpZCA9IE1hdGhDYXQudmVjQWRkKFxuICAgIE1hdGhDYXQudmVjU2NhbGUoIE1hdGguY29zKCByb3QgfHwgMC4wICksIHNpZCApLFxuICAgIE1hdGhDYXQudmVjU2NhbGUoIE1hdGguc2luKCByb3QgfHwgMC4wICksIHRvcCApXG4gICk7XG4gIHRvcCA9IE1hdGhDYXQudmVjM0Nyb3NzKCBzaWQsIGRpciApO1xuXG4gIHJldHVybiBbXG4gICAgc2lkWyAwIF0sIHRvcFsgMCBdLCBkaXJbIDAgXSwgMC4wLFxuICAgIHNpZFsgMSBdLCB0b3BbIDEgXSwgZGlyWyAxIF0sIDAuMCxcbiAgICBzaWRbIDIgXSwgdG9wWyAyIF0sIGRpclsgMiBdLCAwLjAsXG4gICAgLXNpZFsgMCBdICogcG9zWyAwIF0gLSBzaWRbIDEgXSAqIHBvc1sgMSBdIC0gc2lkWyAyIF0gKiBwb3NbIDIgXSxcbiAgICAtdG9wWyAwIF0gKiBwb3NbIDAgXSAtIHRvcFsgMSBdICogcG9zWyAxIF0gLSB0b3BbIDIgXSAqIHBvc1sgMiBdLFxuICAgIC1kaXJbIDAgXSAqIHBvc1sgMCBdIC0gZGlyWyAxIF0gKiBwb3NbIDEgXSAtIGRpclsgMiBdICogcG9zWyAyIF0sXG4gICAgMS4wXG4gIF07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgXCJQZXJzcGVjdGl2ZVwiIHByb2plY3Rpb24gbWF0cml4LiAgXG4gKiBJdCB3b24ndCBpbmNsdWRlIGFzcGVjdCFcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Ygc2NhbGFyXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBzY2FsYXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgc2NhbGFyXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IG1hdDQsIEdlbmVyYXRlZCBtYXRyaXhcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aENhdC5tYXQ0UGVyc3BlY3RpdmUgPSAoIGZvdiwgbmVhciwgZmFyICkgPT4ge1xuICBjb25zdCBwID0gMS4wIC8gTWF0aC50YW4oIGZvdiAqIE1hdGguUEkgLyAzNjAuMCApO1xuICBjb25zdCBkID0gKCBmYXIgLSBuZWFyICk7XG4gIHJldHVybiBbXG4gICAgcCwgMC4wLCAwLjAsIDAuMCxcbiAgICAwLjAsIHAsIDAuMCwgMC4wLFxuICAgIDAuMCwgMC4wLCAoIGZhciArIG5lYXIgKSAvIGQsIDEuMCxcbiAgICAwLjAsIDAuMCwgLTIgKiBmYXIgKiBuZWFyIC8gZCwgMC4wXG4gIF07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNYXRoQ2F0OyIsIi8vIOOBiuWJjeOAgeODiuODs+ODh+ODouOCouODquOBi+OCiO+8gVxuXG5jb25zdCBVbHRyYUNhdCA9IHt9O1xuXG5VbHRyYUNhdC50cmlhbmdsZVN0cmlwUXVhZCA9IFsgLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDEgXTtcblVsdHJhQ2F0LnRyaWFuZ2xlU3RyaXBRdWFkMyA9IFsgLTEsIC0xLCAwLCAxLCAtMSwgMCwgLTEsIDEsIDAsIDEsIDEsIDAgXTtcblVsdHJhQ2F0LnRyaWFuZ2xlU3RyaXBRdWFkTm9yID0gWyAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxIF07XG5VbHRyYUNhdC50cmlhbmdsZVN0cmlwUXVhZFVWID0gWyAwLCAwLCAxLCAwLCAwLCAxLCAxLCAxIF07XG5cbi8vIGRlc3RydWN0aXZlXG5VbHRyYUNhdC5zaHVmZmxlQXJyYXlEID0gKCBhcnJheSwgZGljZSApID0+IHtcbiAgY29uc3QgZiA9IGRpY2UgPyBkaWNlIDogKCkgPT4gTWF0aC5yYW5kb20oKTtcbiAgZm9yICggbGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoIC0gMTsgaSArKyApIHtcbiAgICBjb25zdCBpciA9IGkgKyBNYXRoLmZsb29yKCBmKCkgKiAoIGFycmF5Lmxlbmd0aCAtIGkgKSApO1xuICAgIGNvbnN0IHRlbXAgPSBhcnJheVsgaXIgXTtcbiAgICBhcnJheVsgaXIgXSA9IGFycmF5WyBpIF07XG4gICAgYXJyYXlbIGkgXSA9IHRlbXA7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuVWx0cmFDYXQudHJpSW5kZXhUb0xpbmVJbmRleCA9ICggYXJyYXkgKSA9PiB7XG4gIGxldCByZXQgPSBbXTtcbiAgZm9yICggbGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoIC8gMzsgaSArKyApIHtcbiAgICBjb25zdCBoZWFkID0gaSAqIDM7XG4gICAgcmV0LnB1c2goXG4gICAgICBhcnJheVsgaGVhZCAgICAgXSwgYXJyYXlbIGhlYWQgKyAxIF0sXG4gICAgICBhcnJheVsgaGVhZCArIDEgXSwgYXJyYXlbIGhlYWQgKyAyIF0sXG4gICAgICBhcnJheVsgaGVhZCArIDIgXSwgYXJyYXlbIGhlYWQgICAgIF1cbiAgICApO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5VbHRyYUNhdC5tYXRyaXgyZCA9ICggdywgaCApID0+IHtcbiAgbGV0IGFyciA9IFtdO1xuICBmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGg7IGl5ICsrICkge1xuICAgIGZvciAoIGxldCBpeCA9IDA7IGl4IDwgdzsgaXggKysgKSB7XG4gICAgICBhcnIucHVzaCggaXgsIGl5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5VbHRyYUNhdC5sZXJwID0gKCBhLCBiLCB4ICkgPT4gYSArICggYiAtIGEgKSAqIHg7XG5VbHRyYUNhdC5jbGFtcCA9ICggeCwgbCwgaCApID0+IE1hdGgubWluKCBNYXRoLm1heCggeCwgbCApLCBoICk7XG5VbHRyYUNhdC5zYXR1cmF0ZSA9ICggeCApID0+IE1hdGgubWluKCBNYXRoLm1heCggeCwgMC4wICksIDEuMCApO1xuVWx0cmFDYXQubGluZWFyc3RlcCA9ICggYSwgYiwgeCApID0+IFVsdHJhQ2F0LnNhdHVyYXRlKCAoIHggLSBhICkgLyAoIGIgLSBhICkgKTtcblVsdHJhQ2F0LnNtb290aHN0ZXAgPSAoIGEsIGIsIHggKSA9PiB7XG4gIGNvbnN0IHQgPSBVbHRyYUNhdC5saW5lYXJzdGVwKCBhLCBiLCB4ICk7XG4gIHJldHVybiB0ICogdCAqICggMy4wIC0gMi4wICogdCApO1xufTtcblxuVWx0cmFDYXQuRXhwU21vb3RoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciggZmFjdG9yICkge1xuICAgIHRoaXMuZmFjdG9yID0gZmFjdG9yO1xuICAgIHRoaXMudmFsdWUgPSAwLjA7XG4gIH1cblxuICB1cGRhdGUoIHZhbHVlLCBkdCApIHtcbiAgICB0aGlzLnZhbHVlID0gVWx0cmFDYXQubGVycCggdmFsdWUsIHRoaXMudmFsdWUsIE1hdGguZXhwKCAtdGhpcy5mYWN0b3IgKiBkdCApICk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFVsdHJhQ2F0OyIsImNvbnN0IFhvcnNoaWZ0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciggX3NlZWQgKSB7XG4gICAgdGhpcy5zZXQoIF9zZWVkICk7XG4gIH1cblxuICBnZW4oIF9zZWVkICkge1xuICAgIGlmICggX3NlZWQgKSB7IHRoaXMuc2V0KCBfc2VlZCApOyB9XG4gICAgdGhpcy5zZWVkID0gdGhpcy5zZWVkIF4gKCB0aGlzLnNlZWQgPDwgMTMgKTtcbiAgICB0aGlzLnNlZWQgPSB0aGlzLnNlZWQgXiAoIHRoaXMuc2VlZCA+Pj4gMTcgKTtcbiAgICB0aGlzLnNlZWQgPSB0aGlzLnNlZWQgXiAoIHRoaXMuc2VlZCA8PCA1ICk7XG4gICAgcmV0dXJuIHRoaXMuc2VlZCAvIE1hdGgucG93KCAyLCAzMiApICsgMC41O1xuICB9XG5cbiAgc2V0KCBfc2VlZCApIHtcbiAgICB0aGlzLnNlZWQgPSBfc2VlZCB8fCB0aGlzLnNlZWQgfHwgMTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgWG9yc2hpZnQ7IiwiaW1wb3J0ICcuL3N0eWxlcy9tYWluLnNjc3MnO1xuXG4vLyA9PSBpbXBvcnQgdmFyaW91cyBtb2R1bGVzIC8gc3R1ZmYgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuaW1wb3J0IEdMQ2F0IGZyb20gJy4vbGlicy9nbGNhdC5qcyc7XG5pbXBvcnQgR0xDYXRQYXRoIGZyb20gJy4vbGlicy9nbGNhdC1wYXRoLWd1aSc7XG5pbXBvcnQgTWF0aENhdCBmcm9tICcuL2xpYnMvbWF0aGNhdC5qcyc7XG5pbXBvcnQgVWx0cmFDYXQgZnJvbSAnLi9saWJzL3VsdHJhY2F0LmpzJztcbmltcG9ydCBBdXRvbWF0b24gZnJvbSAnQGZtcy1jYXQvYXV0b21hdG9uJztcbmltcG9ydCBDYW52YXNTYXZlciBmcm9tICcuL2xpYnMvY2FudmFzLXNhdmVyJztcblxuaW1wb3J0IENPTkZJRyBmcm9tICcuL2NvbmZpZy5qc29uJztcblxuLy8gPT0gd2UgYXJlIHN0dWxsIHN0cnVnZ2xpbmcgYnkgdGhpcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0ICQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yLmJpbmQoIGRvY3VtZW50ICk7XG5cbi8vID09IGhpIGNhbnZhcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBjYW52YXMgPSAkKCAnI2NhbnZhcycgKTtcbmxldCB3aWR0aCA9IGNhbnZhcy53aWR0aCA9IENPTkZJRy5yZXNvbHV0aW9uWyAwIF07XG5sZXQgaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IENPTkZJRy5yZXNvbHV0aW9uWyAxIF07XG5cbmNvbnN0IHNhdmVyID0gbmV3IENhbnZhc1NhdmVyKCBjYW52YXMgKTtcblxuY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApO1xuZ2wubGluZVdpZHRoKCAxICk7IC8vIGVcblxuY29uc3QgZ2xDYXQgPSBuZXcgR0xDYXQoIGdsICk7XG5nbENhdC5nZXRFeHRlbnNpb24oICdPRVNfdGV4dHVyZV9mbG9hdCcsIHRydWUgKTtcbmdsQ2F0LmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicsIHRydWUgKTtcbmdsQ2F0LmdldEV4dGVuc2lvbiggJ0VYVF9mcmFnX2RlcHRoJywgdHJ1ZSApO1xuZ2xDYXQuZ2V0RXh0ZW5zaW9uKCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycsIHRydWUgKTtcblxuY29uc3QgZ2xDYXRQYXRoID0gbmV3IEdMQ2F0UGF0aCggZ2xDYXQsIHtcbiAgZWw6ICQoICcjZGl2UGF0aCcgKSxcbiAgY2FudmFzOiBjYW52YXMsXG4gIHN0cmV0Y2g6IHRydWUsXG4gIGRyYXdidWZmZXJzOiB0cnVlXG59ICk7XG5cbi8vIG9oIGhpXG5jb25zdCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBuZXcgRmxvYXQzMkFycmF5KCBVbHRyYUNhdC50cmlhbmdsZVN0cmlwUXVhZCApICk7XG5cbi8vID09IGhlbGxvIGF1dG9tYXRvbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5sZXQgdG90YWxGcmFtZSA9IDA7XG5sZXQgaXNJbml0aWFsRnJhbWUgPSB0cnVlO1xuXG5jb25zdCBhdXRvbWF0b24gPSBuZXcgQXV0b21hdG9uKCB7XG4gIGxvb3A6IHRydWUsXG4gIGZwczogMTIwLFxuICBndWk6ICQoICcjZGl2QXV0b21hdG9uJyApLFxuICBkYXRhOiByZXF1aXJlKCAnLi9hdXRvbWF0b24uanNvbicgKVxufSApO1xuY29uc3QgYXV0byA9IGF1dG9tYXRvbi5hdXRvO1xuXG5pZiAoIG1vZHVsZS5ob3QgKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICcuL2F1dG9tYXRvbi5qc29uJyxcbiAgICAoKSA9PiBhdXRvbWF0b24ubG9hZCggcmVxdWlyZSggJy4vYXV0b21hdG9uLmpzb24nICkgKVxuICApO1xufVxuXG4vLyA9PSBsaWdodHMsIGNhbWVyYSwgYWN0aW9uISA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxubGV0IGNhbWVyYVBvcyA9IFsgMC4wLCAwLjAsIDAuMCBdO1xubGV0IGNhbWVyYVRhciA9IFsgMC4wLCAwLjAsIDAuMCBdO1xubGV0IGNhbWVyYVJvbGwgPSAwLjA7IC8vIHByb3RpcDogY29uc2lkZXJpbmcgcm9sbCBvZiBjYW0gaXMgY29vbCBpZGVhXG5cbmxldCBwZXJzcEZvdiA9IDcwLjA7XG5sZXQgcGVyc3BOZWFyID0gMC4wMTtcbmxldCBwZXJzcEZhciA9IDEwMC4wO1xuXG5sZXQgbGlnaHRQb3MgPSBbIDUuMCwgNS4wLCAxMC4wIF07IC8vIHRoaXMgaXMgcHJldHR5IHJhbmRvbVxuXG5jb25zdCBzaGFkb3dSZXNvID0gQ09ORklHLnNoYWRvd1Jlc287IC8vIHRleHR1cmUgc2l6ZSBmb3Igc2hhZG93IGJ1ZmZlclxuXG5sZXQgbWF0UCA9IE1hdGhDYXQubWF0NFBlcnNwZWN0aXZlKCBwZXJzcEZvdiwgcGVyc3BOZWFyLCBwZXJzcEZhciApO1xubGV0IG1hdFYgPSBNYXRoQ2F0Lm1hdDRMb29rQXQoIGNhbWVyYVBvcywgY2FtZXJhVGFyLCBbIDAuMCwgMS4wLCAwLjAgXSwgY2FtZXJhUm9sbCApO1xubGV0IG1hdFBMID0gTWF0aENhdC5tYXQ0UGVyc3BlY3RpdmUoIHBlcnNwRm92LCBwZXJzcE5lYXIsIHBlcnNwRmFyICk7XG5sZXQgbWF0VkwgPSBNYXRoQ2F0Lm1hdDRMb29rQXQoIGxpZ2h0UG9zLCBjYW1lcmFUYXIsIFsgMC4wLCAxLjAsIDAuMCBdLCAwLjAgKTtcblxuY29uc3QgdXBkYXRlTWF0cmljZXMgPSAoIGNhbU9mZnNldCApID0+IHtcbiAgY2FtZXJhUG9zID0gWyAwLjAsIDAuMCwgYXV0byggJ2NhbWVyYS1SYWRpdXMnICkgXTtcbiAgY2FtZXJhUG9zID0gTWF0aENhdC5yb3RhdGVWZWNCeVF1YXQoIGNhbWVyYVBvcywgTWF0aENhdC5xdWF0QW5nbGVBeGlzKCBhdXRvKCAnY2FtZXJhLXJvdFgnLCB7IHNtb290aDogMTAuMCB9ICkgLSAwLjUsIFsgMS4wLCAwLjAsIDAuMCBdICkgKTtcbiAgY2FtZXJhUG9zID0gTWF0aENhdC5yb3RhdGVWZWNCeVF1YXQoIGNhbWVyYVBvcywgTWF0aENhdC5xdWF0QW5nbGVBeGlzKCBhdXRvKCAnY2FtZXJhLXJvdFknLCB7IHNtb290aDogMTAuMCB9ICkgLSAwLjUsIFsgMC4wLCAxLjAsIDAuMCBdICkgKTtcbiAgaWYgKCBjYW1PZmZzZXQgKSB7IGNhbWVyYVBvcyA9IE1hdGhDYXQudmVjQWRkKCBjYW1lcmFQb3MsIGNhbU9mZnNldCApOyB9XG5cbiAgbWF0UCA9IE1hdGhDYXQubWF0NFBlcnNwZWN0aXZlKCBwZXJzcEZvdiwgcGVyc3BOZWFyLCBwZXJzcEZhciApO1xuICBtYXRWID0gTWF0aENhdC5tYXQ0TG9va0F0KCBjYW1lcmFQb3MsIGNhbWVyYVRhciwgWyAwLjAsIDEuMCwgMC4wIF0sIGNhbWVyYVJvbGwgKTtcblxuICBtYXRQTCA9IE1hdGhDYXQubWF0NFBlcnNwZWN0aXZlKCBwZXJzcEZvdiwgcGVyc3BOZWFyLCBwZXJzcEZhciApO1xuICBtYXRWTCA9IE1hdGhDYXQubWF0NExvb2tBdCggbGlnaHRQb3MsIGNhbWVyYVRhciwgWyAwLjAsIDEuMCwgMC4wIF0sIDAuMCApO1xufTtcbnVwZGF0ZU1hdHJpY2VzKCk7XG5cbi8vID09IG1vdXNlIGxpc3RlbmVyLCB3aHkgdGhvID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5sZXQgbW91c2VYID0gMC4wO1xubGV0IG1vdXNlWSA9IDAuMDtcblxuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCAoIGV2ZW50ICkgPT4ge1xuICBtb3VzZVggPSBldmVudC5vZmZzZXRYO1xuICBtb3VzZVkgPSBldmVudC5vZmZzZXRZO1xufSApO1xuXG4vLyA9PSBnbG9iYWwgdW5pZm9ybSB2YXJpYWJsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZ2xDYXRQYXRoLnNldEdsb2JhbEZ1bmMoICgpID0+IHtcbiAgZ2xDYXQudW5pZm9ybTFpKCAnaXNJbml0aWFsRnJhbWUnLCBpc0luaXRpYWxGcmFtZSApO1xuXG4gIGdsQ2F0LnVuaWZvcm0xZiggJ3RpbWUnLCBhdXRvbWF0b24udGltZSApO1xuICBnbENhdC51bmlmb3JtMWYoICdkZWx0YVRpbWUnLCBhdXRvbWF0b24uZGVsdGFUaW1lICogYXV0byggJ2RlbHRhVGltZS1tdWx0aXBsaWVyJyApICk7XG4gIGdsQ2F0LnVuaWZvcm0xZiggJ3RvdGFsRnJhbWUnLCB0b3RhbEZyYW1lICk7XG5cbiAgZ2xDYXQudW5pZm9ybTNmdiggJ2NhbWVyYVBvcycsIGNhbWVyYVBvcyApO1xuICBnbENhdC51bmlmb3JtM2Z2KCAnY2FtZXJhVGFyJywgY2FtZXJhVGFyICk7XG4gIGdsQ2F0LnVuaWZvcm0xZiggJ2NhbWVyYVJvbGwnLCBjYW1lcmFSb2xsICk7XG5cbiAgZ2xDYXQudW5pZm9ybTFmKCAncGVyc3BGb3YnLCBwZXJzcEZvdiApO1xuICBnbENhdC51bmlmb3JtMWYoICdwZXJzcE5lYXInLCBwZXJzcE5lYXIgKTtcbiAgZ2xDYXQudW5pZm9ybTFmKCAncGVyc3BGYXInLCBwZXJzcEZhciApO1xuXG4gIGdsQ2F0LnVuaWZvcm0zZnYoICdsaWdodFBvcycsIGxpZ2h0UG9zICk7XG5cbiAgZ2xDYXQudW5pZm9ybU1hdHJpeDRmdiggJ21hdFAnLCBtYXRQICk7XG4gIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRWJywgbWF0ViApO1xuICBnbENhdC51bmlmb3JtTWF0cml4NGZ2KCAnbWF0UEwnLCBtYXRQTCApO1xuICBnbENhdC51bmlmb3JtTWF0cml4NGZ2KCAnbWF0VkwnLCBtYXRWTCApO1xuXG4gIGdsQ2F0LnVuaWZvcm0yZnYoICdtb3VzZScsIFsgbW91c2VYLCBtb3VzZVkgXSApO1xuXG4gIGdsQ2F0LnVuaWZvcm00ZnYoICdiZ0NvbG9yJywgWyAwLjAsIDAuMCwgMC4wLCAxLjAgXSApO1xufSApO1xuXG4vLyA9PSBnbGNhdC1wYXRoIHNldHVwID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZ2xDYXRQYXRoLmFkZCgge1xuICByZXR1cm46IHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdmVydDogcmVxdWlyZSggJy4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgZnJhZzogcmVxdWlyZSggJy4vc2hhZGVycy9yZXR1cm4uZnJhZycgKSxcbiAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAxLjAgXSxcbiAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgcGFyYW1zLmlucHV0LCAwICk7XG4gICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgIH1cbiAgfSxcblxuICBpbnNwZWN0b3I6IHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdmVydDogcmVxdWlyZSggJy4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgZnJhZzogcmVxdWlyZSggJy4vc2hhZGVycy9pbnNwZWN0b3IuZnJhZycgKSxcbiAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAxLjAgXSxcbiAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICBnbENhdC51bmlmb3JtM2Z2KCAnY2lyY2xlQ29sb3InLCBbIDEuMCwgMS4wLCAxLjAgXSApO1xuICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhcmFtcy5pbnB1dCwgMCApO1xuICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICB9XG4gIH0sXG5cbiAgdGFyZ2V0OiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHZlcnQ6IHJlcXVpcmUoICcuL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgIGZyYWc6IHJlcXVpcmUoICcuL3NoYWRlcnMvYmcuZnJhZycgKSxcbiAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAxLjAgXSxcbiAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICBmbG9hdDogdHJ1ZSxcbiAgICBkcmF3YnVmZmVyczogMixcbiAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICBmdW5jOiAoKSA9PiB7XG4gICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICB9XG4gIH0sXG5cbiAgc2hhZG93OiB7XG4gICAgd2lkdGg6IHNoYWRvd1Jlc28sXG4gICAgaGVpZ2h0OiBzaGFkb3dSZXNvLFxuICAgIHZlcnQ6IHJlcXVpcmUoICcuL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgIGZyYWc6IHJlcXVpcmUoICcuL3NoYWRlcnMvYmcuZnJhZycgKSxcbiAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICBjbGVhcjogWyBwZXJzcEZhciwgMC4wLCAwLjAsIDEuMCBdLFxuICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgIGZsb2F0OiB0cnVlLFxuICAgIGZ1bmM6ICgpID0+IHtcbiAgICAgIC8vIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICAvLyBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgIH1cbiAgfSxcbn0gKTtcblxuLy8gPT0gc2V0dXAgcGF0aHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IGNvbnRleHQgPSB7XG4gIGdsQ2F0UGF0aDogZ2xDYXRQYXRoLFxuICBhdXRvbWF0b246IGF1dG9tYXRvbixcbiAgd2lkdGg6IHdpZHRoLFxuICBoZWlnaHQ6IGhlaWdodFxufTtcblxucmVxdWlyZSggJy4vcGF0aHMvYmxvb20nICkuZGVmYXVsdCggY29udGV4dCApO1xucmVxdWlyZSggJy4vcGF0aHMvYm94JyApLmRlZmF1bHQoIGNvbnRleHQgKTtcbnJlcXVpcmUoICcuL3BhdGhzL3BpeGVsc29ydCcgKS5kZWZhdWx0KCBjb250ZXh0ICk7XG5yZXF1aXJlKCAnLi9wYXRocy9wYXJ0aWNsZXMnICkuZGVmYXVsdCggY29udGV4dCApO1xucmVxdWlyZSggJy4vcGF0aHMvcG9zdGZ4JyApLmRlZmF1bHQoIGNvbnRleHQgKTtcblxuLy8gPT0gbG9vcCBoZXJlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgaWYgKCAhJCggJyNhY3RpdmUnICkuY2hlY2tlZCApIHtcbiAgICBzZXRUaW1lb3V0KCB1cGRhdGUsIDEwMCApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vID09IHVwZGF0ZSBzb21lIGJ1bmNoIG9mIHNoaXQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBhdXRvbWF0b24udXBkYXRlKCk7XG4gIHVwZGF0ZU1hdHJpY2VzKCk7XG5cbiAgLy8gPT0gbGV0J3MgcmVuZGVyIHRoaXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGdsQ2F0UGF0aC5iZWdpbigpO1xuXG4gIC8vID09IGNvbXB1dGUgc3R1ZmYgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBnbENhdFBhdGgucmVuZGVyKCAncGFydGljbGVzQ29tcHV0ZVJldHVybicgKTtcbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3BhcnRpY2xlc01vdGlvblJlYWQnICk7XG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwYXJ0aWNsZXNFbmZvcmNlJyApO1xuICBnbENhdFBhdGgucmVuZGVyKCAncGFydGljbGVzRGl2ZXJnZW5jZScgKTtcbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3BhcnRpY2xlc1ByZXNzdXJlJyApO1xuICBnbENhdFBhdGgucmVuZGVyKCAncGFydGljbGVzTW90aW9uV3JpdGUnICk7XG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwYXJ0aWNsZXNDb21wdXRlJyApO1xuXG4gIC8vID09IHNoYWRvdyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBnbENhdFBhdGgucmVuZGVyKCAnc2hhZG93JyApO1xuXG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwYXJ0aWNsZXNSZW5kZXInLCB7XG4gICAgdGFyZ2V0OiBnbENhdFBhdGguZmIoICdzaGFkb3cnICksXG4gICAgaXNTaGFkb3c6IHRydWUsXG4gICAgd2lkdGg6IHNoYWRvd1Jlc28sXG4gICAgaGVpZ2h0OiBzaGFkb3dSZXNvXG4gIH0gKTtcblxuICAvLyA9PSBmb3JlZ3JvdW5kID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3RhcmdldCcgKTtcblxuICBnbENhdFBhdGgucmVuZGVyKCAncGFydGljbGVzUmVuZGVyJywge1xuICAgIHRhcmdldDogZ2xDYXRQYXRoLmZiKCAndGFyZ2V0JyApLFxuICAgIHRleHR1cmVTaGFkb3c6IGdsQ2F0UGF0aC5mYiggJ3NoYWRvdycgKS50ZXh0dXJlLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9ICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ2JveCcsIHtcbiAgICB0YXJnZXQ6IGdsQ2F0UGF0aC5mYiggJ3RhcmdldCcgKSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfSApO1xuXG4gIC8vID09IHBvc3QgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBnbENhdFBhdGgucmVuZGVyKCAncHJlQmxvb20nLCB7XG4gICAgaW5wdXQ6IGdsQ2F0UGF0aC5mYiggJ3RhcmdldCcgKS50ZXh0dXJlc1sgMCBdLFxuICAgIGJpYXM6IFsgLTAuOSwgLTAuOSwgLTAuOSBdLFxuICAgIGZhY3RvcjogWyAxLjAsIDEuMCwgMS4wIF1cbiAgfSApO1xuICBnbENhdFBhdGgucmVuZGVyKCAnYmxvb20nICk7XG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwb3N0Qmxvb20nLCB7XG4gICAgZHJ5OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICkudGV4dHVyZXNbIDAgXVxuICB9ICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3BpeGVsc29ydENvbXBhcmUnLCB7XG4gICAgaW5wdXQ6IGdsQ2F0UGF0aC5mYiggJ3Bvc3RCbG9vbScgKS50ZXh0dXJlXG4gIH0gKTtcbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3BpeGVsc29ydFJlbmRlcicsIHtcbiAgICBpbnB1dDogZ2xDYXRQYXRoLmZiKCAncG9zdEJsb29tJyApLnRleHR1cmVcbiAgfSApO1xuXG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwb3N0Jywge1xuICAgIGlucHV0OiBnbENhdFBhdGguZmIoICdwaXhlbHNvcnRSZW5kZXInICkudGV4dHVyZVxuICB9ICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3JldHVybicsIHtcbiAgICB0YXJnZXQ6IEdMQ2F0UGF0aC5udWxsRmIsXG4gICAgaW5wdXQ6IGdsQ2F0UGF0aC5mYiggJ3Bvc3QnICkudGV4dHVyZVxuICB9ICk7XG5cbiAgLy8gZ2xDYXRQYXRoLnJlbmRlciggJ2luc3BlY3RvcicsIHtcbiAgLy8gICB0YXJnZXQ6IEdMQ2F0UGF0aC5udWxsRmIsXG4gIC8vICAgaW5wdXQ6IGdsQ2F0UGF0aC5mYiggJ3BhcnRpY2xlc01vdGlvbldyaXRlJyApLnRleHR1cmVcbiAgLy8gfSApO1xuXG4gIC8vID09IGVuZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBnbENhdFBhdGguZW5kKCk7XG5cbiAgLy8gPT0gc2F2ZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGlmICggJCggJyNzYXZlJyApLmNoZWNrZWQgKSB7XG4gICAgc2F2ZXIuY2FwdHVyZSgpO1xuICAgIGlmICggYXV0b21hdG9uLmZwcyAqIGF1dG9tYXRvbi5sZW5ndGggKiAxLjEgPCBzYXZlci5mcmFtZUNvdW50ICkge1xuICAgICAgJCggJyNzYXZlJyApLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgIHNhdmVyLnNhdmUoKTtcbiAgICB9XG4gIH1cblxuICAvLyA9PSBmaW5hbGl6ZSB0aGUgbG9vcCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgaXNJbml0aWFsRnJhbWUgPSBmYWxzZTtcbiAgdG90YWxGcmFtZSArKztcblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xufTtcblxudXBkYXRlKCk7XG5cbi8vID09IGtleWJvYXJkIGlzIGdvb2QgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCAoIGV2ZW50ICkgPT4ge1xuICBpZiAoIGV2ZW50LndoaWNoID09PSAyNyApIHsgLy8gcGFuaWMgYnV0dG9uXG4gICAgJCggJyNhY3RpdmUnICkuY2hlY2tlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCBldmVudC53aGljaCA9PT0gMzIgKSB7IC8vIHBsYXkgLyBwYXVzZVxuICAgIGF1dG9tYXRvbi5pc1BsYXlpbmcgPyBhdXRvbWF0b24ucGF1c2UoKSA6IGF1dG9tYXRvbi5wbGF5KCk7XG4gIH1cbn0gKTsiLCJpbXBvcnQgVWx0cmFDYXQgZnJvbSAnLi4vbGlicy91bHRyYWNhdCc7XG5cbi8vIC0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCAoIGNvbnRleHQgKSA9PiB7XG4gIGNvbnN0IGdsQ2F0UGF0aCA9IGNvbnRleHQuZ2xDYXRQYXRoO1xuICBjb25zdCBnbENhdCA9IGdsQ2F0UGF0aC5nbENhdDtcbiAgY29uc3QgZ2wgPSBnbENhdC5nbDtcblxuICBjb25zdCB3aWR0aCA9IGNvbnRleHQud2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGNvbnRleHQuaGVpZ2h0O1xuXG4gIC8vIC0tLS0tLVxuXG4gIGNvbnN0IHZib1F1YWQgPSBnbENhdC5jcmVhdGVWZXJ0ZXhidWZmZXIoIG5ldyBGbG9hdDMyQXJyYXkoIFVsdHJhQ2F0LnRyaWFuZ2xlU3RyaXBRdWFkICkgKTtcblxuICAvLyAtLS0tLS1cblxuICBnbENhdFBhdGguYWRkKCB7XG4gICAgcHJlQmxvb206IHtcbiAgICAgIHdpZHRoOiB3aWR0aCAvIDQsXG4gICAgICBoZWlnaHQ6IGhlaWdodCAvIDQsXG4gICAgICB2ZXJ0OiByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICBmcmFnOiByZXF1aXJlKCAnLi4vc2hhZGVycy9ibG9vbS1wcmUuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuT05FIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTNmdiggJ2JpYXMnLCBwYXJhbXMuYmlhcyApO1xuICAgICAgICBnbENhdC51bmlmb3JtM2Z2KCAnZmFjdG9yJywgcGFyYW1zLmZhY3RvciApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgcGFyYW1zLmlucHV0LCAwICk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGJsb29tOiB7XG4gICAgICB3aWR0aDogd2lkdGggLyA0LFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgLyA0LFxuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvZ2F1c3MuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuT05FIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICB0ZW1wRmI6IGdsQ2F0LmNyZWF0ZUZyYW1lYnVmZmVyKCB3aWR0aCAvIDQsIGhlaWdodCAvIDQgKSxcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG4gICAgICAgICAgbGV0IGdhdXNzVmFyID0gWyAzLjAsIDEwLjAsIDMwLjAgXVsgaSBdO1xuICAgICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3ZhcicsIGdhdXNzVmFyICk7XG5cbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBwYXRoLnRlbXBGYi5mcmFtZWJ1ZmZlciApO1xuICAgICAgICAgIGdsQ2F0LmNsZWFyKCAuLi5wYXRoLmNsZWFyICk7XG4gICAgICAgICAgZ2xDYXQudW5pZm9ybTFpKCAnaXNWZXJ0JywgZmFsc2UgKTtcbiAgICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZShcbiAgICAgICAgICAgICdzYW1wbGVyMCcsXG4gICAgICAgICAgICBpID09PSAwID8gZ2xDYXRQYXRoLmZiKCAncHJlQmxvb20nICkudGV4dHVyZSA6IHBhdGguZnJhbWVidWZmZXIudGV4dHVyZSxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApO1xuICAgICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG5cbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBwYXJhbXMuZnJhbWVidWZmZXIgKTtcbiAgICAgICAgICBnbENhdC51bmlmb3JtMWkoICdpc1ZlcnQnLCB0cnVlICk7XG4gICAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhdGgudGVtcEZiLnRleHR1cmUsIDAgKTtcbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHBvc3RCbG9vbToge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICB2ZXJ0OiByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICBmcmFnOiByZXF1aXJlKCAnLi4vc2hhZGVycy9ibG9vbS1wb3N0LmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDAuMCBdLFxuICAgICAgZnJhbWVidWZmZXI6IHRydWUsXG4gICAgICBmbG9hdDogdHJ1ZSxcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJEcnknLCBwYXJhbXMuZHJ5LCAwICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcldldCcsIGdsQ2F0UGF0aC5mYiggJ2Jsb29tJyApLnRleHR1cmUsIDEgKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgIH1cbiAgICB9LFxuICB9ICk7XG59OyIsImltcG9ydCBNYXRoQ2F0IGZyb20gJy4uL2xpYnMvbWF0aGNhdCc7XG5pbXBvcnQgVWx0cmFDYXQgZnJvbSAnLi4vbGlicy91bHRyYWNhdCc7XG5pbXBvcnQgZ2VuQ3ViZSBmcm9tICcuLi9nZW9tcy9jdWJlJztcblxuLy8gLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0ICggY29udGV4dCApID0+IHtcbiAgLy8gPT0gaGkgY29udGV4dCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGdsQ2F0UGF0aCA9IGNvbnRleHQuZ2xDYXRQYXRoO1xuICBjb25zdCBnbENhdCA9IGdsQ2F0UGF0aC5nbENhdDtcbiAgY29uc3QgZ2wgPSBnbENhdC5nbDtcblxuICBjb25zdCBhdXRvID0gY29udGV4dC5hdXRvbWF0b24uYXV0bztcblxuICAvLyA9PSBoaSB2Ym8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgYm94ID0gZ2VuQ3ViZSgpO1xuICBjb25zdCB2Ym9Cb3hQb3MgPSBnbENhdC5jcmVhdGVWZXJ0ZXhidWZmZXIoIG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICAtMS4wLCAtMS4wLCAtMS4wLCAxLjAsIC0xLjAsIC0xLjAsXG4gICAgMS4wLCAtMS4wLCAtMS4wLCAxLjAsIDEuMCwgLTEuMCxcbiAgICAxLjAsIDEuMCwgLTEuMCwgLTEuMCwgMS4wLCAtMS4wLFxuICAgIC0xLjAsIDEuMCwgLTEuMCwgLTEuMCwgLTEuMCwgLTEuMCxcbiAgICAtMS4wLCAtMS4wLCAxLjAsIDEuMCwgLTEuMCwgMS4wLFxuICAgIDEuMCwgLTEuMCwgMS4wLCAxLjAsIDEuMCwgMS4wLFxuICAgIDEuMCwgMS4wLCAxLjAsIC0xLjAsIDEuMCwgMS4wLFxuICAgIC0xLjAsIDEuMCwgMS4wLCAtMS4wLCAtMS4wLCAxLjAsXG4gICAgLTEuMCwgLTEuMCwgLTEuMCwgLTEuMCwgLTEuMCwgMS4wLFxuICAgIDEuMCwgLTEuMCwgLTEuMCwgMS4wLCAtMS4wLCAxLjAsXG4gICAgMS4wLCAxLjAsIC0xLjAsIDEuMCwgMS4wLCAxLjAsXG4gICAgLTEuMCwgMS4wLCAtMS4wLCAtMS4wLCAxLjAsIDEuMCxcbiAgXSApICk7XG5cbiAgLy8gPT0gcGF0aCBkZWZpbml0aW9uIGJlZ2luID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGdsQ2F0UGF0aC5hZGQoIHtcbiAgICBib3g6IHtcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL2JveC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvYm94LmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXSxcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwb3MnLCB2Ym9Cb3hQb3MsIDMgKTtcblxuICAgICAgICBsZXQgbWF0TSA9IE1hdGhDYXQubWF0NElkZW50aXR5KCk7XG4gICAgICAgIG1hdE0gPSBNYXRoQ2F0Lm1hdDRBcHBseSggTWF0aENhdC5tYXQ0U2NhbGUoIFsgMi4xLCAyLjEgKiBhdXRvKCAnYm94LXBoYXNlJyApLCAyLjEgXSApLCBtYXRNICk7XG4gICAgICAgIG1hdE0gPSBNYXRoQ2F0Lm1hdDRBcHBseSggTWF0aENhdC5tYXQ0VHJhbnNsYXRlKCBbIDAuMCwgLTIuMSArIDIuMSAqIGF1dG8oICdib3gtcGhhc2UnICksIDAuMCBdICksIG1hdE0gKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybU1hdHJpeDRmdiggJ21hdE0nLCBtYXRNICk7XG5cbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuTElORVMsIDAsIDI0ICk7XG4gICAgICB9XG4gICAgfVxuICB9ICk7XG5cbiAgaWYgKCBtb2R1bGUuaG90ICkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgW1xuICAgICAgICAnLi4vc2hhZGVycy9ib3gudmVydCcsXG4gICAgICAgICcuLi9zaGFkZXJzL2JveC5mcmFnJ1xuICAgICAgXSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgZ2xDYXRQYXRoLnJlcGxhY2VQcm9ncmFtKFxuICAgICAgICAgICdib3gnLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL2JveC52ZXJ0JyApLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL2JveC5mcmFnJyApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTsiLCIvLyA9PSBsb2FkIHNvbWUgbW9kdWxlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuaW1wb3J0IFhvcnNoaWZ0IGZyb20gJy4uL2xpYnMveG9yc2hpZnQnO1xuaW1wb3J0IFVsdHJhQ2F0IGZyb20gJy4uL2xpYnMvdWx0cmFjYXQnO1xuXG4vLyA9PSByb2xsIHRoZSBkaWNlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3Qgc2VlZCA9IDE1ODgyMzU2O1xubGV0IHhvcnNoaWZ0ID0gbmV3IFhvcnNoaWZ0KCBzZWVkICk7XG5cbi8vID09IHZlcnkgYmFzaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBwcHAgPSAyO1xuY29uc3QgblBhcnRpY2xlU3FydCA9IDUxMjtcbmNvbnN0IG5QYXJ0aWNsZSA9IG5QYXJ0aWNsZVNxcnQgKiBuUGFydGljbGVTcXJ0O1xuXG5jb25zdCBqYWNvYmlJdGVyID0gNTA7XG5cbmNvbnN0IG1vdGlvbkZpZWxkVm94ZWxVbml0ID0gMC4yO1xuY29uc3QgbW90aW9uRmllbGRSZXNvbHV0aW9uWFkgPSAyNTY7XG5jb25zdCBtb3Rpb25GaWVsZFJlc29sdXRpb24gPSBbIG1vdGlvbkZpZWxkUmVzb2x1dGlvblhZICogNCwgbW90aW9uRmllbGRSZXNvbHV0aW9uWFkgKiA4IF07XG5cbmV4cG9ydCBkZWZhdWx0ICggY29udGV4dCApID0+IHtcbiAgLy8gPT0gcHJlcGFyZSBjb250ZXh0ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGdsQ2F0UGF0aCA9IGNvbnRleHQuZ2xDYXRQYXRoO1xuICBjb25zdCBnbENhdCA9IGdsQ2F0UGF0aC5nbENhdDtcbiAgY29uc3QgZ2wgPSBnbENhdC5nbDtcblxuICBjb25zdCBhdXRvID0gY29udGV4dC5hdXRvbWF0b24uYXV0bztcblxuICAvLyA9PSBwcmVwYXJlIHZib3MgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgdmJvUXVhZCA9IGdsQ2F0LmNyZWF0ZVZlcnRleGJ1ZmZlciggbmV3IEZsb2F0MzJBcnJheSggVWx0cmFDYXQudHJpYW5nbGVTdHJpcFF1YWQgKSApO1xuXG4gIGNvbnN0IHZib0NvbXB1dGVVViA9IGdsQ2F0LmNyZWF0ZVZlcnRleGJ1ZmZlciggbmV3IEZsb2F0MzJBcnJheShcbiAgICBVbHRyYUNhdC5tYXRyaXgyZCggblBhcnRpY2xlU3FydCwgblBhcnRpY2xlU3FydCApLm1hcCggKCB2LCBpICkgPT4gKFxuICAgICAgaSAlIDIgPT09IDBcbiAgICAgICAgPyAoIHYgKiBwcHAgKyAwLjUgKSAvIG5QYXJ0aWNsZVNxcnQgLyBwcHBcbiAgICAgICAgOiAoIHYgKyAwLjUgKSAvIG5QYXJ0aWNsZVNxcnRcbiAgICApIClcbiAgKSApO1xuXG4gIGNvbnN0IG9jdCA9IHJlcXVpcmUoICcuLi9nZW9tcy9vY3RhaGVkcm9uJyApKCB7IGRpdjogMS4wIH0gKTtcblxuICBjb25zdCB2Ym9PY3RQb3MgPSBnbENhdC5jcmVhdGVWZXJ0ZXhidWZmZXIoIG5ldyBGbG9hdDMyQXJyYXkoIG9jdC5wb3NpdGlvbiApICk7XG4gIGNvbnN0IHZib09jdE5vciA9IGdsQ2F0LmNyZWF0ZVZlcnRleGJ1ZmZlciggbmV3IEZsb2F0MzJBcnJheSggb2N0Lm5vcm1hbCApICk7XG4gIGNvbnN0IGlib09jdCA9IGdsQ2F0LmNyZWF0ZUluZGV4YnVmZmVyKCBuZXcgVWludDE2QXJyYXkoIG9jdC5pbmRleCApICk7XG5cbiAgLy8gPT0gcHJlcGFyZSByYW5kb20gdGV4dHVyZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IHRleHR1cmVSYW5kb21TaXplID0gMzI7XG4gIGNvbnN0IHRleHR1cmVSYW5kb21VcGRhdGUgPSAoIF90ZXggKSA9PiB7XG4gICAgZ2xDYXQuc2V0VGV4dHVyZUZyb21BcnJheSggX3RleCwgdGV4dHVyZVJhbmRvbVNpemUsIHRleHR1cmVSYW5kb21TaXplLCAoICgpID0+IHtcbiAgICAgIGxldCBsZW4gPSB0ZXh0dXJlUmFuZG9tU2l6ZSAqIHRleHR1cmVSYW5kb21TaXplICogNDtcbiAgICAgIGxldCByZXQgPSBuZXcgVWludDhBcnJheSggbGVuICk7XG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBsZW47IGkgKysgKSB7XG4gICAgICAgIHJldFsgaSBdID0gTWF0aC5mbG9vciggeG9yc2hpZnQuZ2VuKCkgKiAyNTYuMCApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9ICkoKSApO1xuICB9O1xuXG4gIGNvbnN0IHRleHR1cmVSYW5kb21TdGF0aWMgPSBnbENhdC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsQ2F0LnRleHR1cmVXcmFwKCB0ZXh0dXJlUmFuZG9tU3RhdGljLCBnbC5SRVBFQVQgKTtcbiAgdGV4dHVyZVJhbmRvbVVwZGF0ZSggdGV4dHVyZVJhbmRvbVN0YXRpYyApO1xuXG4gIGNvbnN0IHRleHR1cmVSYW5kb20gPSBnbENhdC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsQ2F0LnRleHR1cmVXcmFwKCB0ZXh0dXJlUmFuZG9tLCBnbC5SRVBFQVQgKTtcblxuICAvLyA9PSBUb2J5IEZveCAtIER1bW15ISA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgdGV4dHVyZUR1bW15ID0gZ2xDYXQuY3JlYXRlVGV4dHVyZSgpO1xuICBnbENhdC5zZXRUZXh0dXJlRnJvbUFycmF5KCB0ZXh0dXJlRHVtbXksIDEsIDEsIG5ldyBVaW50OEFycmF5KCBbIDAsIDAsIDAsIDAgXSApICk7XG5cbiAgLy8gPT0gbGV0J3MgY3JlYXRlIHBhdGhzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGdsQ2F0UGF0aC5hZGQoIHtcbiAgICAvLyA9PSBmcmFtZWJ1ZmZlciBzdWNrcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgcGFydGljbGVzQ29tcHV0ZVJldHVybjoge1xuICAgICAgd2lkdGg6IG5QYXJ0aWNsZVNxcnQgKiBwcHAsXG4gICAgICBoZWlnaHQ6IG5QYXJ0aWNsZVNxcnQsXG4gICAgICB2ZXJ0OiByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICBmcmFnOiByZXF1aXJlKCAnLi4vc2hhZGVycy9yZXR1cm4uZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgZmlsdGVyOiBnbC5ORUFSRVNULFxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgIGlmICggY29udGV4dC5hdXRvbWF0b24udGltZSA9PT0gMC4wICkge1xuICAgICAgICAgIHhvcnNoaWZ0LnNldCggc2VlZCApO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIGdsQ2F0UGF0aC5mYiggJ3BhcnRpY2xlc0NvbXB1dGUnICkudGV4dHVyZSwgMCApO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyA9PSBnZW5lcmF0ZSBtb3Rpb24gZmllbGQgYnkgcGFydGljbGVzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgcGFydGljbGVzTW90aW9uUmVhZDoge1xuICAgICAgd2lkdGg6IG1vdGlvbkZpZWxkUmVzb2x1dGlvblsgMCBdLFxuICAgICAgaGVpZ2h0OiBtb3Rpb25GaWVsZFJlc29sdXRpb25bIDEgXSxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1tb3Rpb24tcmVhZC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLW1vdGlvbi1yZWFkLmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLk9ORSBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ2NvbXB1dGVVVicsIHZib0NvbXB1dGVVViwgMiApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uUGNvbXB1dGUnLCBbIG5QYXJ0aWNsZVNxcnQgKiBwcHAsIG5QYXJ0aWNsZVNxcnQgXSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncmVzb2x1dGlvbk1vdGlvbicsIG1vdGlvbkZpZWxkUmVzb2x1dGlvbiApO1xuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncGxhbmVSZXNvbHV0aW9uJywgWyBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSwgbW90aW9uRmllbGRSZXNvbHV0aW9uWFkgXSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICd2b3hlbFVuaXQnLCBtb3Rpb25GaWVsZFZveGVsVW5pdCApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlclBjb21wdXRlJywgZ2xDYXRQYXRoLmZiKCAncGFydGljbGVzQ29tcHV0ZVJldHVybicgKS50ZXh0dXJlLCAwICk7XG5cbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuUE9JTlRTLCAwLCBuUGFydGljbGUgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gPT0gZW5mb3JjZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHBhcnRpY2xlc0VuZm9yY2U6IHtcbiAgICAgIHdpZHRoOiBtb3Rpb25GaWVsZFJlc29sdXRpb25bIDAgXSxcbiAgICAgIGhlaWdodDogbW90aW9uRmllbGRSZXNvbHV0aW9uWyAxIF0sXG4gICAgICB2ZXJ0OiByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICBmcmFnOiByZXF1aXJlKCAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtZW5mb3JjZS5mcmFnJyApLFxuICAgICAgYmxlbmQ6IFsgZ2wuT05FLCBnbC5aRVJPIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncmVzb2x1dGlvbk1vdGlvbicsIG1vdGlvbkZpZWxkUmVzb2x1dGlvbiApO1xuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncGxhbmVSZXNvbHV0aW9uJywgWyBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSwgbW90aW9uRmllbGRSZXNvbHV0aW9uWFkgXSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICd2b3hlbFVuaXQnLCBtb3Rpb25GaWVsZFZveGVsVW5pdCApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlck1vdGlvbicsIGdsQ2F0UGF0aC5mYiggJ3BhcnRpY2xlc01vdGlvblJlYWQnICkudGV4dHVyZSwgMCApO1xuXG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vID09IGdlbmVyYXRlIGRpdmVyZ2VuY2UgZmllbGQgYnkgbW90aW9uIGZpZWxkID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBwYXJ0aWNsZXNEaXZlcmdlbmNlOiB7XG4gICAgICB3aWR0aDogbW90aW9uRmllbGRSZXNvbHV0aW9uWyAwIF0sXG4gICAgICBoZWlnaHQ6IG1vdGlvbkZpZWxkUmVzb2x1dGlvblsgMSBdLFxuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLWRpdmVyZ2VuY2UuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAnblBhcnRpY2xlJywgblBhcnRpY2xlICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uTW90aW9uJywgbW90aW9uRmllbGRSZXNvbHV0aW9uICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdwbGFuZVJlc29sdXRpb24nLCBbIG1vdGlvbkZpZWxkUmVzb2x1dGlvblhZLCBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSBdICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3ZveGVsVW5pdCcsIG1vdGlvbkZpZWxkVm94ZWxVbml0ICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyTW90aW9uJywgZ2xDYXRQYXRoLmZiKCAncGFydGljbGVzRW5mb3JjZScgKS50ZXh0dXJlLCAwICk7XG5cbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gPT0gbGV0J3MgY2FsY3VsYXRlIHByZXNzdXJlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHBhcnRpY2xlc1ByZXNzdXJlOiB7XG4gICAgICB3aWR0aDogbW90aW9uRmllbGRSZXNvbHV0aW9uWyAwIF0sXG4gICAgICBoZWlnaHQ6IG1vdGlvbkZpZWxkUmVzb2x1dGlvblsgMSBdLFxuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLXByZXNzdXJlLmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDAuMCBdLFxuICAgICAgZnJhbWVidWZmZXI6IHRydWUsXG4gICAgICBmbG9hdDogdHJ1ZSxcbiAgICAgIHRlbXBGYjogW1xuICAgICAgICBnbENhdC5jcmVhdGVGcmFtZWJ1ZmZlciggLi4ubW90aW9uRmllbGRSZXNvbHV0aW9uICksXG4gICAgICAgIGdsQ2F0LmNyZWF0ZUZyYW1lYnVmZmVyKCAuLi5tb3Rpb25GaWVsZFJlc29sdXRpb24gKVxuICAgICAgXSxcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uTW90aW9uJywgbW90aW9uRmllbGRSZXNvbHV0aW9uICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdwbGFuZVJlc29sdXRpb24nLCBbIG1vdGlvbkZpZWxkUmVzb2x1dGlvblhZLCBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSBdICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3ZveGVsVW5pdCcsIG1vdGlvbkZpZWxkVm94ZWxVbml0ICk7XG5cbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgamFjb2JpSXRlcjsgaSArKyApIHtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoXG4gICAgICAgICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgICAgICAgIGkgPT09ICggamFjb2JpSXRlciAtIDEgKSA/IHBhcmFtcy5mcmFtZWJ1ZmZlciA6IHBhdGgudGVtcEZiWyBpICUgMiBdLmZyYW1lYnVmZmVyXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlckRpdmVyZ2VuY2UnLCBnbENhdFBhdGguZmIoICdwYXJ0aWNsZXNEaXZlcmdlbmNlJyApLnRleHR1cmUsIDAgKTtcbiAgICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZShcbiAgICAgICAgICAgICdzYW1wbGVyUHJlc3N1cmUnLFxuICAgICAgICAgICAgcGF0aC50ZW1wRmJbICggaSArIDEgKSAlIDIgXS50ZXh0dXJlLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vID09IHdyaXRlIGJhY2sgdGhlIHZlbG9jaXR5ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBwYXJ0aWNsZXNNb3Rpb25Xcml0ZToge1xuICAgICAgd2lkdGg6IG1vdGlvbkZpZWxkUmVzb2x1dGlvblsgMCBdLFxuICAgICAgaGVpZ2h0OiBtb3Rpb25GaWVsZFJlc29sdXRpb25bIDEgXSxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1tb3Rpb24td3JpdGUuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybTJmdiggJ3Jlc29sdXRpb25Nb3Rpb24nLCBtb3Rpb25GaWVsZFJlc29sdXRpb24gKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTJmdiggJ3BsYW5lUmVzb2x1dGlvbicsIFsgbW90aW9uRmllbGRSZXNvbHV0aW9uWFksIG1vdGlvbkZpZWxkUmVzb2x1dGlvblhZIF0gKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAndm94ZWxVbml0JywgbW90aW9uRmllbGRWb3hlbFVuaXQgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJNb3Rpb24nLCBnbENhdFBhdGguZmIoICdwYXJ0aWNsZXNNb3Rpb25SZWFkJyApLnRleHR1cmUsIDAgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyUHJlc3N1cmUnLCBnbENhdFBhdGguZmIoICdwYXJ0aWNsZXNQcmVzc3VyZScgKS50ZXh0dXJlLCAxICk7XG5cbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gPT0gY29tcHV0ZSBwYXJ0aWNsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHBhcnRpY2xlc0NvbXB1dGU6IHtcbiAgICAgIHdpZHRoOiBuUGFydGljbGVTcXJ0ICogcHBwLFxuICAgICAgaGVpZ2h0OiBuUGFydGljbGVTcXJ0LFxuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLWNvbXB1dGUuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgZmlsdGVyOiBnbC5ORUFSRVNULFxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgIHRleHR1cmVSYW5kb21VcGRhdGUoIHRleHR1cmVSYW5kb20gKTtcblxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ25QYXJ0aWNsZScsIG5QYXJ0aWNsZSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICduUGFydGljbGVTcXJ0JywgblBhcnRpY2xlU3FydCApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdwcHAnLCBwcHAgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMWkoICdpc0luaXRGcmFtZScsIGNvbnRleHQuYXV0b21hdG9uLnRpbWUgPT09IDAuMCA/IHRydWUgOiBmYWxzZSApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uTW90aW9uJywgbW90aW9uRmllbGRSZXNvbHV0aW9uICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdwbGFuZVJlc29sdXRpb24nLCBbIG1vdGlvbkZpZWxkUmVzb2x1dGlvblhZLCBtb3Rpb25GaWVsZFJlc29sdXRpb25YWSBdICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3ZveGVsVW5pdCcsIG1vdGlvbkZpZWxkVm94ZWxVbml0ICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyUGNvbXB1dGUnLCBnbENhdFBhdGguZmIoICdwYXJ0aWNsZXNDb21wdXRlUmV0dXJuJyApLnRleHR1cmUsIDAgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyUmFuZG9tJywgdGV4dHVyZVJhbmRvbSwgMSApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJSYW5kb21TdGF0aWMnLCB0ZXh0dXJlUmFuZG9tU3RhdGljLCAyICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlck1vdGlvbldyaXRlJywgZ2xDYXRQYXRoLmZiKCAncGFydGljbGVzTW90aW9uV3JpdGUnICkudGV4dHVyZSwgMyApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ25vaXNlUGhhc2UnLCBhdXRvKCAncGFydGljbGVzLW5vaXNlUGhhc2UnICkgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAnbm9pc2VBbXAnLCBhdXRvKCAncGFydGljbGVzLW5vaXNlQW1wJyApICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2ZsdWlkQW1wJywgYXV0byggJ3BhcnRpY2xlcy1mbHVpZEFtcCcgKSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdnZW5SYXRlJywgYXV0byggJ3BhcnRpY2xlcy1nZW5SYXRlJyApICk7XG5cbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gPT0gcmVuZGVyIHBhcnRpY2xlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHBhcnRpY2xlc1JlbmRlcjoge1xuICAgICAgdmVydDogcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLXJlbmRlci52ZXJ0JyApLFxuICAgICAgZnJhZzogcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLXJlbmRlci5mcmFnJyApLFxuICAgICAgYmxlbmQ6IFsgZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBIF0sXG4gICAgICBkcmF3YnVmZmVyczogMixcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgICBnbENhdC5hdHRyaWJ1dGVEaXZpc29yKCAnY29tcHV0ZVVWJywgdmJvQ29tcHV0ZVVWLCAyLCAxICk7XG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ2dlb21Qb3MnLCB2Ym9PY3RQb3MsIDMgKTtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAnZ2VvbU5vcicsIHZib09jdE5vciwgMyApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ25QYXJ0aWNsZScsIG5QYXJ0aWNsZSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICduUGFydGljbGVTcXJ0JywgblBhcnRpY2xlU3FydCApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdwcHAnLCBwcHAgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncmVzb2x1dGlvblBjb21wdXRlJywgWyBuUGFydGljbGVTcXJ0ICogcHBwLCBuUGFydGljbGVTcXJ0IF0gKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMWkoICdpc1NoYWRvdycsIHBhcmFtcy5pc1NoYWRvdyA/IDEgOiAwICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAnY29sb3JWYXInLCBhdXRvKCAncGFydGljbGVzLWNvbG9yVmFyJyApICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2NvbG9yT2Zmc2V0JywgYXV0byggJ3BhcnRpY2xlcy1jb2xvck9mZnNldCcgKSApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlclBjb21wdXRlJywgZ2xDYXRQYXRoLmZiKCAncGFydGljbGVzQ29tcHV0ZScgKS50ZXh0dXJlLCAwICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlclJhbmRvbScsIHRleHR1cmVSYW5kb20sIDEgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyUmFuZG9tU3RhdGljJywgdGV4dHVyZVJhbmRvbVN0YXRpYywgMiApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJTaGFkb3cnLCBwYXJhbXMudGV4dHVyZVNoYWRvdyB8fCB0ZXh0dXJlRHVtbXksIDMgKTtcblxuICAgICAgICBsZXQgZXh0ID0gZ2xDYXQuZ2V0RXh0ZW5zaW9uKCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGlib09jdCApO1xuICAgICAgICBleHQuZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoIGdsLlRSSUFOR0xFUywgb2N0LmluZGV4Lmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDAsIG5QYXJ0aWNsZSApO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCApO1xuICAgICAgfVxuICAgIH0sXG4gIH0gKTtcblxuICBpZiAoIG1vZHVsZS5ob3QgKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBbXG4gICAgICAgICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1tb3Rpb24tcmVhZC52ZXJ0JyxcbiAgICAgICAgJy4uL3NoYWRlcnMvcGFydGljbGVzLW1vdGlvbi1yZWFkLmZyYWcnXG4gICAgICBdLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBnbENhdFBhdGgucmVwbGFjZVByb2dyYW0oXG4gICAgICAgICAgJ3BhcnRpY2xlc01vdGlvblJlYWQnLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1tb3Rpb24tcmVhZC52ZXJ0JyApLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1tb3Rpb24tcmVhZC5mcmFnJyApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgW1xuICAgICAgICAnLi4vc2hhZGVycy9xdWFkLnZlcnQnLFxuICAgICAgICAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtZW5mb3JjZS5mcmFnJ1xuICAgICAgXSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgZ2xDYXRQYXRoLnJlcGxhY2VQcm9ncmFtKFxuICAgICAgICAgICdwYXJ0aWNsZXNFbmZvcmNlJyxcbiAgICAgICAgICByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLWVuZm9yY2UuZnJhZycgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFtcbiAgICAgICAgJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyxcbiAgICAgICAgJy4uL3NoYWRlcnMvcGFydGljbGVzLWRpdmVyZ2VuY2UuZnJhZydcbiAgICAgIF0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGdsQ2F0UGF0aC5yZXBsYWNlUHJvZ3JhbShcbiAgICAgICAgICAncGFydGljbGVzRGl2ZXJnZW5jZScsXG4gICAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1kaXZlcmdlbmNlLmZyYWcnIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBbXG4gICAgICAgICcuLi9zaGFkZXJzL3F1YWQudmVydCcsXG4gICAgICAgICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1wcmVzc3VyZS5mcmFnJ1xuICAgICAgXSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgZ2xDYXRQYXRoLnJlcGxhY2VQcm9ncmFtKFxuICAgICAgICAgICdwYXJ0aWNsZXNQcmVzc3VyZScsXG4gICAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvcXVhZC52ZXJ0JyApLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1wcmVzc3VyZS5mcmFnJyApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgW1xuICAgICAgICAnLi4vc2hhZGVycy9xdWFkLnZlcnQnLFxuICAgICAgICAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtbW90aW9uLXdyaXRlLmZyYWcnXG4gICAgICBdLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBnbENhdFBhdGgucmVwbGFjZVByb2dyYW0oXG4gICAgICAgICAgJ3BhcnRpY2xlc01vdGlvbldyaXRlJyxcbiAgICAgICAgICByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLW1vdGlvbi13cml0ZS5mcmFnJyApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgW1xuICAgICAgICAnLi4vc2hhZGVycy9xdWFkLnZlcnQnLFxuICAgICAgICAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtY29tcHV0ZS5mcmFnJ1xuICAgICAgXSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgZ2xDYXRQYXRoLnJlcGxhY2VQcm9ncmFtKFxuICAgICAgICAgICdwYXJ0aWNsZXNDb21wdXRlJyxcbiAgICAgICAgICByZXF1aXJlKCAnLi4vc2hhZGVycy9xdWFkLnZlcnQnICksXG4gICAgICAgICAgcmVxdWlyZSggJy4uL3NoYWRlcnMvcGFydGljbGVzLWNvbXB1dGUuZnJhZycgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFtcbiAgICAgICAgJy4uL3NoYWRlcnMvcGFydGljbGVzLXJlbmRlci52ZXJ0JyxcbiAgICAgICAgJy4uL3NoYWRlcnMvcGFydGljbGVzLXJlbmRlci5mcmFnJ1xuICAgICAgXSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgZ2xDYXRQYXRoLnJlcGxhY2VQcm9ncmFtKFxuICAgICAgICAgICdwYXJ0aWNsZXNSZW5kZXInLFxuICAgICAgICAgIHJlcXVpcmUoICcuLi9zaGFkZXJzL3BhcnRpY2xlcy1yZW5kZXIudmVydCcgKSxcbiAgICAgICAgICByZXF1aXJlKCAnLi4vc2hhZGVycy9wYXJ0aWNsZXMtcmVuZGVyLmZyYWcnIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG59OyIsImltcG9ydCBVbHRyYUNhdCBmcm9tICcuLi9saWJzL3VsdHJhY2F0JztcblxuLy8gLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0ICggY29udGV4dCApID0+IHtcbiAgY29uc3QgZ2xDYXRQYXRoID0gY29udGV4dC5nbENhdFBhdGg7XG4gIGNvbnN0IGdsQ2F0ID0gZ2xDYXRQYXRoLmdsQ2F0O1xuICBjb25zdCBnbCA9IGdsQ2F0LmdsO1xuXG4gIGNvbnN0IHdpZHRoID0gY29udGV4dC53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gY29udGV4dC5oZWlnaHQ7XG5cbiAgY29uc3QgYXV0byA9IGNvbnRleHQuYXV0b21hdG9uLmF1dG87XG5cbiAgLy8gLS0tLS0tXG5cbiAgY29uc3QgdmJvUXVhZCA9IGdsQ2F0LmNyZWF0ZVZlcnRleGJ1ZmZlciggbmV3IEZsb2F0MzJBcnJheSggVWx0cmFDYXQudHJpYW5nbGVTdHJpcFF1YWQgKSApO1xuXG4gIC8vIC0tLS0tLVxuXG4gIGdsQ2F0UGF0aC5hZGQoIHtcbiAgICBwaXhlbHNvcnRDb21wYXJlOiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3BpeGVsc29ydC1jb21wYXJlLmZyYWcnICksXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLk9ORSBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgdGVtcEZiOiBnbENhdC5jcmVhdGVGbG9hdEZyYW1lYnVmZmVyKCB3aWR0aCwgaGVpZ2h0ICksXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcblxuICAgICAgICBnbENhdC51bmlmb3JtMWkoICdzaGFkb3cnLCBhdXRvKCAncGl4ZWxzb3J0LXNoYWRvdycgKSA8IDAuNSA/IGZhbHNlIDogdHJ1ZSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICd0aHJlc2hvbGQnLCBhdXRvKCAncGl4ZWxzb3J0LXRocmVzaG9sZCcgKSApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcjAnLCBwYXJhbXMuaW5wdXQsIDAgKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcGl4ZWxzb3J0UmVuZGVyOiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3BpeGVsc29ydC1yZW5kZXIuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuT05FIF0sXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxuICAgICAgZmxvYXQ6IHRydWUsXG4gICAgICB0ZW1wRmI6IGdsQ2F0LmNyZWF0ZUZsb2F0RnJhbWVidWZmZXIoIHdpZHRoLCBoZWlnaHQgKSxcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3RocmVzaG9sZCcsIGF1dG8oICdwaXhlbHNvcnQtdGhyZXNob2xkJyApICk7XG5cbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhcmFtcy5pbnB1dCwgMCApO1xuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJNYXAnLCBnbENhdFBhdGguZmIoICdwaXhlbHNvcnRDb21wYXJlJyApLnRleHR1cmUsIDEgKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgIH1cbiAgICB9LFxuICB9ICk7XG59OyIsImltcG9ydCBVbHRyYUNhdCBmcm9tICcuLi9saWJzL3VsdHJhY2F0JztcblxuLy8gLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0ICggY29udGV4dCApID0+IHtcbiAgY29uc3QgZ2xDYXRQYXRoID0gY29udGV4dC5nbENhdFBhdGg7XG4gIGNvbnN0IGdsQ2F0ID0gZ2xDYXRQYXRoLmdsQ2F0O1xuICBjb25zdCBnbCA9IGdsQ2F0LmdsO1xuXG4gIGNvbnN0IHdpZHRoID0gY29udGV4dC53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gY29udGV4dC5oZWlnaHQ7XG5cbiAgY29uc3QgYXV0byA9IGNvbnRleHQuYXV0b21hdG9uLmF1dG87XG5cbiAgLy8gLS0tLS0tXG5cbiAgY29uc3QgdmJvUXVhZCA9IGdsQ2F0LmNyZWF0ZVZlcnRleGJ1ZmZlciggbmV3IEZsb2F0MzJBcnJheSggVWx0cmFDYXQudHJpYW5nbGVTdHJpcFF1YWQgKSApO1xuXG4gIC8vIC0tLS0tLVxuXG4gIGdsQ2F0UGF0aC5hZGQoIHtcbiAgICBwb3N0OiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3Bvc3QuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2JhcnJlbEFtcCcsIGF1dG8oICdwb3N0LWJhcnJlbEFtcCcgKSApO1xuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdiYXJyZWxPZmZzZXQnLCBhdXRvKCAncG9zdC1iYXJyZWxPZmZzZXQnICkgKTtcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhcmFtcy5pbnB1dCwgMCApO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmeGFhOiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHZlcnQ6IHJlcXVpcmUoICcuLi9zaGFkZXJzL3F1YWQudmVydCcgKSxcbiAgICAgIGZyYWc6IHJlcXVpcmUoICcuLi9zaGFkZXJzL2Z4YWEuZnJhZycgKSxcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICAgIGZsb2F0OiB0cnVlLFxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcjAnLCBwYXJhbXMuaW5wdXQsIDAgKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgIH1cbiAgICB9LFxuICB9ICk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gXCIjZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWM0IGJnQ29sb3I7XFxudW5pZm9ybSBmbG9hdCBwZXJzcEZhcjtcXG5cXG4vLyAtLS0tLS1cXG5cXG52b2lkIG1haW4oKSB7XFxuICBnbF9GcmFnRGF0YVsgMCBdID0gYmdDb2xvcjtcXG4gIGdsX0ZyYWdEYXRhWyAxIF0gPSB2ZWM0KCBwZXJzcEZhciwgMC4wLCAwLjAsIDEuMCApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIHNhdHVyYXRlKGkpIGNsYW1wKGksMC4sMS4pXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlckRyeTtcXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyV2V0O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uO1xcbiAgdmVjMyBkcnkgPSB0ZXh0dXJlMkQoIHNhbXBsZXJEcnksIHV2ICkueHl6O1xcbiAgdmVjMyB3ZXQgPSB0ZXh0dXJlMkQoIHNhbXBsZXJXZXQsIHV2ICkueHl6O1xcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggbWF4KCB2ZWMzKCAwLjAgKSwgc2F0dXJhdGUoIGRyeSArIHdldCApICksIDEuMCApO1xcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIHZlYzMgYmlhcztcXG51bmlmb3JtIHZlYzMgZmFjdG9yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXIwO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uO1xcbiAgdmVjMiBkZWx0YVRleGVsID0gMC4yNSAvIHJlc29sdXRpb247XFxuICB2ZWMyIHV2T3JpZ2luID0gKCBmbG9vciggZ2xfRnJhZ0Nvb3JkLnh5ICkgKyBkZWx0YVRleGVsICogMC41ICkgLyByZXNvbHV0aW9uO1xcblxcbiAgdmVjMyBzdW0gPSB2ZWMzKCAwLjAgKTtcXG4gIGZvciAoIGludCBpeSA9IDA7IGl5IDwgNDsgaXkgKysgKSB7XFxuICAgIGZvciAoIGludCBpeCA9IDA7IGl4IDwgNDsgaXggKysgKSB7XFxuICAgICAgdmVjMiB1diA9IHV2T3JpZ2luICsgdmVjMiggaXgsIGl5ICkgKiBkZWx0YVRleGVsO1xcbiAgICAgIHN1bSArPSB0ZXh0dXJlMkQoIHNhbXBsZXIwLCB1diApLnh5eiAvIDE2LjA7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoXFxuICAgIG1heCggdmVjMyggMC4wICksICggc3VtICsgYmlhcyApICogZmFjdG9yICksXFxuICAgIDEuMFxcbiAgKTtcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2RlZmluZSBUQVUgNi4yODMxODUzMDdcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzMgdlBvcztcXG5cXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgaCA9IHZQb3MueCArIHZQb3MueSArIHZQb3MuejsgLy8gaFxcbiAgZmxvYXQgd2F2ZSA9IHNpbiggMjAuMCAqIGggKyA0LjAgKiBUQVUgKiB0aW1lICk7XFxuICBmbG9hdCBzbGFzaCA9IHN0ZXAoIC0wLjMsIHdhdmUgKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIHNsYXNoICogMC44ICksIDEuMCApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiNkZWZpbmUgSFVHRSA5RTE2XFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1XFxuI2RlZmluZSBWIHZlYzMoMC4sMS4sLTEuKVxcbiNkZWZpbmUgc2F0dXJhdGUoaSkgY2xhbXAoaSwwLiwxLilcXG4jZGVmaW5lIGxvZmkoaSxtKSAoZmxvb3IoKGkpLyhtKSkqKG0pKVxcblxcbi8vIC0tLS0tLVxcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvcztcXG5cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIHZlYzMgY29sb3I7XFxuXFxudmFyeWluZyB2ZWMzIHZQb3M7XFxuXFxudW5pZm9ybSBib29sIGlzU2hhZG93O1xcblxcbnVuaWZvcm0gbWF0NCBtYXRQO1xcbnVuaWZvcm0gbWF0NCBtYXRWO1xcbnVuaWZvcm0gbWF0NCBtYXRQTDtcXG51bmlmb3JtIG1hdDQgbWF0Vkw7XFxudW5pZm9ybSBtYXQ0IG1hdE07XFxuXFxuLy8gLS0tLS0tXFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjNCBwb3MgPSBtYXRNICogdmVjNCggcG9zLCAxLjAgKTtcXG4gIHZQb3MgPSBwb3MueHl6O1xcblxcbiAgdmVjNCBvdXRQb3M7XFxuICBpZiAoIGlzU2hhZG93ICkge1xcbiAgICBvdXRQb3MgPSBtYXRQTCAqIG1hdFZMICogcG9zO1xcbiAgfSBlbHNlIHtcXG4gICAgb3V0UG9zID0gbWF0UCAqIG1hdFYgKiBwb3M7XFxuICAgIG91dFBvcy54IC89IHJlc29sdXRpb24ueCAvIHJlc29sdXRpb24ueTtcXG4gIH1cXG4gIGdsX1Bvc2l0aW9uID0gb3V0UG9zO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIFBJIDMuMTQxNTkyNjVcXG4jZGVmaW5lIFYgdmVjMygwLiwxLiwtMS4pXFxuXFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NSU4gKDEuMCAvIDEyOC4wKVxcbiNkZWZpbmUgRlhBQV9SRURVQ0VfTVVMICgxLjAgLyA4LjApXFxuI2RlZmluZSBGWEFBX1NQQU5fTUFYIDE2LjBcXG5cXG4vLyAtLS0tLS1cXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcblxcbi8vIC0tLS0tLVxcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uO1xcblxcbiAgI2RlZmluZSBUKHYpIHRleHR1cmUyRCggdGV4dHVyZSwgKHYpIC8gcmVzb2x1dGlvbiApLnh5elxcbiAgdmVjMyByZ2IxMSA9IFQoIGdsX0ZyYWdDb29yZC54eSApO1xcbiAgdmVjMyByZ2IwMCA9IFQoIGdsX0ZyYWdDb29yZC54eSArIFYuenogKTtcXG4gIHZlYzMgcmdiMDIgPSBUKCBnbF9GcmFnQ29vcmQueHkgKyBWLnp5ICk7XFxuICB2ZWMzIHJnYjIwID0gVCggZ2xfRnJhZ0Nvb3JkLnh5ICsgVi55eiApO1xcbiAgdmVjMyByZ2IyMiA9IFQoIGdsX0ZyYWdDb29yZC54eSArIFYueXkgKTtcXG4gICN1bmRlZiBUXFxuXFxuICB2ZWMzIGx1bWEgPSB2ZWMzKCAwLjI5OSwgMC41ODcsIDAuMTE0ICk7XFxuICAjZGVmaW5lIEwoYykgZG90KCBjLCBsdW1hIClcXG4gIGZsb2F0IGx1bWExMSA9IEwoIHJnYjExICk7XFxuICBmbG9hdCBsdW1hMDAgPSBMKCByZ2IwMCApO1xcbiAgZmxvYXQgbHVtYTAyID0gTCggcmdiMDIgKTtcXG4gIGZsb2F0IGx1bWEyMCA9IEwoIHJnYjIwICk7XFxuICBmbG9hdCBsdW1hMjIgPSBMKCByZ2IyMiApO1xcbiAgI3VuZGVmIExcXG5cXG4gIGZsb2F0IGx1bWFNaW4gPSBtaW4oIGx1bWEwMCwgbWluKCBtaW4oIGx1bWEwMCwgbHVtYTAyICksIG1pbiggbHVtYTIwLCBsdW1hMjIgKSApICk7XFxuICBmbG9hdCBsdW1hTWF4ID0gbWF4KCBsdW1hMDAsIG1heCggbWF4KCBsdW1hMDAsIGx1bWEwMiApLCBtYXgoIGx1bWEyMCwgbHVtYTIyICkgKSApO1xcblxcbiAgdmVjMiBkaXIgPSB2ZWMyKFxcbiAgICAtKCAoIGx1bWEwMCArIGx1bWEyMCApIC0gKCBsdW1hMDIgKyBsdW1hMjIgKSApLFxcbiAgICAoICggbHVtYTAwICsgbHVtYTAyICkgLSAoIGx1bWEyMCArIGx1bWEyMiApIClcXG4gICk7XFxuXFxuICBmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoXFxuICAgICggbHVtYTAwICsgbHVtYTAyICsgbHVtYTIwICsgbHVtYTIyICkgKiAwLjI1ICogRlhBQV9SRURVQ0VfTVVMLFxcbiAgICBGWEFBX1JFRFVDRV9NSU5cXG4gICk7XFxuICBmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAoIG1pbiggYWJzKCBkaXIueCApLCBhYnMoIGRpci55ICkgKSArIGRpclJlZHVjZSApO1xcbiAgZGlyID0gbWluKFxcbiAgICB2ZWMyKCBGWEFBX1NQQU5fTUFYICksXFxuICAgIG1heChcXG4gICAgICB2ZWMyKCAtRlhBQV9TUEFOX01BWCApLFxcbiAgICAgIGRpciAqIHJjcERpck1pblxcbiAgICApXFxuICApIC8gcmVzb2x1dGlvbjtcXG5cXG4gIHZlYzMgcmdiQSA9IDAuNSAqIChcXG4gICAgdGV4dHVyZTJEKCB0ZXh0dXJlLCB1diArIGRpciAqICggMS4wIC8gMy4wIC0gMC41ICkgKS54eXogK1xcbiAgICB0ZXh0dXJlMkQoIHRleHR1cmUsIHV2ICsgZGlyICogKCAyLjAgLyAzLjAgLSAwLjUgKSApLnh5elxcbiAgKTtcXG4gIHZlYzMgcmdiQiA9IHJnYkEgKiAwLjUgKyAwLjI1ICogKFxcbiAgICB0ZXh0dXJlMkQoIHRleHR1cmUsIHV2IC0gZGlyICogMC41ICkueHl6ICtcXG4gICAgdGV4dHVyZTJEKCB0ZXh0dXJlLCB1diArIGRpciAqIDAuNSApLnh5elxcbiAgKTtcXG5cXG4gIGZsb2F0IGx1bWFCID0gZG90KCByZ2JCLCBsdW1hICk7XFxuICBnbF9GcmFnQ29sb3IgPSAoXFxuICAgICggKCBsdW1hQiA8IGx1bWFNaW4gKSB8fCAoIGx1bWFNYXggPCBsdW1hQiApICkgP1xcbiAgICB2ZWM0KCByZ2JBLCAxLjAgKSA6XFxuICAgIHZlYzQoIHJnYkIsIDEuMCApXFxuICApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIHNhdHVyYXRlKGkpIGNsYW1wKGksMC4sMS4pXFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1XFxuI2RlZmluZSBTQU1QTEVTIDIwXFxuI2RlZmluZSBNVUxfVEhSIDAuMDFcXG5cXG4vLyAtLS0tLS1cXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIGJvb2wgaXNWZXJ0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXIwO1xcblxcbnVuaWZvcm0gZmxvYXQgdmFyO1xcblxcbmZsb2F0IGdhdXNzaWFuKCBmbG9hdCBfeCwgZmxvYXQgX3YgKSB7XFxuICByZXR1cm4gMS4wIC8gc3FydCggMi4wICogUEkgKiBfdiApICogZXhwKCAtIF94ICogX3ggLyAyLjAgLyBfdiApO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbjtcXG5cXG4gIGlmICggdmFyIDw9IDAuMCApIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBzYW1wbGVyMCwgdXYgKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgdmVjMiBidiA9ICggaXNWZXJ0ID8gdmVjMiggMC4wLCAxLjAgKSA6IHZlYzIoIDEuMCwgMC4wICkgKSAvIHJlc29sdXRpb247XFxuXFxuICB2ZWMzIHN1bSA9IHZlYzMoIDAuMCApO1xcbiAgZm9yICggaW50IGkgPSAwOyBpIDw9IFNBTVBMRVM7IGkgKysgKSB7XFxuICAgIGZsb2F0IG11bCA9IGdhdXNzaWFuKCBhYnMoIGZsb2F0KCBpICkgKSwgdmFyICk7XFxuICAgIGlmICggbXVsIDwgTVVMX1RIUiApIHsgYnJlYWs7IH1cXG4gICAgZm9yICggaW50IGogPSAtMTsgaiA8IDI7IGogKz0gMiApIHtcXG4gICAgICB2ZWMyIHYgPSBzYXR1cmF0ZSggdXYgKyBidiAqIGZsb2F0KCBpICogaiApICk7XFxuICAgICAgdmVjMyB0ZXggPSB0ZXh0dXJlMkQoIHNhbXBsZXIwLCB2ICkueHl6O1xcbiAgICAgIHN1bSArPSB0ZXggKiBtdWw7XFxuICAgICAgaWYgKCBpID09IDAgKSB7IGJyZWFrOyB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHN1bSwgMS4wICk7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgUkFESVVTIDQwLjBcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIHZlYzIgbW91c2U7XFxudW5pZm9ybSB2ZWMzIGNpcmNsZUNvbG9yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXIwO1xcblxcbmJvb2wgcHJpbnQoIGluIHZlYzIgX2Nvb3JkLCBmbG9hdCBfaW4gKSB7XFxuICB2ZWMyIGNvb3JkID0gX2Nvb3JkO1xcblxcbiAgLy8gdmVydGljYWwgcmVzdHJpY3Rpb25cXG4gIGlmICggY29vcmQueSA8PSAwLjAgfHwgNS4wIDw9IGNvb3JkLnkgKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgXFxuICAvLyBkb3RcXG4gIGlmICggMC4wIDwgY29vcmQueCAmJiBjb29yZC54IDwgMi4wICkge1xcbiAgICByZXR1cm4gY29vcmQueCA8IDEuMCAmJiBjb29yZC55IDwgMS4wO1xcbiAgfVxcblxcbiAgLy8gcGFkZGVkIGJ5IGRvdFxcbiAgaWYgKCAyLjAgPCBjb29yZC54ICkgeyBjb29yZC54IC09IDIuMDsgfVxcbiAgXFxuICAvLyBkZXRlcm1pbmUgZGlnaXRcXG4gIGZsb2F0IGNpID0gZmxvb3IoIGNvb3JkLnggLyA1LjAgKSArIDEuMDtcXG5cXG4gIC8vIHRvbyBsb3cgLyB0b28gaGlnaFxcbiAgaWYgKCA0LjAgPCBjaSApIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBpZiAoIGNpIDwgLTQuMCApIHsgcmV0dXJuIGZhbHNlOyB9XFxuXFxuICAvLyB4IG9mIGNoYXJcXG4gIGZsb2F0IGNmeCA9IGZsb29yKCBtb2QoIGNvb3JkLngsIDUuMCApICk7XFxuXFxuICAvLyB3aWR0aCBpcyA0XFxuICBpZiAoIDQuMCA9PSBjZnggKSB7IHJldHVybiBmYWxzZTsgfVxcblxcbiAgLy8geSBvZiBjaGFyXFxuICBmbG9hdCBjZnkgPSBmbG9vciggY29vcmQueSApO1xcblxcbiAgLy8gYml0IG9mIGNoYXJcXG4gIGZsb2F0IGNmID0gY2Z4ICsgNC4wICogY2Z5O1xcblxcbiAgLy8gZGV0ZXJtaW5lIGNoYXIgIFxcbiAgZmxvYXQgbnVtID0gMC4wO1xcbiAgaWYgKCAwLjAgPCBjaSApIHtcXG4gICAgZmxvYXQgbiA9IGFicyggX2luICk7XFxuICAgIGZvciAoIGludCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxuICAgICAgaWYgKCBjaSA8IGZsb2F0KCBpICkgKSB7IGJyZWFrOyB9XFxuICAgICAgXFxuICAgICAgbnVtID0gbW9kKCBmbG9vciggbiApLCAxMC4wICk7XFxuICAgICAgbiAtPSBudW07XFxuICAgICAgbiAqPSAxMC4wO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBmbG9hdCBuID0gYWJzKCBfaW4gKTtcXG4gICAgZm9yICggaW50IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXG4gICAgICBpZiAoIC1jaSA8IGZsb2F0KCBpICkgKSB7IGJyZWFrOyB9XFxuICAgICAgXFxuICAgICAgaWYgKCBjaSAhPSAwLjAgJiYgbiA8IDEuMCApIHtcXG4gICAgICAgIC8vIG1pbnVzXFxuICAgICAgICByZXR1cm4gZmxvYXQoIGkgKSA9PSAtY2kgJiYgX2luIDwgMC4wICYmIGNmeSA9PSAyLjAgJiYgMC4wIDwgY2Z4O1xcbiAgICAgIH1cXG4gICAgICBudW0gPSBtb2QoIGZsb29yKCBuICksIDEwLjAgKTtcXG4gICAgICBuIC09IG51bTtcXG4gICAgICBuIC89IDEwLjA7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGJvb2wgYTtcXG4gIGEgPSAxLjAgPT0gbW9kKCBmbG9vciggKFxcbiAgICBudW0gPT0gMC4wID8gNDMyNTM0LjAgOlxcbiAgICBudW0gPT0gMS4wID8gNDEwNjkyLjAgOlxcbiAgICBudW0gPT0gMi4wID8gNDkzMDg3LjAgOlxcbiAgICBudW0gPT0gMy4wID8gNDkzMTkxLjAgOlxcbiAgICBudW0gPT0gNC4wID8gNjMwNDA4LjAgOlxcbiAgICBudW0gPT0gNS4wID8gOTg5MDYzLjAgOlxcbiAgICBudW0gPT0gNi4wID8gMzk5MjU0LjAgOlxcbiAgICBudW0gPT0gNy4wID8gMTAxNjg5OC4wIDpcXG4gICAgbnVtID09IDguMCA/IDQzMTc2Ni4wIDpcXG4gICAgNDMzNzk4LjBcXG4gICkgLyBwb3coIDIuMCwgY2YgKSApLCAyLjAgKTtcXG4gIFxcbiAgcmV0dXJuIGEgPyB0cnVlIDogZmFsc2U7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uO1xcblxcbiAgdmVjMiBtID0gZmxvb3IoIHZlYzIoIDAuMCwgcmVzb2x1dGlvbi55ICkgKyB2ZWMyKCAxLjAsIC0xLjAgKSAqIG1vdXNlICk7XFxuICB2ZWMyIGNlbnRlciA9IGZsb29yKCBtICsgdmVjMiggMS4wLCAwLjcgKSAqIFJBRElVUyApO1xcbiAgZmxvYXQgY2lyY2xlID0gbGVuZ3RoKCBnbF9GcmFnQ29vcmQueHkgLSBjZW50ZXIgKSAtIFJBRElVUztcXG5cXG4gIHZlYzQgY29sID0gdGV4dHVyZTJEKCBzYW1wbGVyMCwgdXYgKTtcXG4gIHZlYzQgbWNvbCA9IHRleHR1cmUyRCggc2FtcGxlcjAsICggbSArIDAuNSApIC8gcmVzb2x1dGlvbiApO1xcbiAgdmVjNCBiY29sID0gdmVjNCggY2lyY2xlQ29sb3IsIDEuMCApO1xcblxcbiAgY29sID0gbWl4KFxcbiAgICBjb2wsXFxuICAgIG1peChcXG4gICAgICBiY29sLFxcbiAgICAgIG1jb2wsXFxuICAgICAgc21vb3Roc3RlcCggMS4wLCAwLjAsIGNpcmNsZSArIDUuMCApXFxuICAgICksXFxuICAgIHNtb290aHN0ZXAoIDEuMCwgMC4wLCBjaXJjbGUgKVxcbiAgKTtcXG5cXG4gIGlmICggY2lyY2xlIDwgMC4wICkge1xcbiAgICBjb2wgPSBwcmludCggZ2xfRnJhZ0Nvb3JkLnh5IC0gY2VudGVyIC0gdmVjMiggMC4wLCA4LjAgKSwgbWNvbC54ICkgPyBiY29sIDogY29sO1xcbiAgICBjb2wgPSBwcmludCggZ2xfRnJhZ0Nvb3JkLnh5IC0gY2VudGVyIC0gdmVjMiggMC4wLCAwLjAgKSwgbWNvbC55ICkgPyBiY29sIDogY29sO1xcbiAgICBjb2wgPSBwcmludCggZ2xfRnJhZ0Nvb3JkLnh5IC0gY2VudGVyIC0gdmVjMiggMC4wLCAtOC4wICksIG1jb2wueiApID8gYmNvbCA6IGNvbDtcXG4gICAgY29sID0gcHJpbnQoIGdsX0ZyYWdDb29yZC54eSAtIGNlbnRlciAtIHZlYzIoIDAuMCwgLTE2LjAgKSwgbWNvbC53ICkgPyBiY29sIDogY29sO1xcbiAgfVxcblxcbiAgZ2xfRnJhZ0NvbG9yID0gY29sO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIFBBUlRJQ0xFX0xJRkVfTEVOR1RIIDEuMFxcblxcbiNkZWZpbmUgSFVHRSA5RTE2XFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1XFxuI2RlZmluZSBUQVUgNi4yODMxODUzMDdcXG4jZGVmaW5lIFYgdmVjMygwLiwxLiwtMS4pXFxuI2RlZmluZSBzYXR1cmF0ZShpKSBjbGFtcChpLDAuLDEuKVxcbiNkZWZpbmUgbG9maShpLG0pIChmbG9vcigoaSkvKG0pKSoobSkpXFxuI2RlZmluZSBsb2ZpcihpLG0pIChmbG9vcigoaSkvKG0pKy41KSoobSkpXFxuXFxuLy8gLS0tLS0tXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBmbG9hdCB0aW1lO1xcblxcbnVuaWZvcm0gZmxvYXQgblBhcnRpY2xlU3FydDtcXG51bmlmb3JtIGZsb2F0IG5QYXJ0aWNsZTtcXG51bmlmb3JtIGZsb2F0IHBwcDtcXG5cXG51bmlmb3JtIGZsb2F0IHRvdGFsRnJhbWU7XFxudW5pZm9ybSBib29sIGluaXQ7XFxudW5pZm9ybSBmbG9hdCBkZWx0YVRpbWU7XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxuXFxudW5pZm9ybSBib29sIGlzSW5pdEZyYW1lO1xcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uTW90aW9uO1xcbnVuaWZvcm0gdmVjMiBwbGFuZVJlc29sdXRpb247XFxudW5pZm9ybSBmbG9hdCB2b3hlbFVuaXQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlclBjb21wdXRlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXJNb3Rpb25Xcml0ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyUmFuZG9tO1xcblxcbnVuaWZvcm0gZmxvYXQgbm9pc2VQaGFzZTtcXG51bmlmb3JtIGZsb2F0IG5vaXNlQW1wO1xcbnVuaWZvcm0gZmxvYXQgZmx1aWRBbXA7XFxudW5pZm9ybSBmbG9hdCB2ZWxTY2FsZTtcXG51bmlmb3JtIGZsb2F0IGdlblJhdGU7XFxuXFxuLy8gLS0tLS0tXFxuXFxudmVjMiB2SW52ZXJ0KCB2ZWMyIF91diApIHtcXG4gIHJldHVybiB2ZWMyKCAwLjAsIDEuMCApICsgdmVjMiggMS4wLCAtMS4wICkgKiBfdXY7XFxufVxcblxcbi8vIC0tLS0tLVxcblxcbm1hdDIgcm90YXRlMkQoIGZsb2F0IF90ICkge1xcbiAgcmV0dXJuIG1hdDIoIGNvcyggX3QgKSwgc2luKCBfdCApLCAtc2luKCBfdCApLCBjb3MoIF90ICkgKTtcXG59XFxuXFxuZmxvYXQgZnJhY3RTaW4oIGZsb2F0IGkgKSB7XFxuICByZXR1cm4gZnJhY3QoIHNpbiggaSApICogMTg0Ni40MiApO1xcbn1cXG5cXG52ZWM0IHNhbXBsZVJhbmRvbSggdmVjMiBfdXYgKSB7XFxuICByZXR1cm4gdGV4dHVyZTJEKCBzYW1wbGVyUmFuZG9tLCBfdXYgKTtcXG59XFxuXFxuZmxvYXQgR1BVUm5kKGlub3V0IHZlYzQgbilcXG57XFxuXFx0Ly8gQmFzZWQgb24gdGhlIHBvc3QgaHR0cDovL2dwZ3B1Lm9yZy9mb3J1bXMvdmlld3RvcGljLnBocD90PTI1OTEmc2lkPTE3MDUxNDgxYjlmNzhmYjQ5ZmJhNWI5OGE1ZTBmMWYzXFxuXFx0Ly8gKFRoZSBwYWdlIG5vIGxvbmdlciBleGlzdHMgYXMgb2YgTWFyY2ggMTd0aCwgMjAxNS4gUGxlYXNlIGxldCBtZSBrbm93IGlmIHlvdSBzZWUgd2h5IHRoaXMgY29kZSB3b3Jrcy4pXFxuXFx0Y29uc3QgdmVjNCBxID0gdmVjNCggICAxMjI1LjAsICAgIDE1ODUuMCwgICAgMjQ1Ny4wLCAgICAyMDk4LjApO1xcblxcdGNvbnN0IHZlYzQgciA9IHZlYzQoICAgMTExMi4wLCAgICAgMzY3LjAsICAgICAgOTIuMCwgICAgIDI2NS4wKTtcXG5cXHRjb25zdCB2ZWM0IGEgPSB2ZWM0KCAgIDM0MjMuMCwgICAgMjY0Ni4wLCAgICAxNzA3LjAsICAgIDE5OTkuMCk7XFxuXFx0Y29uc3QgdmVjNCBtID0gdmVjNCg0MTk0Mjg3LjAsIDQxOTQyNzcuMCwgNDE5NDE5MS4wLCA0MTk0MTY3LjApO1xcblxcblxcdHZlYzQgYmV0YSA9IGZsb29yKG4gLyBxKTtcXG5cXHR2ZWM0IHAgPSBhICogKG4gLSBiZXRhICogcSkgLSBiZXRhICogcjtcXG5cXHRiZXRhID0gKHNpZ24oLXApICsgdmVjNCgxLjApKSAqIHZlYzQoMC41KSAqIG07XFxuXFx0biA9IChwICsgYmV0YSk7XFxuXFxuXFx0cmV0dXJuIGZyYWN0KGRvdChuIC8gbSwgdmVjNCgxLjAsIC0xLjAsIDEuMCwgLTEuMCkpKTtcXG59XFxuXFxuLy9cXG4vLyBEZXNjcmlwdGlvbiA6IEFycmF5IGFuZCB0ZXh0dXJlbGVzcyBHTFNMIDJELzNELzREIHNpbXBsZXhcXG4vLyAgICAgICAgICAgICAgIG5vaXNlIGZ1bmN0aW9ucy5cXG4vLyAgICAgIEF1dGhvciA6IElhbiBNY0V3YW4sIEFzaGltYSBBcnRzLlxcbi8vICBNYWludGFpbmVyIDogaWptXFxuLy8gICAgIExhc3Rtb2QgOiAyMDExMDgyMiAoaWptKVxcbi8vICAgICBMaWNlbnNlIDogQ29weXJpZ2h0IChDKSAyMDExIEFzaGltYSBBcnRzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbi8vICAgICAgICAgICAgICAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlLlxcbi8vICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2FzaGltYS93ZWJnbC1ub2lzZVxcbi8vXFxuXFxudmVjNCBtb2QyODkodmVjNCB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wOyB9XFxuXFxuZmxvYXQgbW9kMjg5KGZsb2F0IHgpIHtcXG4gIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7IH1cXG5cXG52ZWM0IHBlcm11dGUodmVjNCB4KSB7XFxuICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG5mbG9hdCBwZXJtdXRlKGZsb2F0IHgpIHtcXG4gICAgIHJldHVybiBtb2QyODkoKCh4KjM0LjApKzEuMCkqeCk7XFxufVxcblxcbnZlYzQgdGF5bG9ySW52U3FydCh2ZWM0IHIpXFxue1xcbiAgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjtcXG59XFxuXFxuZmxvYXQgdGF5bG9ySW52U3FydChmbG9hdCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbnZlYzQgZ3JhZDQoZmxvYXQgaiwgdmVjNCBpcClcXG4gIHtcXG4gIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgLTEuMCk7XFxuICB2ZWM0IHAscztcXG5cXG4gIHAueHl6ID0gZmxvb3IoIGZyYWN0ICh2ZWMzKGopICogaXAueHl6KSAqIDcuMCkgKiBpcC56IC0gMS4wO1xcbiAgcC53ID0gMS41IC0gZG90KGFicyhwLnh5eiksIG9uZXMueHl6KTtcXG4gIHMgPSB2ZWM0KGxlc3NUaGFuKHAsIHZlYzQoMC4wKSkpO1xcbiAgcC54eXogPSBwLnh5eiArIChzLnh5eioyLjAgLSAxLjApICogcy53d3c7XFxuXFxuICByZXR1cm4gcDtcXG4gIH1cXG5cXG4vLyAoc3FydCg1KSAtIDEpLzQgPSBGNCwgdXNlZCBvbmNlIGJlbG93XFxuI2RlZmluZSBGNCAwLjMwOTAxNjk5NDM3NDk0NzQ1MVxcblxcbmZsb2F0IHNub2lzZSh2ZWM0IHYpXFxuICB7XFxuICBjb25zdCB2ZWM0ICBDID0gdmVjNCggMC4xMzgxOTY2MDExMjUwMTEsICAvLyAoNSAtIHNxcnQoNSkpLzIwICBHNFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMjc2MzkzMjAyMjUwMDIxLCAgLy8gMiAqIEc0XFxuICAgICAgICAgICAgICAgICAgICAgICAgMC40MTQ1ODk4MDMzNzUwMzIsICAvLyAzICogRzRcXG4gICAgICAgICAgICAgICAgICAgICAgIC0wLjQ0NzIxMzU5NTQ5OTk1OCk7IC8vIC0xICsgNCAqIEc0XFxuXFxuLy8gRmlyc3QgY29ybmVyXFxuICB2ZWM0IGkgID0gZmxvb3IodiArIGRvdCh2LCB2ZWM0KEY0KSkgKTtcXG4gIHZlYzQgeDAgPSB2IC0gICBpICsgZG90KGksIEMueHh4eCk7XFxuXFxuLy8gT3RoZXIgY29ybmVyc1xcblxcbi8vIFJhbmsgc29ydGluZyBvcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5IEJpbGwgTGljZWEtS2FuZSwgQU1EIChmb3JtZXJseSBBVEkpXFxuICB2ZWM0IGkwO1xcbiAgdmVjMyBpc1ggPSBzdGVwKCB4MC55encsIHgwLnh4eCApO1xcbiAgdmVjMyBpc1laID0gc3RlcCggeDAuend3LCB4MC55eXogKTtcXG4vLyAgaTAueCA9IGRvdCggaXNYLCB2ZWMzKCAxLjAgKSApO1xcbiAgaTAueCA9IGlzWC54ICsgaXNYLnkgKyBpc1guejtcXG4gIGkwLnl6dyA9IDEuMCAtIGlzWDtcXG4vLyAgaTAueSArPSBkb3QoIGlzWVoueHksIHZlYzIoIDEuMCApICk7XFxuICBpMC55ICs9IGlzWVoueCArIGlzWVoueTtcXG4gIGkwLnp3ICs9IDEuMCAtIGlzWVoueHk7XFxuICBpMC56ICs9IGlzWVouejtcXG4gIGkwLncgKz0gMS4wIC0gaXNZWi56O1xcblxcbiAgLy8gaTAgbm93IGNvbnRhaW5zIHRoZSB1bmlxdWUgdmFsdWVzIDAsMSwyLDMgaW4gZWFjaCBjaGFubmVsXFxuICB2ZWM0IGkzID0gY2xhbXAoIGkwLCAwLjAsIDEuMCApO1xcbiAgdmVjNCBpMiA9IGNsYW1wKCBpMC0xLjAsIDAuMCwgMS4wICk7XFxuICB2ZWM0IGkxID0gY2xhbXAoIGkwLTIuMCwgMC4wLCAxLjAgKTtcXG5cXG4gIC8vICB4MCA9IHgwIC0gMC4wICsgMC4wICogQy54eHh4XFxuICAvLyAgeDEgPSB4MCAtIGkxICArIDEuMCAqIEMueHh4eFxcbiAgLy8gIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eHhcXG4gIC8vICB4MyA9IHgwIC0gaTMgICsgMy4wICogQy54eHh4XFxuICAvLyAgeDQgPSB4MCAtIDEuMCArIDQuMCAqIEMueHh4eFxcbiAgdmVjNCB4MSA9IHgwIC0gaTEgKyBDLnh4eHg7XFxuICB2ZWM0IHgyID0geDAgLSBpMiArIEMueXl5eTtcXG4gIHZlYzQgeDMgPSB4MCAtIGkzICsgQy56enp6O1xcbiAgdmVjNCB4NCA9IHgwICsgQy53d3d3O1xcblxcbi8vIFBlcm11dGF0aW9uc1xcbiAgaSA9IG1vZDI4OShpKTtcXG4gIGZsb2F0IGowID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZShpLncpICsgaS56KSArIGkueSkgKyBpLngpO1xcbiAgdmVjNCBqMSA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUgKFxcbiAgICAgICAgICAgICBpLncgKyB2ZWM0KGkxLncsIGkyLncsIGkzLncsIDEuMCApKVxcbiAgICAgICAgICAgKyBpLnogKyB2ZWM0KGkxLnosIGkyLnosIGkzLnosIDEuMCApKVxcbiAgICAgICAgICAgKyBpLnkgKyB2ZWM0KGkxLnksIGkyLnksIGkzLnksIDEuMCApKVxcbiAgICAgICAgICAgKyBpLnggKyB2ZWM0KGkxLngsIGkyLngsIGkzLngsIDEuMCApKTtcXG5cXG4vLyBHcmFkaWVudHM6IDd4N3g2IHBvaW50cyBvdmVyIGEgY3ViZSwgbWFwcGVkIG9udG8gYSA0LWNyb3NzIHBvbHl0b3BlXFxuLy8gNyo3KjYgPSAyOTQsIHdoaWNoIGlzIGNsb3NlIHRvIHRoZSByaW5nIHNpemUgMTcqMTcgPSAyODkuXFxuICB2ZWM0IGlwID0gdmVjNCgxLjAvMjk0LjAsIDEuMC80OS4wLCAxLjAvNy4wLCAwLjApIDtcXG5cXG4gIHZlYzQgcDAgPSBncmFkNChqMCwgICBpcCk7XFxuICB2ZWM0IHAxID0gZ3JhZDQoajEueCwgaXApO1xcbiAgdmVjNCBwMiA9IGdyYWQ0KGoxLnksIGlwKTtcXG4gIHZlYzQgcDMgPSBncmFkNChqMS56LCBpcCk7XFxuICB2ZWM0IHA0ID0gZ3JhZDQoajEudywgaXApO1xcblxcbi8vIE5vcm1hbGlzZSBncmFkaWVudHNcXG4gIHZlYzQgbm9ybSA9IHRheWxvckludlNxcnQodmVjNChkb3QocDAscDApLCBkb3QocDEscDEpLCBkb3QocDIsIHAyKSwgZG90KHAzLHAzKSkpO1xcbiAgcDAgKj0gbm9ybS54O1xcbiAgcDEgKj0gbm9ybS55O1xcbiAgcDIgKj0gbm9ybS56O1xcbiAgcDMgKj0gbm9ybS53O1xcbiAgcDQgKj0gdGF5bG9ySW52U3FydChkb3QocDQscDQpKTtcXG5cXG4vLyBNaXggY29udHJpYnV0aW9ucyBmcm9tIHRoZSBmaXZlIGNvcm5lcnNcXG4gIHZlYzMgbTAgPSBtYXgoMC42IC0gdmVjMyhkb3QoeDAseDApLCBkb3QoeDEseDEpLCBkb3QoeDIseDIpKSwgMC4wKTtcXG4gIHZlYzIgbTEgPSBtYXgoMC42IC0gdmVjMihkb3QoeDMseDMpLCBkb3QoeDQseDQpICAgICAgICAgICAgKSwgMC4wKTtcXG4gIG0wID0gbTAgKiBtMDtcXG4gIG0xID0gbTEgKiBtMTtcXG4gIHJldHVybiA0OS4wICogKCBkb3QobTAqbTAsIHZlYzMoIGRvdCggcDAsIHgwICksIGRvdCggcDEsIHgxICksIGRvdCggcDIsIHgyICkpKVxcbiAgICAgICAgICAgICAgICsgZG90KG0xKm0xLCB2ZWMyKCBkb3QoIHAzLCB4MyApLCBkb3QoIHA0LCB4NCApICkgKSApIDtcXG5cXG4gIH1cXG5cXG52ZWMzIHJhbmRvbVNwaGVyZSggaW5vdXQgdmVjNCBzZWVkICkge1xcbiAgdmVjMyB2O1xcbiAgZm9yICggaW50IGkgPSAwOyBpIDwgMTA7IGkgKysgKSB7XFxuICAgIHYgPSB2ZWMzKFxcbiAgICAgIEdQVVJuZCggc2VlZCApLFxcbiAgICAgIEdQVVJuZCggc2VlZCApLFxcbiAgICAgIEdQVVJuZCggc2VlZCApXFxuICAgICkgKiAyLjAgLSAxLjA7XFxuICAgIGlmICggbGVuZ3RoKCB2ICkgPCAxLjAgKSB7IGJyZWFrOyB9XFxuICB9XFxuICByZXR1cm4gdjtcXG59XFxuXFxudmVjMiByYW5kb21DaXJjbGUoIGlub3V0IHZlYzQgc2VlZCApIHtcXG4gIHZlYzIgdjtcXG4gIGZvciAoIGludCBpID0gMDsgaSA8IDEwOyBpICsrICkge1xcbiAgICB2ID0gdmVjMihcXG4gICAgICBHUFVSbmQoIHNlZWQgKSxcXG4gICAgICBHUFVSbmQoIHNlZWQgKVxcbiAgICApICogMi4wIC0gMS4wO1xcbiAgICBpZiAoIGxlbmd0aCggdiApIDwgMS4wICkgeyBicmVhazsgfVxcbiAgfVxcbiAgcmV0dXJuIHY7XFxufVxcblxcbnZlYzMgcmFuZG9tQm94KCBpbm91dCB2ZWM0IHNlZWQgKSB7XFxuICB2ZWMzIHY7XFxuICB2ID0gdmVjMyhcXG4gICAgR1BVUm5kKCBzZWVkICksXFxuICAgIEdQVVJuZCggc2VlZCApLFxcbiAgICBHUFVSbmQoIHNlZWQgKVxcbiAgKSAqIDIuMCAtIDEuMDtcXG4gIHJldHVybiB2O1xcbn1cXG5cXG4vLyA9PSBkZWFsIHdpdGggbW90aW9uIGZpZWxkID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnZlYzMgZmV0Y2hNb3Rpb25MaW5lYXIoIHZlYzMgX3YgKSB7XFxuICB2ZWMzIHYgPSBmbG9vciggX3YgLyB2b3hlbFVuaXQgKSArIDAuNTtcXG4gIHZlYzMgdmYgPSAoIF92IC8gdm94ZWxVbml0ICk7XFxuICB2ZWMyIHBsYW5lU2l6ZSA9IHBsYW5lUmVzb2x1dGlvbiAvIHJlc29sdXRpb25Nb3Rpb247XFxuXFxuICAvLyA9PSB3aGVyZSBhcmUgdGhlIHBsYW5lIG9yaWdpbj8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHpSYW5nZSA9IGZsb29yKCAxLjAgLyBwbGFuZVNpemUueCApICogZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS55ICkgLyAyLjA7XFxuICBpZiAoIHYueiA8IC16UmFuZ2UgfHwgelJhbmdlIDwgdi56ICkge1xcbiAgICByZXR1cm4gdmVjMyggMC4wICk7XFxuICB9XFxuICBmbG9hdCBwbGFuZUluZGV4ID0gZmxvb3IoIHYueiArIHpSYW5nZSApICsgKCBmcmFjdCggdmYueiApIDwgMC41ID8gLTEuMCA6IDAuMCApO1xcbiAgdmVjMiBwbGFuZU9yaWdpbjAgPSB2ZWMyKCBmcmFjdCggcGxhbmVJbmRleCAqIHBsYW5lU2l6ZS54ICksIGZsb29yKCBwbGFuZUluZGV4ICogcGxhbmVTaXplLnggKSAqIHBsYW5lU2l6ZS55ICk7XFxuICBwbGFuZUluZGV4ICs9IDEuMDtcXG4gIHZlYzIgcGxhbmVPcmlnaW4xID0gdmVjMiggZnJhY3QoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApLCBmbG9vciggcGxhbmVJbmRleCAqIHBsYW5lU2l6ZS54ICkgKiBwbGFuZVNpemUueSApO1xcblxcbiAgLy8gPT0gcGxhY2UgYSBkb3Qgb24gdGhlIHBsYW5lID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICB2ZWMyIHh5UmFuZ2UgPSBwbGFuZVJlc29sdXRpb24gLyAyLjA7XFxuICBpZiAoIHYueCA8IC14eVJhbmdlLnggfHwgeHlSYW5nZS54IDwgdi54IHx8IHYueSA8IC14eVJhbmdlLnkgfHwgeHlSYW5nZS55IDwgdi55ICkge1xcbiAgICByZXR1cm4gdmVjMyggMC4wICk7XFxuICB9XFxuXFxuICB2ZWMyIHV2MCA9IHBsYW5lT3JpZ2luMCArICggdmYueHkgKyB4eVJhbmdlICkgLyBwbGFuZVJlc29sdXRpb24gKiBwbGFuZVNpemU7XFxuICB2ZWMyIHV2MSA9IHBsYW5lT3JpZ2luMSArICggdmYueHkgKyB4eVJhbmdlICkgLyBwbGFuZVJlc29sdXRpb24gKiBwbGFuZVNpemU7XFxuICByZXR1cm4gbWl4KFxcbiAgICB0ZXh0dXJlMkQoIHNhbXBsZXJNb3Rpb25Xcml0ZSwgdXYwICkueHl6LFxcbiAgICB0ZXh0dXJlMkQoIHNhbXBsZXJNb3Rpb25Xcml0ZSwgdXYxICkueHl6LFxcbiAgICBmcmFjdCggdmYueiArIDAuNSApXFxuICApO1xcbn1cXG5cXG4vLyAtLS0tLS1cXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbjtcXG4gIHZlYzIgcHV2ID0gdmVjMiggKCBmbG9vciggZ2xfRnJhZ0Nvb3JkLnggLyBwcHAgKSAqIHBwcCArIDAuNSApIC8gcmVzb2x1dGlvbi54LCB1di55ICk7XFxuICBmbG9hdCBtb2RlID0gbW9kKCBnbF9GcmFnQ29vcmQueCwgcHBwICk7XFxuICB2ZWMyIGRwaXggPSB2ZWMyKCAxLjAgKSAvIHJlc29sdXRpb247XFxuXFxuICBmbG9hdCBkdCA9IGRlbHRhVGltZTtcXG5cXG4gIC8vID09IHByZXBhcmUgc29tZSB2YXJzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdmVjNCBzZWVkID0gdGV4dHVyZTJEKCBzYW1wbGVyUmFuZG9tLCBwdXYgKTtcXG4gIEdQVVJuZCggc2VlZCApO1xcblxcbiAgdmVjNCBwb3MgPSB0ZXh0dXJlMkQoIHNhbXBsZXJQY29tcHV0ZSwgcHV2ICk7XFxuICB2ZWM0IHZlbCA9IHRleHR1cmUyRCggc2FtcGxlclBjb21wdXRlLCBwdXYgKyBkcGl4ICogdmVjMiggMS4wLCAwLjAgKSApO1xcblxcbiAgZmxvYXQgdGltaW5nID0gbWl4KFxcbiAgICAwLjAsXFxuICAgIFBBUlRJQ0xFX0xJRkVfTEVOR1RILFxcbiAgICBsb2ZpKCBmbG9vciggcHV2LnkgKiBuUGFydGljbGVTcXJ0ICkgLyBuUGFydGljbGVTcXJ0LCAxLjAgLyA0LjAgKVxcbiAgKTtcXG4gIHRpbWluZyArPSBsb2ZpKCB0aW1lLCBQQVJUSUNMRV9MSUZFX0xFTkdUSCApO1xcblxcbiAgaWYgKCB0aW1lIC0gZGVsdGFUaW1lICsgUEFSVElDTEVfTElGRV9MRU5HVEggPCB0aW1pbmcgKSB7XFxuICAgIHRpbWluZyAtPSBQQVJUSUNMRV9MSUZFX0xFTkdUSDtcXG4gIH1cXG5cXG4gIC8vID09IGluaXRpYWxpemUgcGFydGljbGVzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgLy8gaWYgKCBpc0luaXRGcmFtZSApIHtcXG4gIC8vICAgcG9zLncgPSAwLjA7XFxuICAvLyB9XFxuXFxuICAvLyA9PSBnZW5lcmF0ZSBwYXJ0aWNsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGlmIChcXG4gICAgdGltZSAtIGRlbHRhVGltZSA8IHRpbWluZyAmJiB0aW1pbmcgPD0gdGltZSAmJlxcbiAgICBHUFVSbmQoIHNlZWQgKSA8IGdlblJhdGVcXG4gICkge1xcbiAgICBkdCA9IHRpbWUgLSB0aW1pbmc7XFxuXFxuICAgIHZlYzQgdGhpc0lzVmVyeVRlbXBvcmFyeVZhcmlhYmxlID0gdmVjNCggdGltZSApO1xcbiAgICBwb3MueHl6ID0gMC4xICogcmFuZG9tU3BoZXJlKCBzZWVkICkgKyByYW5kb21TcGhlcmUoIHRoaXNJc1ZlcnlUZW1wb3JhcnlWYXJpYWJsZSApO1xcbiAgICBwb3MueHl6ICs9IDAuNiAqIHZlYzMoXFxuICAgICAgLXNub2lzZSggdmVjNCggMS44ICogcG9zLnh5eiwgMS44MTEyICsgbm9pc2VQaGFzZSApICksXFxuICAgICAgc25vaXNlKCB2ZWM0KCAxLjggKiBwb3MueHl6LCAzLjgxMTIgKyBub2lzZVBoYXNlICkgKSxcXG4gICAgICAtc25vaXNlKCB2ZWM0KCAxLjggKiBwb3MueHl6LCA1LjgxMTIgKyBub2lzZVBoYXNlICkgKVxcbiAgICApO1xcblxcbiAgICB2ZWwueHl6ID0gMC4xICogcmFuZG9tU3BoZXJlKCBzZWVkICk7XFxuICAgIHZlbC53ID0gMC4wO1xcblxcbiAgICBwb3MudyA9IDEuMDsgLy8gbGlmZVxcbiAgfVxcbiAgXFxuICBpZiAoIHBvcy53IDw9IDAuMCApIHtcXG4gICAgcG9zID0gdmVjNCggMC4wICk7XFxuICAgIHZlbCA9IHZlYzQoIDAuMCApO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gPT0gdXBkYXRlIHBhcnRpY2xlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgICAvLyBmbHVpZFxcbiAgICB7XFxuICAgICAgdmVjMyBtb3Rpb24gPSBmZXRjaE1vdGlvbkxpbmVhciggcG9zLnh5eiApO1xcbiAgICAgIHZlYzMgdG1wID0gcG9zLnh5eiArIGR0ICogMC41ICogKCB2ZWwueHl6ICsgbW90aW9uICk7XFxuICAgICAgbW90aW9uID0gZmV0Y2hNb3Rpb25MaW5lYXIoIHBvcy54eXogKTtcXG4gICAgICB2ZWwueHl6ICs9IGZsdWlkQW1wICogbW90aW9uO1xcbiAgICB9XFxuXFxuICAgIC8vIHdhbGxcXG4gICAgZmxvYXQgYm9yZGVyID0gMi4wO1xcbiAgICBmb3IgKCBpbnQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xcbiAgICAgIGlmICggYm9yZGVyIDwgYWJzKCBwb3NbIGkgXSApICkge1xcbiAgICAgICAgZmxvYXQgcyA9IHNpZ24oIHBvc1sgaSBdICk7XFxuICAgICAgICBwb3NbIGkgXSA9IHMgKiBib3JkZXI7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIHZvbHRleFxcbiAgICAvLyB2ZWwuenggLT0gZHQgKiAxMC4wICogdmVjMiggLTEuMCwgMS4wICkgKiBub3JtYWxpemUoIHBvcy54eiApO1xcblxcbiAgICAvLyBub2lzZVxcbiAgICAvLyB2ZWwueHl6ICs9IGR0ICogbm9pc2VBbXAgKiAyMC4wICogdmVjMyhcXG4gICAgLy8gICAtbm9pc2UoIHZlYzQoIDEuOCAqIHBvcy54eXosIDEuNDg1ICsgbm9pc2VQaGFzZSApICksXFxuICAgIC8vICAgbm9pc2UoIHZlYzQoIDEuOCAqIHBvcy54eXosIDMuNDg1ICsgbm9pc2VQaGFzZSApICksXFxuICAgIC8vICAgLW5vaXNlKCB2ZWM0KCAxLjggKiBwb3MueHl6LCA1LjQ4NSArIG5vaXNlUGhhc2UgKSApXFxuICAgIC8vICk7XFxuXFxuICAgIC8vIGdyYXZpdHlcXG4gICAgLy8gdmVsLnkgLT0gZHQgKiAxMC44O1xcblxcbiAgICBwb3MueHl6ICs9IHZlbC54eXogKiBkdDtcXG4gICAgcG9zLnh5eiArPSAwLjAxICogZHQgKiAoIHZlYzMoXFxuICAgICAgR1BVUm5kKCBzZWVkICksXFxuICAgICAgR1BVUm5kKCBzZWVkICksXFxuICAgICAgR1BVUm5kKCBzZWVkIClcXG4gICAgKSAtIDAuNSApO1xcbiAgICBwb3MudyAtPSBkdCAvIFBBUlRJQ0xFX0xJRkVfTEVOR1RIO1xcbiAgfVxcblxcbiAgZ2xfRnJhZ0NvbG9yID0gKFxcbiAgICBtb2RlIDwgMS4wID8gcG9zIDpcXG4gICAgdmVsXFxuICApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4vLyA9PSB2YXJpYWJsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnVuaWZvcm0gZmxvYXQgblBhcnRpY2xlO1xcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uTW90aW9uO1xcbnVuaWZvcm0gdmVjMiBwbGFuZVJlc29sdXRpb247XFxudW5pZm9ybSBmbG9hdCB2b3hlbFVuaXQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlck1vdGlvbjtcXG5cXG4vLyA9PSBkZWFsIHdpdGggbW90aW9uIGZpZWxkID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnZlYzIgbW90aW9uQ29vcmQoIHZlYzMgX3YgKSB7XFxuICB2ZWMzIHYgPSBmbG9vciggX3YgLyB2b3hlbFVuaXQgKSArIDAuNTtcXG4gIHZlYzIgcGxhbmVTaXplID0gcGxhbmVSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbk1vdGlvbjtcXG5cXG4gIC8vID09IHdoZXJlIGFyZSB0aGUgcGxhbmUgb3JpZ2luPyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgZmxvYXQgelJhbmdlID0gZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS54ICkgKiBmbG9vciggMS4wIC8gcGxhbmVTaXplLnkgKSAvIDIuMDtcXG4gIGlmICggdi56IDwgLXpSYW5nZSB8fCB6UmFuZ2UgPCB2LnogKSB7XFxuICAgIHJldHVybiB2ZWMyKCAwLjAsIDAuMCApO1xcbiAgfVxcbiAgZmxvYXQgcGxhbmVJbmRleCA9IGZsb29yKCB2LnogKyB6UmFuZ2UgKTtcXG4gIHZlYzIgcGxhbmVPcmlnaW4gPSB2ZWMyKCBmcmFjdCggcGxhbmVJbmRleCAqIHBsYW5lU2l6ZS54ICksIGZsb29yKCBwbGFuZUluZGV4ICogcGxhbmVTaXplLnggKSAqIHBsYW5lU2l6ZS55ICk7XFxuXFxuICAvLyA9PSBwbGFjZSBhIGRvdCBvbiB0aGUgcGxhbmUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIHZlYzIgeHlSYW5nZSA9IHBsYW5lUmVzb2x1dGlvbiAvIDIuMDtcXG4gIGlmICggdi54IDwgLXh5UmFuZ2UueCB8fCB4eVJhbmdlLnggPCB2LnggfHwgdi55IDwgLXh5UmFuZ2UueSB8fCB4eVJhbmdlLnkgPCB2LnkgKSB7XFxuICAgIHJldHVybiB2ZWMyKCAwLjAsIDAuMCApO1xcbiAgfVxcbiAgcmV0dXJuIHBsYW5lT3JpZ2luICsgKCB2Lnh5ICsgeHlSYW5nZSApIC8gcGxhbmVSZXNvbHV0aW9uICogcGxhbmVTaXplO1xcbn1cXG5cXG52ZWMzIG1vdGlvbkNvb3JkSW52KCB2ZWMyIF9jb29yZCApIHtcXG4gIHZlYzIgcGxhbmVTaXplID0gcGxhbmVSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbk1vdGlvbjtcXG4gIHZlYzMgcmV0ID0gdmVjMyggMC4wICk7XFxuXFxuICAvLyA9PSB4IGFuZCB5ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIHJldC54eSA9ICggKCBmcmFjdCggX2Nvb3JkIC8gcGxhbmVTaXplICkgLSAwLjUgKSAqIHBsYW5lUmVzb2x1dGlvbiApICogdm94ZWxVbml0O1xcblxcbiAgLy8gPT0geiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBmbG9hdCB6UmFuZ2UgPSBmbG9vciggMS4wIC8gcGxhbmVTaXplLnggKSAqIGZsb29yKCAxLjAgLyBwbGFuZVNpemUueSApIC8gMi4wO1xcbiAgdmVjMiBwbGFuZVBsYWNlID0gZmxvb3IoIF9jb29yZCAvIHBsYW5lU2l6ZSApO1xcbiAgcmV0LnogPSAoIHBsYW5lUGxhY2UueCArIGZsb29yKCBwbGFuZVBsYWNlLnkgLyBwbGFuZVNpemUueCApIC0gelJhbmdlICsgMC41ICkgKiB2b3hlbFVuaXQ7XFxuXFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vLyA9PSBtYWluID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uTW90aW9uO1xcbiAgdmVjMyB2ID0gbW90aW9uQ29vcmRJbnYoIHV2ICk7XFxuXFxuICB2ZWMyIGQgPSB2ZWMyKCAwLjAsIHZveGVsVW5pdCApO1xcblxcbiAgdmVjNCBjZW50ZXIgPSB0ZXh0dXJlMkQoIHNhbXBsZXJNb3Rpb24sIHV2ICk7XFxuICBmbG9hdCB4bSA9IHRleHR1cmUyRCggc2FtcGxlck1vdGlvbiwgbW90aW9uQ29vcmQoIHYgLSBkLnl4eCApICkueDtcXG4gIGZsb2F0IHhwID0gdGV4dHVyZTJEKCBzYW1wbGVyTW90aW9uLCBtb3Rpb25Db29yZCggdiArIGQueXh4ICkgKS54O1xcbiAgZmxvYXQgeW0gPSB0ZXh0dXJlMkQoIHNhbXBsZXJNb3Rpb24sIG1vdGlvbkNvb3JkKCB2IC0gZC54eXggKSApLnk7XFxuICBmbG9hdCB5cCA9IHRleHR1cmUyRCggc2FtcGxlck1vdGlvbiwgbW90aW9uQ29vcmQoIHYgKyBkLnh5eCApICkueTtcXG4gIGZsb2F0IHptID0gdGV4dHVyZTJEKCBzYW1wbGVyTW90aW9uLCBtb3Rpb25Db29yZCggdiAtIGQueHh5ICkgKS56O1xcbiAgZmxvYXQgenAgPSB0ZXh0dXJlMkQoIHNhbXBsZXJNb3Rpb24sIG1vdGlvbkNvb3JkKCB2ICsgZC54eHkgKSApLno7XFxuXFxuICBmbG9hdCBkaXZlcmdlbmNlID0geHAgLSB4bSArIHlwIC0geW0gKyB6cCAtIHptO1xcbiAgZGl2ZXJnZW5jZSAtPSBtYXgoIGNlbnRlci53IC8gblBhcnRpY2xlICogNjAwLjAgLSAxLjAsIDAuMCApO1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggZGl2ZXJnZW5jZSwgMC4wLCAwLjAsIGNlbnRlci53ICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbi8vID09IHZhcmlhYmxlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb25Nb3Rpb247XFxudW5pZm9ybSB2ZWMyIHBsYW5lUmVzb2x1dGlvbjtcXG51bmlmb3JtIGZsb2F0IHZveGVsVW5pdDtcXG5cXG51bmlmb3JtIGZsb2F0IGRlbHRhVGltZTtcXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyTW90aW9uO1xcblxcbi8vID09IGRlYWwgd2l0aCBtb3Rpb24gZmllbGQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudmVjMiBtb3Rpb25Db29yZCggdmVjMyBfdiApIHtcXG4gIHZlYzMgdiA9IGZsb29yKCBfdiAvIHZveGVsVW5pdCApICsgMC41O1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcblxcbiAgLy8gPT0gd2hlcmUgYXJlIHRoZSBwbGFuZSBvcmlnaW4/ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBmbG9hdCB6UmFuZ2UgPSBmbG9vciggMS4wIC8gcGxhbmVTaXplLnggKSAqIGZsb29yKCAxLjAgLyBwbGFuZVNpemUueSApIC8gMi4wO1xcbiAgaWYgKCB2LnogPCAtelJhbmdlIHx8IHpSYW5nZSA8IHYueiApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICBmbG9hdCBwbGFuZUluZGV4ID0gZmxvb3IoIHYueiArIHpSYW5nZSApO1xcbiAgdmVjMiBwbGFuZU9yaWdpbiA9IHZlYzIoIGZyYWN0KCBwbGFuZUluZGV4ICogcGxhbmVTaXplLnggKSwgZmxvb3IoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApICogcGxhbmVTaXplLnkgKTtcXG5cXG4gIC8vID09IHBsYWNlIGEgZG90IG9uIHRoZSBwbGFuZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdmVjMiB4eVJhbmdlID0gcGxhbmVSZXNvbHV0aW9uIC8gMi4wO1xcbiAgaWYgKCB2LnggPCAteHlSYW5nZS54IHx8IHh5UmFuZ2UueCA8IHYueCB8fCB2LnkgPCAteHlSYW5nZS55IHx8IHh5UmFuZ2UueSA8IHYueSApIHtcXG4gICAgcmV0dXJuIHZlYzIoIDAuMCwgMC4wICk7XFxuICB9XFxuICByZXR1cm4gcGxhbmVPcmlnaW4gKyAoIHYueHkgKyB4eVJhbmdlICkgLyBwbGFuZVJlc29sdXRpb24gKiBwbGFuZVNpemU7XFxufVxcblxcbnZlYzMgbW90aW9uQ29vcmRJbnYoIHZlYzIgX2Nvb3JkICkge1xcbiAgdmVjMiBwbGFuZVNpemUgPSBwbGFuZVJlc29sdXRpb24gLyByZXNvbHV0aW9uTW90aW9uO1xcbiAgdmVjMyByZXQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4gIC8vID09IHggYW5kIHkgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgcmV0Lnh5ID0gKCAoIGZyYWN0KCBfY29vcmQgLyBwbGFuZVNpemUgKSAtIDAuNSApICogcGxhbmVSZXNvbHV0aW9uICkgKiB2b3hlbFVuaXQ7XFxuXFxuICAvLyA9PSB6ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHpSYW5nZSA9IGZsb29yKCAxLjAgLyBwbGFuZVNpemUueCApICogZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS55ICkgLyAyLjA7XFxuICB2ZWMyIHBsYW5lUGxhY2UgPSBmbG9vciggX2Nvb3JkIC8gcGxhbmVTaXplICk7XFxuICByZXQueiA9ICggcGxhbmVQbGFjZS54ICsgZmxvb3IoIHBsYW5lUGxhY2UueSAvIHBsYW5lU2l6ZS54ICkgLSB6UmFuZ2UgKyAwLjUgKSAqIHZveGVsVW5pdDtcXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vID09IHVtID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudmVjMyBleHRyYWN0VmVsb2NpdHkoIHZlYzQgdGV4ICkge1xcbiAgcmV0dXJuIHRleC53ID09IDAuMCA/IHZlYzMoIDAuMCApIDogdGV4Lnh5eiAvIHRleC53O1xcbn1cXG5cXG4vLyA9PSBtYWluID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uTW90aW9uO1xcbiAgdmVjMyB2ID0gbW90aW9uQ29vcmRJbnYoIHV2ICk7XFxuICB2ZWMzIG11bCA9IHZlYzMoIDEuMCApO1xcblxcbiAgZm9yICggaW50IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcXG4gICAgZmxvYXQgYm9yZGVyID0gMi4wO1xcbiAgICBpZiAoIGJvcmRlciA8IGFicyggdlsgaSBdICkgKSB7XFxuICAgICAgdlsgaSBdID0gYm9yZGVyO1xcbiAgICAgIG11bFsgaSBdICo9IC0xLjA7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZlYzMgdmVsID0gdmVjMyggMC4wICk7XFxuXFxuICBmb3IgKCBpbnQgaXogPSAtMTsgaXogPD0gMTsgaXogKysgKSB7XFxuICAgIGZvciAoIGludCBpeSA9IC0xOyBpeSA8PSAxOyBpeSArKyApIHtcXG4gICAgICBmb3IgKCBpbnQgaXggPSAtMTsgaXggPD0gMTsgaXggKysgKSB7XFxuICAgICAgICB2ZWM0IHRleCA9IHRleHR1cmUyRCggc2FtcGxlck1vdGlvbiwgbW90aW9uQ29vcmQoIHYgKyB2ZWMzKCBpeCwgaXksIGl6ICkgKiB2b3hlbFVuaXQgKSApO1xcbiAgICAgICAgdmVsICs9IGV4dHJhY3RWZWxvY2l0eSggdGV4ICkgLyAyNy4wO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgdmVjNCB0ZXggPSB0ZXh0dXJlMkQoIHNhbXBsZXJNb3Rpb24sIHV2ICk7XFxuICB2ZWwgKz0gZGVsdGFUaW1lICogKCB0ZXgudyA9PSAwLjAgPyB2ZWMzKCAwLjAgKSA6IHZlYzMoIDAuMCwgLTEwLjAsIDAuMCApICk7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBtdWwgKiB2ZWwsIHRleC53ICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbi8vID09IHZhcmlhYmxlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudmFyeWluZyB2ZWMzIHZDb2w7XFxudmFyeWluZyBmbG9hdCB2VmFsaWQ7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgLy8gPT0gaWYgaXQgaXMgaW52YWxpZCB0aGVuIGp1c3QgZGlzY2FyZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBpZiAoIHZWYWxpZCA9PSAwLjAgKSB7IGRpc2NhcmQ7IH1cXG5cXG4gIC8vID09IGp1c3Qgc2hvdCBhIGRvdCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggdkNvbCwgMS4wICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgR0xTTElGWSAxXFxuI2RlZmluZSBIVUdFIDlFMTZcXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjU0XFxuI2RlZmluZSBUQVUgNi4yODMxODUzMDdcXG4jZGVmaW5lIFYgdmVjMygwLiwxLiwtMS4pXFxuI2RlZmluZSBzYXR1cmF0ZShpKSBjbGFtcChpLDAuLDEuKVxcbiNkZWZpbmUgbG9maShpLG0pIChmbG9vcigoaSkvKG0pKSoobSkpXFxuI2RlZmluZSBsb2ZpcihpLG0pIChmbG9vcigoaSswLjUpLyhtKSkqKG0pKVxcblxcbi8vID09IHZhcmlhYmxlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuYXR0cmlidXRlIHZlYzIgY29tcHV0ZVVWO1xcblxcbnZhcnlpbmcgdmVjMyB2Q29sO1xcbnZhcnlpbmcgZmxvYXQgdlZhbGlkO1xcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uUGNvbXB1dGU7XFxuXFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb25Nb3Rpb247XFxudW5pZm9ybSB2ZWMyIHBsYW5lUmVzb2x1dGlvbjtcXG51bmlmb3JtIGZsb2F0IHZveGVsVW5pdDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyUGNvbXB1dGU7XFxuXFxuLy8gPT0gZGVhbCB3aXRoIG1vdGlvbiBmaWVsZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG52ZWMyIG1vdGlvbkNvb3JkKCB2ZWMzIF92ICkge1xcbiAgdmVjMyB2ID0gZmxvb3IoIF92IC8gdm94ZWxVbml0ICkgKyAwLjU7XFxuICB2ZWMyIHBsYW5lU2l6ZSA9IHBsYW5lUmVzb2x1dGlvbiAvIHJlc29sdXRpb25Nb3Rpb247XFxuXFxuICAvLyA9PSB3aGVyZSBhcmUgdGhlIHBsYW5lIG9yaWdpbj8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHpSYW5nZSA9IGZsb29yKCAxLjAgLyBwbGFuZVNpemUueCApICogZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS55ICkgLyAyLjA7XFxuICBpZiAoIHYueiA8IC16UmFuZ2UgfHwgelJhbmdlIDwgdi56ICkge1xcbiAgICByZXR1cm4gdmVjMiggMC4wLCAwLjAgKTtcXG4gIH1cXG4gIGZsb2F0IHBsYW5lSW5kZXggPSBmbG9vciggdi56ICsgelJhbmdlICk7XFxuICB2ZWMyIHBsYW5lT3JpZ2luID0gdmVjMiggZnJhY3QoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApLCBmbG9vciggcGxhbmVJbmRleCAqIHBsYW5lU2l6ZS54ICkgKiBwbGFuZVNpemUueSApO1xcblxcbiAgLy8gPT0gcGxhY2UgYSBkb3Qgb24gdGhlIHBsYW5lID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICB2ZWMyIHh5UmFuZ2UgPSBwbGFuZVJlc29sdXRpb24gLyAyLjA7XFxuICBpZiAoIHYueCA8IC14eVJhbmdlLnggfHwgeHlSYW5nZS54IDwgdi54IHx8IHYueSA8IC14eVJhbmdlLnkgfHwgeHlSYW5nZS55IDwgdi55ICkge1xcbiAgICByZXR1cm4gdmVjMiggMC4wLCAwLjAgKTtcXG4gIH1cXG4gIHJldHVybiBwbGFuZU9yaWdpbiArICggdi54eSArIHh5UmFuZ2UgKSAvIHBsYW5lUmVzb2x1dGlvbiAqIHBsYW5lU2l6ZTtcXG59XFxuXFxuLy8gPT0gbWFpbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG52b2lkIG1haW4oKSB7XFxuICAvLyA9PSBmZXRjaCBjb21wdXRlIHRleHR1cmUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIHZlYzIgcHV2ID0gY29tcHV0ZVVWO1xcbiAgdmVjMiBkcHBpeCA9IHZlYzIoIDEuMCApIC8gcmVzb2x1dGlvblBjb21wdXRlO1xcblxcbiAgdmVjNCBwb3MgPSB0ZXh0dXJlMkQoIHNhbXBsZXJQY29tcHV0ZSwgcHV2ICk7XFxuICB2ZWM0IHZlbCA9IHRleHR1cmUyRCggc2FtcGxlclBjb21wdXRlLCBwdXYgKyBkcHBpeCAqIHZlYzIoIDEuMCwgMC4wICkgKTtcXG5cXG4gIC8vID09IHBsYWNlIGEgZG90ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdmVjMiBjb29yZCA9IG1vdGlvbkNvb3JkKCBwb3MueHl6ICk7XFxuICB2VmFsaWQgPSBjb29yZCAhPSB2ZWMyKCAwLjAsIDAuMCApID8gMS4wIDogMC4wOyAvLyBvdXQgb2YgY29tcHV0ZSBjZWxsc1xcbiAgdlZhbGlkID0gMC4wIDwgcG9zLncgPyAxLjAgOiAwLjA7IC8vIGxpZmUgaXMgZGVwbGV0ZWRcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCggY29vcmQgKiAyLjAgLSAxLjAsIDAuMCwgMS4wICk7XFxuICBnbF9Qb2ludFNpemUgPSAxLjA7XFxuXFxuICAvLyA9PSBzZXQgYSBjb2xvciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIHZDb2wgPSB2ZWwueHl6O1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4vLyA9PSB2YXJpYWJsZXMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnVuaWZvcm0gZmxvYXQgZGVsdGFUaW1lO1xcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uTW90aW9uO1xcbnVuaWZvcm0gdmVjMiBwbGFuZVJlc29sdXRpb247XFxudW5pZm9ybSBmbG9hdCB2b3hlbFVuaXQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlck1vdGlvbjtcXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyUHJlc3N1cmU7XFxuXFxuLy8gPT0gZGVhbCB3aXRoIG1vdGlvbiBmaWVsZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG52ZWMyIG1vdGlvbkNvb3JkKCB2ZWMzIF92ICkge1xcbiAgdmVjMyB2ID0gZmxvb3IoIF92IC8gdm94ZWxVbml0ICkgKyAwLjU7XFxuICB2ZWMyIHBsYW5lU2l6ZSA9IHBsYW5lUmVzb2x1dGlvbiAvIHJlc29sdXRpb25Nb3Rpb247XFxuXFxuICAvLyA9PSB3aGVyZSBhcmUgdGhlIHBsYW5lIG9yaWdpbj8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHpSYW5nZSA9IGZsb29yKCAxLjAgLyBwbGFuZVNpemUueCApICogZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS55ICkgLyAyLjA7XFxuICBpZiAoIHYueiA8IC16UmFuZ2UgfHwgelJhbmdlIDwgdi56ICkge1xcbiAgICByZXR1cm4gdmVjMiggMC4wLCAwLjAgKTtcXG4gIH1cXG4gIGZsb2F0IHBsYW5lSW5kZXggPSBmbG9vciggdi56ICsgelJhbmdlICk7XFxuICB2ZWMyIHBsYW5lT3JpZ2luID0gdmVjMiggZnJhY3QoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApLCBmbG9vciggcGxhbmVJbmRleCAqIHBsYW5lU2l6ZS54ICkgKiBwbGFuZVNpemUueSApO1xcblxcbiAgLy8gPT0gcGxhY2UgYSBkb3Qgb24gdGhlIHBsYW5lID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICB2ZWMyIHh5UmFuZ2UgPSBwbGFuZVJlc29sdXRpb24gLyAyLjA7XFxuICBpZiAoIHYueCA8IC14eVJhbmdlLnggfHwgeHlSYW5nZS54IDwgdi54IHx8IHYueSA8IC14eVJhbmdlLnkgfHwgeHlSYW5nZS55IDwgdi55ICkge1xcbiAgICByZXR1cm4gdmVjMiggMC4wLCAwLjAgKTtcXG4gIH1cXG4gIHJldHVybiBwbGFuZU9yaWdpbiArICggdi54eSArIHh5UmFuZ2UgKSAvIHBsYW5lUmVzb2x1dGlvbiAqIHBsYW5lU2l6ZTtcXG59XFxuXFxudmVjMyBtb3Rpb25Db29yZEludiggdmVjMiBfY29vcmQgKSB7XFxuICB2ZWMyIHBsYW5lU2l6ZSA9IHBsYW5lUmVzb2x1dGlvbiAvIHJlc29sdXRpb25Nb3Rpb247XFxuICB2ZWMzIHJldCA9IHZlYzMoIDAuMCApO1xcblxcbiAgLy8gPT0geCBhbmQgeSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICByZXQueHkgPSAoICggZnJhY3QoIF9jb29yZCAvIHBsYW5lU2l6ZSApIC0gMC41ICkgKiBwbGFuZVJlc29sdXRpb24gKSAqIHZveGVsVW5pdDtcXG5cXG4gIC8vID09IHogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgZmxvYXQgelJhbmdlID0gZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS54ICkgKiBmbG9vciggMS4wIC8gcGxhbmVTaXplLnkgKSAvIDIuMDtcXG4gIHZlYzIgcGxhbmVQbGFjZSA9IGZsb29yKCBfY29vcmQgLyBwbGFuZVNpemUgKTtcXG4gIHJldC56ID0gKCBwbGFuZVBsYWNlLnggKyBmbG9vciggcGxhbmVQbGFjZS55IC8gcGxhbmVTaXplLnggKSAtIHpSYW5nZSArIDAuNSApICogdm94ZWxVbml0O1xcblxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuLy8gPT0gdW0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG52ZWMzIGV4dHJhY3RWZWxvY2l0eSggdmVjNCB0ZXggKSB7XFxuICByZXR1cm4gdGV4LncgPT0gMC4wID8gdmVjMyggMC4wICkgOiB0ZXgueHl6IC8gdGV4Lnc7XFxufVxcblxcbi8vID09IG1haW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb25Nb3Rpb247XFxuICB2ZWMzIHYgPSBtb3Rpb25Db29yZEludiggdXYgKTtcXG4gIHZlYzMgbXVsID0gdmVjMyggMS4wICk7XFxuXFxuICBmb3IgKCBpbnQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xcbiAgICBmbG9hdCBib3JkZXIgPSAyLjA7XFxuICAgIGlmICggYm9yZGVyIDwgYWJzKCB2WyBpIF0gKSApIHtcXG4gICAgICB2WyBpIF0gPSBib3JkZXI7XFxuICAgICAgbXVsWyBpIF0gKj0gLTEuMDtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmVjMiBkID0gdmVjMiggMC4wLCB2b3hlbFVuaXQgKTtcXG5cXG4gIGZsb2F0IHhtID0gdGV4dHVyZTJEKCBzYW1wbGVyUHJlc3N1cmUsIG1vdGlvbkNvb3JkKCB2IC0gZC55eHggKSApLng7XFxuICBmbG9hdCB4cCA9IHRleHR1cmUyRCggc2FtcGxlclByZXNzdXJlLCBtb3Rpb25Db29yZCggdiArIGQueXh4ICkgKS54O1xcbiAgZmxvYXQgeW0gPSB0ZXh0dXJlMkQoIHNhbXBsZXJQcmVzc3VyZSwgbW90aW9uQ29vcmQoIHYgLSBkLnh5eCApICkueDtcXG4gIGZsb2F0IHlwID0gdGV4dHVyZTJEKCBzYW1wbGVyUHJlc3N1cmUsIG1vdGlvbkNvb3JkKCB2ICsgZC54eXggKSApLng7XFxuICBmbG9hdCB6bSA9IHRleHR1cmUyRCggc2FtcGxlclByZXNzdXJlLCBtb3Rpb25Db29yZCggdiAtIGQueHh5ICkgKS54O1xcbiAgZmxvYXQgenAgPSB0ZXh0dXJlMkQoIHNhbXBsZXJQcmVzc3VyZSwgbW90aW9uQ29vcmQoIHYgKyBkLnh4eSApICkueDtcXG5cXG4gIHZlYzMgb2xkVmVsID0gZXh0cmFjdFZlbG9jaXR5KCB0ZXh0dXJlMkQoIHNhbXBsZXJNb3Rpb24sIHV2ICkgKTtcXG4gIHZlYzMgbmV3VmVsID0gb2xkVmVsIC0gdmVjMyggeHAgLSB4bSwgeXAgLSB5bSwgenAgLSB6bSApO1xcbiAgbmV3VmVsICo9IG11bDtcXG5cXG4gIGlmICggdm94ZWxVbml0IC8gZGVsdGFUaW1lIDwgbGVuZ3RoKCBuZXdWZWwgKSApIHtcXG4gICAgbmV3VmVsID0gbm9ybWFsaXplKCBuZXdWZWwgKSAqIHZveGVsVW5pdCAvIGRlbHRhVGltZTtcXG4gIH1cXG5cXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG5ld1ZlbCAtIG9sZFZlbCwgMS4wICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbi8vID09IHZhcmlhYmxlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb25Nb3Rpb247XFxudW5pZm9ybSB2ZWMyIHBsYW5lUmVzb2x1dGlvbjtcXG51bmlmb3JtIGZsb2F0IHZveGVsVW5pdDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyRGl2ZXJnZW5jZTtcXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyUHJlc3N1cmU7XFxuXFxuLy8gPT0gZGVhbCB3aXRoIG1vdGlvbiBmaWVsZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG52ZWMyIG1vdGlvbkNvb3JkKCB2ZWMzIF92ICkge1xcbiAgdmVjMyB2ID0gZmxvb3IoIF92IC8gdm94ZWxVbml0ICkgKyAwLjU7XFxuICB2ZWMyIHBsYW5lU2l6ZSA9IHBsYW5lUmVzb2x1dGlvbiAvIHJlc29sdXRpb25Nb3Rpb247XFxuXFxuICAvLyA9PSB3aGVyZSBhcmUgdGhlIHBsYW5lIG9yaWdpbj8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHpSYW5nZSA9IGZsb29yKCAxLjAgLyBwbGFuZVNpemUueCApICogZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS55ICkgLyAyLjA7XFxuICBpZiAoIHYueiA8IC16UmFuZ2UgfHwgelJhbmdlIDwgdi56ICkge1xcbiAgICByZXR1cm4gdmVjMiggMC4wLCAwLjAgKTtcXG4gIH1cXG4gIGZsb2F0IHBsYW5lSW5kZXggPSBmbG9vciggdi56ICsgelJhbmdlICk7XFxuICB2ZWMyIHBsYW5lT3JpZ2luID0gdmVjMiggZnJhY3QoIHBsYW5lSW5kZXggKiBwbGFuZVNpemUueCApLCBmbG9vciggcGxhbmVJbmRleCAqIHBsYW5lU2l6ZS54ICkgKiBwbGFuZVNpemUueSApO1xcblxcbiAgLy8gPT0gcGxhY2UgYSBkb3Qgb24gdGhlIHBsYW5lID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICB2ZWMyIHh5UmFuZ2UgPSBwbGFuZVJlc29sdXRpb24gLyAyLjA7XFxuICBpZiAoIHYueCA8IC14eVJhbmdlLnggfHwgeHlSYW5nZS54IDwgdi54IHx8IHYueSA8IC14eVJhbmdlLnkgfHwgeHlSYW5nZS55IDwgdi55ICkge1xcbiAgICByZXR1cm4gdmVjMiggMC4wLCAwLjAgKTtcXG4gIH1cXG4gIHJldHVybiBwbGFuZU9yaWdpbiArICggdi54eSArIHh5UmFuZ2UgKSAvIHBsYW5lUmVzb2x1dGlvbiAqIHBsYW5lU2l6ZTtcXG59XFxuXFxudmVjMyBtb3Rpb25Db29yZEludiggdmVjMiBfY29vcmQgKSB7XFxuICB2ZWMyIHBsYW5lU2l6ZSA9IHBsYW5lUmVzb2x1dGlvbiAvIHJlc29sdXRpb25Nb3Rpb247XFxuICB2ZWMzIHJldCA9IHZlYzMoIDAuMCApO1xcblxcbiAgLy8gPT0geCBhbmQgeSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICByZXQueHkgPSAoICggZnJhY3QoIF9jb29yZCAvIHBsYW5lU2l6ZSApIC0gMC41ICkgKiBwbGFuZVJlc29sdXRpb24gKSAqIHZveGVsVW5pdDtcXG5cXG4gIC8vID09IHogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgZmxvYXQgelJhbmdlID0gZmxvb3IoIDEuMCAvIHBsYW5lU2l6ZS54ICkgKiBmbG9vciggMS4wIC8gcGxhbmVTaXplLnkgKSAvIDIuMDtcXG4gIHZlYzIgcGxhbmVQbGFjZSA9IGZsb29yKCBfY29vcmQgLyBwbGFuZVNpemUgKTtcXG4gIHJldC56ID0gKCBwbGFuZVBsYWNlLnggKyBmbG9vciggcGxhbmVQbGFjZS55IC8gcGxhbmVTaXplLnggKSAtIHpSYW5nZSArIDAuNSApICogdm94ZWxVbml0O1xcblxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuLy8gPT0gbWFpbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbk1vdGlvbjtcXG4gIHZlYzMgdiA9IG1vdGlvbkNvb3JkSW52KCB1diApO1xcblxcbiAgdmVjMiBkID0gdmVjMiggMC4wLCB2b3hlbFVuaXQgKTtcXG5cXG4gIHZlYzQgZGl2ZXJnZW5jZSA9IHRleHR1cmUyRCggc2FtcGxlckRpdmVyZ2VuY2UsIHV2ICk7XFxuICBpZiAoIGRpdmVyZ2VuY2UudyA9PSAwLjAgKSB7IGRpc2NhcmQ7IH0gLy8gdGhpcyBpcyBhbiBhaXJcXG5cXG4gIGZsb2F0IHhtID0gdGV4dHVyZTJEKCBzYW1wbGVyUHJlc3N1cmUsIG1vdGlvbkNvb3JkKCB2IC0gZC55eHggKSApLng7XFxuICBmbG9hdCB4cCA9IHRleHR1cmUyRCggc2FtcGxlclByZXNzdXJlLCBtb3Rpb25Db29yZCggdiArIGQueXh4ICkgKS54O1xcbiAgZmxvYXQgeW0gPSB0ZXh0dXJlMkQoIHNhbXBsZXJQcmVzc3VyZSwgbW90aW9uQ29vcmQoIHYgLSBkLnh5eCApICkueDtcXG4gIGZsb2F0IHlwID0gdGV4dHVyZTJEKCBzYW1wbGVyUHJlc3N1cmUsIG1vdGlvbkNvb3JkKCB2ICsgZC54eXggKSApLng7XFxuICBmbG9hdCB6bSA9IHRleHR1cmUyRCggc2FtcGxlclByZXNzdXJlLCBtb3Rpb25Db29yZCggdiAtIGQueHh5ICkgKS54O1xcbiAgZmxvYXQgenAgPSB0ZXh0dXJlMkQoIHNhbXBsZXJQcmVzc3VyZSwgbW90aW9uQ29vcmQoIHYgKyBkLnh4eSApICkueDtcXG5cXG4gIGZsb2F0IHByZXNzdXJlID0gKCB4bSArIHhwICsgeW0gKyB5cCArIHptICsgenAgLSBkaXZlcmdlbmNlLnggKSAvIDYuMDtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHByZXNzdXJlLCAwLjAsIDAuMCwgMS4wICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgUEkgMy4xNDE1OTI2NVxcbiNkZWZpbmUgVEFVIDYuMjgzMTg1MzFcXG4jZGVmaW5lIHNhdHVyYXRlKGkpIGNsYW1wKGksMC4sMS4pXFxuXFxuLy8gLS0tLS0tXFxuXFxuI2V4dGVuc2lvbiBHTF9FWFRfZHJhd19idWZmZXJzIDogcmVxdWlyZVxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMyB2UG9zO1xcbnZhcnlpbmcgdmVjMyB2Tm9yO1xcbnZhcnlpbmcgdmVjMyB2Q29sO1xcbnZhcnlpbmcgZmxvYXQgdkxpZmU7XFxuXFxudW5pZm9ybSBtYXQ0IG1hdFBMO1xcbnVuaWZvcm0gbWF0NCBtYXRWTDtcXG5cXG51bmlmb3JtIHZlYzMgY2FtZXJhUG9zO1xcbnVuaWZvcm0gZmxvYXQgcGVyc3BGYXI7XFxudW5pZm9ybSB2ZWMzIGxpZ2h0UG9zO1xcblxcbnVuaWZvcm0gYm9vbCBpc1NoYWRvdztcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyU2hhZG93O1xcblxcbi8vID09IHJvdGF0ZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxubWF0MiByb3RhdGUyRCggZmxvYXQgX3QgKSB7XFxuICByZXR1cm4gbWF0MiggY29zKCBfdCApLCBzaW4oIF90ICksIC1zaW4oIF90ICksIGNvcyggX3QgKSApO1xcbn1cXG5cXG4vLyA9PSB1aCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbmZsb2F0IHNoYWRvdyggZmxvYXQgZCApIHtcXG4gIHZlYzQgcGwgPSBtYXRQTCAqIG1hdFZMICogdmVjNCggdlBvcywgMS4wICk7XFxuICB2ZWMyIHV2ID0gcGwueHkgLyBwbC53ICogMC41ICsgMC41O1xcblxcbiAgZmxvYXQgZGMgPSBsZW5ndGgoIHZQb3MgLSBsaWdodFBvcyApO1xcbiAgZmxvYXQgcmV0ID0gMC4wO1xcbiAgZm9yICggaW50IGl5ID0gLTE7IGl5IDw9IDE7IGl5ICsrICkge1xcbiAgICBmb3IgKCBpbnQgaXggPSAtMTsgaXggPD0gMTsgaXggKysgKSB7XFxuICAgICAgdmVjMiB1diA9IHV2ICsgdmVjMiggZmxvYXQoIGl4ICksIGZsb2F0ICggaXkgKSApICogMUUtMztcXG4gICAgICBmbG9hdCBwcm9qID0gdGV4dHVyZTJEKCBzYW1wbGVyU2hhZG93LCB1diApLng7XFxuICAgICAgZmxvYXQgYmlhcyA9IDAuMSArICggMS4wIC0gZCApICogMC4zO1xcblxcbiAgICAgIGZsb2F0IGRpZiA9IHNtb290aHN0ZXAoIGJpYXMgKiAyLjAsIGJpYXMsICggZGMgLSBwcm9qICkgKTtcXG4gICAgICByZXQgKz0gZGlmIC8gOS4wO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vLyA9PSBtYWluIHByb2NlZHVyZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbnZvaWQgbWFpbigpIHtcXG4gIGlmICggdkxpZmUgPD0gMC4wICkgeyBkaXNjYXJkOyB9XFxuXFxuICBpZiAoIGlzU2hhZG93ICkge1xcbiAgICBmbG9hdCBkZXB0aCA9IGxlbmd0aCggdlBvcyAtIGxpZ2h0UG9zICk7XFxuICAgIGdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCBkZXB0aCwgMC4wLCAwLjAsIDEuMCApO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICB2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCB2UG9zIC0gbGlnaHRQb3MgKTtcXG4gIHZlYzMgcmF5RGlyID0gbm9ybWFsaXplKCB2UG9zIC0gY2FtZXJhUG9zICk7XFxuICBmbG9hdCBkID0gZG90KCAtdk5vciwgbGlnaHREaXIgKTtcXG4gIGZsb2F0IGRpZiA9IG1peCggMS4wLCBkLCAwLjUgKTtcXG4gIHZlYzMgY29sID0gZGlmICogdkNvbDtcXG5cXG4gIGZsb2F0IHNoYWRvd0ZhY3RvciA9IHNoYWRvdyggZCApO1xcbiAgY29sICo9IG1peCggMC41LCAxLjAsIHNoYWRvd0ZhY3RvciApO1xcbiAgY29sID0gbWF4KCB2ZWMzKCAwLjAgKSwgY29sICk7XFxuXFxuICBnbF9GcmFnRGF0YVsgMCBdID0gdmVjNCggY29sLCAxLjAgKTtcXG4gIGdsX0ZyYWdEYXRhWyAxIF0gPSB2ZWM0KCBsZW5ndGgoIGNhbWVyYVBvcyAtIHZQb3MgKSwgMC4wLCAwLjAsIDEuMCApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiNkZWZpbmUgSFVHRSA5RTE2XFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1NFxcbiNkZWZpbmUgVEFVIDYuMjgzMTg1MzA3XFxuI2RlZmluZSBWIHZlYzMoMC4sMS4sLTEuKVxcbiNkZWZpbmUgc2F0dXJhdGUoaSkgY2xhbXAoaSwwLiwxLilcXG4jZGVmaW5lIGxvZmkoaSxtKSAoZmxvb3IoKGkpLyhtKSkqKG0pKVxcbiNkZWZpbmUgbG9maXIoaSxtKSAoZmxvb3IoKGkrMC41KS8obSkpKihtKSlcXG5cXG4vLyAtLS0tLS1cXG5cXG5hdHRyaWJ1dGUgdmVjMiBjb21wdXRlVVY7XFxuYXR0cmlidXRlIHZlYzMgZ2VvbVBvcztcXG5hdHRyaWJ1dGUgdmVjMyBnZW9tTm9yO1xcblxcbnZhcnlpbmcgdmVjMyB2UG9zO1xcbnZhcnlpbmcgdmVjMyB2Tm9yO1xcbnZhcnlpbmcgdmVjMyB2Q29sO1xcbnZhcnlpbmcgZmxvYXQgdkxpZmU7XFxuXFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb25QY29tcHV0ZTtcXG5cXG51bmlmb3JtIG1hdDQgbWF0UDtcXG51bmlmb3JtIG1hdDQgbWF0VjtcXG51bmlmb3JtIG1hdDQgbWF0Vkw7XFxudW5pZm9ybSBtYXQ0IG1hdFBMO1xcblxcbnVuaWZvcm0gYm9vbCBpc1NoYWRvdztcXG5cXG51bmlmb3JtIGZsb2F0IGNvbG9yVmFyO1xcbnVuaWZvcm0gZmxvYXQgY29sb3JPZmZzZXQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlclBjb21wdXRlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXJSYW5kb21TdGF0aWM7XFxuXFxuLy8gLS0tLS0tXFxuXFxudmVjMyBjYXRDb2xvciggZmxvYXQgX3AgKSB7XFxuICByZXR1cm4gMC41ICsgMC41ICogdmVjMyhcXG4gICAgY29zKCBfcCApLFxcbiAgICBjb3MoIF9wICsgUEkgLyAzLjAgKiA0LjAgKSxcXG4gICAgY29zKCBfcCArIFBJIC8gMy4wICogMi4wIClcXG4gICk7XFxufVxcblxcbnZlYzQgcmFuZG9tKCB2ZWMyIF91diApIHtcXG4gIHJldHVybiB0ZXh0dXJlMkQoIHNhbXBsZXJSYW5kb21TdGF0aWMsIF91diApO1xcbn1cXG5cXG5tYXQyIHJvdGF0ZTJEKCBmbG9hdCBfdCApIHtcXG4gIHJldHVybiBtYXQyKCBjb3MoIF90ICksIHNpbiggX3QgKSwgLXNpbiggX3QgKSwgY29zKCBfdCApICk7XFxufVxcblxcbi8vIC0tLS0tLVxcblxcbnZlYzMgcm90YXRlR2VvbWV0cnkoIHZlYzMgX3AsIHZlYzMgX3YgKSB7XFxuICB2ZWMzIHYgPSBfdjtcXG4gIHYueXogPSByb3RhdGUyRCggNC4wICogX3AueCApICogdi55ejtcXG4gIHYuenggPSByb3RhdGUyRCggNC4wICogX3AueSApICogdi56eDtcXG4gIHYueHkgPSByb3RhdGUyRCggNC4wICogX3AueiApICogdi54eTtcXG4gIHJldHVybiB2O1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICAvLyA9PSBmZXRjaCBjb21wdXRlIHRleHR1cmUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIHZlYzIgcHV2ID0gY29tcHV0ZVVWO1xcbiAgdmVjMiBkcHBpeCA9IHZlYzIoIDEuMCApIC8gcmVzb2x1dGlvblBjb21wdXRlO1xcblxcbiAgdmVjNCBwb3MgPSB0ZXh0dXJlMkQoIHNhbXBsZXJQY29tcHV0ZSwgcHV2ICk7XFxuICB2ZWM0IHZlbCA9IHRleHR1cmUyRCggc2FtcGxlclBjb21wdXRlLCBwdXYgKyBkcHBpeCAqIHZlYzIoIDEuMCwgMC4wICkgKTtcXG5cXG4gIC8vID09ID8/Pz8/Pz8/ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdmVjNCBkaWNlID0gcmFuZG9tKCBwdXYueXkgKiAxODIuOTIgKTtcXG5cXG4gIC8vID09IGFzc2lnbiB2YXJ5aW5nIHZhcmlhYmxlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgdkxpZmUgPSBwb3MudztcXG5cXG4gIC8vIHZDb2wgPSAoXFxuICAvLyAgIGRpY2UueSA8IDAuOFxcbiAgLy8gICA/IHBvdyggY2F0Q29sb3IoIFRBVSAqICggKCBkaWNlLnggKiAyLjAgLSAxLjAgKSAqIGNvbG9yVmFyICsgY29sb3JPZmZzZXQgKSApLCB2ZWMzKCAyLjAgKSApXFxuICAvLyAgIDogdmVjMyggMC40IClcXG4gIC8vICk7XFxuICAvLyB2Q29sID0gYWJzKCB2ZWwueHl6ICk7XFxuICB2Q29sID0gY2F0Q29sb3IoIDQuNSAtIGxlbmd0aCggdmVsICkgKiAwLjMgKTtcXG4gIHZDb2wgKj0gMC41ICsgMC40ICogbGVuZ3RoKCB2ZWwgKTtcXG4gIHZDb2wgKj0gdkxpZmU7XFxuICAvLyB2Q29sID0gdmVjMyggNS4wICk7XFxuXFxuICAvLyA9PSBnZW9tZXRyeSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIGZsb2F0IHNpemUgPSAoIDAuMDEgKyAwLjAxICogcG93KCBkaWNlLncsIDIuMCApICk7XFxuICBzaXplICo9IG1pbiggbGVuZ3RoKCB2Q29sICksIDEuMCApO1xcblxcbiAgdk5vciA9IHJvdGF0ZUdlb21ldHJ5KCBwb3MueHl6LCBnZW9tTm9yICk7XFxuICBwb3MueHl6ICs9IHNpemUgKiByb3RhdGVHZW9tZXRyeSggcG9zLnh5eiwgZ2VvbVBvcyApO1xcblxcbiAgLy8gPT0gZmluYWxpemUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICB2UG9zID0gcG9zLnh5ejtcXG5cXG4gIHZlYzQgb3V0UG9zO1xcbiAgaWYgKCBpc1NoYWRvdyApIHtcXG4gICAgb3V0UG9zID0gbWF0UEwgKiBtYXRWTCAqIHZlYzQoIHBvcy54eXosIDEuMCApO1xcbiAgfSBlbHNlIHtcXG4gICAgb3V0UG9zID0gbWF0UCAqIG1hdFYgKiB2ZWM0KCBwb3MueHl6LCAxLjAgKTtcXG4gICAgb3V0UG9zLnggLz0gcmVzb2x1dGlvbi54IC8gcmVzb2x1dGlvbi55O1xcbiAgfVxcbiAgZ2xfUG9zaXRpb24gPSBvdXRQb3M7XFxuICAvLyBnbF9Qb2ludFNpemUgPSByZXNvbHV0aW9uLnkgKiBzaXplIC8gb3V0UG9zLno7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgRElSIGZhbHNlXFxuI2RlZmluZSBSRVZFUlNFIGZhbHNlXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxuXFxudW5pZm9ybSBmbG9hdCB0aHJlc2hvbGQ7XFxudW5pZm9ybSBib29sIHNoYWRvdztcXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyMDtcXG5cXG5mbG9hdCBncmF5KCB2ZWMzIGMgKSB7XFxuICByZXR1cm4gZG90KCBjLCB2ZWMzKCAwLjI5OSwgMC41ODcsIDAuMTE0ICkgKTtcXG59XFxuXFxudmVjMyB0b1JnYiggZmxvYXQgaSApIHtcXG4gIHJldHVybiB2ZWMzKFxcbiAgICBtb2QoIGksIDI1Ni4wICksXFxuICAgIG1vZCggZmxvb3IoIGkgLyAyNTYuMCApLCAyNTYuMCApLFxcbiAgICBmbG9vciggaSAvIDY1NTM2LjAgKVxcbiAgKSAvIDI1NS4wO1xcbn1cXG5cXG5ib29sIHRociggZmxvYXQgdiApIHtcXG4gIHJldHVybiBzaGFkb3cgPyAoIHRocmVzaG9sZCA8IHYgKSA6ICggdiA8IDEuMCAtIHRocmVzaG9sZCApO1xcbn1cXG5cXG52ZWM0IGRyYXcoIHZlYzIgdXYgKSB7XFxuICB2ZWMyIGRpciA9IERJUiA/IHZlYzIoIDAuMCwgMS4wICkgOiB2ZWMyKCAxLjAsIDAuMCApO1xcbiAgZmxvYXQgd2lkID0gRElSID8gcmVzb2x1dGlvbi55IDogcmVzb2x1dGlvbi54O1xcbiAgZmxvYXQgcG9zID0gRElSID8gZmxvb3IoIHV2LnkgKiByZXNvbHV0aW9uLnkgKSA6IGZsb29yKCB1di54ICogcmVzb2x1dGlvbi54ICk7XFxuICBcXG4gIGZsb2F0IHZhbCA9IGdyYXkoIHRleHR1cmUyRCggc2FtcGxlcjAsIHV2ICkueHl6ICk7XFxuICBcXG4gIGlmICggIXRociggdmFsICkgKSB7XFxuICAgIGZsb2F0IHBvc3QgPSBwb3M7XFxuICAgIGZsb2F0IHJhbmsgPSAwLjA7XFxuICAgIGZsb2F0IGhlYWQgPSAwLjA7XFxuICAgIGZsb2F0IHRhaWwgPSAwLjA7XFxuICAgIFxcbiAgICBmb3IgKCBpbnQgaSA9IDA7IGkgPCAyMDAwOyBpICsrICkge1xcbiAgICAgIGlmICggaW50KCB3aWQgKSA9PSBpICkgeyBicmVhazsgfVxcbiAgICAgIHBvc3QgLT0gMS4wO1xcbiAgICAgIGlmICggcG9zdCA9PSAtMS4wICkgeyBoZWFkID0gcG9zdCArIDEuMDsgYnJlYWs7IH1cXG4gICAgICB2ZWMyIHAgPSBkaXIgKiAoIHBvc3QgKyAwLjUgKSAvIHdpZCArIGRpci55eCAqIHV2O1xcbiAgICAgIGZsb2F0IHYgPSBncmF5KCB0ZXh0dXJlMkQoIHNhbXBsZXIwLCBwICkueHl6ICk7XFxuICAgICAgaWYgKCB0aHIoIHYgKSApIHsgaGVhZCA9IHBvc3QgKyAxLjA7IGJyZWFrOyB9XFxuICAgICAgaWYgKCB2IDw9IHZhbCApIHsgcmFuayArPSAxLjA7IH1cXG4gICAgfVxcbiAgICBcXG4gICAgcG9zdCA9IHBvcztcXG4gICAgZm9yICggaW50IGkgPSAwOyBpIDwgMjAwMDsgaSArKyApIHtcXG4gICAgICBpZiAoIGludCggd2lkICkgPT0gaSApIHsgYnJlYWs7IH1cXG4gICAgICBwb3N0ICs9IDEuMDtcXG4gICAgICBpZiAoIHdpZCA9PSBwb3N0ICkgeyB0YWlsID0gcG9zdCAtIDEuMDsgYnJlYWs7IH1cXG4gICAgICB2ZWMyIHAgPSBkaXIgKiAoIHBvc3QgKyAwLjUgKSAvIHdpZCArIGRpci55eCAqIHV2O1xcbiAgICAgIGZsb2F0IHYgPSBncmF5KCB0ZXh0dXJlMkQoIHNhbXBsZXIwLCBwICkueHl6ICk7XFxuICAgICAgaWYgKCB0aHIoIHYgKSApIHsgdGFpbCA9IHBvc3QgLSAxLjA7IGJyZWFrOyB9XFxuICAgICAgaWYgKCB2IDwgdmFsICkgeyByYW5rICs9IDEuMDsgfVxcbiAgICB9XFxuICAgIFxcbiAgICBwb3MgPSBSRVZFUlNFID8gKCB0YWlsIC0gcmFuayApIDogKCBoZWFkICsgcmFuayApO1xcbiAgfVxcbiAgXFxuICByZXR1cm4gdmVjNCggdG9SZ2IoIHBvcyApLCAxLjAgKTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gZHJhdyggZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbi54eSApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIERJUiBmYWxzZVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXIwO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXJNYXA7XFxuXFxuZmxvYXQgZnJvbVJnYiggdmVjMyB2ICkge1xcbiAgcmV0dXJuICggKCB2LnogKiAyNTYuMCArIHYueSApICogMjU2LjAgKyB2LnggKSAqIDI1NS4wO1xcbn1cXG5cXG52ZWM0IGRyYXcoIHZlYzIgdXYgKSB7XFxuICB2ZWMyIGRpciA9IERJUiA/IHZlYzIoIDAuMCwgMS4wICkgOiB2ZWMyKCAxLjAsIDAuMCApO1xcbiAgZmxvYXQgd2lkID0gRElSID8gcmVzb2x1dGlvbi55IDogcmVzb2x1dGlvbi54O1xcbiAgZmxvYXQgcG9zID0gRElSID8gZmxvb3IoIHV2LnkgKiByZXNvbHV0aW9uLnkgKSA6IGZsb29yKCB1di54ICogcmVzb2x1dGlvbi54ICk7XFxuICBcXG4gIGZvciAoIGludCBpID0gMDsgaSA8IDIwMDA7IGkgKysgKSB7XFxuICAgIGlmICggaW50KCB3aWQgKSA9PSBpICkgeyBicmVhazsgfVxcblxcbiAgICB2ZWMyIHAgPSB1diArIGRpciAqIGZsb2F0KCBpICkgLyB3aWQ7XFxuICAgIGlmICggcC54IDwgMS4wICYmIHAueSA8IDEuMCApIHtcXG4gICAgICBmbG9hdCB2ID0gZnJvbVJnYiggdGV4dHVyZTJEKCBzYW1wbGVyTWFwLCBwICkueHl6ICk7XFxuICAgICAgaWYgKCBhYnMoIHYgLSBwb3MgKSA8IDAuNSApIHtcXG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQoIHNhbXBsZXIwLCBwICk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgXFxuICAgIHAgPSB1diAtIGRpciAqIGZsb2F0KCBpICkgLyB3aWQ7XFxuICAgIGlmICggMC4wIDwgcC54ICYmIDAuMCA8IHAueSApIHtcXG4gICAgICBmbG9hdCB2ID0gZnJvbVJnYiggdGV4dHVyZTJEKCBzYW1wbGVyTWFwLCBwICkueHl6ICk7XFxuICAgICAgaWYgKCBhYnMoIHYgLSBwb3MgKSA8IDAuNSApIHtcXG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQoIHNhbXBsZXIwLCBwICk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIFxcbiAgcmV0dXJuIHZlYzQoIDEuMCwgMC4wLCAxLjAsIDEuMCApO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICBnbF9GcmFnQ29sb3IgPSBkcmF3KCBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uLnh5ICk7XFxufVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgQkFSUkVMX0lURVIgMTBcXG5cXG4jZGVmaW5lIEhVR0UgOUUxNlxcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NVxcbiNkZWZpbmUgViB2ZWMzKDAuLDEuLC0xLilcXG4jZGVmaW5lIHNhdHVyYXRlKGkpIGNsYW1wKGksMC4sMS4pXFxuI2RlZmluZSBsb2ZpKGksbSkgKGZsb29yKChpKS8obSkpKihtKSlcXG5cXG4vLyAtLS0tLS1cXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxuXFxudW5pZm9ybSBmbG9hdCBiYXJyZWxBbXA7XFxudW5pZm9ybSBmbG9hdCBiYXJyZWxPZmZzZXQ7XFxudW5pZm9ybSBmbG9hdCBxdWFsaXR5U2hpdDY7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlcjA7XFxuXFxuLy8gLS0tLS0tXFxuXFxudmVjMyBiYXJyZWwoIGZsb2F0IGFtcCwgdmVjMiB1diApIHtcXG5cXHRmbG9hdCBjb3JuID0gbGVuZ3RoKCB2ZWMyKCAwLjUgKSApO1xcblxcdGZsb2F0IGEgPSBtaW4oIDMuMCAqIHNxcnQoIGFtcCApLCBjb3JuICogUEkgKTtcXG5cXHRmbG9hdCB6b29tID0gY29ybiAvICggdGFuKCBjb3JuICogYSApICsgY29ybiApO1xcblxcdHZlYzIgcCA9IHNhdHVyYXRlKFxcbiAgICAoIHV2ICsgbm9ybWFsaXplKCB1diAtIDAuNSApICogdGFuKCBsZW5ndGgoIHV2IC0gMC41ICkgKiBhICkgKSAqIHpvb20gK1xcbiAgICAwLjUgKiAoIDEuMCAtIHpvb20gKVxcbiAgKTtcXG5cXHRyZXR1cm4gdGV4dHVyZTJEKCBzYW1wbGVyMCwgdmVjMiggcC54LCBwLnkgKSApLnh5ejtcXG59XFxuXFxuLy8gLS0tLS0tXFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb247XFxuICB2ZWMyIHAgPSAoIGdsX0ZyYWdDb29yZC54eSAqIDIuMCAtIHJlc29sdXRpb24gKSAvIHJlc29sdXRpb24ueTtcXG4gIGZsb2F0IHZpZyA9IDEuMCAtIGxlbmd0aCggcCApICogMC4yO1xcblxcbiAgdmVjMyB0ZXggPSB2ZWMzKCAwLjAgKTtcXG5cXG4gIGZvciAoIGludCBpID0gMDsgaSA8IEJBUlJFTF9JVEVSOyBpICsrICkge1xcbiAgICBmbG9hdCBmaSA9ICggZmxvYXQoIGkgKSArIDAuNSApIC8gZmxvYXQoIEJBUlJFTF9JVEVSICk7XFxuICAgIHZlYzMgYSA9IHNhdHVyYXRlKCB2ZWMzKFxcbiAgICAgIDEuMCAtIDMuMCAqIGFicyggMS4wIC8gNi4wIC0gZmkgKSxcXG4gICAgICAxLjAgLSAzLjAgKiBhYnMoIDEuMCAvIDIuMCAtIGZpICksXFxuICAgICAgMS4wIC0gMy4wICogYWJzKCA1LjAgLyA2LjAgLSBmaSApXFxuICAgICkgKSAvIGZsb2F0KCBCQVJSRUxfSVRFUiApICogNC4wO1xcbiAgICB0ZXggKz0gYSAqIGJhcnJlbCggYmFycmVsT2Zmc2V0ICsgYmFycmVsQW1wICogZmksIHV2ICk7XFxuICB9XFxuXFxuICB0ZXggPSBtaXgoIHZlYzMoIDAuMCApLCB0ZXgsIHZpZyApO1xcblxcbiAgdmVjMyBjb2wgPSBwb3coIHNhdHVyYXRlKCB0ZXgueHl6ICksIHZlYzMoIDEuMCAvIDIuMiApICk7XFxuICBjb2wgPSB2ZWMzKFxcbiAgICBzbW9vdGhzdGVwKCAtMC4xMCwgMS4xMCwgY29sLnggKSxcXG4gICAgc21vb3Roc3RlcCggIDAuMDAsIDEuMDAsIGNvbC55ICksXFxuICAgIHNtb290aHN0ZXAoIC0wLjMwLCAxLjMwLCBjb2wueiApXFxuICApO1xcbiAgY29sID0gbWl4KCBjb2wsIDEuMCAtIGNvbCwgcXVhbGl0eVNoaXQ2ICk7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2wsIDEuMCApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMyIHA7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KCBwLCAwLjAsIDEuMCApO1xcbn1cIiIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIHNhbXBsZXIyRCBzYW1wbGVyMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbjtcXG4gIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggc2FtcGxlcjAsIHV2ICk7XFxufVwiIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vbWFpbi5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vbWFpbi5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==